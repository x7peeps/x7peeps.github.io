<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>恶意样本分析,学习 on x7peeps</title>
    <link>https://x7peeps.com/tags/%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0/index.html</link>
    <description>Recent content in 恶意样本分析,学习 on x7peeps</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 10 Nov 2022 22:25:00 +0000</lastBuildDate><atom:link href="https://x7peeps.com/tags/%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>恶意样本分析-12-使用内存取证检测高级恶意软件</title>
      <link>https://x7peeps.com/%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80/%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90-12-%E4%BD%BF%E7%94%A8%E5%86%85%E5%AD%98%E5%8F%96%E8%AF%81%E7%8B%A9%E7%8C%8E%E6%81%B6%E6%84%8F%E8%BD%AF%E4%BB%B6/index.html</link>
      <pubDate>Thu, 10 Nov 2022 22:25:00 +0000</pubDate>
      <guid>https://x7peeps.com/%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80/%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90-12-%E4%BD%BF%E7%94%A8%E5%86%85%E5%AD%98%E5%8F%96%E8%AF%81%E7%8B%A9%E7%8C%8E%E6%81%B6%E6%84%8F%E8%BD%AF%E4%BB%B6/index.html</guid>
      <description>11. 使用内存取证检测高级恶意软件 在前一章中，我们研究了不同的Volatility插件，它们有助于从内存映像中提取有价值的信息。在本章中，我们将继续我们的内存取证之旅，我们将看到更多的插件，这些插件将帮助你从被高级恶意软件感染的内存映像中提取取证痕迹，这些恶意软件使用了隐身和隐藏技术。在下一节中，我们将重点介绍使用内存取证来检测代码注入技术。下一节将讨论在第8章“代码注入和挂钩”中已经涉及到的一些概念，所以强烈建议在阅读下一节之前阅读这一章。
1. 检测代码注入 回想一下第8章的代码注入和挂钩，代码注入是一种将恶意代码(如EXE、DLL或shellcode)注入合法进程内存并在合法进程的上下文中执行恶意代码的技术。为了向远程进程注入代码，恶意程序通常会分配一个具有读、写和执行权限的内存(PAGE_EXECUTE_READWRITE)，然后将代码注入到远程进程分配的内存中。要检测注入远程进程的代码，可以根据内存保护和内存内容查找可疑的内存范围。一个引人注目的问题是，什么是可疑的内存范围以及如何获得有关进程内存范围的信息?如果你回想一下前一章(在使用ldrmodules检测隐藏DLL部分)，Windows在内核空间中维护一个名为虚拟地址描述符(VADs)的二叉树结构，每个VAD节点描述进程内存中一个几乎连续的内存区域。如果进程内存区域包含一个内存映射文件(如可执行文件、DLL等)，那么其中一个VAD节点存储有关其基址、文件路径和内存保护的信息。下面的描述不是VAD的准确表示，但它应该有助于您理解这个概念。在下面的截图中，内核空间中的一个VAD节点描述了关于进程可执行文件(explorer.exe)加载位置、它的完整路径和内存保护的信息。类似地，其他VAD节点将描述进程内存范围，包括那些包含映射的可执行映像(如DLL)的进程。这意味着VAD可以用来确定每个相邻进程内存范围的内存保护，它还可以给出包含内存映射镜像文件(如可执行文件或DLL)的内存区域的信息: 1.1 通过采用信息 要从内存映像中获取VAD信息，可以使用vadinfo Volatility插件。下面以vadinfo为例，使用进程ID (pid 2180)显示explorer.exe进程的内存区域。在下面的输出中，内核内存中地址为0x8724d718的第一个VAD节点描述了进程内存中的内存范围0x00db0000-0x0102ffff及其内存保护PAGE_EXECUTE_WRITECOPY。由于第一个节点描述的是一个包含内存映射的可执行映像(explorer.exe)的内存范围，因此它还提供了磁盘上的完整路径。第二个节点0x8723fb50描述了0x004b0000-0x004effff的内存范围，它不包含任何内存映射文件。类似地，地址0x8723fb78的第三个节点显示进程内存范围的信息0x77690,000-0x777cbfff，其中包含ntdll.dll及其内存保护:
$ python vol.py -f win7.vmem --profile=Win7SP1x86 vadinfo -p 2180 Volatility Foundation Volatility Framework 2.6 VAD node @ 0x8724d718 Start 0x00db0000 End 0x0102ffff Tag Vadm Flags: CommitCharge: 4, Protection: 7, VadType: 2 Protection: PAGE_EXECUTE_WRITECOPY Vad Type: VadImageMap ControlArea @87240008 Segment 82135000 NumberOfSectionReferences: 1 NumberOfPfnReferences: 215 NumberOfMappedViews: 1 NumberOfUserReferences: 2 Control Flags: Accessed: 1, File: 1, Image: 1 FileObject @8723f8c0, Name: \Device\HarddiskVolume1\Windows\explorer.</description>
    </item>
    <item>
      <title>恶意样本分析-8-恶意软件的功能和持久化</title>
      <link>https://x7peeps.com/%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80/%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90-8-%E6%81%B6%E6%84%8F%E8%BD%AF%E4%BB%B6%E5%8A%9F%E8%83%BD%E5%92%8C%E6%8C%81%E4%B9%85%E5%8C%96/index.html</link>
      <pubDate>Thu, 17 Mar 2022 13:15:00 +0000</pubDate>
      <guid>https://x7peeps.com/%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80/%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90-8-%E6%81%B6%E6%84%8F%E8%BD%AF%E4%BB%B6%E5%8A%9F%E8%83%BD%E5%92%8C%E6%8C%81%E4%B9%85%E5%8C%96/index.html</guid>
      <description>7. 恶意软件的功能和持久化 恶意软件可以进行各种操作，它可以包括各种功能。了解一个恶意软件所做的事情和它所表现出来的行为，对于理解恶意二进制文件的性质和目的至关重要。在过去的几章中，你学到了进行恶意软件分析所需的技能和工具。在本章和接下来的几章中，我们将主要侧重于了解不同的恶意软件行为、它们的特点和能力。
1. 恶意软件的功能 现在，你应该对恶意软件如何利用API函数与系统互动有了了解。在本节中，您将了解恶意软件如何利用各种API函数来实现某些功能。关于在哪里可以找到关于特定API的帮助以及如何阅读API文档的信息，请参阅第5章 &amp;ldquo;使用IDA进行反汇编 &amp;ldquo;中的第3节 &amp;ldquo;反汇编Windows API&amp;rdquo;。
1.1 下载器 在恶意软件分析中，你会遇到的最简单的恶意软件类型是下载器。下载器是一个从互联网下载另一个恶意软件组件并在系统上执行的程序。它通过调用UrlDownloadToFile()API，将文件下载到磁盘上。一旦下载，它就会使用ShellExecute()、WinExec()或CreateProcess()API调用来执行下载的组件。通常情况下，你会发现下载器被用作攻击壳代码的一部分。
下面的截图显示了一个32位的恶意软件下载器使用UrlDownloadToFileA()和ShellExecuteA()来下载和执行一个恶意软件二进制。为了确定正在下载恶意软件二进制文件的URL，在调用UrlDownloadToFileA()时设置了一个断点。运行代码后，断点被触发，如以下截图所示。UrlDownloadToFileA()的第二个参数显示将下载恶意软件可执行文件（wowreg32.exe）的URL，第三个参数指定下载的可执行文件在磁盘上的位置。在这种情况下，下载器将下载的可执行文件保存在%TEMP%目录下，称为temp.exe。
将恶意软件的可执行文件下载到%TEMP%目录后，下载者通过调用ShellExecuteA()API来执行它，如下面的截图所示。另外，恶意软件也可以使用WinExec()或CreateProcess()API来执行下载的文件。
在调试恶意二进制文件时，最好是运行监控工具 (如Wireshark）和模拟工具（如InetSim），这样你就可以 观察恶意软件的行动并捕获其产生的流量。
1.2 释放器 Dropper是一个将额外的恶意软件组件嵌入自身的程序。当执行时，下载器会提取恶意软件组件并将其下载到磁盘。下拉程序 通常在资源部分嵌入额外的二进制文件。为了提取嵌入的 为了提取嵌入的可执行文件，投放器使用FindResource(), LoadResource(), LockResource()和 SizeOfResource()的API调用。在下面的截图中，Resource Hacker工具（在第2章静态分析中涉及到 第2章，静态分析）显示了一个PE文件在恶意软件样本的资源部分的存在。 恶意软件样本的资源部分存在一个PE文件。在这种情况下，资源类型是一个DLL。
在x64dbg中加载恶意二进制文件并查看对API调用的引用（在前一章中涉及），显示对资源相关API调用的引用。这是恶意软件从资源部分提取内容的一个迹象。在这一点上，你可以在调用FindResourceA()API的地址上设置一个断点，如图所示。
在下面的截图中，运行程序后，由于上一步设置的断点，执行在FindResourceA()API处暂停。传递给FindResourceA()API的第二和第三个参数告诉你，该恶意软件正试图找到DLL/101资源，如下所示。
在执行FindResourceA()后，其返回值（存储在EAX中），即指定资源信息块的句柄，被作为第二个参数传递给LoadResource()API。LoadResource()检索与该资源相关的数据的句柄。LoadResource()的返回值包含检索到的句柄，然后作为参数传递给LockResource()API，后者获得实际资源的指针。在下面的截图中，调用LockResource()后，执行立即暂停。检查转储窗口中的返回值（存储在EAX中），显示了从资源部分检索到的PE可执行内容。
一旦它检索到资源，恶意软件使用SizeofResource()API确定资源（PE文件）的大小。接下来，恶意软件使用CreateFileA在磁盘上投放了一个DLL，如下所示。
然后使用 WriteFile() API 将提取的 PE 内容写入 DLL。在下面的截图中，第一个参数0x5c是DLL的句柄，第二个参数0x00404060是检索到的资源（PE文件）的地址，第三个参数0x1c00是资源的大小，这是用调用SizeOfResource()确定的。
1.2.1 逆向64位dropper释放器 下面是一个64位恶意软件投放器（称为黑客之门）的例子。如果你还不熟悉调试64位样本，请参考前一章的2.7节，调试64位恶意软件。该恶意软件使用相同的API函数集来寻找和提取资源；不同的是，前几个参数被放置在寄存器中，而不是推到堆栈中（因为它是一个64位二进制文件）。恶意软件首先使用FindResourceW()API找到BIN/100资源，如下所示。
然后，恶意软件使用LoadResource()检索与资源相关的数据的句柄，然后它使用LockResource()获得实际资源的指针。在下面的截图中，检查LockResource()API的返回值（RAX）显示了提取的资源。在这种情况下，64位恶意软件投放者从其资源部分提取DLL，随后它将DLL投放到磁盘上。
1.3 键盘记录器 键盘记录器是一种旨在拦截和记录键盘点击的程序。攻击者在其恶意程序中使用键盘记录功能来窃取通过键盘输入的机密信息（如用户名、密码、信用卡信息等）。在本节中，我们将主要关注用户模式的软件键盘记录器。攻击者可以使用各种技术记录击键。最常见的记录击键的方法是使用记录的Windows API函数。(a) 检查键的状态（使用 (a) 检查钥匙状态（使用GetAsyncKeyState() API）和(b) 安装钩子（使用SetWindowHookEX() API）。
1.3.1 使用GetAsyncKeyState()的键盘记录器 这种技术涉及查询键盘上每个键的状态。为了做到这一点，键盘记录器利用GetAsyncKeyState()API函数来确定按键是否被按下。从GetAsyncKeyState()的返回值，可以确定在调用该函数时，该键是向上还是向下，以及该键是否在之前调用GetAsyncKeyState()后被按下。下面是GetAsyncKeyState()API的函数原型。
SHORT GetAsyncKeyState(int vKey)。GetAsynKeyState()接受一个整数参数vKey，指定256个可能的虚拟键代码之一。为了确定键盘上单个按键的状态。GetAsyncKeyState() API可以通过传递与所需键相关的虚拟键代码作为参数来调用。为了确定键盘上所有按键的状态，一个键盘记录器在一个循环中不断轮询GetAsyncKeyState()API（通过传递每个虚拟按键代码作为参数），以确定哪个按键被按下。
你可以在MSDN网站（https://msdn.microsoft.com/en-us/ library/windows/desktop/dd375731(v=vs.85).aspx）上找到与虚拟键代码相关的符号常量名称。
下面的截图显示了一个键盘记录器的代码片段。该键盘记录器通过调用地址为0x401441的GetKeyState()API来确定Shift键的状态（如果它是向上或向下）。在地址0x401459，键盘记录器调用GetAsyncKeyState()，这是一个循环的一部分，在循环的每个迭代中，虚拟键代码（从键代码数组中读取）被作为参数传递，以确定每个键的状态。在地址0x401463处，一个测试操作（与AND操作相同）被执行。 在地址0x401463，对GetAsyncKeyState()的返回值进行测试操作（与AND操作相同），以确定最重要的位是否被设置。如果最重要的位被设置了，这就表明按键被按下了。如果一个特定的键被按下，那么键盘记录器就会调用地址为0x40146c的GetKeyState()来检查Caps Lock键的状态（以检查它是否被打开）。使用这种技术，恶意软件可以确定在键盘上输入的是大写字母、小写字母、数字还是特殊字符。
下面的截图显示了该循环的结束。从代码中可以看出，该恶意软件在0x5c（92）键代码中进行迭代。在这种情况下，var_4作为索引进入要检查的键代码数组，它在循环结束时被递增，只要var_4的值小于0x5c（92），循环就会继续。
1.3.2 使用SetWindowsHookEx()的键盘记录器 另一种常见的键盘记录器技术是，它安装一个函数（称为钩子程序）来监测键盘事件（如按键）。在这种方法中，恶意程序注册了一个函数（钩子程序），当键盘事件被触发时，该函数将被通知，该函数可以将按键记录到一个文件或通过网络发送。恶意程序使用SetWindowsHookEx()API来指定要监控的事件类型（如键盘、鼠标等）以及当特定类型的事件发生时应该被通知的钩子程序。钩子程序可以包含在一个DLL或当前模块中。在下面的截图中，恶意软件样本通过调用SetWindowsHookEx()和WH_KEYBOARD_LL参数（恶意软件也可能使用WH_KEYBOARD）为低级别的键盘事件注册了一个钩子过程。第二个参数 第二个参数，offset hook_proc，是挂钩过程的地址。当键盘事件发生时，这个函数将被通知。检查这个函数可以了解到键盘记录器是如何和在哪里记录击键的。第三个参数是包含钩子程序的模块（如DLL或当前模块）的句柄。第四个参数，0，指定钩子程序将与同一桌面上的所有现有线程相关。</description>
    </item>
    <item>
      <title>恶意样本分析-7-调试恶意软件二进制文件</title>
      <link>https://x7peeps.com/%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80/%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90-7-%E8%B0%83%E8%AF%95%E6%81%B6%E6%84%8F%E8%BD%AF%E4%BB%B6%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6/index.html</link>
      <pubDate>Thu, 17 Mar 2022 10:15:00 +0000</pubDate>
      <guid>https://x7peeps.com/%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80/%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90-7-%E8%B0%83%E8%AF%95%E6%81%B6%E6%84%8F%E8%BD%AF%E4%BB%B6%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6/index.html</guid>
      <description>6. 调试恶意软件二进制文件 调试时一个通过受控方式执行恶意代码的技术。Debugger是一个程序，使你可以在更细颗粒度的级别上检查恶意代码。debugger提供了对恶意软件运行时行为的完全控制，并允许控制执行单个或多个指令，也可以选择功能执行程序的（而不是执行整个程序），同时研究恶意软件的每个行动。
在本章中，你将主要学习IDA Pro（商业反汇编/调试器）和x64dbg（开源x32/x64调试器）提供的调试特性。你将在本章了解这些调试器提供的特性，以及如何使用他们检查程序的运行时行为。根据可用资源的不同，可以自由选择这两个调试器中的一个活两个来调试恶意二进制文件。当调试恶意软件时，需要采取适当措施，因为您将在系统上运行恶意代码。在本章最后，还有如何使用.net反编译器/调试器dnSpy（https://github.com/0xd4d/dnSpy)来调试.net应用程序。
其他受欢迎的反汇编器/调试器包括radare2 (http://rada.re/r/index.html),调试工具的WinDbg部分为Windows (https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/), Ollydbg (http://www.ollydbg.de/version2.html),免疫调试器(https://www.immunityinc.com/products/debugger/),Hopper (https://www.hopperapp.com/)和Binary Ninja (https://binary.ninja/)。
1. 通用调试内容 在我们深入研究这些调试器（IDA Pro、x64dbg和DnSpy）提供的特性之前，有必要了解大多数调试器提供的一些常见特性。在本节中，您将主要看到通用的调试概念，在接下来的小节中，我们将重点介绍IDA Pro、x64dbg和dnSpy的基本特性。
1.1 启动和附加到进程 调试通常选择要调试的程序。有两种方法调试程序： （a）将调试器附加到一个正在运行的进程上， （b）启动一个新的进程。当您将调试器附加到正在运行的进程时，你讲无法控制或者监视程序的初始操作，因为当你有机会附加到进程时，它的所有启动和初始化代码都已经执行了。当您将调试器附加到某个进程时，调试器将刮起该进程，使您有机会在恢复进程之前检查进程的资源或设置断点。
另一方面，启动一个新进程允许你监视或调试流程采取的每个操作，您还将能够监视流程的初始操作。当你启动调试器时，原始二进制文件将以调试器的用户权限执行。当进程在调试器下启动时，执行将在程序的入口暂停。程序的入口点事将要执行的第一条指令的地址。子啊后面的小节中，将学习如何使用IDApro、x64dbg和dnspy启动并附加到 进程。程序的日寇点不一定是main或winmain函数；在将控制转移到main或winmain之前，执行初始化例程（启动历程）。启动历程的目的是在将控制传递给朱函数之前初始化程序的环境。这个初始化被调试器指定为程序的入口点。
程序的入口不一定是main或WinMain函数;在将控制转移到main或WinMain之前，初始化程序(启动程序)被执行。启动例程的目的是在将控制传递给主函数之前初始化程序环境。这个初始化被调试器指定为程序的入口点。
1.2 控制进程执行 调试器使您能够在进程执行时控制/修改进程的行为。调试器提供的两个重要功能是:(a)控制执行的能力，(b)中断执行的能力(使用断点)。使用调试器，您可以在将控制权返回给调试器之前执行一个或多个指令(或选择函数)。在分析过程中，您将结合调试器的受控执行和中断(断点)特性来监视恶意软件的行为。在本节中，您将了解调试器提供的常用执行控制功能;在后面的章节中，您将学习如何在IDA Pro、x64dbg和dnSpy中使用这些特性。
下面是调试器提供的一些常见的执行控制选项:
继续（运行）。 这将执行所有的指令，直到达到一个断点或发生一个异常。当你把一个恶意软件加载到调试器中，并在没有设置断点的情况下使用继续（运行）选项时，它将执行所有的指令而不给你任何控制权；所以，你通常将这个选项和断点一起使用，在断点位置中断程序。
步入和跨步。 使用Step into和Step over，你可以执行一条指令。在执行完单条指令后，调试器停止，给你一个机会检查进程的资源。当您执行一条调用函数的指令时，步入和跨步的区别就出现了。例如，在下面的代码中，在➊，有一个对函数sub_401000的调用。当你对这条指令使用step into选项时，调试器将在函数的开始处（地址为0x401000）停止，而当你使用step over时，整个函数将被执行，调试器将在下一条指令➋（即地址为0x00401018）暂停。你通常会使用step into来进入一个函数内部，以了解它的内部工作原理。当你已经知道一个函数的作用（例如在API函数中）并希望跳过它时，就会使用Step over。
.text:00401010 push ebp .text:00401011 mov ebp, esp .text:00401013 call sub_401000 ➊ .text:00401018 xor eax,eax ➋ Execute till Return（运行至返回）。 这个选项允许你执行当前函数中的所有指令，直到它返回。如果你不小心进入了一个函数（或进入了一个不感兴趣的函数），并希望从里面出来，这就很有用。在一个函数中使用这个选项会把你带到函数的末端（ret或retn），之后你可以使用step into或step over选项返回到调用的函数。 Run to cursor 运行到光标（运行到选择）。 这允许你执行指令直到当前的光标位置，或者直到到达所选指令。 1.3 用断点中断程序 断点是调试器的一项功能，它允许你在程序中一个非常具体的位置中断程序的执行。断点可以用来暂停某条指令的执行，或者当程序调用某个函数/API函数时，或者当程序从某个内存地址读、写或执行时。你可以在一个程序中设置多个断点，当到达任何一个断点时，程序的执行将被中断。一旦达到一个断点，就有可能监测/修改程序的各个方面。调试器通常允许你设置不同类型的中断点。</description>
    </item>
    <item>
      <title>恶意样本分析6-IDA使用</title>
      <link>https://x7peeps.com/%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80/%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90-6-IDA%E4%BD%BF%E7%94%A8/index.html</link>
      <pubDate>Tue, 08 Sep 2020 13:15:00 +0000</pubDate>
      <guid>https://x7peeps.com/%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80/%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90-6-IDA%E4%BD%BF%E7%94%A8/index.html</guid>
      <description>使用IDA反汇编 代码分析常用语了解恶意样本内部源码不可见时使用。
1. 代码分析工具 代码分析工具可以根据他们的功能、描述、数量进行分类。 反汇编程序是一个可以将机器语言转汇编代码；并且可以静态代码分析。静态代码分析可以在不执行二进制程序的时候让你了解到程序的行为。
一个调试器是个应用程序同时也是可以反汇编代码；除此之外也可以执行控制汇编二进制执行。使用调试工具，你不仅可以执行单条指令，或选择函数，或执行整个程序。调试工具可以动态分析，还可以在程序执行的过程中检查可疑的二进制。
反编译器是一个将机器码转成更高级语言的程序（伪代码）。反编译器能够很好辅助反推工程进程并能够简化工作。
2. 静态代码分析（使用IDA反汇编） Hex-Rays IDA pro https://www.hex-rays.com/products/ida/ IDA是最有影响力且流行的商业反编译调试工具；常被用于逆向工程，恶意病毒分析以及脆弱性研究。IDA可以运行在不同平台（macOS、Linux和windows）支持分析不同的文件类型（PE/ELF/Macho-O）。除商业版本之外，IDA还提供2个其他版本：IDA demo版本（评估版本）和IDA免费版本；两个版本都有一定的限制，都可以反编译32和64位windows程序，但是免费版无法调试二进制，demo版本无法调试64位二进制，demo版本也无法保存数据库，并且demo版本和免费版都无法支持IDApython。
本部分和下一部分将会看下IDA pro的特征，并且使用IDA施行静态代码分析。这一部分仅包含与恶意代码分析相关的功能。
IDA相关深入了解图书推荐《The IDA Pro Book》by Chris Eagle
2.1 在IDA中加载二进制 IDA会像windows一样加载文件到内存中。IDA可以通过判断文件头确定最可能适合的加载器。在选择文件后IDA会加载对话框，用于确认合适的加载起和进程类型。文件设置（file option）选项是用于加载未识别的文件，一般使用该选项处理shellcode。默认情况下IDA不会在反编译中加载PE头和源部分。通过使用手动加载checkbox选项，可以手动选择加载基址和加载位置，IDA将会在加载的每个部分包括PE头给予相应的提示。点击OK，IDA将文件加载到内存，并且开始反编译相关代码。
2.2 扩展IDA显示 IDA桌面版结合了很多静态分析工具的特征到一个单独特窗口中。下面将对IDA卓敏啊版和它不同窗口进行介绍。其包含多个不同的标签（IDA View,Hex View-1,等等），也可以通过点击添加标签按钮或者点击View/open subviews菜单进行添加。
2.2.1 反汇编窗口 当二进制文件被加载，IDA展示的窗口就是反汇编编辑窗口（也叫做IDA-view窗口），这是个主要窗口，用于分析和展示反汇编代码，并且可以用于分析反汇编二进制。 IDA可以使用两个模式展示反编译的代码：Graph view（graph diassembly view）和Text view（实际应该叫text diassembly view）,默认进入的是graph view，这里可以使用空格快捷键进行切换。 在graph view模式下，IDA一次只显示一个函数，在一个流程图的窗口中函数在基本块区中断。这个模式可以快速识别分支和循环生命。在Graph view模式下，颜色和箭头的指示方向都是根据判断显示的。条件跳转使用红色和绿色的箭头，true条件用绿色箭头表示，false使用红色箭头表示。蓝色的箭头是被用来表示无条件跳转，循环使用的是向上的蓝色的箭头表示。在graph view中虚拟地址默认不显示（每个基础块仅显示最基本的信息展示）。如果需要显示虚拟地址信息，需要点击Options/general然后点击Line prefixes以启用。 下图中可以观察到条件跳转中，绿色箭头（条件true）进行跳转，对应的虚拟地址也是跳转，而红色箭头指向正常的数据流，虚拟地址为连续。 在text view模式中，整个反编译目前处于线性方式展示。整个虚拟地址默认展示，&amp;lt;section name&amp;gt;:&amp;lt;virtual address&amp;gt;格式。在text view窗口中最左边的部分被称为箭头窗口，用于展示程序的非线性流。虚线箭头代表条件跳转，实线箭头表示无条件跳转，加粗的箭头表示循环。 2.2.2 函数窗口function widnow 函数窗口显示所有IDA识别出来的函数，该床扣同时也显示每个函数可以被找到的虚拟地址，每个函数的大小，以及其他函数相关信息。双击可以定位跳转到对应函数的位置。每个函数与大量的标志相关联（例如R、F、L等等标志）。通过F1按钮可以获取更多关于相关标志的帮助信息。一个有用的标志L标志，代表函数的库函数。库函数是编译器产生而非恶意软件作者编写的函数；从代码分析的角度来看，恶意样本分析的重点应该在恶意代码上，而不是库函数本身。
2.2.3 输出窗口out window 输出窗口展示的是IDA以及IDA插件输出的相关信息。这些对于分析恶意样本以及样本对系统操作分析提供很多信息。可以通过查看输出在output窗口的内容可以获取IDA执行加载过程中的相关信息。
2.2.4 十六进制窗口Hex view window 通过点击HexView-1标签可以展示Hex窗口。Hex窗口可以展示一系列的十六进制转储内容以及ASCII字符。默认情况下，十六进制窗口（hex window）。默认情况下十六进制窗口同步反编译窗口（disassembly window）内容；也就是在反汇编窗口中选择了一部分字节的数据，相应的在十六进制窗口中同样的会进行标记高亮相关的内容，这对于标记内存地址很有帮助。</description>
    </item>
    <item>
      <title>恶意样本分析4-基础DLL分析</title>
      <link>https://x7peeps.com/%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80/%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90-4-%E5%9F%BA%E7%A1%80DLL%E5%88%86%E6%9E%90/index.html</link>
      <pubDate>Wed, 25 Sep 2019 19:24:00 +0000</pubDate>
      <guid>https://x7peeps.com/%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80/%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90-4-%E5%9F%BA%E7%A1%80DLL%E5%88%86%E6%9E%90/index.html</guid>
      <description>&lt;p&gt;
&lt;a href=&#34;#image-6274031c8eff435f9e6167c2d16679bd&#34; class=&#34;lightbox-link&#34;&gt;
&lt;img src=&#34;https://x7peeps.com/%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80/%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90-4-%E5%9F%BA%E7%A1%80DLL%E5%88%86%E6%9E%90/20190923224925.png-A&#34; alt=&#34;&#34; style=&#34;height: auto; width: auto;&#34; loading=&#34;lazy&#34;&gt;
&lt;/a&gt;
&lt;a href=&#34;javascript:history.back();&#34; class=&#34;lightbox&#34; id=&#34;image-6274031c8eff435f9e6167c2d16679bd&#34;&gt;
&lt;img src=&#34;https://x7peeps.com/%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80/%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90-4-%E5%9F%BA%E7%A1%80DLL%E5%88%86%E6%9E%90/20190923224925.png-A&#34; alt=&#34;&#34; class=&#34;lightbox-image&#34; loading=&#34;lazy&#34;&gt;
&lt;/a&gt;
当恶意代码打包进dll，需要对其进行一定量的定性分析，除了平台的手段，这里还有一些基础的dll分析手段。&lt;/p&gt;</description>
    </item>
    <item>
      <title>恶意样本分析4-基础DLL分析</title>
      <link>https://x7peeps.com/%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80/%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90-5-%E6%B1%87%E7%BC%96%E5%8F%8A%E5%8F%8D%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80/index.html</link>
      <pubDate>Wed, 25 Sep 2019 19:24:00 +0000</pubDate>
      <guid>https://x7peeps.com/%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80/%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90-5-%E6%B1%87%E7%BC%96%E5%8F%8A%E5%8F%8D%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80/index.html</guid>
      <description>&lt;h2 id=&#34;汇编及反汇编入门&#34;&gt;汇编及反汇编入门&lt;/h2&gt;
&lt;p&gt;基于基础动态分析有其局限，为了获取更深的洞察，需要代码分析（逆向分析）
例如，大多数样本使用c2服务加密通信。使用动态分析我们能够确定加密通信，但是无法获得其通信内容，因此我们需要了解如何进行代码分析。&lt;/p&gt;
&lt;p&gt;动态和静态分析提供了了解恶意程序函数的好办法，单数不足以，提过所有关于恶意程序的信息。病毒坐着通常使用C或C++编写病毒程序，通过编译器编译。在你的调查过程中，你只有可执行的恶意程序，没有源代码。为了获得更深的关于恶意程序的内部工作和了解，代码分析是其至关重要的方面。&lt;/p&gt;
&lt;p&gt;这一块最好提前拥有C语言的基础，及汇编基础。这一块的相关资源可在继续之前学习：
计算机基础、内存及CPU
数据转换，结构及位运算
分支和循环
功能和堆栈
数组，字符和结构
64x架构框架

&lt;a href=&#34;#image-0fb5f6b29772b2ecb7e4ca573d0b674d&#34; class=&#34;lightbox-link&#34;&gt;
&lt;img src=&#34;https://x7peeps.com/%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80/%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90-5-%E6%B1%87%E7%BC%96%E5%8F%8A%E5%8F%8D%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80/20200428160722.png-A&#34; alt=&#34;&#34; style=&#34;height: auto; width: auto;&#34; loading=&#34;lazy&#34;&gt;
&lt;/a&gt;
&lt;a href=&#34;javascript:history.back();&#34; class=&#34;lightbox&#34; id=&#34;image-0fb5f6b29772b2ecb7e4ca573d0b674d&#34;&gt;
&lt;img src=&#34;https://x7peeps.com/%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80/%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90-5-%E6%B1%87%E7%BC%96%E5%8F%8A%E5%8F%8D%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80/20200428160722.png-A&#34; alt=&#34;&#34; class=&#34;lightbox-image&#34; loading=&#34;lazy&#34;&gt;
&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>恶意样本分析3-基础动态分析</title>
      <link>https://x7peeps.com/%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80/%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90-3-%E5%9F%BA%E7%A1%80%E5%8A%A8%E6%80%81%E5%88%86%E6%9E%90/index.html</link>
      <pubDate>Fri, 20 Sep 2019 18:15:00 +0000</pubDate>
      <guid>https://x7peeps.com/%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80/%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90-3-%E5%9F%BA%E7%A1%80%E5%8A%A8%E6%80%81%E5%88%86%E6%9E%90/index.html</guid>
      <description>&lt;p&gt;动态分析过程中，当恶意程序执行的时候，需要监控其行为。目标过程的目标是获取恶意程序行为的实时数据，以及其对操作系统的影响。&lt;/p&gt;</description>
    </item>
    <item>
      <title>恶意样本分析2-基础静态分析</title>
      <link>https://x7peeps.com/%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80/%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90-2-%E5%9F%BA%E7%A1%80%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/index.html</link>
      <pubDate>Sun, 15 Sep 2019 10:29:03 +0000</pubDate>
      <guid>https://x7peeps.com/%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80/%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90-2-%E5%9F%BA%E7%A1%80%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/index.html</guid>
      <description>&lt;p&gt;基础的静态分析可以考虑直接使用各公司平台产品分析产出，这里根据国外的习惯使用一些基本工具脚本进行相关分析的基础工作梳理。&lt;/p&gt;</description>
    </item>
    <item>
      <title>恶意样本分析1-配置实验环境</title>
      <link>https://x7peeps.com/%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80/%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90-1-%E9%85%8D%E7%BD%AE%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83/index.html</link>
      <pubDate>Tue, 03 Sep 2019 20:29:03 +0000</pubDate>
      <guid>https://x7peeps.com/%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80/%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90-1-%E9%85%8D%E7%BD%AE%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83/index.html</guid>
      <description>&lt;p&gt;
&lt;a href=&#34;#image-503641d80da6ab8c284fa9bb8a087426&#34; class=&#34;lightbox-link&#34;&gt;
&lt;img src=&#34;https://x7peeps.com/%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80/%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90-1-%E9%85%8D%E7%BD%AE%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83/1555673578514.png-A&#34; alt=&#34;&#34; style=&#34;height: auto; width: auto;&#34; loading=&#34;lazy&#34;&gt;
&lt;/a&gt;
&lt;a href=&#34;javascript:history.back();&#34; class=&#34;lightbox&#34; id=&#34;image-503641d80da6ab8c284fa9bb8a087426&#34;&gt;
&lt;img src=&#34;https://x7peeps.com/%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80/%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90-1-%E9%85%8D%E7%BD%AE%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83/1555673578514.png-A&#34; alt=&#34;&#34; class=&#34;lightbox-image&#34; loading=&#34;lazy&#34;&gt;
&lt;/a&gt;
对于日常探针分析工作，样本分析作为不可缺少的一个环节，经常能够在其中发现比较重要的细节，对此部分的学习和总结尤其重要，这一系列即为最近收集总结的一部分。&lt;/p&gt;</description>
    </item>
    <item>
      <title>恶意样本分析-10-恶意软件的混淆技术</title>
      <link>https://x7peeps.com/%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80/%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90-10-%E6%81%B6%E6%84%8F%E8%BD%AF%E4%BB%B6%E7%9A%84%E6%B7%B7%E6%B7%86%E6%8A%80%E6%9C%AF/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://x7peeps.com/%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80/%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90-10-%E6%81%B6%E6%84%8F%E8%BD%AF%E4%BB%B6%E7%9A%84%E6%B7%B7%E6%B7%86%E6%8A%80%E6%9C%AF/index.html</guid>
      <description>9. 恶意软件的混淆技术 混淆一词指的是掩盖有意义信息的过程。恶意软件作者经常使用各种混淆技术来隐藏信息，并修改恶意内容，使安全分析人员难以发现和分析。敌方通常使用编码/加密技术来掩盖安全产品的信息。除了使用编码/加密，攻击者还使用打包器等程序来混淆恶意二进制内容，这使得分析和逆向工程更加困难。在本章中，我们将研究如何识别这些混淆技术，以及如何解码/解密和解压恶意二进制文件。我们将首先看一下编码/加密技术，随后我们将看一下解包技术。
攻击者通常出于以下原因使用编码和加密。
掩盖命令和控制通信 隐藏基于签名的解决方案，如入侵防御系统 隐藏恶意软件所使用的配置文件的内容 加密从受害者系统中传出的信息 混淆恶意二进制文件中的字符串，以躲避静态分析 在我们深入研究恶意软件如何使用加密算法之前，让我们试着了解一下本章将使用的基本知识和一些术语。明文是指未加密的信息；这可能是命令和控制（C2）流量或恶意软件想要加密的文件内容。加密文本指的是加密信息；这可能是恶意软件从C2服务器收到的加密的可执行文件或加密命令。
恶意软件对明文进行加密，将明文与密钥一起作为输入传递给加密函数，从而产生一个密码文本。由此产生的密码文本通常被恶意软件用来写入文件或通过网络发送。
以同样的方式，恶意软件可以从C2服务器或文件中接收加密的内容，然后通过将加密的内容和密钥传递给解密功能来解密，如下所示。
在分析恶意软件时，你可能想了解某个特定内容是如何被加密或解密的。要做到这一点，你将主要关注识别加密或解密功能以及用于加密或解密内容的密钥。例如，如果你想确定网络内容是如何被加密的，那么你可能会在网络输出操作（如HttpSendRequest()）之前找到加密函数。以同样的方式，如果你想知道C2的加密内容是如何被解密的，那么你很可能在使用诸如InternetReadFile()这样的API从C2检索到内容后找到解密函数。
一旦确定了加密/解密功能，检查这些功能将使你了解内容是如何加密/解密的，使用的密钥，以及用于混淆数据的算法。
1. 简单编码 大多数时候，攻击者使用非常简单的编码算法，如Base64编码或xor加密来掩盖数据。攻击者之所以使用简单的算法，是因为它们容易实现，占用较少的系统资源，而且刚好可以掩盖安全产品和安全分析人员分析的内容。
1.1 凯撒密码 凯撒密码，也被称为移位密码，是一种传统的密码，是最简单的编码技术之一。它通过将明文中的每个字母在字母表中下移一些固定的位置来对信息进行编码。例如，如果你将字符 &amp;ldquo;A &amp;ldquo;向下移动3个位置，那么你将得到 &amp;ldquo;D&amp;rdquo;，而 &amp;ldquo;B &amp;ldquo;将是 &amp;ldquo;E&amp;rdquo;，以此类推，当移动到 &amp;ldquo;X &amp;ldquo;时，将包裹回 &amp;ldquo;A&amp;rdquo;。
1.1.1 凯撒密码的工作原理 理解凯撒密码的最好方法是写下从A到Z的字母，并给这些字母分配一个索引，从0到25，如下所示换句话说，&amp;lsquo;A&amp;rsquo;对应于索引0，&amp;lsquo;B&amp;rsquo;对应于索引1，以此类推。一组从A到Z的所有字母被称为字符集。
现在，让我们假设你想把字母转移三个位置，那么3就成了你的密钥。为了加密字母&amp;rsquo;A&amp;rsquo;，将字母A的索引，即0，加到钥匙3上；这样的结果是0+3=3。现在用结果3作为索引，找到相应的字母，也就是&amp;rsquo;D&amp;rsquo;，这样&amp;rsquo;A&amp;rsquo;就被加密成&amp;rsquo;D&amp;rsquo;了。为了加密&amp;rsquo;B&amp;rsquo;，你将把&amp;rsquo;B&amp;rsquo;的索引（1）加到钥匙3上，结果是4，索引4与&amp;rsquo;E&amp;rsquo;有关，所以&amp;rsquo;B&amp;rsquo;加密为&amp;rsquo;E&amp;rsquo;，以此类推。
这种技术的问题出现在我们到达&amp;rsquo;X&amp;rsquo;的时候，它的索引是23。当我们将23+3相加时，我们得到26，但我们知道没有与索引26相关的字符，因为最大索引值是25。我们还知道，索引26应该绕回索引0（与&amp;rsquo;A&amp;rsquo;相关）。为了解决这个问题，我们用字符集的长度进行模数运算。在这种情况下，字符集ABCDEFGHIJKLMNOPQRSTUVWXYZ的长度是26。现在，为了加密&amp;rsquo;X&amp;rsquo;，我们使用&amp;rsquo;X&amp;rsquo;的索引（23）并将其添加到密钥（3）中，然后对字符集的长度（26）进行模数运算（也就是26=0(mod26)），如下所示。这个操作的结果是0，它被用作索引来寻找相应的字符，也就是&amp;rsquo;A&amp;rsquo;。
(23+3)%26 = 0模数操作允许你循环回到开头。你可以用同样的逻辑来加密字符集中的所有字符（从A到Z），并绕回起点。在凯撒密码中，你可以用以下方法获得被加密（密文）字符的索引。
(i + key) % (length of the character set 字符串长度) where i = index of plaintext character 明文字符串索引以同样的方式，你可以用以下方式获得明文（解密）字符的索引。
(j - key) % (length of the character set) where j = index of ciphertext character下图显示了字符集、加密和以3为密钥的文本 &amp;ldquo;ZEUS &amp;ldquo;的解密（移动三个位置）。加密后，文本 &amp;ldquo;ZEUS &amp;ldquo;被翻译成 &amp;ldquo;CHXV&amp;rdquo;，然后解密又将其翻译成 &amp;ldquo;ZEUS&amp;rdquo;。</description>
    </item>
    <item>
      <title>恶意样本分析-11-使用内存取证狩猎恶意软件</title>
      <link>https://x7peeps.com/%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80/%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90-11-%E4%BD%BF%E7%94%A8%E5%86%85%E5%AD%98%E5%8F%96%E8%AF%81%E7%8B%A9%E7%8C%8E%E6%81%B6%E6%84%8F%E8%BD%AF%E4%BB%B6/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://x7peeps.com/%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80/%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90-11-%E4%BD%BF%E7%94%A8%E5%86%85%E5%AD%98%E5%8F%96%E8%AF%81%E7%8B%A9%E7%8C%8E%E6%81%B6%E6%84%8F%E8%BD%AF%E4%BB%B6/index.html</guid>
      <description>恶意样本分析-11-使用内存取证狩猎恶意软件 10.使用内存取证狩猎恶意软件 在到目前为止所涵盖的章节中，我们看了概念、工具和技术用于分析恶意软件使用静态，动态和代码分析。在本章中，你将理解另一种技术，称为内存取证(或内存分析)。
内存取证(或内存分析)是一种调查性技术，涉及到从计算机的物理内存(RAM)中找到并提取司法证据。一个计算机的内存存储有关系统运行状态的有价值的信息。获取存储并进行分析将为司法提供必要的信息调查，例如系统上正在运行哪些应用程序，哪些对象(文件、注册表等)这些应用程序正在访问、活动网络连接、加载模块、加载的内核驱动程序和其他信息。由于这个原因，内存取证是用于事件响应和恶意软件分析。
在事件响应期间，在大多数情况下，您将无法访问恶意软件样本但您可能只拥有一个可疑系统的内存映像。例如，你可以从安全产品收到关于系统可能存在恶意行为的警报，在这种情况下，您可以获取可疑系统的内存映像，以执行内存司法鉴定确认感染和找到恶意工件。
除了将内存取证用于事件响应之外，还可以将其用作恶意软件分析(针对恶意软件样本)来获得额外的信息关于恶意软件感染后的行为。例如，当你有一个恶意软件示例中，除了执行静态、动态和代码分析之外，您还可以执行在一个孤立的环境中采样，然后获取受感染的计算机内存和检查内存图像，了解恶意软件在感染后的行为。
使用内存取证的另一个原因是，某些恶意软件示例可能不会将恶意组件写入磁盘（仅在内存中）。因此，磁盘取证或文件系统分析可能会失败。在这种情况下，内存取证在查找恶意组件。
一些恶意软件示例通过挂钩或修改操作系统结构。在这种情况下，内存取证可能很有用，因为它可以绕过恶意软件使用的技巧来隐藏操作系统并实时取证工具。本章向您介绍内存取证的概念并涵盖用于获取和分析内存映像的工具。
1. 内存取证步骤 是将内存取证用作事件响应的一部分，还是用于恶意软件分析，以下是内存取证中的一般步骤：
内存获取：这涉及获取（或转储）内存目标计算机到磁盘。取决于您是否正在调查感染者系统或使用内存取证作为恶意软件分析的一部分，目标计算机可以是您怀疑被感染的系统（在您的网络上），也可以是可能是实验室环境中执行的分析计算机恶意软件示例。 内存分析：将内存转储到磁盘后，此步骤涉及分析转储的内存以查找和提取电子证据。 2. 内存采集 存储器采集是将易失性存储器（RAM）采集到非易失性存储器的过程存储（磁盘上的文件）。有各种工具可以让您获取物理机。以下是一些允许您获取（转储）的工具物理内存到 Windows 上。其中一些工具是商业性的，其中许多注册后可以免费下载。以下工具适用于两个 x86 （32-位） 和 x64（64 位）计算机：
Comae Memory Toolkit （DumpIt） by Comae Technologies （免费下载注册）： https://my.comae.io/ Belkasoft RAM Capturer（注册后免费下载）：https://belkasoft.com/ram-capturer ACCESSData的FTK镜像软件（注册后免费下载）：https://accessdata.com/product-download Memoryze by FireEye（注册后免费下载）：https://www.fireeye.com/services/freeware/memoryze.html Volexity的浪涌收集（商业）：https://www.volexity.com/productsoverview/surge/ PassMark Software的OSForensics（商业）：https://www.osforensics.com/osforensics.html WinPmem（开源），Rekall Memory取证框架的一部分：http://blog.rekall-forensic.com/search?q=winpmem 2.1 使用转储进行内存采集 DumpIt是一款出色的内存采集工具，可让您转储物理内存在视窗上。它支持采集 32 位 （x86） 和 64 位 （x64） 计算机。Dump它是称为Comae内存工具包的工具包的一部分，该工具包由各种独立工具，有助于不同文件之间的内存采集和转换格式。要下载 Comae 内存工具包的最新副本，您需要创建一个通过在 https://my.comae.io 上注册帐户。创建帐户后，您可以登录并下载Comae内存工具包的最新副本。
下载 Comae 工具包后，解压缩存档，然后导航到 32 位或 64 位目录，具体取决于您是要转储 32 位还是 64 位的内存机器。该目录由各种文件组成，包括 DumpIt.</description>
    </item>
    <item>
      <title>恶意样本分析-9-代码注入和钩子</title>
      <link>https://x7peeps.com/%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80/%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90-9-%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5%E5%92%8C%E9%92%A9%E5%AD%90/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://x7peeps.com/%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80/%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90-9-%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5%E5%92%8C%E9%92%A9%E5%AD%90/index.html</guid>
      <description>8. 代码注入和钩子 在上一章中，我们研究了恶意软件用来留在受害者系统中的不同持久性机制。在本章中，你将学习恶意程序如何将代码注入另一个进程（称为目标进程或远程进程）以执行恶意行动。将恶意代码注入目标进程的内存并在目标进程的上下文中执行恶意代码的技术被称为代码注入（或进程注入）。
攻击者通常选择一个合法进程（如explorer.exe或svchost.exe）作为目标进程。一旦恶意代码被注入目标进程，它就可以在目标进程的上下文中执行恶意行为，如记录击键、窃取密码和渗出数据。在将代码注入目标进程的内存后，负责注入代码的恶意软件组件可以继续在系统上持续存在，从而在每次系统重启时将代码注入目标进程，或者它可以从文件系统中删除自己，只将恶意代码保留在内存中。/
在我们深入研究恶意软件的代码注入技术之前，必须了解虚拟内存的概念。
8.1 虚拟内存 当你双击一个包含指令序列的程序时，就会创建一个进程。Windows操作系统为每个新创建的进程提供自己的私有内存地址空间（称为进程内存）。进程内存是虚拟内存的一部分；虚拟内存不是真正的内存，而是由操作系统的内存管理器创造的一种假象。正是由于这种假象，每个进程都认为它有自己的私有内存空间。在运行期间，Windows内存管理器在硬件的帮助下，将虚拟地址转化为实际数据所在的物理地址（在RAM中）；为了管理内存，它将一些内存分页到磁盘。当进程的线程访问被分页到磁盘的虚拟地址时，内存管理器将其从磁盘装回内存。下图说明了两个进程，A和B，它们的进程内存被映射到物理内存中，而有些部分被分页到磁盘上。
由于我们通常处理的是虚拟地址（就是你在调试器中看到的那些），所以在本章的其余部分，我们将不讨论物理内存。现在，让我们来关注一下虚拟内存。虚拟内存被划分为进程内存（进程空间或用户空间）和内核内存（内核空间或系统空间）。虚拟内存地址空间的大小取决于硬件平台。例如，在32位架构上，默认情况下，总的虚拟地址空间（包括进程和内核内存）最大为4GB。低于一半的部分（下2GB空间），范围从0x00000000到0x7FFFFFFF，被保留给用户进程（进程内存或用户空间），地址的上半部分（上2GB空间），范围从0x80000000到0xFFFFFFFF，被保留给内核内存（内核空间）。
在32位系统中，在4GB的虚拟地址空间中，每个进程认为它有2GB的进程内存，范围从0x00000000 - 0x7FFFFFFF。由于每个进程认为它有自己的私有虚拟地址空间（最终被映射到物理内存），总的虚拟地址会比可用的物理内存（RAM）大很多。Windows内存管理器通过将一些内存分页到磁盘来解决这个问题；这释放了物理内存，它可以用于其他进程或操作系统本身。尽管每个Windows进程都有自己的私有内存空间，但内核内存在大多数情况下是公用的，并由所有进程共享。下图显示了32位架构的内存布局。你可能会注意到在用户空间和内核空间之间有一个64KB的空隙；这个区域是不可访问的，它可以确保内核不会意外地越过边界而破坏用户空间。你可以通过检查符号MmHighestUserAddress来确定进程地址空间的上边界（最后可用的地址），通过使用内核调试器（如Windbg）查询符号MmSystemRangeStart来确定内核空间的下边界（第一个可用地址）。
即使每个进程的虚拟地址范围是相同的（x00000000 - 0x7FFFFFFF），硬件和Windows都确保映射到这个范围的物理地址对每个进程是不同的。例如，当两个进程访问同一个虚拟地址时，每个进程最终将访问物理内存中的不同地址。通过为每个进程提供私有的地址空间，操作系统确保进程不会覆盖对方的数据。
虚拟内存空间不需要总是被分成2GB的两半，这只是默认设置。例如，你可以通过以下命令启用3GB的启动开关，将进程内存增加到3GB，范围从0x00000000 - 0xBFFFFFFF；内核内存得到剩余的1GB，从0xC0000000-0xFFFFFFFF。
bcdedit /set increaseuserva 3072x64架构为进程和内核内存提供更大的地址空间，如下图所示。在x64架构上，用户空间的范围是0x000000000000-0x000007ffffffff，而内核空间的范围是0xffff080000000000及以上。你可能会注意到在用户空间和内核空间之间有一个巨大的地址差距；这个地址范围是不能使用的。尽管在下面的截图中，内核空间是从0xffff080000000000开始的，但内核空间的第一个可用地址是从ffff800000000开始的。原因是x64代码中使用的所有地址都必须是规范的。如果一个地址的第47-63位全部被设置或全部被清除，那么这个地址就是规范的的。试图使用一个非规范的地址会导致一个页面故障异常。
1.1 进程内存组件（用户空间） 有了对虚拟内存的了解，让我们把注意力集中在虚拟内存的一部分，即进程内存。进程内存是用户应用程序使用的内存。下面的截图显示了两个进程，并给出了驻留在进程内存中的组件的高级概述。在下面的截图中，为了简单起见，内核空间被故意留空（我们将在下一节中填补这一空白）。请记住，进程共享相同的内核空间。
过程存储器由以下主要部分组成。
进程可执行文件。这个区域包含与应用程序相关的可执行文件。当双击磁盘上的一个程序时，就会创建一个进程，并将与该程序相关的可执行文件加载到进程内存中。 动态链接库（DLLs）。当一个进程被创建时，其所有相关的DLLs被加载到进程内存中。这个区域代表与进程相关的所有DLLs。 进程环境变量。这个内存区域存储进程的环境变量，如临时目录、主目录、AppData目录等等。 进程堆。这个区域指定了进程的堆。每个进程有一个单一的堆，并且可以根据需要创建额外的堆。这个区域指定了进程所接受的动态输入。 线程堆栈。这个区域代表分配给每个线程的进程内存的专用范围，称为其运行时堆栈。每个线程都有自己的堆栈，在这里可以找到函数参数、局部变量和返回地址。 进程环境块（PEB）。这个区域代表了PEB结构，它包含了关于可执行文件的加载位置、它在磁盘上的完整路径以及在内存中找到DLL的信息。 你可以通过使用Process Hacker（https://processhacker.sourceforge.io/）工具来检查一个进程的内存内容。要做到这一点，启动Process Hacker，右键单击所需的进程，选择属性，并选择内存选项卡。
1.2 内核内存内容（内核空间） 内核内存包含操作系统和设备驱动程序。下面的截图显示了用户空间和内核空间的组件。在本节中，我们将主要关注内核空间的组件。
内核内存由以下关键部分组成。
hal.dll。硬件抽象层（HAL）是在可加载的内核模块hal.dll中实现的。HAL将操作系统与硬件隔离；它实现了支持不同硬件平台（主要是芯片组）的功能。它主要为Windows执行器、内核和内核模式设备驱动程序提供服务。内核模式设备驱动程序调用hal.dll暴露的功能与硬件进行交互，而不是直接与硬件进行通信。 ntoskrnl.exe。这个二进制文件是被称为内核镜像的Windows操作系统的核心组件。ntoskrnl.exe二进制文件提供两种类型的功能：执行和内核。执行器实现了被称为系统服务例程的功能，用户模式的应用程序可以通过一个受控机制调用这些功能。执行器还实现了主要的操作系统组件，如内存管理器、I/O管理器、对象管理器、进程/线程管理器，等等。内核实现了低级别的操作系统服务，并公开了一系列的例程，这些例程由执行器建立，以提供高级别的服务。 Win32K.sys。这个内核模式的驱动程序实现了用户界面和图形设备接口（GDI）服务，这些服务用于在输出设备（如显示器）上渲染图形。它为GUI应用程序提供功能。 2. 用户模式和内核模式 在上一节中，我们看到虚拟内存是如何被分为用户空间（进程内存）和内核空间（内核内存）的。用户空间包含的代码（如可执行文件和DLL）以受限的访问方式运行，被称为用户模式。换句话说，在用户空间运行的可执行文件或DLL代码不能访问内核空间的任何东西，也不能与硬件直接交互。内核空间包含内核本身（ntoskrnl.exe）和设备驱动程序。运行在内核空间的代码以高权限执行，即所谓的内核模式，它可以同时访问用户空间和内核空间。通过为内核提供高权限级别，操作系统确保用户模式的应用程序不能通过访问受保护的内存或I/O端口而导致系统不稳定。第三方驱动程序可以通过实现和安装签名的驱动程序使他们的代码在内核模式下运行。
空间（用户空间/内核空间）和模式（用户模式/内核模式）之间的区别是，空间指定了内容（数据/代码）的存储位置，而模式指的是执行模式，它指定了允许应用程序的指令如何执行。
如果用户模式的应用程序不能直接与硬件交互，那么问题是，在用户模式下运行的恶意软件二进制文件如何通过调用WriteFile API将内容写入磁盘上的文件？事实上，大多数由用户模式应用程序调用的API，最终都会调用内核执行程序（ntoskrnl.exe）中实现的系统服务程序（功能），而内核执行程序又会与硬件进行交互（例如，向磁盘上的文件写入）。以同样的方式，任何调用GUI相关API的用户模式应用程序最终都会调用内核空间中win32k.sys所暴露的功能。下图说明了这个概念；为了简单起见，我从用户空间删除了一些组件。ntdll.dll（驻留在用户空间）充当了用户空间和内核空间之间的网关。以同样的方式，user32.dll作为GUI应用程序的网关。在下一节，我们将主要关注通过ntdll.dll将API调用过渡到内核执行的系统服务例程。
2.1 Windows API调用流程 Windows操作系统通过暴露在DLLs中实现的API来提供服务。一个应用程序通过调用DLL中实现的API来使用服务。大多数API函数最终会调用ntoskrnl.exe（内核执行）中的系统服务程序。在这一节中，我们将研究当应用程序调用API时会发生什么，以及API如何最终调用ntoskrnl.exe（执行）中的系统服务例程。具体来说，我们将看看当一个应用程序调用WriteFile()API时会发生什么。下图给出了API调用流程的高级概述。
当一个进程通过双击程序被调用时，进程的可执行图像及其所有相关的DLLs被Windows加载器加载到进程内存中。当一个进程启动时，主线程被创建，它从内存中读取可执行代码并开始执行它。需要记住的一点是，执行代码的不是进程，而是执行代码的线程（进程只是线程的一个容器）。被创建的线程开始在用户模式下执行（有限制的访问）。一个进程可以根据需要明确地创建额外的线程。 我们假设一个应用程序需要调用WriteFile()API，它是由kernel32.dll导出的。为了将执行控制转移到WriteFile()，线程必须知道WriteFile()在内存中的地址。如果应用程序导入了WriteFile()，那么它可以通过查看一个叫做导入地址表（IAT）的函数指针表来确定其地址，如前图所示。这个表位于内存中的应用程序的可执行映像中，当DLLs被加载时，它被windows加载器填充了函数地址。 一个应用程序也可以在运行期间通过调用LoadLibrary()API来加载DLL。 它可以通过使用GetProcessAddress()API来确定加载的DLL中的函数地址。如果一个应用程序在运行期间加载一个DLL，那么IAT就不会被填充。 一旦线程从IAT或在运行时确定了WriteFile()的地址，它就会调用WriteFile()，在kernel32.dll中实现。WriteFile()函数中的代码最终会调用一个DLL网关，ntdll.dll导出的函数NtWriteFile()。ntdll.dll 中的 NtWriteFile() 函数并不是 NtWriteFile() 的真正实现。实际的函数，具有相同的名称，NtWriteFile()（系统服务例程），驻留在ntoskrnl.exe（执行）中，它包含真正的实现。ntdll.dll中的NtWriteFile()只是一个存根例程，执行SYSENTER（x86）或SYSCALL（x64）指令。这些指令将代码过渡到内核模式。 现在，在内核模式下运行的线程（具有不受限制的访问权限）需要找到实际函数NtWriteFile()的地址，该函数在ntoskrnl.exe中实现。要做到这一点，它需要查询内核空间中的一个表称为系统服务描述符表（SSDT），并确定NtWriteFile()的地址。然后，它调用Windows执行程序（在ntoskrnl.exe中）中实际的NtWriteFile()（系统服务例程），该程序将请求引向I/O管理器中的I/O功能。然后，I/O管理器将请求指向适当的内核模式设备驱动程序。内核模式设备驱动程序使用HAL导出的例程来与硬件接口。 3. 代码注入技术 如前所述，代码注入技术的目的是将代码注入远程进程的内存，并在远程进程的上下文中执行注入的代码。注入的代码可以是一个模块，如可执行文件，DLL，甚至是shellcode。代码注入技术为攻击者提供了许多好处；一旦代码被注入到远程进程中，攻击者可以做以下事情。
迫使远程进程执行注入的代码以进行恶意操作（如下载额外的文件或窃取键盘按键信息）。 注入一个恶意模块（如DLL），并将远程进程的API调用重定向到注入模块中的一个恶意函数。然后，该恶意函数可以拦截API调用的输入参数，也可以过滤输出参数。例如，Internet Explorer使用HttpSendRequest()向Web服务器发送一个包含可选POST有效载荷的请求，它使用InternetReadFile()从服务器的响应中获取字节，并在浏览器中显示它。攻击者可以在Internet Explorer的进程内存中注入一个模块，并将HttpSendRequest()重定向到被注入模块中的恶意函数，以便从POST有效载荷中提取证书。以同样的方式，它可以拦截从InternetReadFile()API收到的数据，读取数据或修改从网络服务器收到的数据。这使攻击者能够在数据到达网络服务器之前拦截数据（如银行凭证），也使攻击者能够在数据到达受害者的浏览器之前替换或插入额外的数据到服务器的响应中（如在HTML内容中插入一个额外的字段）。 将代码注入到已经运行的进程中，允许攻击者实现持久性。 将代码注入到受信任的进程中，允许攻击者绕过安全产品（如白名单软件）并躲避用户。 在本节中，我们将主要关注用户空间中的代码注入技术。我们将研究攻击者用来对远程进程进行代码注入的各种方法。</description>
    </item>
  </channel>
</rss>